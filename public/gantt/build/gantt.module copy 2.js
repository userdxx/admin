import locale_zh from  './locales/locale_ZH'
const productName = 'gantt';

var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function () {
      try {
        new Blob();
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ];

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function (obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value
}


function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return {done: value === undefined, value: value}
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator
    };
  }

  return iterator
}

function Headers$1(headers) {
  this.map = {};

  if (headers instanceof Headers$1) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers$1.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers$1.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers$1.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null
};

Headers$1.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name))
};

Headers$1.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers$1.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers$1.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items)
};

Headers$1.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items)
};

Headers$1.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items)
};

if (support.iterable) {
  Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = function () {
      reject(reader.error);
    };
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);

      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode)
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse)
  };

  return this
}


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers$1(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers$1(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body);
}

Request.prototype.clone = function () {
  return new Request(this, {body: this._bodyInit})
};

function decode(body) {
  var form = new FormData();
  body
    .trim()
    .split('&')
    .forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers$1();


  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers
}

Body.call(Request.prototype);

function Response$1(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers$1(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response$1.prototype);

Response$1.prototype.clone = function () {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers$1(this.headers),
    url: this.url
  })
};

Response$1.error = function () {
  var response = new Response$1(null, {status: 0, statusText: ''});
  response.type = 'error';
  return response
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response$1.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response$1(null, {status: status, headers: {location: url}})
};

var DOMException$1 = self.DOMException;
try {
  new DOMException$1();
} catch (err) {
  DOMException$1 = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException$1.prototype = Object.create(Error.prototype);
  DOMException$1.prototype.constructor = DOMException$1;
}

function fetch$1(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException$1('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response$1(body, options));
    };

    xhr.onerror = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function () {
      reject(new DOMException$1('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function (value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {

        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  })
}

fetch$1.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch$1;
  self.Headers = Headers$1;
  self.Request = Request;
  self.Response = Response$1;
}

(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
    factory();
}((function () {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var Emitter =

    function () {
      function Emitter() {
        _classCallCheck(this, Emitter);

        Object.defineProperty(this, 'listeners', {
          value: {},
          writable: true,
          configurable: true
        });
      }

      _createClass(Emitter, [{
        key: "addEventListener",
        value: function addEventListener(type, callback) {
          if (!(type in this.listeners)) {
            this.listeners[type] = [];
          }

          this.listeners[type].push(callback);
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type, callback) {
          if (!(type in this.listeners)) {
            return;
          }

          var stack = this.listeners[type];

          for (var i = 0, l = stack.length; i < l; i++) {
            if (stack[i] === callback) {
              stack.splice(i, 1);
              return;
            }
          }
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          var _this = this;

          if (!(event.type in this.listeners)) {
            return;
          }

          var debounce = function debounce(callback) {
            setTimeout(function () {
              return callback.call(_this, event);
            });
          };

          var stack = this.listeners[event.type];

          for (var i = 0, l = stack.length; i < l; i++) {
            debounce(stack[i]);
          }

          return !event.defaultPrevented;
        }
      }]);

      return Emitter;
    }();

  var AbortSignal =

    function (_Emitter) {
      _inherits(AbortSignal, _Emitter);

      function AbortSignal() {
        var _this2;

        _classCallCheck(this, AbortSignal);

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this));


        if (!_this2.listeners) {
          Emitter.call(_assertThisInitialized(_this2));
        }


        Object.defineProperty(_assertThisInitialized(_this2), 'aborted', {
          value: false,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this2), 'onabort', {
          value: null,
          writable: true,
          configurable: true
        });
        return _this2;
      }

      _createClass(AbortSignal, [{
        key: "toString",
        value: function toString() {
          return '[object AbortSignal]';
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          if (event.type === 'abort') {
            this.aborted = true;

            if (typeof this.onabort === 'function') {
              this.onabort.call(this, event);
            }
          }

          _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, event);
        }
      }]);

      return AbortSignal;
    }(Emitter);
  var AbortController =

    function () {
      function AbortController() {
        _classCallCheck(this, AbortController);


        Object.defineProperty(this, 'signal', {
          value: new AbortSignal(),
          writable: true,
          configurable: true
        });
      }

      _createClass(AbortController, [{
        key: "abort",
        value: function abort() {
          var event;

          try {
            event = new Event('abort');
          } catch (e) {
            if (typeof document !== 'undefined') {
              if (!document.createEvent) {

                event = document.createEventObject();
                event.type = 'abort';
              } else {

                event = document.createEvent('Event');
                event.initEvent('abort', false, false);
              }
            } else {

              event = {
                type: 'abort',
                bubbles: false,
                cancelable: false
              };
            }
          }

          this.signal.dispatchEvent(event);
        }
      }, {
        key: "toString",
        value: function toString() {
          return '[object AbortController]';
        }
      }]);

      return AbortController;
    }();

  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {


    AbortController.prototype[Symbol.toStringTag] = 'AbortController';
    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';
  }

  function polyfillNeeded(self) {
    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');
      return true;
    }


    return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;
  }


  function abortableFetchDecorator(patchTargets) {
    if ('function' === typeof patchTargets) {
      patchTargets = {
        fetch: patchTargets
      };
    }
    var _patchTargets = patchTargets,
      fetch = _patchTargets.fetch,
      _patchTargets$Request = _patchTargets.Request,
      NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,
      NativeAbortController = _patchTargets.AbortController,
      _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,
      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;

    if (!polyfillNeeded({
      fetch: fetch,
      Request: NativeRequest,
      AbortController: NativeAbortController,
      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
    })) {
      return {
        fetch: fetch,
        Request: Request
      };
    }
    var Request = NativeRequest;
    if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      Request = function Request(input, init) {
        var signal;

        if (init && init.signal) {
          signal = init.signal;
          delete init.signal;
        }

        var request = new NativeRequest(input, init);

        if (signal) {
          Object.defineProperty(request, 'signal', {
            writable: false,
            enumerable: false,
            configurable: true,
            value: signal
          });
        }
        return request;
      };
      Request.prototype = NativeRequest.prototype;
    }
    var realFetch = fetch;
    var abortableFetch = function abortableFetch(input, init) {
      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;

      if (signal) {
        var abortError;
        try {
          abortError = new DOMException('Aborted', 'AbortError');
        } catch (err) {
          abortError = new Error('Aborted');
          abortError.name = 'AbortError';
        }
        if (signal.aborted) {
          return Promise.reject(abortError);
        }
        var cancellation = new Promise(function (_, reject) {
          signal.addEventListener('abort', function () {
            return reject(abortError);
          }, {
            once: true
          });
        });
        if (init && init.signal) {
          delete init.signal;
        }

        return Promise.race([cancellation, realFetch(input, init)]);
      }

      return realFetch(input, init);
    };

    return {
      fetch: abortableFetch,
      Request: Request
    };
  }

  (function (self) {

    if (!polyfillNeeded(self)) {
      return;
    }

    if (!self.fetch) {
      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');
      return;
    }

    var _abortableFetch = abortableFetchDecorator(self),
      fetch = _abortableFetch.fetch,
      Request = _abortableFetch.Request;

    self.fetch = fetch;
    self.Request = Request;
    Object.defineProperty(self, 'AbortController', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortController
    });
    Object.defineProperty(self, 'AbortSignal', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortSignal
    });
  })(typeof self !== 'undefined' ? self : global);

})));


const camelLettersRe = /([a-z])([A-Z])/g,
  escapeRegExpRe = /[.*+?^${}()|[\]\\]/g,
  idRe = /(^[^a-z]+|[^\w]+)/gi,
  replaceCamelLetters = (all, g1, g2) => {
    return g1 + '-' + g2.toLowerCase();
  },
  replaceNonIdChar = c => {
    if (c) {
      return `_x${c.charCodeAt(0).toString(16)}`;
    }

    return '__blank__';
  },
  hyphenateCache = {};


class StringHelper {

  static capitalizeFirstLetter(string) {
    if (!string) return null;
    return string[0].toUpperCase() + string.substr(1);
  }


  static lowercaseFirstLetter(string) {
    if (!string) return null;
    return string[0].toLowerCase() + string.substr(1);
  }


  static hyphenate(string) {

    const cached = hyphenateCache[string];

    if (cached) {
      return cached;
    }

    return hyphenateCache[string] = string.replace(camelLettersRe, replaceCamelLetters);
  }


  static safeJsonParse(string) {
    let parsed = null;

    try {
      parsed = JSON.parse(string);
    } catch (e) {
      console.error(e);
    }

    return parsed;
  }


  static safeJsonStringify(obj) {
    let result = null;

    try {
      result = JSON.stringify(obj);
    } catch (e) {
      console.error(e);
    }

    return result;
  }


  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }

  static escapeRegExp(string) {

    return string.replace(escapeRegExpRe, '\\$&');
  }


  static joinPaths(paths, pathSeparator = '/') {
    return paths.join(pathSeparator).replace(new RegExp('\\' + pathSeparator + '+', 'g'), pathSeparator);
  }

}

StringHelper._$name = 'StringHelper';


let isSiesta = false;

try {
  isSiesta = Boolean(window !== window.parent && window.parent.Siesta);
} catch (e) {
}


class VersionHelper {

  static setVersion(product, version) {
    product = product.toLowerCase();
    this[product] = {
      version,

      isNewerThan(otherVersion) {
        return otherVersion < version;
      },

      isOlderThan(otherVersion) {
        return otherVersion > version;
      }

    };
    let bundleFor = '';


    if (typeof productName !== 'undefined') {
      bundleFor = productName;
    }

    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, '-')}`;

    if (window.bryntum[globalKey] === true) {
      if (isSiesta) {
        window.BUNDLE_EXCEPTION = true;
      } else {
        throw new Error('Bundle included twice, check cache-busters and file types (.js)');
      }
    } else {
      window.bryntum[globalKey] = true;
    }
  }


  static getVersion(product) {
    product = product.toLowerCase();

    if (!this[product]) {
      throw new Error('No version specified');
    }

    return this[product].version;
  }


  static checkVersion(product, version, test, message) {
    const productVersion = this.getVersion(product);
    let result;

    switch (test) {
      case '<':
        result = productVersion < version;
        break;

      case '<=':
        result = productVersion <= version;
        break;

      case '=':
        result = productVersion === version;
        break;

      case '>=':
        result = productVersion >= version;
        break;

      case '>':
        result = productVersion > version;
        break;
    }

    return result;
  }


  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = this.checkVersion(product, invalidAsOfVersion, '<', message);

    if (!invalidAsOfVersion.endsWith('.0.0')) {
      throw new Error('May only break APIs in major releases');
    }

    if (!message) {
      throw new Error('Must provide helpful message for developers');
    }

    if (justWarn) {

      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }

  static get isTestEnv() {
    return isSiesta;
  }

}

(window.bryntum || (window.bryntum = {})).getVersion = VersionHelper.getVersion.bind(VersionHelper);
window.bryntum.checkVersion = VersionHelper.checkVersion.bind(VersionHelper);
window.bryntum.deprecate = VersionHelper.deprecate.bind(VersionHelper);
VersionHelper._$name = 'VersionHelper';


const defaultConfigSymbol = Symbol('defaultConfig'),
  propertyInitializersSymbol = Symbol('propertyInitializers'),
  classHierarchySymbol = Symbol('classHierarchy'),
  configurationSymbol = Symbol('configuration'),
  originalConfigSymbol = Symbol('originalConfig'),
  instancePropertiesSymbol = Symbol('instanceProperties');


class Base { 
  constructor(...args) { 
    this.construct(...args);
    this.afterConstruct();
  } 
  construct(...args) {

    if (args[0] !== null) {
      this.configure(...args);
    }

    this.afterConfigure();
  }


  static destroy(...args) {
    args.forEach(object => {
      if (object && object.destroy && !object.isDestroyed) {
        object.destroy();
      }
    });
  }


  destroy() {
    const me = this;
    me.isDestroying = true;
    me.doDestroy();
    Object.setPrototypeOf(this, null);

    for (let key in me) {
      delete me[key];
    }

    delete me[originalConfigSymbol];

    me.isDestroyed = true;
  }


  _thisIsAUsedExpression(getter) {
  }

  static get $name() {
    return this.hasOwnProperty('_$name') && this._$name || this.name;
  }

  get $name() {
    return this.constructor.$name;
  }
  startConfigure(config) {
  }
  finishConfigure(config) {
  }
  afterConfigure() {
  }
  afterConstruct() {
  }
  callback(fn, thisObject, args) {

    if (thisObject === 'this') {
      thisObject = this;
    }

    const {
      handler,
      thisObj
    } = this.resolveCallback(fn, thisObject);
    return args ? handler.apply(thisObj, args) : handler.call(thisObj);
  }
  resolveCallback(handler, thisObj = this) {

    if (handler.substr) {
      if (handler.startsWith('up.')) {
        handler = handler.substr(3);

        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner) ;
      } else if (handler.startsWith('this.')) {
        thisObj = this;
      }

      handler = thisObj[handler];
    }

    return {
      handler,
      thisObj
    };
  }

  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const {
        handler,
        thisObj
      } = this.resolveCallback(inHandler, inThisObj);

      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  delay(fn, by) {

    fn = this.setTimeout ? fn : fn.bind(this);
    (typeof by === 'number' ? this.setTimeout || setTimeout : this.requestAnimationFrame || requestAnimationFrame)(fn, by);
  }
  doDestroy() {
  }


  destroyProperties(...properties) {
    const me = this;
    let key, propertyValue;

    for (key of properties) {


      if (key in me && (!me[configurationSymbol] || !me[configurationSymbol][key])) {
        propertyValue = me[key];

        if (propertyValue && propertyValue.destroy) {
          propertyValue.destroy();
        }

        delete me[key];
      }
    }
  }


  configure(config = {}) {
    const me = this;
    me.initialConfig = config;


    me.isConfiguring = true;

    Object.assign(me, me.getProperties());


    me.setConfig(me[originalConfigSymbol] = Base.assign(me.getDefaultConfiguration(), config), true);
    me.isConfiguring = false;
  }


  setConfig(config, isConstructing) {
    const me = this,
      wasConfiguring = me[configurationSymbol],
      configDone = wasConfiguring ? me.configDone : me.configDone = {},
      instanceProperties = me[instancePropertiesSymbol] = {};
    let key, instanceProperty;

    me[configurationSymbol] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;


    for (key in config) {


      if (config[key] != null || config.hasOwnProperty(key)) {


        if (!instanceProperties[key] && (instanceProperty = Reflect.getOwnPropertyDescriptor(me, key)) && !('value' in instanceProperty)) {
          instanceProperties[key] = instanceProperty;
        }


        Reflect.defineProperty(me, key, Base.createPropInitializer(key));

        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }

    if (isConstructing) {
      me.startConfigure(config);
    }


    for (key in config) {


      if (!configDone[key]) {
        me[key] = config[key];
      }
    }

    if (wasConfiguring) {
      me[configurationSymbol] = wasConfiguring;
    } else {
      delete me[configurationSymbol];
    }

    if (isConstructing) {
      me.finishConfigure(config);
    }
  }


  get config() {
    let result = {},
      myConfig = this[originalConfigSymbol],
      key;


    for (key in myConfig) {
      result[key] = myConfig[key];
    }

    return result;
  }


  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }


  static getDefaultConfiguration() {
    const configDescriptor = this.getConfigDescriptor(),
      config = configDescriptor.needsFork ? this.fork(configDescriptor.defaultConfig) : Object.setPrototypeOf({}, configDescriptor.defaultConfig);

    if (VersionHelper.isTestEnv && config.testConfig && window.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }

    return config;
  }


  static getConfigDescriptor(shallow) {
    const me = this;
    let configDescriptor = !shallow && me.hasOwnProperty(defaultConfigSymbol) ? me[defaultConfigSymbol] : null,
      defaults,
      key,
      cls,
      value,
      superConfigDescriptor;

    if (!configDescriptor) {
      configDescriptor = {
        defaultConfig: defaults = me.hasOwnProperty('defaultConfig') ? me.defaultConfig : {},

        needsFork: 0
      };

      if (!shallow) {
        me[defaultConfigSymbol] = configDescriptor;
      }

      for (key in defaults) {
        value = defaults[key];


        if (value && (value.constructor === Object || Array.isArray(value)) && !Object.isFrozen(value)) {

          configDescriptor.needsFork = 1;
          break;
        }
      }


      if (!shallow) {
        for (cls = me.superclass; cls && cls !== Base; cls = cls.superclass) {
          superConfigDescriptor = cls.getConfigDescriptor(true);

          if (Object.keys(superConfigDescriptor.defaultConfig).length) {
            configDescriptor.needsFork |= superConfigDescriptor.needsFork;
            Object.setPrototypeOf(defaults, defaults = superConfigDescriptor.defaultConfig);
          }
        }
      }
    }

    return configDescriptor;
  }

  static fork(obj) {
    var ret, key, value;

    if (obj && obj.constructor === Object && !Object.isFrozen(obj)) {
      ret = Object.setPrototypeOf({}, obj);

      for (key in obj) {
        value = obj[key];

        if (value) {
          if (value.constructor === Object) {
            ret[key] = this.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }

    return ret;
  }

  static assign(dest, ...sources) {
    var i = 0,
      ln = sources.length,
      source,
      key;

    for (; i < ln; i++) {
      source = sources[i];

      for (key in source) {
        dest[key] = source[key];
      }
    }

    return dest;
  }


  getProperties() {
    const hierarchy = this.classHierarchy(),
      len = hierarchy.length;
    let result = {},
      i,
      cls;


    for (i = 0; i < len; i++) {
      cls = hierarchy[i];

      if (cls.hasOwnProperty('properties')) {
        Object.assign(result, cls.properties);
      }
    }

    return result;
  }

  static get superclass() {
    return Object.getPrototypeOf(this);
  }

  static createPropInitializer(key) {


    var result = (this[propertyInitializersSymbol] || (this[propertyInitializersSymbol] = {}))[key];

    if (!result) {
      let initializingFlagName = 'initializing' + StringHelper.capitalizeFirstLetter(key);
      result = this[propertyInitializersSymbol][key] = {
        configurable: true,

        get() {
          const me = this,
            instanceProperty = me[instancePropertiesSymbol][key];

          if (instanceProperty) {
            Reflect.defineProperty(me, key, instanceProperty);
          } else {
            delete me[key];
          }

          me[initializingFlagName] = true;
          me[key] = me[configurationSymbol][key];
          me[initializingFlagName] = false;


          me.configDone[key] = true;

          return me[key];
        },

        set(value) {
          const me = this,
            instanceProperty = me[instancePropertiesSymbol][key];

          if (instanceProperty) {
            Reflect.defineProperty(me, key, instanceProperty);
          } else {
            delete me[key];
          }


          me.configDone[key] = true;

          me[key] = value;
        }

      };
    }

    return result;
  }


  classHierarchy(topClass) {
    let cls = this.constructor,
      fullClassHierarchy = cls.hasOwnProperty(classHierarchySymbol) ? cls[classHierarchySymbol] : null,
      result;

    if (!fullClassHierarchy) {


      for (fullClassHierarchy = cls[classHierarchySymbol] = []; cls !== Base; cls = Object.getPrototypeOf(cls)) {
        fullClassHierarchy.unshift(cls);
      }

      Object.freeze(fullClassHierarchy);
    }

    if (topClass) {
      for (let i = 0; !result && i < fullClassHierarchy.length; i++) {
        if (fullClassHierarchy[i] === topClass) {
          result = fullClassHierarchy.slice(i);
        }
      }
    } else {
      result = fullClassHierarchy;
    }

    return result;
  }


  classNameHierarchy(topClass) {
    return this.classHierarchy(topClass).map(f => f.$name);
  }


  static isOfTypeName(type) {
    return this.classNameHierarchy().includes(type);
  }


  detachListeners(name) {
    let detachers = this.$detachers;
    detachers = detachers && detachers[name];

    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }


  trackDetacher(name, detacher) {
    const detachers = this.$detachers || (this.$detachers = {}),
      bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher);
  }


  untrackDetachers(eventer) {
    const detachers = this.$detachers;

    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];

        for (let i = bucket.length; i-- > 0;) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }

}

Object.assign(Base.prototype, {
  $detachers: null
});
VersionHelper.setVersion('core', '0.0.0');
Base._$name = 'Base';


class ArrayHelper {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== undefined && !(Array.isArray(item) && item.length === 0) && item !== '') res.push(item);
      return res;
    }, []);
  }


  static remove(array, ...items) {
    let index,
      item,
      removed = false;

    for (let i = 0; i < items.length; i++) {
      item = items[i];

      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }

    return removed;
  }


  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;

    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;

      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }

    return this.binarySearch(array, item, comparatorFn);
  }


  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;

    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }

    --end;

    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);

      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }

    return begin;
  }

  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }

  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }


  static fill(count, itemOrArray = {}, fn = null) {
    const result = [],
      items = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];

    for (let i = 0; i < count; i++) {
      for (let item of items) {


        const processedItem = Object.assign({}, item);

        if (fn) {
          fn(processedItem, i);
        }

        result.push(processedItem);
      }
    }

    return result;
  }


  static populate(count, fn) {
    const items = [];

    for (let i = 0; i < count; i++) {
      items.push(fn(i));
    }

    return items;
  }


  static include(array, item) {
    if (!array.includes(item)) {
      array.push(item);
    }
  }


  static allowNegative(array) {

    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== 'string') {
          return Reflect.get(target, name, receiver);
        }

        const index = Number(name);

        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }

        return target[index < 0 ? target.length + index : index];
      },

      set(target, name, value, receiver) {
        if (typeof name !== 'string') {
          return Reflect.set(target, name, value, receiver);
        }

        const index = Number(name);

        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }

        target[index < 0 ? target.length + index : index] = value;
        return true;
      }

    });
  }

  static delta(a, b) {


    if (!b) {
      return {
        onlyInA: a,
        onlyInB: [],
        inBoth: []
      };
    }

    const onlyInA = [],
      onlyInB = [],
      inBoth = [];

    for (let i = 0; i < a.length; i++) {
      const item = a[i];

      if (b.includes(item)) {
        inBoth.push(item);
      } else {
        onlyInA.push(item);
      }
    }

    for (let i = 0; i < b.length; i++) {
      const item = b[i];

      if (!inBoth.includes(item)) {
        onlyInB.push(item);
      }
    }

    return {
      onlyInA,
      onlyInB,
      inBoth
    };
  }

}

ArrayHelper._$name = 'ArrayHelper';


const specialProperties = {
    thisObj: 1,
    detachable: 1,
    once: 1,
    detacher: 1,
    prio: 1,
    args: 1,
    expires: 1,
    name: 1,
    _oldDestructor: 1
  },
  priorityComparator = (a, b) => b.prio - a.prio;


var Events = (Target => class Events extends (Target || Base) {


  static get defaultConfig() {
    return {

      listeners: null
    };
  }

  destroy() {
    this.trigger('beforeDestroy');
    super.destroy();
  }


  construct(...args) {
    super.construct(...args);
    this.processConfiguredListeners();
  }

  processConfiguredListeners(listeners = this.listeners && this.initialEventListeners) {
    const me = this;


    if (listeners && !me.defaultListenersInitialized) {
      const ret = me.addListener(listeners, me);

      if (me.listeners.detachable !== false) {
        me.listenerDetacher = ret;
      }

      me.defaultListenersInitialized = true;
    }
  }


  doDestroy() {
    const me = this;
    me.trigger('destroy');

    if (me.listenerDetacher) {
      me.listenerDetacher();
    }

    me.removeAllListeners();
    super.doDestroy();
  }


  addListener(config, thisObj, arg2) {
    const me = this,
      events = me.eventListeners || (me.eventListeners = {});

    if (typeof config === 'string') {


      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: arg2
      });
    } else {


      thisObj = config.thisObj !== undefined ? config.thisObj : config.thisObj = thisObj;

      for (const key in config) {
        if (!specialProperties[key]) {
          const listenerSpec = config[key],
            listener = {
              fn: typeof listenerSpec === 'object' ? listenerSpec.fn : listenerSpec,
              thisObj: listenerSpec.thisObj !== undefined ? listenerSpec.thisObj : thisObj,
              args: listenerSpec.args || config.args,
              prio: listenerSpec.prio !== undefined ? listenerSpec.prio : config.prio !== undefined ? config.prio : 0,
              once: listenerSpec.once !== undefined ? listenerSpec.once : config.once !== undefined ? config.once : false,
              catchAll: key === 'catchAll'
            },
            eventName = key.toLowerCase(),
            listeners = events[eventName] || (events[eventName] = []);

          if (listenerSpec.expires) {
            me.delay(() => me.un(eventName, listener), config.expires);
          }

          listeners.splice(ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length), 0, listener);
        }
      }

      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }

      if (thisObj) {
        me.attachAutoDetacher(config);
      }

      const detachable = config.detachable !== false,
        name = config.name,
        destroy = config.expires || detachable || name ? () => {

          if (!me.isDestroyed) {
            me.removeListener(config);
          }
        } : null;

      if (destroy) {
        destroy.eventer = me;
        destroy.listenerName = name;

        if (name && thisObj && thisObj.trackDetacher) {
          thisObj.trackDetacher(name, destroy);
        }

        if (config.expires) {
          me.delay(destroy, config.expires);
        }

        if (detachable) {
          return destroy;
        }
      }
    }
  }


  on() {
    return this.addListener(...arguments);
  }


  un() {
    this.removeListener(...arguments);
  }


  set listeners(listeners) {


    if (this.isConfiguring) {
      this.initialEventListeners = listeners;
    } else {
      this.removeAllListeners();

      if (listeners) {
        this.on(listeners);
      }
    }
  }

  get listeners() {
    return this.eventListeners || this.initialEventListeners;
  }


  removeListener(config, thisObj = config.thisObj, ...params) {
    const me = this;

    if (typeof config === 'string') {
      me.removeListener({
        [config]: thisObj
      }, params.length > 0 ? params[0] : true);
      return;
    }

    Object.entries(config).forEach(([key, configListener]) => {
      if (specialProperties[key]) {
        return;
      }

      const eventName = key.toLowerCase(),
        listeners = me.eventListeners && me.eventListeners[eventName];

      if (listeners) {
        const index = listeners.findIndex(listener => (listener.fn === configListener || listener.fn === configListener.fn) && (listener.thisObj === thisObj || listener.thisObj === configListener.thisObj || !thisObj));

        if (index >= 0) {


          listeners.splice(index, 1);

          if (!listeners.length) {
            delete me.eventListeners[eventName];
          }
        }
      }
    });

    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }


  hasListener(eventName) {
    return Boolean(this.eventListeners && this.eventListeners[eventName]);
  }


  relayAll(through, prefix, transformCase = true) {
    (this.relayAllTargets || (this.relayAllTargets = [])).push({
      through,
      prefix,
      transformCase
    });
  }


  removeAllListeners() {
    const listeners = this.eventListeners;
    let i, thisObj;

    for (const event in listeners) {
      const bucket = listeners[event];


      for (i = bucket.length; i-- > 0;) {
        const cfg = bucket[i];
        this.removeListener(event, cfg);
        thisObj = cfg.thisObj;

        if (thisObj && thisObj.untrackDetachers) {
          thisObj.untrackDetachers(this);
        }
      }
    }
  }

  relayEvents(source, eventNames, prefix) {
    const listenerConfig = {
        detachable: true
      },
      retrigger = (eventName, ...params) => {
        return this.trigger((prefix || '') + eventName, ...params);
      };

    eventNames.forEach(eventName => {
      listenerConfig[eventName] = (...params) => {
        return retrigger(eventName, ...params);
      };
    });
    return source.on(listenerConfig);
  }


  attachAutoDetacher(config) {
    const target = config.thisObj,

      destructorName = 'doDestroy' in target ? 'doDestroy' : 'destroy';

    if (destructorName in target) {
      config._oldDestructor = target[destructorName];

      target[destructorName] = () => {


        if (!this.isDestroyed) {
          this.removeListener(config);
        }

        config._oldDestructor.call(target);
      };
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }


  detachAutoDetacher(config) {
    const target = config.thisObj,
      destructorName = 'doDestroy' in target ? 'doDestroy' : 'destroy';

    if (config._oldDestructor) {
      target[destructorName] = config._oldDestructor;
    }
  }


  await(eventName, options = {
    checkLog: true,
    resetLog: true
  }) {
    const me = this;

    if (options === false) {
      options = {
        checkLog: false
      };
    }

    return new Promise(resolve => {

      if (options.checkLog && me._triggered && me._triggered[eventName]) {

        resolve();

        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }

      me.on({
        [eventName]: (...params) => {

          resolve(...params);

          if (options.resetLog) {
            me.clearLog(eventName);
          }
        },
        prio: -10000,

        once: true

      });
    });
  }

  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }


  callPreventable(eventName, eventObject, fn, args = [], quiet = false) {
    const me = this;

    if (!quiet && me.trigger('before' + StringHelper.capitalizeFirstLetter(eventName), eventObject) === false) {
      return false;
    }

    const result = fn(eventObject, ...args);

    if (!quiet) {
      me.trigger(eventName, eventObject);
    }

    return result;
  }


  trigger(eventName, param) {
    const me = this,
      name = eventName.toLowerCase(),
      {
        eventsSuspended,
        relayAllTargets,
        callOnFunctions,
        owner
      } = me;
    let listeners = me.eventListeners && me.eventListeners[name],
      doSlice = true;

    if (!me._triggered) {
      me._triggered = {};
    }

    me._triggered[eventName] = true;

    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) eventsSuspended.queue.push(arguments);
      return true;
    }


    if (me.eventListeners && me.eventListeners.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);

      listeners.sort(priorityComparator);
      doSlice = false;
    }

    if (!listeners && !relayAllTargets && !callOnFunctions) return true;

    if (param) {
      if (!('source' in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }

    if (param.type !== name) {

      if (param.constructor !== Object) {
        Reflect.defineProperty(param, 'type', {
          get: () => name
        });
      } else {
        param.type = name;
      }
    }

    if (callOnFunctions) {
      const fnName = 'on' + StringHelper.capitalizeFirstLetter(eventName);

      if (fnName in me) {
        me.callback(me[fnName], me, [param]);


        if (!me.isDestroyed && Object.prototype.hasOwnProperty.call(me, fnName) && (!me.pluginFunctionChain || !me.pluginFunctionChain[fnName])) {
          const myProto = Object.getPrototypeOf(me);

          if (fnName in myProto) {
            myProto[fnName].call(me, param);

            if (me.isDestroyed) {
              return;
            }
          }
        }
      }
    }

    if (listeners) {
      let i = 0,
        listener,
        handler;


      if (doSlice) {
        listeners = listeners.slice();
      }

      for (i; i < listeners.length && !me.isDestroyed; i++) {
        listener = listeners[i];
        let thisObj = listener.thisObj;


        if (!thisObj || !thisObj.isDestroyed) {
          if (listener.once) {
            me.removeListener(name, listener);
          }

          if (typeof listener.fn === 'string') {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }

            if (!handler) {
              const result = me.resolveCallback(listener.fn);
              handler = result.handler;
              thisObj = result.thisObj;
            }
          } else {
            handler = listener.fn;
          }

          if (listener.args) {
            if (handler.call(thisObj || me, ...listener.args, param) === false) {
              return false;
            }
          } else {
            if (handler.call(thisObj || me, param) === false) {
              return false;
            }
          }
        }
      }
    }

    if (relayAllTargets) {
      relayAllTargets.forEach(config => {
        let name = eventName;
        if (config.transformCase) name = StringHelper.capitalizeFirstLetter(name);
        if (config.prefix) name = config.prefix + name;
        if (config.through.trigger(name, param) === false) return false;
      });
    }


    if (param.bubbles && owner && !owner.isDestroyed) {
      return owner.trigger(eventName, param);
    }

    return true;
  }


  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = {
      shouldQueue: queue,
      queue: [],
      count: 0
    });
    eventsSuspended.count++;
  }


  resumeEvents() {
    const suspended = this.eventsSuspended;

    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;

        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }

    return !Boolean(this.eventsSuspended);
  }

});


class BryntumWidgetAdapterRegister {
  static register(type, widgetClass) {
    const classEntry = widgetClassRegister[widgetClass];
    type = type.toLowerCase();

    widgetRegister[type] = widgetClass;

    if (classEntry) {
      classEntry[type] = 1;
    } else {
      widgetClassRegister[widgetClass] = {
        [type]: 1
      };
    }
  }

  static getClass(type) {
    return widgetRegister[type.toLowerCase()];
  }


  static isType(widget, type, deep) {
    type = type.toLowerCase();

    for (let widgetClass = widget.constructor; widgetClass; widgetClass = deep && Object.getPrototypeOf(widgetClass)) {


      const
        name = widgetClass.hasOwnProperty('$name') ? widgetClass.$name : widgetClass.name,
        classEntry = widgetClassRegister[widgetClass] || name && (widgetClassRegister[widgetClass] = {
          [name.toLowerCase()]: 1
        });

      if (classEntry && classEntry[type]) {
        return true;
      }
    }
  }

  static createWidget(type, config) {
    const widgetClass = this.getClass(type || 'widget');

    if (widgetClass) {
      return new widgetClass(config);
    }

    return null;
  }

}

const widgetRegister = BryntumWidgetAdapterRegister.widgetRegister = {},
  widgetClassRegister = BryntumWidgetAdapterRegister.widgetClassRegister = {};
BryntumWidgetAdapterRegister._$name = 'BryntumWidgetAdapterRegister';


function isInstanceOfClass(instance, type) {
  const classHierarchy = instance.classHierarchy();

  for (let i = 0; i < classHierarchy.length; i++) {
    if (classHierarchy[i].$name.toLowerCase() === type) {
      return true;
    }
  }

  return false;
}


class IdHelper {

  static generateId(prefix = 'generatedId') {
    return prefix + ++IdHelper.idCounter;
  }


  static register(obj, prefix = '') {
    let objId = obj.id;

    if (objId == null) {
      objId = obj.id = IdHelper.generateId(prefix);
      obj.hasGeneratedId = true;
    }

    if (objId in IdHelper.idMap && !this.disableThrow) {
      throw new Error('Id ' + objId + ' already in use');
    }

    IdHelper.idMap[objId] = obj;
  }


  static unregister(obj) {

    if (IdHelper.idMap[obj.id] === obj) {
      delete IdHelper.idMap[obj.id];
    }
  }


  static get(id) {
    return IdHelper.idMap[id];
  }


  static query(selector, deep = false) {
    const idMap = IdHelper.idMap;

    for (let id in idMap) {
      if (widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }

    return null;
  }


  static queryAll(selector, deep = false) {
    const idMap = IdHelper.idMap,
      result = [];

    for (let id in idMap) {
      if (widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }

    return result;
  }


  static fromElement(element, type, limit) {
    const typeOfType = typeof type;

    if (element && element instanceof Event) {
      element = element.target;
    }

    if (typeOfType === 'number' || type && type.nodeType === 1) {
      limit = type;
      type = null;
    }

    let target = element,
      cache = IdHelper.idMap,
      depth = 0,
      topmost,
      cmpId,
      cmp;

    if (typeof limit !== 'number') {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }

    if (typeOfType === 'string') {
      type = type.toLowerCase();
    }

    while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;

      if (cmpId) {
        cmp = cache[cmpId];

        if (cmp) {
          if (type) {
            if (typeOfType === 'function') {
              if (type(cmp)) {
                return cmp;
              }
            } else if (widgetMatches(cmp, type) || isInstanceOfClass(cmp, type)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }

        depth++;
      }

      target = target.parentNode;
    }

    return null;
  }

}

function widgetMatches(candidate, selector, deep) {
  if (selector === '*') {
    return true;
  }

  if (typeof selector === 'function') {
    return selector(candidate);
  }

  return BryntumWidgetAdapterRegister.isType(candidate, selector, deep);
}

IdHelper.idCounter = 0;
IdHelper.idMap = {};

(window.bryntum || (window.bryntum = {})).get = IdHelper.get;
window.bryntum.IdHelper = IdHelper;
window.bryntum.query = IdHelper.query;
window.bryntum.queryAll = IdHelper.queryAll;
window.bryntum.fromElement = IdHelper.fromElement;
IdHelper._$name = 'IdHelper';


class WidgetHelper {


  static set adapter(adapterClass) {
    this._adapter = new adapterClass();
  }

  static get adapter() {
    if (!this._adapter) {
      throw new Error('Widget adapter is required. Please import BryntumWidgetAdapter class. See docs here: https://www.bryntum.com/docs/grid/#Core/adapter/widget/BryntumWidgetAdapter');
    }

    return this._adapter;
  }


  static get hasAdapter() {
    return !!this._adapter;
  }


  static getById(id) {
    return IdHelper.get(id);
  }


  static fromElement(element, type, limit) {
    return IdHelper.fromElement(element, type, limit);
  }


  static createWidget(config = {}) {
    return this.adapter.createWidget(config);
  }


  static append(widget, config) {
    widget = Array.isArray(widget) && widget || [widget];

    if (config instanceof HTMLElement || typeof config === 'string') {
      config = {
        appendTo: config
      };
    }

    if (config.insertFirst) {
      const target = typeof config.insertFirst === 'string' ? document.getElementById(config.insertFirst) : config.insertFirst;

      if (target.firstChild) {
        config.insertBefore = target.firstChild;
      } else {
        config.appendTo = target;
      }
    }

    return this.adapter.appendWidgets(widget, config);
  }


  static openPopup(element, config) {
    return this.adapter.openPopup(element, config);
  }


  static showContextMenu(element, config) {
    return this.adapter.showContextMenu(element, config);
  }


  static attachTooltip(element, configOrText) {
    return this.adapter.attachTooltip(element, configOrText);
  }


  static hasTooltipAttached(element) {
    return this.adapter.hasTooltipAttached(element);
  }


  static destroyTooltipAttached(element) {
    return this.adapter.destroyTooltipAttached(element);
  }


  static mask(element, msg) {
    return this.adapter.mask(element, msg);
  }


  static unmask(element, close = true) {
    this.adapter.unmask(element);
  }


  static toast(msg) {
    this.adapter.toast(msg);
  }


  static set defaultStyle(style) {
    this.adapter.defaultStyle = style;
  }

  static get defaultStyle() {
    return this.adapter.defaultStyle;
  }

}

WidgetHelper._$name = 'WidgetHelper';


class BrowserHelper {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;

    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));

    me._isIE11 = Boolean(userAgent.match(/rv:11/));
    me._edgeVersion = me.getVersion(userAgent, /Edge?\/(\d+)\./);
    me._isEdge = me._edgeVersion > 0 && me._edgeVersion < 80;

    if (!me._isEdge) {
      me._edgeVersion = 0;
    }

    me._isWebkit = Boolean(userAgent.match(/WebKit/)) && !me._isEdge;
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = !me._isEdge ? me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./) : 0;
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome && !me._isEdge;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._isAndroid = Boolean(userAgent.match(/Android/g));

    try {
      document.querySelector(':scope');


      me.supportsQueryScope = !me._isFirefox;
    } catch (e) {
      me.supportsQueryScope = false;
    }

    me._supportsPassive = false;

    try {


      document.addEventListener('__notvalid__', null, {
        get passive() {
          me._supportsPassive = true;
        }

      });
    } catch (e) {
    }

  }


  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseInt(match[1]) : 0;
  }


  static get isTouchDevice() {
    if ('_isTouchDevice' in this) return this._isTouchDevice;
    return 'ontouchstart' in window ||
      !this.isEdge && navigator.maxTouchPoints > 0 ||
      this.isEdge && window.TouchEvent || navigator.msMaxTouchPoints > 0;
  }

  static get supportsPointerEvents() {
    return Boolean(window.PointerEvent || window.MSPointerEvent);
  }

  static set isTouchDevice(value) {
    this._isTouchDevice = value;
  }


  static get isMac() {
    return this._isMac;
  }


  static get isWindows() {
    return this._isWindows;
  }


  static get isLinux() {
    return this._isLinux;
  }


  static get isIE11() {
    return this._isIE11;
  }


  static get isEdge() {
    return this._isEdge;
  }


  static get edgeVersion() {
    return this._edgeVersion;
  }


  static get isWebkit() {
    return this._isWebkit;
  }


  static get isChrome() {
    return this._isChrome;
  }


  static get chromeVersion() {
    return this._chromeVersion;
  }


  static get isFirefox() {
    return this._isFirefox;
  }


  static get firefoxVersion() {
    return this._firefoxVersion;
  }


  static get isSafari() {
    return this._isSafari;
  }


  static get isMobileSafari() {
    return this._isMobileSafari;
  }

  static get isAndroid() {
    return this._isAndroid;
  }


  static get supportsPassive() {
    return this._supportsPassive;
  }

  static get storageAvailable() {
    let storage, x;

    try {
      storage = localStorage;
      x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (
        e.code === 22 ||
        e.code === 1014 ||

        e.name === 'QuotaExceededError' ||
        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
        storage.length !== 0;
    }
  }

  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }

  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }

  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }


  static searchParam(paramName, defaultValue = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=([^&]*)`),
      match = search.match(re);
    return match && match[1] || defaultValue;
  }

  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + '=',
      cookieItems = document.cookie.split(';');

    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];

      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }

      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }

    return '';
  }

  static get queryString() {
    const params = new URLSearchParams(window.location.search);
    return Object.fromEntries(params.entries());
  }

}

BrowserHelper.cacheFlags();
BrowserHelper._$name = 'BrowserHelper';


const paramValueRegExp = /^(\w+)=(.*)$/,
  parseParams = function (paramString) {
    const result = {},
      params = paramString.split('&');


    for (const nameValuePair of params) {
      const [match, name, value] = paramValueRegExp.exec(nameValuePair);

      if (match) {
        let paramValue = result[name];

        if (paramValue) {
          if (!Array.isArray(paramValue)) {
            paramValue = result[name] = [paramValue];
          }

          paramValue.push(value);
        } else {
          result[name] = value;
        }
      }
    }

    return result;
  };


class AjaxHelper {

  static get(url, options) {
    return this.fetch(url, options);
  }


  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === 'string')) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';
    }

    return this.fetch(url, Object.assign({
      method: 'POST',
      body: payload
    }, options));
  }


  static fetch(url, options = {}) {
    const controller = new AbortController();

    Object.assign(options, {
      abortController: controller,
      signal: controller.signal
    });

    if (!('credentials' in options)) {
      options.credentials = 'include';
    }

    if (options.queryParams) {
      const params = Object.entries(options.queryParams);

      if (params.length) {
        url += '?' + params.map(([param, value]) => `${param}=${encodeURIComponent(value)}`).join('&');
      }
    }

    if (url.match(/undefined|null|\[object/)) {
      throw new Error('Incorrect URL: ' + url);
    }


    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then(response => {
        if (options.parseJson) {
          response.json().then(json => {
            response.parsedJson = json;
            resolve(response);
          }).catch(error => {
            response.parsedJson = null;
            response.error = error;
            reject(response);
          });
        } else {
          resolve(response);
        }
      }).catch(error => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;

    promise.abort = function () {
      controller.abort();
    };

    return promise;
  }


  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;

    if (!AjaxHelper.originalFetch) {
      AjaxHelper.originalFetch = AjaxHelper.fetch;
    }

    AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
  }

  static mockAjaxFetch(url, options) {
    let urlAndParams = url.split('?'),
      result = this.mockAjaxMap[urlAndParams[0]],
      parsedJson = null;

    if (result) {
      if (typeof result === 'function') {
        result = result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }

      try {
        parsedJson = options.parseJson && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }

      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: 'OK',
        url: url,
        parsedJson: parsedJson,
        text: () => new Promise(resolve => {
          resolve(result.responseText);
        }),
        json: () => new Promise(resolve => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function (resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function () {
            resolve(result);
          }, 'delay' in result ? result.delay : 100);
        }
      });
    } else {
      return AjaxHelper.originalFetch(url, options);
    }
  }

}

AjaxHelper._$name = 'AjaxHelper';


class LocaleManager extends Events(Base) {
  static get defaultConfig() {
    return {
      locales: {}
    };
  }

  construct(...args) {
    const me = this;
    super.construct(...args);


    const scriptTag = document.querySelector('script[data-default-locale]');

    if (scriptTag) {
      me.defaultLocaleName = scriptTag.dataset.defaultLocale;
    }

    if (window.bryntum && window.bryntum.locales) {
      Object.keys(window.bryntum.locales).forEach(localeName => {

        if (!localeName.startsWith('moment')) {
          const locale = window.bryntum.locales[localeName];

          if (locale.extends) {
            me.extendLocale(locale.extends, locale);
          } else {
            me.registerLocale(locale.localeName, {
              desc: locale.localeDesc,
              locale: locale
            });
          }
        }
      });

      if (!me.locale) {

        if (me.defaultLocaleName !== 'En') {

          me.applyLocale(me.defaultLocaleName || Object.keys(me.locales)[0]);
        }
      }
    }
  }

  set locales(localeConfigs) {
    this._locales = localeConfigs;
  }


  get locales() {
    return this._locales;
  }


  set locale(locale) {
    if (typeof locale === 'string') {
      this.applyLocale(locale);
    } else {
      if (!locale.locale) {
        locale = {
          locale,
          localeName: locale.localeName || 'custom'
        };
      }

      this.registerLocale(locale.localeName, locale);
      this.applyLocale(locale.localeName);
    }
  }

  get locale() {
    return this._locale;
  }


  registerLocale(name, config) {
    const me = this,
      isDefault = me.defaultLocaleName === name,
      isCurrent = me.locale && me.locale.localeName === name,
      isFirst = Object.keys(me.locales).length === 0;
    me.locales[name] = config;


    if (isDefault || !me.defaultLocaleName && (isFirst || isCurrent)) {
      me.internalApplyLocale(config);
    }
  }


  extendLocale(name, config) {
    const locale = this.locales[name];
    if (!locale) return false;
    Object.keys(config).forEach(cls => {
      if (!locale.locale[cls]) {
        locale.locale[cls] = config[cls];
      } else {
        Object.assign(locale.locale[cls], config[cls]);
      }
    });
    delete locale.locale.extends;
    return true;
  }

  internalApplyLocale(localeConfig) {
    const me = this;
    me._locale = localeConfig.locale;
    me.trigger('locale', localeConfig);
  }


  applyLocale(name, forceApply = false, ignoreError = false) {
    const me = this,
      localeConfig = me.locales[name];

    if (localeConfig && localeConfig.locale && me._locale === localeConfig.locale && !forceApply) {

      return true;
    }

    if (!localeConfig) {
      if (ignoreError) return true;
      throw new Error(`Locale ${name} not registered`);
    }

    function internalApply() {
      me.internalApplyLocale(localeConfig);
    }

    if (!localeConfig.locale) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.path).then(response => {


          response.text().then(text => {

            const parseLocale = new Function(text);
            parseLocale();
            localeConfig.locale = window.bryntum.locales[name];
            internalApply();
            resolve(localeConfig);
          });
        }).catch(response => reject(response));
      });
    }

    internalApply();
    return true;
  }


  loadLocale(path) {
    return AjaxHelper.get(path);
  }

}

const LocaleManagerSingelton = new LocaleManager();


var Localizable = (Target => class Localizable extends (Target || Base) {
  static get defaultConfig() {
    return {
      localeClass: null,
      localizableProperties: []
    };
  }

  static get inTextLocaleRegExp() {
    return /L{([^}]+)}/g;
  }

  static parseText(text) {
    const match = this.inTextLocaleRegExp.exec(text);
    return match ? match[1] : text;
  }

  construct(config = {}, ...args) {
    const me = this;

    super.construct(config, ...args);
    LocaleManagerSingelton.on('locale', me.updateLocalization, me);
    me.updateLocalization();
  }

  get localeClass() {

    return this._localeClass || this.parent && this.parent.localeClass || null;
  }

  set localeClass(key) {
    this._localeClass = key;
  }

  localizeProperty(name) {
    const me = this;

    if (typeof me[name] === 'string') {
      me.originalLocales = me.originalLocales || {};

      me.originalLocales[name] = me.originalLocales[name] || me[name];
      const text = me.originalLocales[name];

      if (text) {
        me[name] = me.L(text);
      }
    }
  }

  updateLocalization() {
    const me = this;
    me.localizableProperties && me.localizableProperties.forEach(me.localizeProperty, me);
  }

  static getTranslation(text, templateData, cls) {
    const {
      locale
    } = LocaleManagerSingelton;
    let result, name;

    if (locale) {
      text = this.parseText(text);

      while (cls && (name = typeof cls === 'string' ? cls : cls.$name || cls.name)) {
        const classTranslation = locale[name];

        if (classTranslation && text in classTranslation) {
          const translation = classTranslation[text];
          result = typeof translation === 'function' && templateData !== undefined ? translation(templateData) : translation;

          break;
        } else if (typeof cls === 'string') {
          break;
        } else {
          cls = Object.getPrototypeOf(cls);
        }
      }
    }

    return result;
  }


  buildLocalizableProperties(config) {
    const localizableProperties = [];

    if (config.localizableProperties) {
      localizableProperties.push(...config.localizableProperties);
    }

    for (let cls = this.constructor.superclass; cls && cls !== Base; cls = cls.superclass) {
      const superConfigDefaultConfig = cls.getConfigDescriptor(true).defaultConfig;

      if (superConfigDefaultConfig && superConfigDefaultConfig.localizableProperties) {
        localizableProperties.push(...superConfigDefaultConfig.localizableProperties.filter(i => localizableProperties.indexOf(i) < 0));
      }
    }

    return localizableProperties;
  }

  startConfigure(config) {
    config.localizableProperties = this.buildLocalizableProperties(config);
    super.startConfigure(config);
  }


  static L(text, templateData = undefined, ...translationProviders) {


    if (!translationProviders.length) {
      translationProviders = [this];
    }

    let translation;
    translationProviders.some(cls => {
      translation = this.getTranslation(text, templateData, cls);
      return translation !== undefined;
    });
    return translation === undefined ? text : translation;
  }


  L(text, templateData = undefined) {


    if (this.localeClass && this.localeClass !== this.constructor) {
      return Localizable.L(text, templateData, this.localeClass, this.constructor);
    } else {
      return Localizable.L(text, templateData, this.constructor);
    }
  }


  get localeManager() {
    return LocaleManagerSingelton;
  }

});


const enOrdinalSuffix = number => number + ({
    1: 'st',
    2: 'nd',
    3: 'rd'
  }[number[number.length - 1]] || 'th'),

  LTRSymbolRegexp = new RegExp('\u200E'),
  defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value,
  useIntlFormat = (name, options, date) => {
    const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale, options));
    let result = formatter.format(date);


    if (BrowserHelper.isIE11) {
      result = result.replace(LTRSymbolRegexp, '');
    }

    return result;
  };

let locale = 'en-US',
  ordinalSuffix = enOrdinalSuffix,

  formatCache = {},
  intlFormatterCache = {},
  parserCache = {};

const MS_PER_DAY = 864e5,
  MS_PER_WEEK = MS_PER_DAY * 7,
  DEFAULT_YEAR = 2020,

  DEFAULT_MONTH = 0,
  DEFAULT_DAY = 1,
  formats = {

    M: date => date.getMonth() + 1,


    Mo: date => ordinalSuffix(formats.M(date).toString()),

    MM: date => (date.getMonth() + 1).toString().padStart(2, '0'),


    MMM: date => useIntlFormat('MMM', {
      month: 'short'
    }, date),

    MMMM: date => useIntlFormat('MMMM', {
      month: 'long'
    }, date),

    Q: date => Math.ceil((date.getMonth() + 1) / 3),

    Qo: date => ordinalSuffix(formats.Q(date).toString()),

    D: date => date.getDate(),


    Do: date => ordinalSuffix(formats.D(date).toString()),

    DD: date => date.getDate().toString().padStart(2, '0'),


    DDD: date => Math.ceil((new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / MS_PER_DAY),

    DDDo: date => ordinalSuffix(formats.DDD(date).toString()),

    DDDD: date => formats.DDD(date).toString().padStart(3, '0'),

    d: date => date.getDay(),

    do: date => ordinalSuffix(date.getDay().toString()),

    d1: date => formats.ddd(date).substring(0, 1),

    dd: date => formats.ddd(date).substring(0, 2),

    ddd: date => useIntlFormat('ddd', {
      weekday: 'short'
    }, date),

    dddd: date => useIntlFormat('dddd', {
      weekday: 'long'
    }, date),
    e: date => date.getDay(),
    E: date => date.getDay() + 1,

    W: date => {

      const target = new Date(date.valueOf());
      target.setDate(target.getDate() - (date.getDay() + 6) % 7 + 3);
      const firstThursday = target.valueOf();
      target.setMonth(0, 1);

      if (target.getDay() !== 4) {
        target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7);
      }

      return 1 + Math.ceil((firstThursday - target) / MS_PER_WEEK);
    },
    Wo: date => ordinalSuffix(formats.W(date).toString()),
    WW: date => formats.W(date).toString().padStart(2, '0'),

    Y: date => date.getFullYear(),


    YY: date => date.getFullYear() % 100,


    YYYY: date => date.getFullYear(),


    A: date => date.getHours() < 12 ? 'AM' : 'PM',
    a: date => date.getHours() < 12 ? 'am' : 'pm',

    H: date => date.getHours(),

    HH: date => date.getHours().toString().padStart(2, '0'),

    h: date => date.getHours() % 12 || 12,

    hh: date => formats.h(date).toString().padStart(2, '0'),

    k: date => date.getHours() + 1,

    kk: date => formats.k(date).toString().padStart(2, '0'),

    K: date => useIntlFormat('K', {
      hour: 'numeric'
    }, date),

    KK: date => useIntlFormat('KK', {
      hour: '2-digit'
    }, date),

    m: date => date.getMinutes(),


    mm: date => formats.m(date).toString().padStart(2, '0'),

    s: date => date.getSeconds(),


    ss: date => formats.s(date).toString().padStart(2, '0'),

    S: date => date.getMilliseconds().toString().substr(0, 1),

    SS: date => date.getMilliseconds().toString().substr(0, 2).padEnd(2, '0'),

    SSS: date => date.getMilliseconds().toString().substr(0, 3).padEnd(3, '0'),
    z: date => useIntlFormat('z', {
      timeZoneName: 'short'
    }, date),
    zz: date => useIntlFormat('zz', {
      timeZoneName: 'long'
    }, date),
    LT: date => useIntlFormat('LT', {
      hour: '2-digit',
      minute: '2-digit'
    }, date),
    LTS: date => useIntlFormat('LTS', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }, date),
    L: date => useIntlFormat('L', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    }, date),
    l: date => useIntlFormat('l', {
      year: 'numeric',
      month: 'numeric',
      day: 'numeric'
    }, date),
    LL: date => useIntlFormat('LL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }, date),
    ll: date => useIntlFormat('ll', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    }, date),
    LLL: date => useIntlFormat('LLL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    }, date),
    lll: date => useIntlFormat('lll', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    }, date),
    LLLL: date => useIntlFormat('LLLL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      weekday: 'long'
    }, date),
    llll: date => useIntlFormat('llll', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      weekday: 'short'
    }, date)
  },

  formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length),
  formatRegexp = `^(?:${formatKeys.join('|')})`,

  emptyFn = () => ({}),
  isNumber = str => numberRegex.test(str),
  parseMilliseconds = str => isNumber(str) && {
    milliseconds: parseInt(str.padEnd(3, '0').substring(0, 3))
  },
  parsers = {
    YYYY: str => ({
      year: parseInt(str)
    }),
    Y: str => ({
      year: parseInt(str)
    }),
    YY: str => {
      const year = parseInt(str);
      return {
        year: year + (year > 1968 ? 1900 : 2000)
      };
    },
    MM: str => ({
      month: parseInt(str) - 1
    }),
    Mo: str => ({
      month: parseInt(str) - 1
    }),
    DD: str => ({
      date: parseInt(str)
    }),
    M: str => ({
      month: parseInt(str) - 1
    }),
    D: str => ({
      date: parseInt(str)
    }),
    Do: str => ({
      date: parseInt(str)
    }),
    DDD: emptyFn,
    MMM: emptyFn,
    MMMM: emptyFn,
    DDDo: emptyFn,
    DDDD: emptyFn,
    d: emptyFn,
    do: emptyFn,
    d1: emptyFn,
    dd: emptyFn,
    ddd: emptyFn,
    dddd: emptyFn,
    Q: emptyFn,
    Qo: emptyFn,
    W: emptyFn,
    Wo: emptyFn,
    WW: emptyFn,
    e: emptyFn,
    E: emptyFn,
    HH: str => ({
      hours: parseInt(str)
    }),
    hh: str => ({
      hours: parseInt(str)
    }),
    mm: str => ({
      minutes: parseInt(str)
    }),
    H: str => ({
      hours: parseInt(str)
    }),
    m: str => ({
      minutes: parseInt(str)
    }),
    ss: str => ({
      seconds: parseInt(str)
    }),
    s: str => ({
      seconds: parseInt(str)
    }),
    S: parseMilliseconds,
    SS: parseMilliseconds,
    SSS: parseMilliseconds,
    A: str => ({
      amPm: str.toLowerCase()
    }),
    a: str => ({
      amPm: str.toLowerCase()
    }),
    L: 'MM/DD/YYYY',
    LT: 'HH:mm A',

    Z: str => {
      if (!str || !timeZoneRegEx.test(str) && str !== 'Z') {
        return null;
      }

      let timeZone = 0;


      if (str !== 'Z') {
        const matches = timeZoneRegEx.exec(str);

        if (matches) {
          const sign = matches[1] === '+' ? 1 : -1,
            hours = parseInt(matches[2]) || 0,
            minutes = parseInt(matches[3]) || 0;
          timeZone = sign * (hours * 60 + minutes);
        } else {
          timeZone = -1 * new Date().getTimezoneOffset();
        }
      }

      return {
        timeZone
      };
    }
  },
  parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length),
  parserRegexp = new RegExp(`(${parserKeys.join('|')})`),

  localeStrRegExp = new RegExp('(l|LL|ll|LLL|lll|LLLL|llll)'),


  validConversions = {


    year: {
      year: 1,
      quarter: 4,
      month: 12,
      week: 52,
      day: 365,
      hour: 24 * 365,
      minute: 1440 * 365,
      second: 86400 * 365,
      millisecond: 86400000 * 365
    },
    quarter: {
      year: 1 / 4,
      quarter: 1,
      month: 3,
      week: 4,
      day: 91,
      hour: 24 * 91,
      minute: 1440 * 91,
      second: 86400 * 91,
      millisecond: 86400000 * 91
    },
    month: {
      year: 1 / 12,
      quarter: 1 / 3,
      month: 1,
      week: 4,
      day: -30,
      hour: -24 * 30,
      minute: -1440 * 30,
      second: -86400 * 30,
      millisecond: -86400000 * 30
    },
    week: {
      year: -1 / 52,
      quarter: -1 / 13,
      month: -1 / 4,
      day: 7,
      hour: 168,
      minute: 10080,
      second: 604800,
      millisecond: 604800000
    },
    day: {
      year: -1 / 365,
      quarter: -1 / 91,
      month: -1 / 30,
      week: 1 / 7,
      hour: 24,
      minute: 1440,
      second: 86400,
      millisecond: 86400000
    },
    hour: {
      year: -1 / (365 * 24),
      quarter: -1 / (91 * 24),
      month: -1 / (30 * 24),
      week: 1 / 168,
      day: 1 / 24,
      minute: 60,
      second: 3600,
      millisecond: 3600000
    },
    minute: {
      year: -1 / (365 * 1440),
      quarter: -1 / (91 * 1440),
      month: -1 / (30 * 1440),
      week: 1 / 10080,
      day: 1 / 1440,
      hour: 1 / 60,
      second: 60,
      millisecond: 60000
    },
    second: {
      year: -1 / (365 * 86400),
      quarter: -1 / (91 * 86400),
      month: -1 / (30 * 86400),
      week: 1 / 604800,
      day: 1 / 86400,
      hour: 1 / 3600,
      minute: 1 / 60,
      millisecond: 1000
    },
    millisecond: {
      year: -1 / (365 * 86400000),
      quarter: -1 / (91 * 86400000),
      month: -1 / (30 * 86400000),
      week: 1 / 604800000,
      day: 1 / 86400000,
      hour: 1 / 3600000,
      minute: 1 / 60000,
      second: 1 / 1000
    }
  },
  normalizedUnits = {
    ms: 'millisecond',
    milliseconds: 'millisecond',
    s: 'second',
    seconds: 'second',
    m: 'minute',
    minutes: 'minute',
    h: 'hour',
    hours: 'hour',
    d: 'day',
    days: 'day',
    w: 'week',
    weeks: 'week',
    M: 'month',
    months: 'month',
    q: 'quarter',
    quarters: 'quarter',
    y: 'year',
    years: 'year'
  },
  withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i,
  noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i,
  canonicalUnitNames = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'],
  canonicalUnitAbbreviations = [['mil'], ['s', 'sec'], ['m', 'min'], ['h', 'hr'], ['d'], ['w', 'wk'], ['mo', 'mon', 'mnt'], ['q', 'quar', 'qrt'], ['y', 'yr']],
  deltaUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'],

  dateProperties = ['milliseconds', 'seconds', 'minutes', 'hours', 'date', 'month', 'year'],

  parseNumber = n => {
    const result = parseFloat(n);
    return isNaN(result) ? null : result;
  },
  numberRegex = /^[0-9]+$/,
  timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/,
  unitMagnitudes = {
    millisecond: 0,
    second: 1,
    minute: 2,
    hour: 3,
    day: 4,
    week: 5,
    month: 6,
    quarter: 7,
    year: 8
  };


class DateHelper extends Localizable() {


  static set defaultFormat(format) {
    this._defaultFormat = format;
  }

  static get defaultFormat() {
    return this._defaultFormat || 'YYYY-MM-DDTHH:mm:ssZ';
  }


  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }

  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || 'YYYY-MM-DDTHH:mm:ss.SSSZ';
  }

  static buildParser(format) {


    const parts = format.split(parserRegexp),
      parser = [];


    if (parts.length === 1 || localeStrRegExp.test(format)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {

        if (index !== 0 || curr !== '') {

          if (parserRegexp.test(curr)) {
            const localeParsers = this.L('parsers') !== 'parsers' && this.L('parsers') || {},
              fn = localeParsers[curr] || parsers[curr];


            if (curr === 'Z' && index < array.length - 2) {
              throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
            }


            if (typeof fn === 'string') {


              const nestedParsers = DateHelper.buildParser(fn),
                lastItem = nestedParsers.pop();
              delete lastItem.last;

              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parsers[curr];
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, 'pattern')) {
          parser.push(prev);
        }

        return prev;
      }, {});
    }

    parser[parser.length - 1].last = true;
    return parser;
  }


  static parse(dateString, format = this.defaultParseFormat) {
    if (dateString instanceof Date) {
      return dateString;
    }

    if (typeof dateString !== 'string' || !dateString) {
      return null;
    }


    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };

    format = format.replace(/S+/gm, 'SSS');
    let parser = parserCache[format],
      result;

    if (!parser) {
      parser = parserCache[format] = DateHelper.buildParser(format);
    }


    parser.reduce((dateString, parser) => {
      if (parser.last) {
        Object.assign(config, parser.fn(dateString));
      } else {
        let splitAt;

        if (parser.splitter === 'T' && dateString.indexOf('T') === -1) {
          splitAt = dateString.indexOf(' ');
        } else {

          splitAt = parser.splitter !== '' ? dateString.indexOf(parser.splitter) : parser.pattern && parser.pattern.length || -1;
        }

        let part, rest;


        if (splitAt === -1 || parser.pattern === 'SSS' && dateString.match(/^\d+Z$/)) {


          const chunks = dateString.split(/([Z\-+])/);


          if (chunks.length === 1) {
            part = dateString;
            rest = '';
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString.substring(0, splitAt) || dateString;
          rest = dateString.substring(splitAt + parser.splitter.length);
        }

        if (parser.fn) {

          const res = parser.fn(part);

          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }

        return rest;
      }
    }, dateString);

    if (config.year && !config.date) {
      config.date = 1;
    }

    const date = this.create(config);

    if (date) {
      result = date;
    } else {

      result = new Date(dateString);
    }

    return result;
  }


  static create(definition) {

    const def = Object.assign({}, definition);
    let invalid = isNaN(def.year),
      useUTC = false;

    if (!invalid) {
      let allNull = true;
      dateProperties.forEach(property => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }

        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }

    if (def.amPm === 'pm') {
      def.hours = def.hours % 12 + 12;
    }

    if ('timeZone' in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }

    if (invalid) {
      return null;
    }

    const args = [defaultValue(def.year, DEFAULT_YEAR), defaultValue(def.month, DEFAULT_MONTH), defaultValue(def.date, DEFAULT_DAY), def.hours, def.minutes, def.seconds, def.milliseconds];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }


  static format(date, format = this.defaultFormat) {

    if (!date || isNaN(date)) {
      return null;
    }

    let formatter = formatCache[format],
      output = '';

    if (!formatter) {
      formatter = formatCache[format] = [];

      for (let i = 0; i < format.length; i++) {

        const formatMatch = format.substr(i).match(formatRegexp),
          predefined = formatMatch && formatMatch[0];

        if (predefined) {
          const localeFormats = this.L('formats') !== 'formats' && this.L('formats') || {},
            fn = localeFormats[predefined] || formats[predefined];
          formatter.push(fn);
          i += predefined.length - 1;
        } else if (format[i] === '{') {

          const index = format.indexOf('}', i + 1);

          if (index === -1) {
            formatter.push(format.substr(i + 1));
            i = format.length;
          } else {
            formatter.push(format.substring(i + 1, index));

            i = index;
          }
        } else {
          formatter.push(format[i]);
        }
      }
    }

    formatter.forEach(step => {
      if (typeof step === 'string') {
        output += step;
      } else {
        output += step(date);
      }
    });


    if (BrowserHelper.isEdge || BrowserHelper.isIE11) {
      output = output.replace(/\u200E/g, '');
    }

    return output;
  }


  static asMilliseconds(amount, unit = null) {
    if (typeof amount === 'string') {
      unit = amount;
      amount = 1;
    }

    return this.as('millisecond', amount, unit);
  }


  static formatDelta(delta, abbrev = false) {
    const result = [],
      getUnit = abbrev ? this.getShortNameOfUnit : this.getLocalizedNameOfUnit,
      sep = abbrev ? '' : ' ';

    for (const unitName of deltaUnits) {
      const d = Math.floor(this.as(unitName, delta));


      if (d) {
        result.push(`${d}${sep}${getUnit.call(this, unitName, d > 1)}`);
        delta -= this.as('ms', d, unitName);
      }

      if (!delta) {
        break;
      }
    }

    return result.join(', ');
  }


  static as(toUnit, amount, fromUnit = 'ms') {
    if (toUnit === fromUnit) return amount;
    toUnit = this.normalizeUnit(toUnit);
    fromUnit = this.normalizeUnit(fromUnit);

    if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }

  static formatContainsHourInfo(format) {
    const stripEscapeRe = /(\\.)/g,
      hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format.replace(stripEscapeRe, ''));
  }


  static is24HourFormat(format) {
    return this.format(this.getTime(13, 0, 0), format).includes('13');
  }


  static add(date, amount, unit = 'ms') {
    const me = this;
    let d;

    if (typeof date === 'string') {
      d = me.parse(date);
    } else {
      d = new Date(date.getTime());
    }

    if (!unit || amount === 0) return d;
    unit = DateHelper.normalizeUnit(unit);

    switch (unit) {
      case 'millisecond':
        d = new Date(d.getTime() + amount);
        break;

      case 'second':
        d = new Date(d.getTime() + amount * 1000);
        break;

      case 'minute':
        d = new Date(d.getTime() + amount * 60000);
        break;

      case 'hour':
        d = new Date(d.getTime() + amount * 3600000);
        break;

      case 'day':

        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
        } else {
          d = new Date(d.getTime() + amount * 86400000);
        }

        if (d.getHours() === 23 && d.getHours() === 0) {
          d = me.add(d, 1, 'hour');
        }

        break;

      case 'week':
        d.setDate(d.getDate() + amount * 7);
        break;

      case 'month': {
        let day = d.getDate();

        if (day > 28) {
          day = Math.min(day, me.getLastDateOfMonth(me.add(me.getFirstDateOfMonth(d), amount, 'month')).getDate());
        }

        d.setDate(day);
        d.setMonth(d.getMonth() + amount);
        break;
      }

      case 'quarter':
        d = me.add(d, amount * 3, 'month');
        break;

      case 'year':
        d.setFullYear(d.getFullYear() + amount);
        break;
    }

    return d;
  }


  static diff(start, end, unit = 'ms', fractional = true) {
    unit = DateHelper.normalizeUnit(unit);
    if (!start || !end) return 0;
    let amount;

    switch (unit) {
      case 'year':
        amount = this.diff(start, end, 'month') / 12;
        break;

      case 'quarter':
        amount = this.diff(start, end, 'month') / 3;
        break;

      case 'month':
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        break;

      case 'week':
        amount = this.diff(start, end, 'day') / 7;
        break;

      case 'day': {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1000) / 86400000;
        break;
      }

      case 'hour':
        amount = (end - start) / 3600000;
        break;

      case 'minute':
        amount = (end - start) / 60000;
        break;

      case 'second':
        amount = (end - start) / 1000;
        break;

      case 'millisecond':
        amount = end - start;
        break;
    }

    return fractional ? amount : Math.round(amount);
  }


  static startOf(date, unit = 'day', clone = true) {
    if (!date) {
      return null;
    }

    unit = this.normalizeUnit(unit);
    if (clone) date = this.clone(date);
    const toSet = {},
      index = unitMagnitudes[unit];

    for (let i = 0; i < index; i++) {
      const currentUnit = canonicalUnitNames[i];

      if (currentUnit !== 'quarter' && currentUnit !== 'week') {
        toSet[currentUnit] = currentUnit === 'day' ? 1 : 0;
      }
    }

    if (unit === 'quarter') {
      toSet.month = (this.get(date, 'quarter') - 1) * 3;
    } else if (unit === 'week') {
      const delta = date.getDay() - this.weekStartDay;
      toSet.day = date.getDate() - delta;
    }

    return this.set(date, toSet);
  }


  static clone(date) {
    return new Date(date.getTime());
  }


  static clearTime(date, clone = true) {
    return DateHelper.startOf(date, 'day', clone);
  }


  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }

    if (typeof unit === 'string') {
      switch (this.normalizeUnit(unit)) {
        case 'millisecond':

          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }

          break;

        case 'second':

          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }

          break;

        case 'minute':

          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }

          break;

        case 'hour':
          date.setHours(amount);
          break;

        case 'day':
        case 'date':
          date.setDate(amount);
          break;

        case 'week':
          throw new Error('week not implemented');

        case 'month':
          date.setMonth(amount);
          break;

        case 'quarter':

          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;

        case 'year':
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit)
        .sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit, amount]) => {
        this.set(date, unit, amount);
      });
    }

    return date;
  }


  static constrain(date, min, max) {
    if (min != null) {
      date = this.max(date, min);
    }

    return max == null ? date : this.min(date, max);
  }


  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }

    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }


  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }


  static isDST(date) {

    const jan = new Date(date.getFullYear(), 0, 1),
      jul = new Date(date.getFullYear(), 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }


  static isBefore(first, second) {
    return first < second;
  }


  static isAfter(first, second) {
    return first > second;
  }


  static isEqual(first, second, unit = null) {
    if (unit === null) {

      return first && second && first.getTime() === second.getTime();
    }

    return this.startOf(first, unit) - this.startOf(second, unit) === 0;
  }


  static compare(first, second, unit = null) {
    const DH = this;

    if (unit) {
      first = DH.startOf(first, unit);
      second = DH.startOf(second, unit);
    }

    if (DH.isBefore(first, second)) return -1;
    if (DH.isAfter(first, second)) return 1;
    return 0;
  }


  static isStartOf(date, unit) {
    return this.isEqual(date, this.startOf(date, unit));
  }


  static betweenLesser(date, start, end) {

    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }


  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }


  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return this.betweenLesser(date1Start, date2Start, date2End) || this.betweenLesser(date2Start, date1Start, date1End);
  }


  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[unit1] - unitMagnitudes[unit2]);
  }


  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }


  static get weekStartDay() {

    const weekStartDay = this.L('weekStartDay');

    if (weekStartDay !== 'weekStartDay') {
      return weekStartDay;
    }

    return 0;
  }


  static get(date, unit) {
    switch (this.normalizeUnit(unit)) {
      case 'millisecond':
        return date.getMilliseconds();

      case 'second':
        return date.getSeconds();

      case 'minute':
        return date.getMinutes();

      case 'hour':
        return date.getHours();

      case 'date':
      case 'day':

        return date.getDate();

      case 'week':
        return formats.W(date);

      case 'month':
        return date.getMonth();

      case 'quarter':
        return Math.floor(date.getMonth() / 3) + 1;

      case 'year':
        return date.getFullYear();
    }

    return null;
  }


  static daysInMonth(date) {
    const d = this.clone(date);
    d.setDate(1);
    d.setMonth(date.getMonth() + 1);
    d.setDate(0);
    return d.getDate();
  }


  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }


  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }


  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }


  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }


  static getNext(date, unit, increment = 1, weekStartDay = this.weekStartDay) {
    const me = this;

    if (unit === 'week') {
      let dt = me.clone(date);
      const day = dt.getDay();
      dt = me.startOf(dt, 'day');
      dt = me.add(dt, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)), 'day');

      if (dt.getDay() !== weekStartDay) me.add(dt, 1, 'hour');
      return dt;
    }

    return me.startOf(me.add(date, increment, unit), unit);
  }


  static isValidDate(date) {
    return this.isDate(date) && !isNaN(date);
  }


  static isDate(value) {

    return value && value.constructor && value.constructor.name === 'Date';
  }


  static getStartOfNextDay(date, clone, noNeedToClearTime) {
    let nextDay = DateHelper.add(noNeedToClearTime ? date : DateHelper.clearTime(date, clone), 1, 'day');

    if (nextDay.getDate() == date.getDate()) {
      const offsetNextDay = DateHelper.add(DateHelper.clearTime(date, clone), 'day', 2).getTimezoneOffset(),
        offsetDate = date.getTimezoneOffset();
      nextDay = DateHelper.add(nextDay, offsetDate - offsetNextDay, 'minute');
    }

    return nextDay;
  }


  static getEndOfPreviousDay(date, noNeedToClearTime) {
    const dateOnly = noNeedToClearTime ? date : DateHelper.clearTime(date, true);

    if (dateOnly - date) {
      return dateOnly;
    } else {
      return this.add(dateOnly, -1, 'day');
    }
  }


  static formatCount(count, unit) {
    unit = DateHelper.normalizeUnit(unit);
    if (count !== 1) unit += 's';
    return count + ' ' + unit;
  }


  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DateHelper.normalizeUnit(baseUnit);
    unit = DateHelper.normalizeUnit(unit);
    if (baseUnit === unit) return 1;


    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DateHelper.as(unit, 1, baseUnit);
    }

    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DateHelper.as(baseUnit, 1, unit);
    }

    return -1;
  }


  static getMeasuringUnit(unit) {
    if (unit === 'week') return 'day';
    return unit;
  }


  static getShortNameOfUnit(unit) {
    const me = this;


    unit = me.parseTimeUnit(unit);

    return me.unitLookup[unit].abbrev;
  }


  static getLocalizedNameOfUnit(unit, plural) {
    const me = this;

    unit = me.normalizeUnit(unit);


    unit = me.parseTimeUnit(unit);

    return me.unitLookup[unit][plural ? 'plural' : 'single'];
  }


  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }

    if (unit.toLowerCase() === 'date') {
      return unit.toLowerCase();
    }

    return canonicalUnitNames.includes(unit.toLowerCase())
      ? unit.toLowerCase()
      : normalizedUnits[unit] || normalizedUnits[unit.toLowerCase()];
  }

  static getUnitByName(name) {

    return DateHelper.normalizeUnit(name) || DateHelper.normalizeUnit(this.parseTimeUnit(name));
  }


  static getDurationInUnit(start, end, unit, doNotRound) {
    return this.diff(start, end, unit, doNotRound);
  }


  static doesUnitsAlign(majorUnit, minorUnit) {


    if (majorUnit !== minorUnit && minorUnit === 'week') return false;
    return true;
  }

  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[this.normalizeUnit(unit)] - 1] || null;
  }

  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[this.normalizeUnit(unit)] + 1] || null;
  }


  static parseDuration(value, allowDecimals = true, defaultUnit) {
    const me = this,
      durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex,
      match = durationRegEx.exec(value);

    if (value == null || !match) {
      return null;
    }

    const magnitude = parseNumber(match[1]),
      unit = me.parseTimeUnit(match[2]) || defaultUnit;

    if (!unit) {
      return null;
    }

    return {
      magnitude,
      unit
    };
  }


  static parseTimeUnit(unitName) {


    const unitMatch = unitName == null ? null : this.durationRegEx.exec(unitName.toLowerCase());

    if (!unitMatch) {
      return null;
    }

    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }

  static fillDayNames() {
    const me = this,
      tempDate = new Date('2000-01-01T12:00:00'),
      dayNames = me._dayNames || [],
      dayShortNames = me._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;

    for (let day = 2; day < 9; day++) {
      tempDate.setDate(day);
      dayNames.push(me.format(tempDate, 'dddd'));
      dayShortNames.push(me.format(tempDate, 'ddd'));
    }

    me._dayNames = dayNames;
    me._dayShortNames = dayShortNames;
  }

  static getDayNames() {
    return this._dayNames;
  }

  static getDayName(day) {
    return this._dayNames[day];
  }

  static getDayShortNames() {
    return this._dayShortNames;
  }

  static getDayShortName(day) {
    return this._dayShortNames[day];
  }

  static fillMonthNames() {
    const me = this,
      tempDate = new Date('2000-01-15T12:00:00'),
      monthNames = me._monthNames || [],
      monthShortNames = me._monthShortNames || [];
    monthNames.length = 0;
    monthShortNames.length = 0;

    for (let month = 0; month < 12; month++) {
      tempDate.setMonth(month);
      monthNames.push(me.format(tempDate, 'MMMM'));
      monthShortNames.push(me.format(tempDate, 'MMM'));
    }

    me._monthNames = monthNames;
    me._monthShortNames = monthShortNames;
  }

  static getMonthShortNames() {
    return this._monthShortNames;
  }

  static getMonthShortName(month) {
    return this._monthShortNames[month];
  }

  static getMonthNames() {
    return this._monthNames;
  }

  static getMonthName(month) {
    return this._monthNames[month];
  }

  static set locale(name) {
    locale = name;
  }

  static get locale() {
    return locale;
  }

  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this,
      unitLookup = {};
    let unitAbbrRegEx = '';

    for (let i = 0; i < unitAbbreviations.length; i++) {
      const
        abbreviations = unitAbbreviations[i],

        unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];


      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? '|' : ''}(`;

      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }

      locale = me.L('locale') || 'en-US';

      if (locale !== 'en-US') {

        const canonicalAbbreviations = canonicalUnitAbbreviations[i];

        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }

      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName})`;
    }

    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }

  static applyLocale() {
    const me = this,
      unitAbbreviations = me.L('unitAbbreviations'),
      unitNames = me.unitNames = me.L('unitNames');


    if (unitNames === 'unitNames') {
      return;
    }

    locale = me.L('locale') || 'en-US';

    if (locale === 'en-US') {

      ordinalSuffix = enOrdinalSuffix;
    } else if (me.L('ordinalSuffix') !== 'ordinalSuffix') {
      ordinalSuffix = me.L('ordinalSuffix');
    }

    formatCache = {};
    parserCache = {};
    intlFormatterCache = {};
    me.setupDurationRegEx(unitNames, unitAbbreviations);

    me.fillDayNames();
    me.fillMonthNames();
  }

}


DateHelper._$name = 'DateHelper';

LocaleManagerSingelton.on({
  locale: 'applyLocale',
  prio: 1000,
  thisObj: DateHelper
});

if (LocaleManagerSingelton.locale) DateHelper.applyLocale();
DateHelper._$name = 'DateHelper';


const whiteSpaceRe = /\s+/,
  typeOf = value => {
    const baseType = typeof value;

    if (baseType === 'object') {
      if (value === null) {
        return 'null';
      }

      if (Object.prototype.toString.call(value) === '[object Date]') {
        return 'date';
      }
    }

    return baseType;
  };

const toFixedFix = 1.005.toFixed(2) === '1.01' ? null : function (number, fractionDigits) {
  const split = number.toString().split('.'),
    newNumber = +(!split[1] ? split[0] : split.join('.') + '1');
  return number.toFixed.call(newNumber, fractionDigits);
};


class ObjectHelper {

  static isEqual(a, b, useIsDeeply = false) {

    if (a === null && b !== null || a === undefined && b !== undefined || b === null && a !== null || b === undefined && a !== undefined) {
      return false;
    }

    if (a == null && b == null) {
      return true;
    }

    if (a === b) {
      return true;
    }

    const typeA = typeof a,
      typeB = typeof b;

    if (typeA === typeB) {
      switch (typeA) {
        case 'number':
        case 'string':
        case 'boolean':
          return a === b;
      }

      switch (true) {
        case a instanceof Date && b instanceof Date:


          return a.getTime() === b.getTime();

        case Array.isArray(a) && Array.isArray(b):
          return a.length === b.length ? a.every((v, idx) => this.isEqual(v, b[idx], useIsDeeply)) : false;

        case typeA === 'object' && a.constructor.prototype === b.constructor.prototype:
          return useIsDeeply ? this.isDeeplyEqual(a, b, useIsDeeply) : JSON.stringify(a) === JSON.stringify(b);
      }
    }

    return String(a) === String(b);
  }


  static isDeeplyEqual(a, b, options = {}) {


    if (a === b) {
      return true;
    }

    if (!a || !b) {
      return false;
    }

    const aKeys = this.keys(a, options.ignore),
      bKeys = this.keys(b, options.ignore);

    if (aKeys.length !== bKeys.length) {
      return false;
    }

    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i];
      const bKey = bKeys[i];

      if (aKey !== bKey) {
        return false;
      }

      const aVal = a[aKey];
      const bVal = b[bKey];


      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        }) === false) {
          continue;
        }
      }

      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });

        if (result === false) {
          return false;
        }

        if (result === true) {
          continue;
        }
      }

      if (!this.isEqual(aVal, bVal, options)) {
        return false;
      }
    }

    return true;
  }


  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) != -1;
  }


  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }

    return a < b;
  }


  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }

    return a > b;
  }


  static fork(obj) {
    var ret, key, value;

    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);

      for (key in obj) {
        value = obj[key];

        if (value) {
          if (value.constructor === Object) {
            ret[key] = this.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }

    return ret;
  }

  static assign(dest, ...sources) {
    var i = 0,
      ln = sources.length,
      source,
      key;

    for (; i < ln; i++) {
      source = sources[i];

      for (key in source) {
        dest[key] = source[key];
      }
    }

    return dest;
  }

  static clone(source) {
    if (source == null) {
      return source;
    }

    var type = source.constructor.name,
      result = source,
      i,
      key;

    if (type === 'Date') {
      return new Date(source.getTime());
    }

    if (type === 'Array') {
      i = source.length;
      result = [];

      while (i--) {
        result[i] = this.clone(source[i]);
      }
    } else if (type === 'Object') {
      result = {};

      for (key in source) {
        result[key] = this.clone(source[key]);
      }
    }

    return result;
  }

  static merge(dest, ...sources) {
    var i = 0,
      ln = sources.length,
      source,
      key,
      value,
      sourceKey;

    for (; i < ln; i++) {
      source = sources[i];

      for (key in source) {
        value = source[key];

        if (value && value.constructor === Object) {
          sourceKey = dest[key];

          if (sourceKey && sourceKey.constructor.name === 'Object') {
            this.merge(sourceKey, value);
          } else {
            dest[key] = this.clone(value);
          }
        } else {
          dest[key] = value;
        }
      }
    }

    return dest;
  }


  static copyProperties(dest, source, props) {
    let prop, i;

    for (i = 0; i < props.length; i++) {
      prop = props[i];

      if (prop in source) {
        dest[prop] = source[prop];
      }
    }

    return dest;
  }


  static copyPropertiesIf(dest, source, props) {
    for (const prop of props) {
      if (!(prop in dest)) {
        dest[prop] = source[prop];
      }
    }

    return dest;
  }


  static keys(object, ignore = null) {
    const result = [];

    for (const p in object) {
      if (!ignore || !ignore[p]) {
        result.push(p);
      }
    }

    return result;
  }


  static isEmpty(object) {
    for (const p in object) {

      return false;
    }

    return true;
  }


  static getTruthyKeys(source) {
    const keys = Object.keys(source);

    for (let i = 0; i < keys.length;) {
      if (source[keys[i]]) {
        i++;
      } else {
        keys.splice(i, 1);
      }
    }

    return keys;
  }


  static getTruthyValues(source) {
    const keys = Object.keys(source);

    for (let i = 0; i < keys.length;) {
      if (source[keys[i]]) {
        keys[i] = source[keys[i++]];
      } else {
        keys.splice(i, 1);
      }
    }

    return keys;
  }


  static createTruthyKeys(source) {
    if (typeof source === 'string') {
      source = source.split(whiteSpaceRe);
    }

    const result = {};

    for (const key of source) {
      if (key.length) {
        result[key] = 1;
      }
    }

    return result;
  }


  static allKeys(object) {
    const result = [];

    for (object; object; object = Object.getPrototypeOf(object)) {
      result.push(...Object.keys(object));
    }

    return result;
  }


  static pathExists(object, path) {
    const properties = path.split('.');
    return properties.every(property => {
      if (!(property in object)) {
        return false;
      }

      object = object[property];
      return true;
    });
  }


  static getPath(object, path) {
    return path.split('.').reduce((result, key) => {
      return (result || {})[key];
    }, object);
  }


  static setPath(object, path, value) {
    path.split('.').reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;

      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }

      return result[key];
    }, object);
    return object;
  }


  static pathifyKeys(object) {
    const result = {};

    for (const key in object) {
      if (Object.hasOwnProperty.call(object, key)) {
        if (object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);

          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }

    return result;
  }


  static deletePath(object, path) {
    path.split('.').reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      } else if (Object.hasOwnProperty.call(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }

  static coerce(from, to) {
    var fromType = typeOf(from),
      toType = typeOf(to),
      isString = typeof from === 'string';

    if (fromType !== toType) {
      switch (toType) {
        case 'string':
          return String(from);

        case 'number':
          return Number(from);

        case 'boolean':


          return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);

        case 'null':
          return isString && (!from || from === 'null') ? null : false;

        case 'undefined':
          return isString && (!from || from === 'undefined') ? undefined : false;

        case 'date':
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }

    return from;
  }

  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto = Object.getPrototypeOf(object),
      existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);

    while (!existingProperty && proto && deep) {
      proto = Object.getPrototypeOf(proto);

      if (proto) {
        existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);
      }
    }

    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = v => {
          existingProperty.set.call(object, v);

          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }

      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);

          if (newGetter) {
            result = newGetter.call(object, result);
          }

          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = v => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };

      newProperty.get = () => {
        let result = object[`_${propertyName}`];

        if (newGetter) {
          result = newGetter.call(object, result);
        }

        return result;
      };
    }

    Object.defineProperty(object, propertyName, newProperty);
  }


  static getPropertyDescriptor(object, propertyName) {
    let result = null;

    for (let obj = object; !result && obj !== Base; obj = Object.getPrototypeOf(obj)) {
      result = Object.getOwnPropertyDescriptor(obj, propertyName);
    }

    return result;
  }


  static cleanupProperties(obj) {
    Object.entries(obj).forEach(([key, value]) => value == null && delete obj[key]);
    return obj;
  }


  static assertType(value, type, name) {

    if (value != null && typeof value !== type) {
      throw new Error(`Incorrect type "${typeof value}" for ${name}, expected "${type}"`);
    }
  }


  static assertNumber(value, name) {
    const asNumber = Number(value);

    if (typeof value !== 'number' || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }


  static assertBoolean(value, name) {
    this.assertType(value, 'boolean', name);
  }


  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }

    return number.toFixed(digits);
  }


  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }


  static round(number, digits) {

    if (digits == null) {
      return number;
    }

    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }

}

ObjectHelper._$name = 'ObjectHelper';


class DomClassList {

  constructor(...classes) {
    if (typeof classes[0] === 'object') {
      Object.assign(this, classes[0]);
    } else {
      this.process(1, classes);
    }

    this[dirtySymbol] = true;
  }


  clone() {
    return new DomClassList(this);
  }


  contains(className) {
    if (typeof className === 'string' && className) {
      return Boolean(this[className]);
    }

    return false;
  }


  toString() {

    return this.length ? `${this.value} ` : '';
  }

  toJSON() {
    return this.toString();
  }


  trim() {
    return this.value;
  }


  isEqual(other) {
    if (typeof other === 'string') {
      testClassList.value = other;
      other = testClassList;
    }

    if (this.length === other.length) {
      const otherClasses = ObjectHelper.getTruthyKeys(other);

      for (let i = 0, len = otherClasses.length; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }

      return true;
    }

    return false;
  }


  get value() {
    const me = this;

    if (me[dirtySymbol]) {
      const keys = ObjectHelper.getTruthyKeys(me);
      me[lengthSymbol] = keys.length;
      me[valueSymbol] = keys.join(' ');
      me[dirtySymbol] = false;
    }

    return me[valueSymbol];
  }

  set value(value) {
    const me = this,
      keys = Object.keys(me),
      len = keys.length;

    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }

    if (value) {
      me.process(1, [value]);
    } else {

      me[dirtySymbol] = true;
    }
  }

  get length() {


    return this.value ? this[lengthSymbol] : 0;
  }

  process(value, classes) {
    const len = classes.length;

    for (let i = 0; i < len; i++) {
      if (classes[i]) {
        const cls = classes[i],
          splitClasses = cls.values ? Array.from(cls.values()) : cls.item ? Array.from(cls) : cls.split(whiteSpaceRe$1),
          len = splitClasses.length;

        for (let i = 0; i < len; i++) {
          if (splitClasses[i]) {
            this[splitClasses[i]] = value;
          }
        }
      }
    }

    this[dirtySymbol] = true;
  }


  add(...classes) {
    this.process(1, classes);
  }


  remove(...classes) {
    this.process(0, classes);
  }


  split() {
    return ObjectHelper.getTruthyKeys(this);
  }

  forEach(fn) {
    return ObjectHelper.getTruthyKeys(this).forEach(fn);
  }

  get isDomClassList() {
    return true;
  }

}

const whiteSpaceRe$1 = /\s+/,
  valueSymbol = Symbol('value'),
  lengthSymbol = Symbol('length'),
  dirtySymbol = Symbol('dirty'),
  testClassList = new DomClassList();
DomClassList._$name = 'DomClassList';


const DEFAULT_FONT_SIZE = 14,
  t0t0 = {
    align: 't0-t0'
  };

let scrollBarWidth = null,
  idCounter = 0,
  themeInfo = null,
  host;

const


  translateMatrixRe = /(?:matrix\((?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(-?\d*\.?[0-9]*),\s?(-?\d*\.?[0-9]*))|(?:matrix3d\((?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(-?\d*),\s?(-?\d*))/,
  pxTtranslateXRe = /translate(3d|X)?\((-?\d*\.?[0-9]*)px(?:,\s?(-?\d*\.?[0-9]*)px)?/,
  pxTtranslateYRe = /translate(3d|Y)?\((-?\d*\.?[0-9]*)px(?:,\s?(-?\d*\.?[0-9]*)px)?/,
  domIdRe = /^[^a-z]+|[^\w:.-]+/gi,
  whiteSpaceRe$2 = /\s+/,


  elementCreateProperties = {
    tag: 1,
    html: 1,
    children: 1,
    tooltip: 1,
    style: 1,
    dataset: 1,
    parent: 1,
    nextSibling: 1,
    ns: 1,
    reference: 1,
    className: 1,
    unmatched: 1,

    _element: 1,

    onlyChildren: 1,

    elementData: 1,
    compareHtml: 1,

    syncOptions: 1

  },
  styleIgnoreProperties = {
    length: 1,
    parentRule: 1,
    style: 1
  },
  styleDimensionProperties = {
    width: 1,
    height: 1,
    top: 1,
    left: 1,
    minWidth: 1,
    minHeight: 1,
    maxWidth: 1,
    maxHeight: 1,
    fontSize: 1
  },
  nativeFocusableTags = {
    BUTTON: 1,
    IFRAME: 1,
    EMBED: 1,
    INPUT: 1,
    OBJECT: 1,
    SELECT: 1,
    TEXTAREA: 1,
    HTML: BrowserHelper.isIE11 ? 1 : 0,
    BODY: BrowserHelper.isIE11 ? 0 : 1
  },
  win = window,
  doc = document,
  emptyObject = {},
  emptyArray = [],
  arraySlice = Array.prototype.slice,
  immediatePromise = new Promise(resolve => resolve()),
  fontProps = ['font-size', 'font-size-adjust', 'font-style', 'font-weight', 'font-family', 'font-kerning', 'font-stretch', 'line-height', 'text-transform', 'text-decoration', 'letter-spacing', 'word-break'],
  isHiddenWidget = e => e._hidden,
  parentNode = el => el.parentNode || el.host,
  isVisible = e => {
    const style = e.ownerDocument.defaultView.getComputedStyle(e);
    return style.getPropertyValue('display') !== 'none' && style.getPropertyValue('visibility') !== 'hidden';
  },
  getRootNode = document.documentElement.getRootNode ? el => el.getRootNode() : el => {
    while (el.parentNode) el = el.parentNode;

    return el;
  },


  hasLayout = el => el && (el === document.body || ('offsetParent' in el ? el.offsetParent : hasLayout(el.parentNode))),


  isInDocument = el => el && (document.body.contains(el) || (host = getRootNode(el).host) && isInDocument(host));
let templateElement, htmlParser;


class DomHelper {

  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {

      if (!this.isVisible(element) || IdHelper.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }

    const nodeName = element.nodeName;


    return nativeFocusableTags[nodeName] || (nodeName === 'A' || nodeName === 'LINK') && !!element.href || element.getAttribute('tabIndex') != null || element.contentEditable === 'true';
  }


  static isInView(el, whole = true) {
    let elRect = Rectangle.from(el),
      inView = true;
    const fullHeight = elRect.height,
      fullWidth = elRect.width;

    while (inView && el.parentElement) {
      el = el.parentElement;
      elRect = elRect.intersect(Rectangle.from(el));
      inView = elRect && (!whole || elRect.height >= fullHeight && elRect.width >= fullWidth);
    }

    return inView;
  }


  static isVisible(element) {
    const document = element.ownerDocument;


    for (; element; element = parentNode(element)) {

      if (element === document) {
        return true;
      }

      if (element.nodeType === 1 && !isVisible(element)) {
        return false;
      }
    }

    return false;
  }

  static roundPx(px, devicePixelRatio = window.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }


  static isCustomElement(element) {
    return element && element.shadowRoot;
  }


  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);

    if (DomHelper.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }

    return el;
  }


  static get activeElement() {
    let el = document.activeElement;

    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }

    return el;
  }


  static getId(element) {
    return element.id || (element.id = 'b-element-' + ++idCounter);
  }


  static getElement(elementOrSelector) {

    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }

    return doc.querySelector(elementOrSelector);
  }


  static setAttributes(elementOrSelector, attributes) {
    const element = this.getElement(elementOrSelector);
    Object.entries(attributes).forEach(([key, value]) => element.setAttribute(key, value));
  }


  static setLength(element, style, value) {
    if (arguments.length === 1) {
      return typeof element === 'number' ? `${element}px` : element;
    } else {
      element = this.getElement(element);
      return element.style[style] = typeof value === 'number' ? `${value}px` : value;
    }
  }


  static getChild(element, selector) {

    if (BrowserHelper.supportsQueryScope) {
      selector = ':scope>' + selector;
    } else {
      const elId = element.id || (element.id = 'b-element-' + ++idCounter);
      selector = `#${elId} > ${selector}`;
    }

    return element.querySelector(selector);
  }


  static hasChild(element, selector) {
    return DomHelper.getChild(element, selector) != null;
  }


  static children(element, selector) {
    return Array.from(element.querySelectorAll(selector));
  }


  static down(element, selector) {
    if (!element) {
      return null;
    }

    if (element.matches && element.matches(selector)) {
      return element;
    }

    if (BrowserHelper.supportsQueryScope) {
      selector = ':scope ' + selector;
    } else {
      const elId = element.id || (element.id = 'b-element-' + ++idCounter);
      selector = `#${elId} ${selector}`;
    }

    return element.querySelector(selector);
  }


  static isDescendant(parentElement, childElement) {

    if (!parentElement.contains) {
      parentElement = parentElement.body;
    }

    return parentElement.contains(childElement);
  }


  static forEachSelector(element, selector, fn) {
    if (typeof element === 'string') {
      fn = selector;
      selector = element;
      element = doc;
    }

    this.children(element, selector).forEach(fn);
  }


  static forEachChild(element, fn) {
    Array.from(element.children).forEach(fn);
  }


  static removeEachSelector(element, selector) {
    this.forEachSelector(element, selector, child => child.remove());
  }

  static removeClsGlobally(element, ...classes) {
    classes.forEach(cls => this.forEachSelector(element, '.' + cls, child => child.classList.remove(cls)));
  }


  static up(element, selector) {

    return element && element.closest(selector);
  }

  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false,
      ancestor,
      parent = element;
    if (!Array.isArray(possibleAncestorParents)) possibleAncestorParents = [possibleAncestorParents];

    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }

      if (outerElement && parent === outerElement) break;
      ancestor = parent;
    }

    if (!found) return null;
    return ancestor || element;
  }


  static getParents(element) {
    const parents = [];

    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }

    return parents;
  }


  static makeValidId(id) {
    if (id == null) return null;
    return String(id).replace(domIdRe, '');
  }


  static createElement(config = {}, returnAll = false, refs = null, syncIdField = null) {
    if (typeof config.parent === 'string') {
      config.parent = document.getElementById(config.parent);
    }

    if (config.syncOptions && config.syncOptions.syncIdField) {
      syncIdField = config.syncOptions.syncIdField;
    }

    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode;
    let element;

    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || 'svg');
    } else {
      element = doc.createElement(config.tag || 'div');
    }

    if (config.html != null) {
      if (config.html instanceof DocumentFragment) {
        element.appendChild(config.html);
      } else {
        element.innerHTML = config.html;
      }
    }

    if (config.tooltip) {
      WidgetHelper.attachTooltip(element, config.tooltip);
    }

    if (config.style) {
      this.applyStyle(element, config.style);
    }

    if (config.dataset) {
      Object.assign(element.dataset, config.dataset);
    }

    if (parent) {
      parent.insertBefore(element, config.nextSibling);
    }

    if (config.reference) {
      (refs || (refs = {}))[config.reference] = element;
      element.setAttribute('reference', config.reference);
    }

    if (config.elementData) {
      element.elementData = config.elementData;
    }

    const {
      className
    } = config;

    if (className) {
      if (className.isDomClassList) {
        element.className = className.toString();
      } else if (typeof className === 'object') {
        element.className = new DomClassList(className);
      } else {
        element.className = className;
      }
    }

    for (const prop of Object.keys(config)) {
      if (!elementCreateProperties[prop]) {
        if (config.ns) {
          element.setAttribute(prop, config[prop]);
        } else {
          element[prop] = config[prop];
        }
      }
    }

    if (returnAll === true) {
      returnAll = [element];
    } else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }

    if (config.children) {
      if (syncIdField) {

        element.syncIdMap = {};
      }

      config.children.forEach(child => {

        if (child) {

          if (typeof child === 'string') {
            element.appendChild(document.createTextNode(child));
          } else if (isNaN(child.nodeType)) {
            child.parent = element;

            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }

            const childElement = DomHelper.createElement(child, returnAll, refs, syncIdField),
              syncId = child.dataset && child.dataset[syncIdField];

            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }

            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }

    element.lastConfig = config;

    config._element = element;


    return refs || returnAll || element;
  }


  static createElementFromTemplate(template, options = emptyObject) {
    const {
      array,
      raw,
      fragment
    } = options;
    let result;


    if (DomHelper.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement('template'))).innerHTML = template;
      result = templateElement.content;

      if (fragment) {


        return result.cloneNode(true);
      }
    } else {
      (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, 'text/html');
      result = htmlParser.parseFromString(template, 'text/html').body;


      if (fragment) {

        const nodes = result ? result.childNodes : emptyArray;
        result = document.createDocumentFragment();

        while (nodes.length) {
          result.appendChild(nodes[0]);
        }

        return result;
      } else if (!result) {
        result = {
          children: [],
          childNodes: []
        };
      }
    }

    if (raw) {
      result = result.childNodes;
    } else {
      result = result.children;
    }

    return result.length === 1 && !array ? result[0] : arraySlice.call(result);
  }


  static insertFirst(into, element) {
    if (element && element.nodeType !== Node.ELEMENT_NODE && element.tag) {
      element = DomHelper.createElement(element);
    }

    return into.insertBefore(element, into.firstElementChild);
  }


  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== Node.ELEMENT_NODE && element.tag) {
      element = DomHelper.createElement(element);
    }

    return beforeElement ? into.insertBefore(element, beforeElement) : DomHelper.insertFirst(into, element);
  }


  static append(parentElement, elementOrConfig) {
    if (elementOrConfig) {
      if (typeof elementOrConfig === 'string') {
        elementOrConfig = DomHelper.createElementFromTemplate(elementOrConfig);
      } else if (elementOrConfig.nodeType !== Node.ELEMENT_NODE && elementOrConfig.tag) {
        elementOrConfig = DomHelper.createElement(elementOrConfig);
      }
    }

    if (Array.isArray(elementOrConfig)) {
      return elementOrConfig.map(element => parentElement.appendChild(element));
    } else {
      return parentElement.appendChild(elementOrConfig);
    }
  }


  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);

    if (matches) {
      return parseInt(matches[2]);
    } else {

      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(this.getStyleValue(this.getElement(element), 'transform'));
      return matches ? parseInt(matches[1] || matches[3]) : 0;
    }
  }


  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);

    if (matches) {

      const y = parseInt(matches[matches[1] === 'Y' ? 2 : 3]);

      return isNaN(y) ? 0 : y;
    } else {

      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(this.getStyleValue(this.getElement(element), 'transform'));
      return matches ? parseInt(matches[2] || matches[4]) : 0;
    }
  }


  static getTranslateXY(element) {
    return [this.getTranslateX(element), this.getTranslateY(element)];
  }


  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }


  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }


  static getOffsetXY(element, container = null) {
    return [this.getOffsetX(element, container), this.getOffsetY(element, container)];
  }


  static focusWithoutScrolling(element) {
    function resetScroll(scrollHierarchy) {
      scrollHierarchy.forEach(({
                                 element,
                                 scrollLeft,
                                 scrollTop
                               }) => {

        if (element.scrollLeft !== scrollLeft) {
          element.scrollLeft = scrollLeft;
        }

        if (element.scrollTop !== scrollTop) {
          element.scrollTop = scrollTop;
        }
      });
    }


    const preventScrollSupported = BrowserHelper.chromeVersion >= 64 || BrowserHelper.fireFoxVersion >= 68;

    if (preventScrollSupported) {
      element.focus({
        preventScroll: true
      });
    } else {


      const parents = DomHelper.getParents(element),
        scrollHierarchy = parents.map(parent => ({
          element: parent,
          scrollLeft: parent.scrollLeft,
          scrollTop: parent.scrollTop
        }));
      element.focus();

      if (BrowserHelper.isIE11) {
        resetScroll(scrollHierarchy);
      } else {
        setTimeout(() => resetScroll(scrollHierarchy), 0);
      }
    }
  }


  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }


  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }


  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style),
      measure = prop.split('-')[1];
    let value = this.getStyleValue(element, prop);

    if (/%/.test(value)) {

      if (element.parentElement) {
        value = parseInt(this.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }

    return value;
  }


  static setTranslateX(element, x) {
    const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/);

    x = DomHelper.roundPx(x);

    if (t.length > 1) {
      t[t[0].startsWith('matrix3d') ? 12 : 4] = x;
      element.style.transform = t.join(',');
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }


  static setTranslateY(element, y) {
    const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/);

    y = DomHelper.roundPx(y);

    if (t.length > 1) {
      t[t[0].startsWith('matrix3d') ? 13 : 5] = y;
      element.style.transform = t.join(',') + ')';
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }


  static setTop(element, y) {
    this.setLength(element, 'top', y);
  }


  static setLeft(element, x) {
    this.setLength(element, 'left', x);
  }


  static setTranslateXY(element, x, y) {
    if (x == null) {
      return this.setTranslateY(element, y);
    }

    if (y == null) {
      return this.setTranslateX(element, x);
    }

    x = DomHelper.roundPx(x);
    y = DomHelper.roundPx(y);
    const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/),
      is3d = t[0].startsWith('matrix3d');

    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(',') + ')';
    } else {
      element.style.transform = `translateX(${x}px) translateY(${y}px)`;
    }
  }


  static addTranslateX(element, x) {
    DomHelper.setTranslateX(element, DomHelper.getTranslateX(element) + x);
  }


  static addTranslateY(element, y) {
    DomHelper.setTranslateY(element, DomHelper.getTranslateY(element) + y);
  }


  static addLeft(element, x) {
    DomHelper.setLeft(element, DomHelper.getOffsetX(element) + x);
  }


  static addTop(element, y) {
    DomHelper.setTop(element, DomHelper.getOffsetY(element) + y);
  }


  static alignTo(element, target, alignSpec = t0t0) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = this.getTranslateXY(element),
      elRect = Rectangle.from(element, true),
      targetRect = elRect.alignTo(Object.assign(alignSpec, {
        target
      }));
    this.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }


  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);

    if (Array.isArray(propName)) {
      const result = {};

      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }

      return result;
    }


    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }


  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === 'border' ? '-width' : '',
      ret = {
        raw: {}
      };

    for (const edge of ['top', 'right', 'bottom', 'left']) {
      if (!edges || edges.includes(edge[0])) {


        ret[edge] = parseFloat(ret.raw[edge] = DomHelper.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`));
      }
    }


    ret.width = ret.left + ret.right;
    ret.height = ret.top + ret.bottom;
    return ret;
  }


  static applyStyle(element, style, overwrite = false) {
    if (typeof style === 'string') {
      if (overwrite) {

        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {


        element.style.cssText += style;
      }
    } else {
      if (overwrite) {
        element.style.cssText = '';
      }

      if (style.style) {
        if (typeof style.style === 'string') {
          element.style.cssText = style.style;
        } else {
          style = Object.assign({}, style.style, style);
        }
      }

      for (const key in style) {


        if (!styleIgnoreProperties[key]) {

          if (styleDimensionProperties[key] && typeof style[key] == 'number') {
            element.style[StringHelper.hyphenate(key)] = style[key] + 'px';
          } else {
            element.style[StringHelper.hyphenate(key)] = style[key];
          }
        }
      }
    }
  }

  static getCSSText(style) {
    if (typeof style === 'string') {
      return style;
    }

    let cssText = '';

    for (const key in style) {


      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }

    return cssText;
  }


  static addClasses(element, classes) {
    classes.forEach(cls => element.classList.add(cls));
  }


  static removeClasses(element, classes) {
    classes.forEach(cls => element.classList.remove(cls));
  }


  static toggleClasses(element, classes, force = null) {
    if (!Array.isArray(classes)) {
      classes = [classes];
    }

    if (force === true) {
      this.addClasses(element, classes);
    } else if (force === false) {
      this.removeClasses(element, classes);
    } else {
      classes.forEach(cls => element.classList.toggle(cls));
    }
  }


  static addTemporaryClass(element, cls, duration, delayable = window) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout(() => element.classList.remove(cls), duration);
    }
  }


  static getPropertyTransitionDuration(el, property) {
    const style = window.getComputedStyle(el),
      properties = style.transitionProperty.split(', '),
      durations = style.transitionDuration.split(', '),
      index = properties.indexOf(property);
    let result;

    if (index !== -1) {

      result = parseFloat(durations[index]) * 1000;
    }

    return result;
  }


  static highlight(element, delayable = window) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }

    return new Promise(resolve => {
      delayable.setTimeout(() => {
        element.classList.add('b-fx-highlight');
        delayable.setTimeout(() => {
          element.classList.remove('b-fx-highlight');
          resolve();
        }, 1000);
      }, 0);
    });
  }


  static get scrollBarWidth() {

    if (scrollBarWidth === null && doc.body) {
      const element = DomHelper.createElement({
        parent: doc.body,
        style: 'position:absolute;top:-999px;width:100px;height:100px;overflow:scroll'
      });
      scrollBarWidth = element.offsetWidth - element.clientWidth;
      element.remove();
    }

    return scrollBarWidth;
  }


  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }


  static measureText(text, sourceElement, useHTML, parentElement) {
    const offScreenDiv = this.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? 'innerHTML' : 'innerText'] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = '';
    return result;
  }


  static measureSize(size, sourceElement) {
    if (!size) {
      return 0;
    }

    if (typeof size === 'number') {
      return size;
    }

    if (!size.length) {
      return 0;
    }

    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }

    if (sourceElement) {
      const offScreenDiv = this.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = '';
      offScreenDiv.style.width = DomHelper.setLength(size);

      const result = offScreenDiv.offsetWidth;
      offScreenDiv.style.width = offScreenDiv.className = '';
      return result;
    }

    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }

    return isNaN(size) ? 0 : parseInt(size);
  }

  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement),
      offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DomHelper.createElement({
        parent: parentElement,
        style: 'position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict',
        className: 'b-measure-element',
        children: [{
          style: 'white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none'
        }]
      }, true)[1];
    fontProps.forEach(prop => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;

    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }

    return offScreenDiv;
  }


  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === 'string') {
      if (sourceElement === '') {
        targetElement.innerHTML = '';
        return;
      } else {
        sourceElement = this.createElementFromTemplate(sourceElement);
      }
    }

    this.performSync(sourceElement, targetElement);
    return targetElement;
  }

  static performSync(sourceElement, targetElement) {

    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      this.syncAttributes(sourceElement, targetElement);
      this.syncContent(sourceElement, targetElement);
      this.syncChildren(sourceElement, targetElement);
      return true;
    }

    return false;
  }

  static getSyncAttributes(element) {
    const attributes = {},

      names = [];

    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];

      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }

    return {
      attributes,
      names
    };
  }


  static syncAttributes(sourceElement, targetElement) {
    const
      {
        attributes: sourceAttributes,
        names: sourceNames
      } = this.getSyncAttributes(sourceElement),
      {
        attributes: targetAttributes,
        names: targetNames
      } = this.getSyncAttributes(targetElement),

      hasDataset = sourceNames.includes('dataset'),

      toAdd = sourceNames.filter(attr => !targetNames.includes(attr)),
      toRemove = targetNames.filter(attr => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith('data-'))),
      toSync = sourceNames.filter(attr => targetNames.includes(attr));

    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];

        if (attr === 'style') {
          this.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === 'dataset') {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }

    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }

    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];

        if (attr === 'style') {

          this.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === 'dataset') {

          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else if (attr === 'class' && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === 'object')) {
          let classList;

          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {

            classList = new DomClassList(sourceAttributes.class);
          }

          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute('class', classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }


  static syncContent(sourceElement, targetElement) {
    if (sourceElement.childElementCount === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }

  static setInnerText(targetElement, text) {


    const firstChild = targetElement.firstChild;

    if (firstChild) {
      firstChild.data = text;
    } else {

      targetElement.textContent = text;
    }
  }


  static syncChildren(sourceElement, targetElement) {
    const me = this,
      sourceNodes = arraySlice.call(sourceElement.childNodes),
      targetNodes = arraySlice.call(targetElement.childNodes);

    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(),
        targetNode = targetNodes.shift();

      if (sourceNode && sourceNode.nodeType !== Node.TEXT_NODE && sourceNode.nodeType !== Node.ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }

      if (targetNode && targetNode.nodeType !== Node.TEXT_NODE && targetNode.nodeType !== Node.ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }

      if (!targetNode) {

        targetElement.appendChild(sourceNode);
      } else {

        if (sourceNode.nodeType === targetNode.nodeType) {

          if (sourceNode.nodeType === Node.TEXT_NODE) {

            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {

              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        } else if (sourceNode.nodeType === Node.TEXT_NODE && targetNode.nodeType === Node.ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          throw new Error('Currently no support for transforming nodeType');
        }
      }
    }

    targetNodes.forEach(targetNode => {
      targetNode.remove();
    });
  }


  static syncClassList(element, newClasses) {
    const classList = element.classList,
      isString = typeof newClasses === 'string',
      newClsArray = isString ? newClasses.trim().split(whiteSpaceRe$2) : Array.isArray(newClasses) ? newClasses : ObjectHelper.getTruthyKeys(newClasses),
      classCount = newClsArray.length;
    let changed = classList.length !== classCount,
      i;


    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }

    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(' ');
    }
  }


  static setTheme(newThemeName) {
    newThemeName = newThemeName.toLowerCase();
    const oldThemeName = this.themeInfo.name.toLowerCase(),
      oldThemeLink = document.head.querySelector('#bryntum-theme:not([data-loading])') || document.head.querySelector(`[href$="${oldThemeName}.css"]:not([data-loading])`);

    DomHelper.removeEachSelector(document.head, '#bryntum-theme[data-loading]');

    if (!oldThemeLink || !oldThemeLink.href.includes(`${oldThemeName}.css`)) {
      throw new Error(`Theme link for ${oldThemeName} not found`);
    }

    if (oldThemeLink.href.includes(newThemeName)) {
      return immediatePromise;
    }

    return new Promise((resolve, reject) => {
      const newThemeLink = document.createElement('link'),
        nextSibling = oldThemeLink.nextSibling,
        oldThemeName = DomHelper.themeInfo.name.toLowerCase(),
        themeEvent = {
          theme: newThemeName,
          prev: oldThemeName
        },
        onThemeLoad = () => {
          delete newThemeLink.dataset.loading;
          themeInfo = null;
          oldThemeLink.remove();
          window.bryntum.GlobalEvents.trigger('theme', themeEvent);
          resolve(themeEvent);
        },
        onThemeLoadError = e => {
          delete newThemeLink.dataset.loading;
          reject(e);
        };

      newThemeLink.rel = 'stylesheet';
      newThemeLink.id = 'bryntum-theme';
      newThemeLink.addEventListener('load', onThemeLoad);
      newThemeLink.addEventListener('error', onThemeLoadError);
      newThemeLink.dataset.loading = 'true';
      newThemeLink.href = oldThemeLink.href.replace(oldThemeName, newThemeName);
      nextSibling.parentNode.insertBefore(newThemeLink, nextSibling);
    });
  }


  static get themeInfo() {
    if (!themeInfo) {
      const testDiv = this.createElement({
          parent: document.body,
          className: 'b-theme-info'
        }),

        themeData = this.getStyleValue(testDiv, 'content', false, ':before');

      if (themeData) {

        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ''));
        } catch (e) {
          themeInfo = null;
        }
      }

      testDiv.remove();
    }

    return themeInfo;
  }

  static isOrphaned(element) {
    return element !== document.body && element !== document.documentElement && element.nodeType === Node.ELEMENT_NODE && element.offsetParent === null;
  }

}

let clearTouchTimer;

const clearTouchEvent = () => DomHelper.isTouchEvent = false,
  setTouchEvent = () => {
    DomHelper.isTouchEvent = true;

    clearTimeout(clearTouchTimer);
    clearTouchTimer = setTimeout(clearTouchEvent, 400);
  };


doc.addEventListener('touchstart', setTouchEvent, true);
doc.addEventListener('touchend', setTouchEvent, true);
DomHelper.supportsTemplate = 'content' in doc.createElement('template');


if (!('children' in Node.prototype)) {
  const elementFilter = node => node.nodeType === 1;

  Object.defineProperty(Node.prototype, 'children', {
    get: function () {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}

if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;

    while (--i >= 0 && matches.item(i) !== this) {
    }

    return i > -1;
  };
}

if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function (s) {
    var el = this;
    if (!doc.documentElement.contains(el)) return null;

    do {
      if (el.matches(s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);

    return null;
  };
} else {

  Node.prototype.closest = function (selector) {
    return this.parentNode.closest(selector);
  };
}

(function (arr) {
  arr.forEach(function (item) {
    if (Object.prototype.hasOwnProperty.call(item, 'remove')) {
      return;
    }

    Object.defineProperty(item, 'remove', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

if (!SVGElement.prototype.contains) {
  SVGElement.prototype.contains = function (node) {
    do {
      if (this === node) {
        return true;
      }

      node = node.parentNode;
    } while (node);

    return false;
  };
}

if (typeof win.CustomEvent !== 'function') {
  let evt, constructor;

  win.CustomEvent = constructor = function (event, params = {
    bubbles: false,
    cancelable: false,
    detail: undefined
  }) {
    evt = doc.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  };

  constructor.prototype = win.Event.prototype;

  win.MouseEvent = constructor = function (event, params = {
    bubbles: false,
    cancelable: false,
    detail: undefined
  }) {
    evt = doc.createEvent('MouseEvents');
    evt.initMouseEvent(event, params.bubbles, params.cancelable, doc.defaultView || win, params.detail, params.screenX, params.screenY, params.clientX, params.clientY, false, false, false, false, 0, document);
    return evt;
  };

  constructor.prototype = win.Event.prototype;

  win.KeyboardEvent = constructor = function (event, params = {
    bubbles: false,
    cancelable: false,
    detail: undefined
  }) {
    const modifiers = `${params.shiftKey ? 'Shift ' : ''}${params.ctrlKey ? 'Control' : ''}`;
    evt = doc.createEvent('KeyboardEvent');
    evt.initKeyboardEvent(event, params.bubbles, params.cancelable, doc.defaultView || win, params.key, params.location, modifiers, false, '');
    return evt;
  };

  constructor.prototype = win.Event.prototype;
}


if (!Object.getOwnPropertyDescriptor(SVGElement.prototype, 'dataset') || !Object.getOwnPropertyDescriptor(SVGElement.prototype, 'dataset').get) {
  var propDescriptor = {
    enumerable: true,
    get: function () {

      var i,
        that = this,
        map = {},
        attrVal,
        attrName,
        propName,
        attribute,
        attributes = this.attributes,
        attsLength = attributes.length,
        toUpperCase = function (n0) {
          return n0.charAt(1).toUpperCase();
        },
        getter = function () {
          return this;
        },
        setter = function (attrName, value) {
          return typeof value !== 'undefined' ? this.setAttribute(attrName, value) : this.removeAttribute(attrName);
        };

      for (i = 0; i < attsLength; i++) {
        attribute = attributes[i];


        if (attribute && attribute.name && /^data-\w[\w-]*$/.test(attribute.name)) {
          attrVal = attribute.value;
          attrName = attribute.name;

          propName = attrName.substr(5).replace(/-./g, toUpperCase);
          Object.defineProperty(map, propName, {
            enumerable: this.enumerable,
            get: getter.bind(attrVal || ''),
            set: setter.bind(that, attrName)
          });
        }
      }

      return map;
    }
  };


  Object.defineProperty(SVGElement.prototype, 'dataset', propDescriptor);
}

const nativeAdd = DOMTokenList.prototype.add,
  nativeRemove = DOMTokenList.prototype.remove;

DOMTokenList.prototype.add = function (cls) {
  if (Array.isArray(cls)) {
    nativeAdd.call(this, ...cls);
  } else {
    nativeAdd.call(this, ...arguments);
  }
};

DOMTokenList.prototype.remove = function (cls) {
  if (Array.isArray(cls)) {
    nativeRemove.call(this, ...cls);
  } else {
    nativeRemove.call(this, ...arguments);
  }
};

DomHelper._$name = 'DomHelper';


const allBorders = ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
  allPaddings = ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'],
  borderNames = {
    t: 'border-top-width',
    r: 'border-right-width',
    b: 'border-bottom-width',
    l: 'border-left-width'
  },
  paddingNames = {
    t: 'padding-top',
    r: 'padding-right',
    b: 'padding-bottom',
    l: 'padding-left'
  },
  zeroBased = Object.freeze({
    x: 0,
    y: 0
  }),
  alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i,
  alignPointRe = /^([trblc])(\d*)$/i,
  edgeNames = ['top', 'right', 'bottom', 'left'],
  edgeIndices = {
    t: 0,
    r: 1,
    b: 2,
    l: 3
  },
  defaultAlignments = ['b-t', 'l-r', 't-b', 'r-l'],
  zeroOffsets = Object.freeze([0, 0]),
  matchDimensions = ['width', 'height'];

function parseAlign(alignSpec) {
  const parts = alignSpecRe.exec(alignSpec),
    myOffset = parseInt(parts[2] || 50),
    targetOffset = parseInt(parts[4] || 50);

  return {
    myAlignmentPoint: parts[1] + myOffset,

    myEdge: parts[1],

    myOffset,

    targetAlignmentPoint: parts[3] + targetOffset,

    targetEdge: parts[3],

    targetOffset,

    startZone: edgeIndices[parts[3]]

  };
}

function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}

function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === 'number') {
    return [offset, offset];
  }

  return offset;
}


class Rectangle {

  static from(element, relativeTo, ignorePageScroll) {
    if (element instanceof Rectangle) {
      return element;
    }

    if (ignorePageScroll === undefined && typeof relativeTo === 'boolean') {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }

    if (relativeTo) {

      let {
        scrollLeft,
        scrollTop
      } = relativeTo;

      if ((BrowserHelper.isEdge || BrowserHelper.isSafari) && relativeTo === document.body) {
        scrollLeft = scrollTop = 0;
      }

      relativeTo = Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
    } else {
      relativeTo = zeroBased;
    }


    const isViewport = element === document || element === window,
      viewRect = isViewport ? new Rectangle(0, 0, window.innerWidth, window.innerHeight) : element.getBoundingClientRect(),
      scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [window.pageXOffset, window.pageYOffset];
    return new Rectangle(viewRect.left + scrollOffset[0] - relativeTo.x, viewRect.top + scrollOffset[1] - relativeTo.y, viewRect.width, viewRect.height);
  }


  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);

    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseInt(borders[borderNames.l]);
      result.y += parseInt(borders[borderNames.t]);
      result.right -= parseInt(borders[borderNames.r]);
      result.bottom -= parseInt(borders[borderNames.b]);
    }

    return result;
  }


  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);

    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders),
        padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseInt(borders[borderNames.l]) + parseInt(padding[paddingNames.l]);
      result.y += parseInt(borders[borderNames.t]) + parseInt(padding[paddingNames.t]);
      result.right -= parseInt(borders[borderNames.r]) + parseInt(padding[paddingNames.r]);
      result.bottom -= parseInt(borders[borderNames.b]) + parseInt(padding[paddingNames.b]);
    }

    return result;
  }


  static client(element, relativeTo, ignorePageScroll = false) {
    const result = this.content(element, relativeTo, ignorePageScroll),
      scrollbarWidth = DomHelper.scrollBarWidth;
    let padding;

    if (scrollbarWidth) {


      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, 'overflow-y') !== 'hidden') {
        padding = parseInt(DomHelper.getStyleValue(element, 'padding-right'));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }


      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, 'overflow-x') !== 'hidden') {
        padding = parseInt(DomHelper.getStyleValue(element, 'padding-bottom'));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }

    return result;
  }


  static union(...rectangles) {
    let {
        x,
        y,
        right,
        bottom
      } = rectangles[0],
      current;

    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];

        if (current.x < x) {
          x = current.x;
        }

        if (current.y < y) {
          y = current.y;
        }

        if (current.right > right) {
          right = current.right;
        }

        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }

    return new Rectangle(x, y, right - x, bottom - y);
  }


  round(devicePixelRatio) {
    VersionHelper.deprecate('Core', '3.0.0', 'Use Rectangle.roundPx() method instead.');
    return this.roundPx(devicePixelRatio);
  }


  roundPx(devicePixelRatio = window.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }


  static get $name() {
    return Object.prototype.hasOwnProperty.call(this, '_$name') && this._$name || this.name;
  }

  get $name() {
    return this.constructor.$name;
  }


  constructor(x, y, width, height) {
    ObjectHelper.assertNumber(x, 'Rectangle.x');
    ObjectHelper.assertNumber(y, 'Rectangle.y');
    ObjectHelper.assertNumber(width, 'Rectangle.width');
    ObjectHelper.assertNumber(height, 'Rectangle.height');
    const me = this;
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }


  clone() {
    const me = this,
      result = new Rectangle(me.x, me.y, me.width, me.height);
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }


  contains(other) {
    const me = this;

    if (other instanceof Rectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }


  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this,
      y = Math.max(me.y, other.y),
      r = Math.min(me.right, other.right),
      b = Math.min(me.bottom, other.bottom),
      x = Math.max(me.x, other.x),
      intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;

    if (intersect) {
      return useBoolean ? true : new Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }

  equals(other, round = false) {
    const processor = round ? x => Math.round(x) : x => x;
    return other instanceof Rectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }


  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }


  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }

    if (y != null) {
      this._y = y;
    }

    return this;
  }


  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }


  get center() {
    return new Rectangle.Point(this.x + this.width / 2, this.y + this.height / 2);
  }


  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }

  get x() {
    return this._x;
  }


  set left(x) {
    this.x = x;
  }

  get left() {
    return this.x;
  }


  set top(y) {
    this.y = y;
  }

  get top() {
    return this.y;
  }


  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }

  get y() {
    return this._y;
  }


  set width(width) {
    this._width = width;
  }

  get width() {
    return this._width;
  }


  set height(height) {
    this._height = height;
  }

  get height() {
    return this._height;
  }


  set right(right) {
    this._width = right - this._x;
  }

  get right() {
    return this._x + this._width;
  }


  set bottom(bottom) {
    this._height = bottom - this._y;
  }

  get bottom() {
    return this._y + this._height;
  }

  get area() {
    return this.width * this.height;
  }

  set minWidth(minWidth) {
    const me = this;

    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      me.width = Math.max(me.width, me._minWidth);
    }
  }

  get minWidth() {
    return this._minWidth;
  }

  set minHeight(minHeight) {
    const me = this;

    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      me.height = Math.max(me.height, me._minHeight);
    }
  }

  get minHeight() {
    return this._minHeight;
  }


  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }


  inflate(amount) {
    return this.adjust(-amount, -amount, amount, amount);
  }


  constrainTo(constrainTo, strict) {
    const me = this,
      originalHeight = me.height,
      originalY = me.y,
      minWidth = me.minWidth || me.width,
      minHeight = me.minHeight || me.height;

    if (me.height >= constrainTo.height) {

      if (strict && minHeight > constrainTo.height) {
        return false;
      }

      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }

    if (me.width >= constrainTo.width) {

      if (strict && minWidth > constrainTo.width) {

        me.y = originalY;
        me.height = originalHeight;
        return false;
      }

      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }

    let overflow = me.bottom - constrainTo.bottom;

    if (overflow > 0) {
      me.translate(0, -overflow);
    }

    overflow = me.right - constrainTo.right;

    if (overflow > 0) {
      me.translate(-overflow);
    }

    overflow = constrainTo.y - me.y;

    if (overflow > 0) {
      me.translate(0, overflow);
    }

    overflow = constrainTo.x - me.x;

    if (overflow > 0) {
      me.translate(overflow);
    }

    return me;
  }


  alignTo(spec) {


    let result = this.clone(),
      target = spec.target,
      constrainTo = spec.constrainTo,
      calculatedAnchorPosition,
      zone,
      resultZone,
      constrainingToViewport;

    if (target && !(target instanceof Rectangle)) {
      target = Rectangle.from(target.element ? target.element : target);
    }

    if (constrainTo && !(constrainTo instanceof Rectangle)) {


      constrainingToViewport = constrainTo === window || constrainTo === document;


      const ignorePageScroll = 'ignorePageScroll' in spec ? spec.ignorePageScroll : !constrainingToViewport;
      constrainTo = Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);

      if (spec.constrainPadding) {
        constrainTo.inflate(-spec.constrainPadding);
      }
    }

    const me = this,
      targetOffsets = createOffsets(spec.offset),
      {
        align,
        axisLock,
        anchorSize,
        anchorPosition
      } = spec,
      alignSpec = parseAlign(align),
      position = spec.position || (target && target.$name === 'Point' ? target : null),
      targetConstrainRect = constrainTo && constrainTo.clone(),
      constraintZones = [],
      zoneOrder = [{
        zone: zone = alignSpec.startZone,
        align
      }],
      matchDimension = spec.matchSize && matchDimensions[alignSpec.startZone & 1],
      originalSize = me[matchDimension];

    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    }

    if (constrainTo) {
      result.constrainTo(constrainTo);
    }

    if (constrainTo && alignSpec.startZone != null) {


      if (axisLock) {


        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });

        if (axisLock === 'flexible') {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      } else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }


    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? 'y' : 'x';
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }

    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }

    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;

    if (position) {
      result.moveTo(position.x, position.y);

      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    } else {


      const offsets = anchorSize ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets,
        targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets),
        myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);


      const overlap = result.intersect(target, true);


      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }

        resultZone = alignSpec.startZone;
        result.translate(...offsets);
      } else if (constrainTo && !constrainTo.contains(result)) {
        let requestedResult = result.clone(),
          solutions = [],
          zone,
          largestZone;


        calculatedAnchorPosition = null;


        constraintZones[0] = zone = constrainTo.clone();
        zone.bottom = target.y - offsets[1];

        constraintZones[1] = zone = constrainTo.clone();
        zone.x = target.right + offsets[0];

        constraintZones[2] = zone = constrainTo.clone();
        zone.y = target.bottom + offsets[1];

        constraintZones[3] = zone = constrainTo.clone();
        zone.right = target.x - offsets[0];

        for (let i = 0; i < zoneOrder.length; i++) {

          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }

          zone = constraintZones[resultZone = zoneOrder[i].zone];

          result = result.alignTo({
            target: target,
            offsets: offsets,
            align: zoneOrder[i].align
          });


          if (result.constrainTo(zone, true)) {
            solutions.push({
              result: result,
              zone: resultZone
            });


            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }

          if (!largestZone || zone.area > largestZone.area) {
            const r = result.clone();

            switch (resultZone) {

              case 0:
                r.moveTo(null, zone.bottom - r.height);
                break;


              case 1:
                r.moveTo(zone.left);
                break;


              case 2:
                r.moveTo(null, zone.top);
                break;


              case 3:
                r.moveTo(zone.right - r.width);
                break;
            }

            largestZone = {
              area: zone.area,
              result: r,
              zone: resultZone
            };
          }
        }

        if (solutions.length) {


          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s1, s2) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s1.result.x) ** 2 + (requestedResult.y - s1.result.y) ** 2),
                s2TranslationDistance = Math.sqrt((requestedResult.x - s2.result.x) ** 2 + (requestedResult.y - s2.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }

          result = solutions[0].result;
          resultZone = solutions[0].zone;
        } else {
          result = largestZone.result;
          resultZone = largestZone.zone;


          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }

      result.zone = resultZone;


      if (anchorSize) {


        if (!calculatedAnchorPosition) {
          let isLeftOrRight = resultZone & 1,
            start = isLeftOrRight ? 'y' : 'x',
            end = isLeftOrRight ? 'bottom' : 'right',
            startValue = Math.max(target[start], result[start]),
            endValue = Math.min(target[end], result[end]),
            anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2,
            anchorEnd = anchorStart + anchorSize[0];

          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }

          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }


          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }

        result.anchor = calculatedAnchorPosition;
      }
    }

    return result;
  }


  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    const me = this,
      parts = alignPointRe.exec(alignmentPoint),
      edge = parts[1].toLowerCase(),
      edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;

    switch (edge) {
      case 't':
        return [me.x + me.width * edgeOffset, me.y - margins[1]];

      case 'r':
        return [me.right + margins[0], me.y + me.height * edgeOffset];

      case 'b':
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];

      case 'l':
        return [me.x - margins[0], me.y + me.height * edgeOffset];

      case 'c': {
        const center = me.center;
        return [center.x + margins[0], center.y + margins[1]];
      }
    }
  }


  highlight() {
    const me = this,
      highlightElement = DomHelper.createElement({
        parent: document.body,
        style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
      });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }

}

Rectangle._$name = 'Rectangle';


class Point extends Rectangle {

  static from(event) {
    const touchPoints = event.changedTouches;
    return new Point(touchPoints ? touchPoints[0].screenX : event.screenX, touchPoints ? touchPoints[0].screenY : event.pageY);
  }


  constructor(x, y) {
    super(x, y, 0, 0);
  }


  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }

  toArray() {
    return [this.x, this.y];
  }

}


Point.__proto__.Point = Point;
Point._$name = 'Point';


class FunctionHelper {
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function (...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }

  static bindAll(obj) {
    for (let key in obj) {
      if (typeof obj[key] === 'function') {
        obj[key] = obj[key].bind(obj);
      }
    }
  }


  static createInterceptor(original, interceptor, thisObj) {
    return (...args) => {
      if (interceptor.call(thisObj, ...args) !== false) {
        return original.call(thisObj, ...args);
      }

      return false;
    };
  }


  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args),
        sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }


  static createThrottled(fn, buffer, thisObj, extraArgs, alt) {
    let lastCallTime = 0,
      callArgs,
      timerId,
      result;

    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn.apply(thisObj, callArgs);
    };

    result = function (...args) {
      let elapsed = performance.now() - lastCallTime;
      callArgs = args;

      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }

        if (alt) {
          callArgs.push.apply(callArgs, extraArgs);
          alt.apply(thisObj, callArgs);
        }
      }
    };

    result.cancel = () => clearTimeout(timerId);

    return result;
  }


  static createBuffered(fn, buffer, thisObj, args) {
    let callArgs, timerId, result;

    const invoke = () => {
      timerId = 0;
      callArgs.push.apply(callArgs, args);
      fn.apply(thisObj, callArgs);
    };

    result = function (...args) {
      callArgs = args;

      if (timerId) {
        clearTimeout(timerId);
      }

      timerId = setTimeout(invoke, buffer);
    };

    result.cancel = () => clearTimeout(timerId);

    return result;
  }

  static returnTrue() {
    return true;
  }

  static animate(duration, fn, thisObj, easing = 'linear') {
    let cancel = false;
    const result = new Promise(resolve => {
      const start = performance.now(),
        iterate = () => {
          const progress = Math.min((performance.now() - start) / duration, 1),
            delayable = thisObj && thisObj.setTimeout ? thisObj : window;

          if (!cancel) {
            if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {
              resolve();
            }
          }

          if (cancel || progress === 1) {


            delayable.requestAnimationFrame(() => resolve());
          } else {
            delayable.requestAnimationFrame(iterate);
          }
        };

      iterate();
    });

    result.cancel = () => {
      cancel = true;
      return false;
    };

    return result;
  }

}


const half = 0.5,
  e1 = 1.70158,
  e2 = 7.5625,
  e3 = 1.525,
  e4 = 2 / 2.75,
  e5 = 2.25 / 2.75,
  e6 = 1 / 2.75,
  e7 = 1.5 / 2.75,
  e8 = 2.5 / 2.75,
  e9 = 2.625 / 2.75,
  e10 = 0.75,
  e11 = 0.9375,
  e12 = 0.984375;
FunctionHelper.easingFunctions = {
  linear: t => t,
  easeInQuad: t => Math.pow(t, 2),
  easeOutQuad: t => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: t => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: t => Math.pow(t, 3),
  easeOutCubic: t => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: t => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: t => Math.pow(t, 4),
  easeOutQuart: t => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: t => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: t => Math.pow(t, 5),
  easeOutQuint: t => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: t => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: t => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: t => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: t => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: t => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: t => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: t => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: t => t * t * ((e1 + 1) * t - e1),
  easeOutBack: t => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: t => {
    let s = 1.70158;
    return (t /= half) < 1 ? half * (t * t * (((s *= e3) + 1) * t - s)) : half * ((t -= 2) * t * (((s *= e3) + 1) * t + s) + 2);
  },
  elastic: t => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: t => {
    let s = 1.70158;
    return (t /= half) < 1 ? half * (t * t * (((s *= e3) + 1) * t - s)) : half * ((t -= 2) * t * (((s *= e3) + 1) * t + s) + 2);
  },
  swingFrom: t => t * t * ((e1 + 1) * t - e1),
  swingTo: t => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: t => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: t => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: t => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: t => Math.pow(t, 4),
  easeTo: t => Math.pow(t, 0.25)
};
FunctionHelper._$name = 'FunctionHelper';


const touchProperties = ['clientX', 'clientY', 'pageX', 'pageY', 'screenX', 'screenY'],
  isOption = {
    element: 1,
    thisObj: 1,
    once: 1,
    delegate: 1,
    delay: 1,
    capture: 1,
    passive: 1,
    throttled: 1,
    autoDetach: 1,
    expires: 1
  },
  ctrlKeyProp = {
    get: () => true
  },
  normalizedKeyNames = {
    Spacebar: 'Space',
    Del: 'Delete',
    Esc: 'Escape',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown'
  },
  fixEvent = event => {
    const {
      type
    } = event;

    if (type.startsWith('key')) {
      const normalizedKeyName = normalizedKeyNames[event.key];

      if (normalizedKeyName) {
        Object.defineProperty(event, 'key', {
          get: () => normalizedKeyName
        });
      }

      if (event.key === ' ' && !event.code) {
        Object.defineProperty(event, 'code', {
          get: () => 'Space'
        });
      }
    }


    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, 'ctrlKey', ctrlKeyProp);
    }


    if (event.target && event.target.shadowRoot && event.composedPath && !BrowserHelper.isIE11 && !BrowserHelper.isEdge) {
      const targetElement = event.composedPath()[0],
        originalTarget = event.target;

      if (event.target !== targetElement) {
        Object.defineProperty(event, 'target', {
          get: () => targetElement
        });

        Object.defineProperty(event, 'originalTarget', {
          get: () => originalTarget
        });
      }
    }


    if (BrowserHelper.isChrome && event.target) {
      const {
          target
        } = event,
        {
          offsetX,
          offsetY
        } = event,
        {
          offsetWidth,
          offsetHeight
        } = target,
        x = Math.min(Math.max(offsetX, 0), offsetWidth - 1),
        y = Math.min(Math.max(offsetY, 0), offsetHeight - 1);

      if (!Object.getOwnPropertyDescriptor(event, 'offsetX') && (offsetX < 0 || offsetX >= offsetWidth)) {
        Object.defineProperty(event, 'offsetX', {
          get: () => x
        });
      }

      if (!Object.getOwnPropertyDescriptor(event, 'offsetY') && (offsetY < 0 || offsetY >= offsetHeight)) {
        Object.defineProperty(event, 'offsetY', {
          get: () => y
        });
      }
    }

    if (event.target && event.target.nodeType === 9 && 'clientX' in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, 'target', {
        get: () => targetElement
      });
    }


    if (event.target && event.target.nodeType === 3) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, 'target', {
        get: () => targetElement
      });
    }

    if (event.relatedTarget && event.relatedTarget.nodeType === 3) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, 'relatedTarget', {
        get: () => relatedTargetElement
      });
    }


    if (type.startsWith('touch') && event.touches.length) {
      EventHelper.normalizeEvent(event);
    }

    return event;
  };


class EventHelper {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.touches[0] || event.changedTouches[0], touchProperties);
  }


  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }

    return [event.clientX, event.clientY];
  }


  static getDistanceBetween(event1, event2) {
    const xy1 = this.getXY(event1),
      xy2 = this.getXY(event2);

    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }


  static getPagePoint(event) {
    return new Point(event.pageX, event.pageY);
  }


  static getClientPoint(event) {
    return new Point(event.clientX, event.clientY);
  }


  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {

      if (typeof eventName === 'string') {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      } else {
        options = Object.assign({
          element
        }, eventName);
      }
    } else {
      options = element;
    }

    return this.on(options);
  }


  static on(options) {
    const EventHelper = this,
      element = options.element,
      thisObj = options.thisObj,
      handlerDetails = [],
      keys = ObjectHelper.allKeys(options);
    let len = keys.length,
      i,
      eventName;

    for (i = 0; i < len; i++) {
      eventName = keys[i];

      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];

        if (typeof handlerSpec !== 'object') {
          handlerSpec = {
            handler: handlerSpec
          };
        }

        const targetElement = handlerSpec.element || element;


        if (BrowserHelper.isTouchDevice && !BrowserHelper.isAndroid) {
          if (eventName === 'contextmenu') {
            handlerDetails.push(EventHelper.addElementListener(targetElement, 'touchstart', {
              handler: EventHelper.createContextMenuWrapper(handlerSpec.handler, handlerSpec.thisObj || thisObj)
            }, options));
          }
        }


        handlerDetails.push(EventHelper.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }

    const detacher = () => {
      len = handlerDetails.length;

      for (i = 0; i < len; i++) {
        const handlerSpec = handlerDetails[i];
        handlerSpec[0].removeEventListener(handlerSpec[1], handlerSpec[2], handlerSpec[3]);
      }

      handlerDetails.length = 0;
    };

    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher, thisObj);
    }

    return detacher;
  }


  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = this.createHandler(element, eventName, handlerSpec, defaults),
      handlerHasPassive = ('passive' in handlerSpec),
      expires = handlerSpec.expires || defaults.expires,
      thisObj = defaults.thisObj;
    let options = handlerSpec.capture || defaults.capture;


    if ((handlerHasPassive || 'passive' in defaults) && BrowserHelper.supportsPassive) {
      options = {
        capture: !!options,
        passive: handlerHasPassive ? handlerSpec.passive : defaults.passive
      };
    }

    element.addEventListener(eventName, handler, options);

    if (expires) {
      const delayable = thisObj && thisObj.setTimeout ? thisObj : window;
      (typeof expires === 'number' ? delayable.setTimeout : delayable.requestAnimationFrame).call(delayable, () => element.removeEventListener(eventName, handler, options), expires);
    }

    return [element, eventName, handler, options];
  }

  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay = handlerSpec.delay || defaults.delay,
      throttled = handlerSpec.throttled || defaults.throttled,
      once = handlerSpec.once || defaults.once,
      thisObj = handlerSpec.thisObj || defaults.thisObj,
      capture = handlerSpec.capture || defaults.capture,
      delegate = handlerSpec.delegate || defaults.delegate;


    let wrappedFn = handlerSpec.handler,


      handler = (event, ...args) => {

        if (this.playingDemo && event.isTrusted) {
          return;
        }


        if (thisObj && thisObj.isDestroyed) {

          return;
        }

        fixEvent(event);


        if (delegate) {

          const delegatedTarget = event.target instanceof HTMLElement && event.target.closest(delegate);

          if (!delegatedTarget) {
            return;
          }


          Object.defineProperty(event, 'currentTarget', {
            get: () => delegatedTarget,
            configurable: true
          });
        }

        if (typeof wrappedFn === 'string') {
          wrappedFn = thisObj[wrappedFn];
        }

        wrappedFn.call(thisObj, event, ...args);
      };


    if (delay != null) {
      const wrappedFn = handler,
        delayable = thisObj && thisObj.setTimeout ? thisObj : window;

      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn(...args);
        }, delay);
      };
    }


    if (throttled != null) {
      let alt,
        buffer = throttled;

      if (throttled.buffer) {
        alt = e => throttled.alt.call(this, fixEvent(e));

        buffer = throttled.buffer;
      }

      if (thisObj && thisObj.isDelayable) {
        handler = thisObj.throttle(handler, buffer, thisObj, null, alt);
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt);
      }
    }


    if (once) {
      const wrappedFn = handler;

      handler = (...args) => {
        element.removeEventListener(eventName, handler, capture);
        wrappedFn(...args);
      };
    }


    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => element.removeEventListener(eventName, handler), thisObj);
    }

    return handler;
  }

  static onTransitionEnd({
                           element,
                           property,
                           handler,
                           timeout,
                           thisObj = window
                         }) {
    let timerId;
    const detacher = EventHelper.on({
      element,
      thisObj,

      transitionend(e) {
        if (e.propertyName === property) {
          if (timerId) {
            if (thisObj.isDelayable) {
              thisObj.clearTimeout(timerId);
            } else {
              clearTimeout(timerId);
            }

            timerId = null;
          }

          detacher();
          handler.call(thisObj);
        }
      }

    });

    if (timeout == null) {
      timeout = DomHelper.getPropertyTransitionDuration(element, property);
    }

    if (timeout != null) {
      if (thisObj.isDelayable) {
        timerId = thisObj.setTimeout(() => {
          detacher();
          handler.call(thisObj);
        }, timeout);
      } else {
        timerId = setTimeout(() => {
          detacher();
          handler.call(thisObj);
        }, timeout);
      }
    }
  }


  static createContextMenuWrapper(handler, me) {
    const EventHelper = this;
    return event => {

      if (event.touches.length === 1) {
        const tapholdStartTouch = event.touches[0],

          tapholdTimer = setTimeout(() => {

            touchMoveRemover();
            const contextmenuEvent = new MouseEvent('contextmenu', tapholdStartTouch);
            Object.defineProperty(contextmenuEvent, 'target', {
              get() {
                return tapholdStartTouch.target;
              }

            });

            if (typeof handler === 'string') {
              handler = me[handler];
            }

            contextmenuEvent.browserEvent = event;

            handler.call(me, contextmenuEvent);
            EventHelper.contextMenuTouchId = tapholdStartTouch.identifier;
          }, EventHelper.longPressTime),


          cancelTapholdTimer = () => {
            EventHelper.contextMenuTouchId = null;
            touchMoveRemover();
            clearTimeout(tapholdTimer);
          },

          touchMoveRemover = EventHelper.on({
            element: document,
            touchmove: cancelTapholdTimer,
            touchend: cancelTapholdTimer,
            pointermove: cancelTapholdTimer,
            pointerup: cancelTapholdTimer,
            capture: true
          });
      }
    };
  }


  static createDblClickWrapper(element, handler, me) {
    const EventHelper = this;
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EventHelper.on({
          element,

          touchstart: secondStart => {
            startId = secondStart.changedTouches[0].identifier;

            secondStart.preventDefault();
          },
          touchend: secondClick => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true),
                offsetX = secondClick.changedTouches[0].pageX - targetRect.x,
                offsetY = secondClick.changedTouches[0].pageY - targetRect.y,
                dblclickEventConfig = Object.assign({
                  browserEvent: secondClick
                }, secondClick),
                dblclickEvent = new MouseEvent('dblclick', dblclickEventConfig);
              Object.defineProperty(dblclickEvent, 'target', {
                get() {
                  return secondClick.target;
                }

              });
              Object.defineProperty(dblclickEvent, 'offsetX', {
                get() {
                  return offsetX;
                }

              });
              Object.defineProperty(dblclickEvent, 'offsetY', {
                get() {
                  return offsetY;
                }

              });

              if (typeof handler === 'string') {
                handler = me[handler];
              }

              handler.call(me, dblclickEvent);
            }
          },
          once: true
        });

        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EventHelper.dblClickTime);
      }
    };
  }

  static lockComposedPath(event) {
    if (event.composedPath) {
      event.composedPath = (path => () => path)(event.composedPath());
    }
  }

}


EventHelper.longPressTime = 500;


EventHelper.dblClickTime = 300;

EventHelper.on({
  element: document,

  mousedown() {
    if (!DomHelper.isTouchEvent) {
      DomHelper.usingKeyboard = false;
      document.body.classList.remove('b-using-keyboard');
    }
  },

  touchmove() {
    DomHelper.usingKeyboard = false;
    document.body.classList.remove('b-using-keyboard');
  },

  keydown() {
    DomHelper.usingKeyboard = true;
    document.body.classList.add('b-using-keyboard');
  }

});


if (BrowserHelper.isTouchDevice) {
  EventHelper.on({
    element: document,
    touchmove: event => {

      if (event.target.closest('.b-dragging')) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}

EventHelper._$name = 'EventHelper';


let resizeFireTimer = null;

const resizedQueue = [],
  isAbsolutelyPositioned = n => n.nodeType === 1 && n.ownerDocument.defaultView.getComputedStyle(n).getPropertyValue('position') === 'absolute';


class ResizeMonitor {

  static addResizeListener(element, handler) {
    const me = this;

    if (element === document || element === window) {
      element = document.body;
    }

    if (!element.classList.contains('b-resize-monitored')) {
      element.classList.add('b-resize-monitored');
      element._bResizemonitor = {
        handlers: []
      };
    }

    if (element === document.body) {
      if (!me.hasWindowResizeListener) {

        window.addEventListener('resize', me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    } else if (window.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }

      me.resizeObserver.observe(element);
    } else {
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: 'b-resize-monitors',
        children: [{
          className: 'b-resize-monitor-expand'
        }, {
          className: 'b-resize-monitor-shrink'
        }]
      }, true);
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1000000;
      expand.addEventListener('scroll', me.onSizeMonitorScroll, true);
      shrink.addEventListener('scroll', me.onSizeMonitorScroll, true);

      (handler.targetMutationMonitor = new MutationObserver(m => {
        const changedNodes = [];

        for (const mr of m) {
          if (mr.type === 'childList') {
            changedNodes.push.apply(changedNodes, mr.removedNodes);
            changedNodes.push.apply(changedNodes, mr.addedNodes);
          }
        }


        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }


        expand.dispatchEvent(new CustomEvent('scroll', {
          bubbles: false
        }));
      })).observe(element, {
        childList: true,
        subtree: true
      });

      handler.monitorElement = monitors;
    }

    element._bResizemonitor.handlers.push(handler);
  }


  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === window) {
        element = document.body;
      }

      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;

      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);

        listenerCount = resizeMonitor.handlers.length;
      }

      if (!listenerCount) {
        element.classList.remove('b-resize-monitored');

        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        } else {

          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }

          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }

  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target,
        resizeMonitor = resizedElement._bResizemonitor,
        newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();

      if (resizedElement.offsetParent) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;

          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }

  static onSizeMonitorScroll(e) {

    if (document.body.contains(e.target)) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode,
        resizedElement = monitorNode.parentNode,
        resizeMonitor = resizedElement._bResizemonitor,
        newRect = resizedElement.getBoundingClientRect();

      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;

        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(ResizeMonitor.fireResizeEvents);
        }
      }

      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1000000;
    }
  }

  static onWindowResize(e) {
    const resizedElement = document.body,
      resizeMonitor = resizedElement._bResizemonitor,
      oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();

    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }

  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {

        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }

    resizeFireTimer = null;
    resizedQueue.length = 0;
  }

}

ResizeMonitor._$name = 'ResizeMonitor';


let globalDelays = null;

if (VersionHelper.isTestEnv) {
  globalDelays = window.bryntum.globalDelays = {
    timeouts: new Map(),
    intervals: new Map(),
    animationFrames: new Map(),

    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    }

  };
}


var Delayable = (Target => class Delayable extends (Target || Base) {
  get isDelayable() {
    return true;
  }

  doDestroy() {
    const me = this;

    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn, id) => {
        if (typeof fn === 'function') {
          fn();
        }

        clearTimeout(id);

        if (globalDelays) {
          globalDelays.timeouts.delete(id);
        }
      });
      me.timeoutIds = null;
    }

    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }

    if (me.intervalIds) {
      me.intervalIds.forEach(id => {
        clearInterval(id);

        if (globalDelays) {
          globalDelays.intervals.delete(id);
        }
      });
      me.intervalIds = null;
    }

    if (me.animationFrameIds) {
      me.animationFrameIds.forEach(id => {
        cancelAnimationFrame(id);

        if (globalDelays) {
          globalDelays.animationFrames.delete(id);
        }
      });
      me.animationFrameIds = null;
    }

    super.doDestroy();
  }


  hasTimeout(name) {
    return !!(this.timeoutMap && this.timeoutMap.has(name));
  }


  setTimeout({
               fn,
               delay,
               name,
               runOnDestroy,
               cancelOutstanding,
               args
             }) {
    if (arguments.length > 1 || typeof arguments[0] === 'function') {
      [fn, delay, name, runOnDestroy] = arguments;
    }

    if (typeof fn === 'string') {
      name = fn;
    } else if (!name) {
      name = fn.name;
    }

    if (cancelOutstanding) {
      this.clearTimeout(name);
    }

    const me = this,
      timeoutIds = me.timeoutIds || (me.timeoutIds = new Map()),
      timeoutMap = me.timeoutMap || (me.timeoutMap = new Map()),
      timeoutId = setTimeout(() => {
        if (typeof fn === 'string') {
          fn = me[name];
        }

        timeoutIds && timeoutIds.delete(timeoutId);
        timeoutMap && timeoutMap.delete(name);
        globalDelays && globalDelays.timeouts.delete(timeoutId);
        fn.apply(me, args);
      }, delay);
    timeoutIds.set(timeoutId, runOnDestroy ? fn : true);

    if (globalDelays) {
      globalDelays.timeouts.set(timeoutId, {
        fn,
        delay,
        name
      });
    }

    if (name) {
      timeoutMap.set(name, timeoutId);
    }

    return timeoutId;
  }


  clearTimeout(idOrName) {
    let id = idOrName;

    if (typeof id === 'string') {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }

    clearTimeout(id);
    this.timeoutIds && this.timeoutIds.delete(id);
    globalDelays && globalDelays.timeouts.delete(id);
  }


  clearInterval(id) {
    clearInterval(id);
    this.intervalIds && this.intervalIds.delete(id);
    globalDelays && globalDelays.intervals.delete(id);
  }


  setInterval(fn, delay) {
    const intervalId = setInterval(fn, delay);
    (this.intervalIds || (this.intervalIds = new Set())).add(intervalId);
    globalDelays && globalDelays.intervals.set(intervalId, {
      fn,
      delay
    });
    return intervalId;
  }


  requestAnimationFrame(fn, extraArgs = [], thisObj = this) {
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = new Set()),
      frameId = requestAnimationFrame(() => {
        globalDelays && globalDelays.animationFrames.delete(frameId);
        animationFrameIds.delete(frameId);
        return fn.apply(thisObj, extraArgs);
      });
    animationFrameIds.add(frameId);
    globalDelays && globalDelays.animationFrames.set(frameId, {
      fn,
      extraArgs,
      thisObj
    });
    return frameId;
  }


  createOnFrame(fn, extraArgs = [], thisObj = this, cancelOutstanding) {
    let rafId;

    const result = (...args) => {

      if (rafId && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }

      if (!rafId) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn === 'string') {
            fn = thisObj[fn];
          }

          rafId = null;
          args.push(...extraArgs);
          fn.apply(thisObj, args);
        });
      }
    };

    result.cancel = () => this.cancelAnimationFrame(rafId);

    return result;
  }


  cancelAnimationFrame(handle) {
    cancelAnimationFrame(handle);
    this.animationFrameIds && this.animationFrameIds.delete(handle);
    globalDelays && globalDelays.animationFrames.delete(handle);
  }


  buffer(fn, delay, thisObj = this) {
    let timeoutId = null;

    if (typeof fn === 'string') {
      fn = thisObj[fn];
    }

    const func = (...params) => {
      func.called = false;

      if (timeoutId !== null) {
        this.clearTimeout(timeoutId);
      }

      timeoutId = this.setTimeout(() => {
        fn.call(thisObj, ...params);

        func.called = true;
      }, delay);
    };

    func.cancel = () => this.clearTimeout(timeoutId);

    return func;
  }


  throttle(fn, buffer, thisObj = this, extraArgs, alt) {
    const me = this;
    let lastCallTime = 0,
      callArgs,
      timerId;

    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn.apply(thisObj, callArgs);
      result.called = true;
    };

    const result = (...args) => {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;

      if (elapsed >= buffer) {
        me.clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = me.setTimeout(invoke, buffer - elapsed);
          result.called = false;
        }

        if (alt) {
          callArgs.push.apply(callArgs, extraArgs);
          alt.apply(thisObj, callArgs);
        }
      }
    };

    result.cancel = () => me.clearTimeout(timerId);

    return result;
  }


  get widgetClass() {
  }

});


class CollectionFilter extends Base {
  static get defaultConfig() {
    return {

      property: null,


      value: null,


      operator: null,


      filterBy: null,


      convert: null,


      caseSensitive: true,


      id: null
    };
  }

  construct(config) {
    if (typeof config === 'function') {
      config = {
        filterBy: config
      };
    }

    super.construct(config);
  }


  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId('b-filter'));
  }

  set id(id) {
    this._id = id;
  }

  onChange(propertyChanged) {
    const me = this;

    if (!me.isConfiguring && me.owner && !me.owner.isConfiguring && me.owner.onFilterChanged) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }

  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }


  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }

  defaultFilterBy(candidate) {
    return this[this.operator](this.convert(candidate[this.property]));
  }


  set property(property) {
    this._property = property;

    this.onChange('property');
  }

  get property() {
    return this._property;
  }


  set value(value) {
    this._value = !this.caseSensitive && typeof value === 'string' ? value.toLowerCase() : value;

    this.onChange('value');
  }

  get value() {
    return this._value;
  }


  set operator(operator) {
    this._operator = operator;

    this.onChange('operator');
  }

  get operator() {
    return this._operator || (typeof this.value === 'string' ? '*' : '=');
  }

  convert(value) {
    return !this.caseSensitive && typeof value === 'string' ? value.toLowerCase() : value;
  }

  filter(candidate) {
    return this.filterBy(candidate);
  }

  startsWith(v) {
    return String(v).startsWith(this.value);
  }

  endsWith(v) {
    return String(v).endsWith(this.value);
  }

  '='(v) {
    return ObjectHelper.isEqual(v, this.value);
  }

  '!='(v) {
    return !ObjectHelper.isEqual(v, this.value);
  }

  '>'(v) {
    return ObjectHelper.isMoreThan(v, this.value);
  }

  '>='(v) {
    return ObjectHelper.isMoreThan(v, this.value) || ObjectHelper.isEqual(v, this.value);
  }

  '<'(v) {
    return ObjectHelper.isLessThan(v, this.value);
  }

  '<='(v) {
    return ObjectHelper.isLessThan(v, this.value) || ObjectHelper.isEqual(v, this.value);
  }

  '*'(v) {
    return ObjectHelper.isPartial(v, this.value);
  }

  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }

    return function (candidate) {
      let match = true;

      for (const filter of filters) {

        if (!filter.disabled) {
          match = filter.filter(candidate);
        }

        if (!match) {
          break;
        }
      }

      return match;
    };
  }

}

CollectionFilter._$name = 'CollectionFilter';


class CollectionSorter extends Base {
  static get defaultConfig() {
    return {

      property: null,


      direction: 'ASC',


      sortFn: null,


      convert: null,


      id: null,


      useLocaleSort: null
    };
  }

  construct(config) {
    if (typeof config === 'function') {
      config = {
        sortFn: config
      };
    }

    super.construct(config);
  }


  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId('b-sorter'));
  }

  set id(id) {
    this._id = id;
  }

  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }

  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }

    return this.defaultSortFn;
  }


  defaultSortFn(lhs, rhs) {
    const me = this,
      {
        convert,
        property,
        useLocaleSort
      } = me,
      multiplier = me.direction.toLowerCase() === 'desc' ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];

    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }

    if (useLocaleSort && lhs != null && rhs != null) {

      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }

      if (typeof useLocaleSort === 'string') {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }

      if (typeof useLocaleSort === 'object') {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }

    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }

  static generateSortFunction(sorters, tieBreaker) {
    const items = sorters.isCollection ? sorters.values : sorters,
      n = items.length;
    return (lhs, rhs) => {
      let comp, i;

      for (i = 0; i < n; ++i) {
        comp = items[i].sortFn(lhs, rhs);

        if (comp) {
          return comp;
        }
      }

      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }

}

CollectionSorter._$name = 'CollectionSorter';


const return0 = () => 0,
  reverseNumericSortFn = (a, b) => b - a,
  filteredIndicesProperty = Symbol('filteredIndicesProperty'),
  emptyArray$1 = Object.freeze([]),
  sortEvent = Object.freeze({
    action: 'sort',
    added: emptyArray$1,
    removed: emptyArray$1,
    replaced: emptyArray$1
  }),
  filterEvent = Object.freeze({
    action: 'filter',
    added: emptyArray$1,
    removed: emptyArray$1,
    replaced: emptyArray$1
  }),
  keyTypes = {
    string: 1,
    number: 1
  },
  nonPrimitives = new WeakMap(),
  safeIndexKey = value => {
    if (value && typeof value === 'object') {
      let substitute = nonPrimitives.get(value);

      if (substitute === undefined) {
        substitute = Symbol('bscik');

        nonPrimitives.set(value, substitute);
      }

      value = substitute;
    }

    return value;
  };


class Collection extends Events(Base) {
  static get defaultConfig() {
    return {

      idProperty: 'id',


      extraKeys: null,


      autoFilter: true
    };
  }

  construct(config) {

    this.generation = 0;
    this._values = [];
    super.construct(config);
  }

  doDestroy() {
    super.doDestroy();
    this._values.length = 0;

    if (this.isFiltered) {
      this._filteredValues.length = 0;
      this.filters.destroy();
    }

    this._sorters && this._sorters.destroy();
  }

  get isCollection() {
    return true;
  }


  clear() {
    const me = this,
      removed = this._values.slice();

    if (me.totalCount) {
      me._values.length = 0;

      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }

      me._indicesInvalid = true;

      me.generation++;
      me.trigger('change', {
        action: 'clear',
        removed
      });
    }
  }


  replaceValues({
                  values,
                  filteredValues,
                  silent = false,
                  isNewDataset = false
                }) {
    const me = this;
    let replacedValues, replacedFilteredValues;


    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);

      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }

      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;

      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
        me._indicesInvalid = true;
      } else {
        if (me._filteredValues) {
          me._filteredValues.length = 0;
        }
      }
    }

    me._indicesInvalid = true;

    me.generation++;

    if (!silent) {
      me.trigger('change', {
        action: 'replaceValues',
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }

  set values(values) {
    this.splice(0, this._values.length, values);
  }


  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }


  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }


  forEach(fn, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
  }


  map(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
  }


  find(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
  }

  get first() {
    return this.values[0];
  }

  get last() {
    return this.values[this.count - 1];
  }


  get allValues() {
    return this._values;
  }


  add(...items) {
    if (items.length === 1) {
      this.splice(this._values.length, null, ...items);
    } else {
      this.splice(this._values.length, null, items);
    }
  }


  remove(...items) {
    if (items.length === 1) {
      this.splice(0, ...items);
    } else {
      this.splice(0, items);
    }
  }


  move(item, beforeItem) {
    const me = this,
      {
        _values
      } = me,
      itemIndex = me.indexOf(item, true);
    let beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;

    if (itemIndex === -1 || beforeIndex === -1) {
      throw new Error('Collection move parameters must be present in Collection');
    }

    if (itemIndex !== beforeIndex && itemIndex !== beforeIndex - 1) {
      if (itemIndex < beforeIndex) {
        beforeIndex--;
      }

      _values.splice(itemIndex, 1);

      _values.splice(beforeIndex, 0, item);

      me._indicesInvalid = true;
      me.trigger('change', {
        action: 'move',
        item,
        from: itemIndex,
        to: beforeIndex
      });
    }

    return beforeIndex;
  }


  splice(index = 0, toRemove, ...toAdd) {
    const me = this,
      idProperty = me.idProperty,
      values = me._values,
      newIds = {},
      removed = [],
      replaced = [],
      oldCount = me.totalCount;
    let added, mutated;


    if (toAdd) {
      if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      }

      if (oldCount && toAdd.length) {

        const idIndex = me.indices[idProperty];
        added = [];

        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i],
            id = safeIndexKey(newItem[idProperty]),
            existingIndex = idIndex[id];

          newIds[id] = true;


          if (existingIndex != null) {

            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }

    if (toRemove) {

      if (typeof toRemove === 'number') {
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = safeIndexKey(values[removeIndex][idProperty]);

          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            me._indicesInvalid = mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0,
          lastIdx;

        if (!Array.isArray(toRemove)) {
          toRemove = [toRemove];
        }


        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === 'number',
            idx = isNumeric ? item : me.indexOf(item, true);

          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }

          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }

          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);

        if (contiguous) {


          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            me._indicesInvalid = mutated = true;
          }
        } else {


          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];

            if (removeIndex !== -1) {
              const id = safeIndexKey(values[removeIndex][idProperty]);

              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                me._indicesInvalid = mutated = true;
              }
            }
          }
        }
      }
    }

    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      me._indicesInvalid = mutated = true;
    }

    if (me.isSorted) {
      me.onSortersChanged();
    } else if (me.isFiltered) {
      if (me.autoFilter) {
        me.onFiltersChanged();
      } else {
        me._filteredValues.push(...added);
      }
    }


    if (mutated || replaced.length) {

      me.generation++;


      me.trigger('change', {
        action: 'splice',
        removed,
        added,
        replaced,
        oldCount
      });
    } else {

      me.trigger('noChange', {
        index,
        toRemove,
        toAdd
      });
    }
  }


  changeId(item, newId) {
    const me = this,
      {
        idProperty
      } = me,
      oldId = keyTypes[typeof item] ? item : item[idProperty],
      member = me.get(oldId);

    if (member) {
      const existingMember = me.get(newId);

      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }

      member[idProperty] = newId;

      if (!me._indicesInvalid) {
        const idIndex = me.indices.id,
          memberIndex = idIndex[oldId];
        delete idIndex[oldId];
        idIndex[newId] = memberIndex;
      }
    }
  }


  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }

  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }


  getBy(propertyName, value, ignoreFilters = false) {
    const me = this;

    if (me.isFiltered && ignoreFilters) {
      const index = me.findIndex(propertyName, value, true);

      if (index !== -1) {
        return me._values[index];
      }
    } else {
      const index = me.findIndex(propertyName, value);

      if (index !== -1) {
        return me.values[index];
      }
    }
  }


  get count() {
    return this.values.length;
  }


  get totalCount() {
    return this._values.length;
  }

  set idProperty(idProperty) {
    this._idProperty = idProperty;
    this.addIndex(idProperty);
  }


  get idProperty() {
    return this._idProperty;
  }

  set extraKeys(extraKeys) {
    if (!Array.isArray(extraKeys)) {
      extraKeys = [extraKeys];
    }

    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }


  get sorters() {
    if (!this._sorters) {
      this._sorters = new Collection({
        listeners: {
          change: 'onSortersChanged',
          thisObj: this
        }
      });
    }

    return this._sorters;
  }


  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }


  get isSorted() {
    return Boolean(this._sorters && this._sorters.count);
  }

  onSortersChanged() {
    const me = this;
    delete me._sortFunction;

    me._values.sort(me.sortFunction);

    me._indicesInvalid = true;
    me.trigger('change', sortEvent);
  }


  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }

    return this._sortFunction;
  }


  get filters() {
    if (!this._filters) {
      this._filters = new Collection({
        listeners: {
          change: 'onFiltersChanged',
          thisObj: this
        }
      });
    }

    return this._filters;
  }


  addFilter(filter) {
    const result = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    this.filters.add(result);
    return result;
  }


  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }

  onFiltersChanged() {
    const me = this;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    me.trigger('change', filterEvent);
  }


  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }

    return this._filterFunction;
  }


  addIndex(indexProperty) {
    (this._indices || (this._indices = {}))[indexProperty] = {};

    this._indicesInvalid = true;

  }


  findIndex(propertyName, value, ignoreFilters = false) {
    const me = this,
      isFiltered = me.isFiltered,
      index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];

    if (index) {
      const itemIndex = index[safeIndexKey(value)];

      if (itemIndex != null) {
        return itemIndex;
      }
    } else {

      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values,
        count = values.length;

      for (let i = 0; i < count; i++) {
        if (values[i][propertyName] == value) {
          return i;
        }
      }
    }

    return -1;
  }


  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }


  includes(item, ignoreFilters = false) {
    return this.indexOf(item, ignoreFilters) !== -1;
  }

  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }

    return this._indices;
  }


  rebuildIndices() {
    const me = this,
      isFiltered = me.isFiltered,
      indices = me._indices || (me._indices = {}),
      keyProps = Object.keys(indices),
      indexCount = keyProps.length,
      values = me._values,
      count = values.length;
    let i, j;

    if (isFiltered) {
      indices[filteredIndicesProperty] = {};
    }

    for (i = 0; i < indexCount; i++) {
      indices[keyProps[i]] = {};

      if (isFiltered) {
        indices[filteredIndicesProperty][keyProps[i]] = {};
      }
    }


    for (i = 0; i < count; i++) {
      const item = values[i];

      for (j = 0; j < indexCount; j++) {
        const keyProp = keyProps[j];

        indices[keyProp][safeIndexKey(item[keyProp])] = i;
      }
    }

    if (isFiltered) {
      const values = me._filteredValues,
        count = values.length,
        indices = me._indices[filteredIndicesProperty];

      for (i = 0; i < count; i++) {
        const item = values[i];

        for (j = 0; j < indexCount; j++) {
          const keyProp = keyProps[j];

          indices[keyProp][safeIndexKey(item[keyProp])] = i;
        }
      }
    }

    me._indicesInvalid = false;
  }

}

Collection._$name = 'Collection';


const scrollLiterals = {
    true: 'auto',
    false: 'hidden',
    'hidden-scroll': 'auto'
  },
  scrollerCls = 'b-widget-scroller',
  defaultScrollOptions = {
    block: 'nearest'
  },
  immediatePromise$1 = new Promise(resolve => resolve()),
  scrollPromise = element => new Promise(resolve => EventHelper.on({
    element,
    scroll: resolve,
    once: true
  })),
  xAxis = {
    x: 1
  };


class Scroller extends Delayable(Events(Base)) {
  static get defaultConfig() {
    return {

      element: null,


      overflowX: null,


      overflowY: null,


      translate: null,
      _x: 0,
      _y: 0,
      scrollEndBuffer: 100
    };
  }


  addPartner(otherScroller, axes = xAxis) {
    if (typeof axes === 'string') {
      axes = {
        [axes]: 1
      };
    }

    (this.partners || (this.partners = new Collection())).add({
      id: otherScroller.id,
      scroller: otherScroller,
      axes
    });

    if (!otherScroller.partners || !otherScroller.partners.includes(this.id)) {
      otherScroller.addPartner(this, axes);
    }
  }


  removePartner(otherScroller) {
    if (this.partners && this.partners.includes(otherScroller)) {
      this.partners.remove(otherScroller);
      otherScroller.removePartner(this);
    }
  }


  scrollIntoView(element, options = defaultScrollOptions) {
    const isRectangle = element instanceof Rectangle,
      originalRect = isRectangle ? element : Rectangle.from(element),
      {
        xDelta,
        yDelta
      } = this.getDeltaTo(element, options),
      result = this.scrollBy(xDelta, yDelta, options);

    if (options.highlight || options.focus) {
      result.then(() => {
        if (isRectangle) {
          element = originalRect.translate(-xDelta, -yDelta);
        }

        if (options.highlight) {
          DomHelper.highlight(element, this);
        }

        if (options.focus) {
          element.focus();
        }
      });
    }

    return result;
  }


  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
    const me = this,
      animate = typeof options === 'object' ? options.animate : options,
      absX = Math.abs(xDelta),
      absY = Math.abs(yDelta);

    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }


    if (xDelta || yDelta) {
      me.silent = options.silent;
    }

    let duration = animate && (typeof animate === 'number' ? animate : typeof animate.duration === 'number' ? animate.duration : 300);

    if (duration && (absX > 10 || absY > 10)) {
      const {
        x,
        y
      } = me;
      let lastX = x,
        lastY = y;

      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }

      me.scrollAnimation = FunctionHelper.animate(duration, progress => {
        const isEnd = progress === 1;

        if (xDelta) {


          if (me.x !== lastX && !options.force) {
            return me.scrollAnimation && me.scrollAnimation.cancel();
          }

          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }

        if (yDelta) {


          if (me.y !== lastY && !options.force) {
            return me.scrollAnimation && me.scrollAnimation.cancel();
          }

          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }

        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add('b-scrolling');
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove('b-scrolling');
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta | yDelta) {
        me.x += xDelta;
        me.y += yDelta;
        return scrollPromise(me.element);
      } else {
        return immediatePromise$1;
      }
    }
  }


  scrollTo(toX, toY, options) {
    const {
        x,
        y
      } = this,
      xDelta = toX == null ? 0 : toX - x,
      yDelta = toY == null ? 0 : toY - y;
    return this.scrollBy(xDelta, yDelta, options);
  }

  doDestroy() {
    const me = this;

    if (me._element) {
      me._element.removeEventListener('scroll', me.scrollHandler);

      me.wheelListenerRemover && me.wheelListenerRemover();
    }

    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
    }

    me.partners && me.partners.forEach(partner => partner.scroller.removePartner(me));
    super.doDestroy();
  }


  onElMutation(mutations) {
    const me = this,
      [x, y] = DomHelper.getTranslateXY(me.element);


    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent('scroll', {
        bubbles: true
      });
      Object.defineProperty(scrollEvent, 'target', {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }

  onScroll(e) {
    const me = this;

    if (!me.widget || !me.widget.isDestroyed) {

      me.positionDirty = true;

      if (!me.element.classList.contains('b-scrolling')) {
        me.element.classList.add('b-scrolling');
      }

      e.widget = me.widget;

      if (!me.silent) {
        me.trigger('scroll', e);
      }

      me.syncPartners();

      me.controllingPartner = null;


      me.scrollEndHandler(e);
    }
  }

  syncPartners() {
    const me = this;

    if (me.partners) {
      me.partners.forEach(({
                             axes,
                             scroller
                           }) => {

        if (scroller !== me.controllingPartner) {
          scroller.sync(me, axes);
        }
      });
    }
  }

  onScrollEnd(e) {
    if (this.silent) {
      this.silent = false;
    }

    this.trigger('scrollEnd', e);
    this.element.classList.remove('b-scrolling');
  }


  getDeltaTo(element, options) {
    const me = this;

    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }

    const elementRect = element instanceof Rectangle ? element : Rectangle.from(element),
      block = options.block || 'nearest',
      scrollerRect = me.viewport,
      edgeOffset = options.edgeOffset || 0,

      xOffset = scrollerRect.width >= elementRect.width + edgeOffset * 2 ? edgeOffset : 0,
      yOffset = scrollerRect.height >= elementRect.height + edgeOffset * 2 ? edgeOffset : 0,
      elRect = elementRect.clone().adjust(-xOffset, -yOffset, xOffset, yOffset).constrainTo(new Rectangle(scrollerRect.x - me.x, scrollerRect.y - me.y, me.scrollWidth, me.scrollHeight)),
      targetRect = elRect.clone();
    let xDelta = 0,
      yDelta = 0;

    if (block === 'start') {
      targetRect.moveTo(scrollerRect.x, scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === 'end') {
      targetRect.translate(scrollerRect.right - targetRect.right, scrollerRect.bottom - targetRect.bottom);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else {

      if (block === 'center') {
        const center = scrollerRect.center;
        targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
        xDelta = xDelta || elRect.x - targetRect.x;
        yDelta = yDelta || elRect.y - targetRect.y;
      } else {

        if (targetRect.width > scrollerRect.width) {
          xDelta = targetRect.x - scrollerRect.x;
        } else {
          if (targetRect.right > scrollerRect.right) {
            xDelta = targetRect.right - scrollerRect.right;
          } else if (targetRect.x < scrollerRect.x) {
            xDelta = targetRect.x - scrollerRect.x;
          }
        }

        if (targetRect.height > scrollerRect.height) {
          yDelta = targetRect.y - scrollerRect.y;
        } else {
          if (targetRect.bottom > scrollerRect.bottom) {
            yDelta = targetRect.bottom - scrollerRect.bottom;
          } else if (targetRect.y < scrollerRect.y) {
            yDelta = targetRect.y - scrollerRect.y;
          }
        }
      }
    }

    return {


      xDelta: options.x === false ? 0 : Math.round(Math.max(Math.min(xDelta, me.maxX - me.x), -me.x)),
      yDelta: options.y === false ? 0 : Math.round(Math.max(Math.min(yDelta, me.maxY - me.y), -me.y))
    };
  }


  get viewport() {
    return Rectangle.client(this.element);
  }

  get element() {
    return this._element;
  }

  set element(element) {
    const me = this,
      scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me));

    if (!me.scrollEndHandler) {
      me.scrollEndHandler = me.buffer(me.onScrollEnd, me.scrollEndBuffer);
    }

    if (me._element) {
      if (me.translate) {
        me.mutationObserver && me.mutationObserver.disconnect(me._element);
      } else {
        me._element.removeEventListener('scroll', scrollHandler);

        me._element.classList.remove(scrollerCls);
      }
    }

    me._element = element;

    if (me.translate) {
      if (!me.mutationObserver) {
        me.mutationObserver = new MutationObserver(mutations => me.onElMutation(mutations));
      }

      me.mutationObserver.observe(element, {
        attributes: true
      });
      me._x = me._y = 0;

      if (document.contains(element)) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      }
    } else {
      element.addEventListener('scroll', scrollHandler);
      element.classList.add(scrollerCls);
    }


    me.updateOverflowX(me.overflowX);
    me.updateOverflowY(me.overflowY);
  }


  get x() {
    const me = this,
      {
        element
      } = me;

    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }

      me.positionDirty = false;
    }

    return me._x;
  }

  set x(x) {
    const {
      element,
      widget
    } = this;

    if (widget && widget.isConfiguring) {
      return;
    }

    this._x = x;

    if (element) {
      this.trigger('scrollStart', {
        x
      });

      if (this.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = x;
      }


      this.positionDirty = true;
    }
  }

  sync(controllingPartner, axes) {
    const {
      x,
      y
    } = axes;
    this.controllingPartner = controllingPartner;

    if (x != null) {
      this.x = controllingPartner.x;
    }

    if (y != null) {
      this.y = controllingPartner.y;
    }
  }


  get y() {
    const me = this,
      {
        element
      } = me;

    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }

      me.positionDirty = false;
    }

    return me._y;
  }

  set y(y) {
    const {
      element,
      widget
    } = this;

    if (widget && widget.isConfiguring) {
      return;
    }

    this._y = y;

    if (element) {
      this.trigger('scrollStart', {
        y
      });

      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }


      this.positionDirty = true;
    }
  }


  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }


  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }


  get overflowX() {
    return this._overflowX;
  }

  set overflowX(overflowX) {
    this._overflowX = overflowX;

    if (this.element) {
      this.updateOverflowX(overflowX);
    }
  }

  updateOverflowX(overflowX) {
    const {
      element,
      translate
    } = this;


    if (overflowX === 'hidden-scroll' && !translate) {
      element.classList.add('b-hide-scroll');


      this.enableWheel();
    }

    if (!translate) {
      element.style.overflowX = scrollLiterals[overflowX] || overflowX;
    }

    this.positionDirty = !this.isConfiguring;
  }


  get overflowY() {
    return this._overflowY;
  }

  set overflowY(overflowY) {
    this._overflowY = overflowY;

    if (this.element) {
      this.updateOverflowY(overflowY);
    }
  }

  updateOverflowY(overflowY) {
    const {
      element,
      translate
    } = this;


    if (overflowY === 'hidden-scroll' && !translate) {
      element.classList.add('b-hide-scroll');


      this.enableWheel();
    }

    if (!translate) {
      element.style.overflowY = scrollLiterals[overflowY] || overflowY;
    }

    this.positionDirty = !this.isConfiguring;
  }

  enableWheel() {
    if (!BrowserHelper.isChrome && !BrowserHelper.isSafari && !this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: 'onWheel',
        thisObj: this
      });
    }
  }

  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX !== false) {
      this.x += e.deltaX;

      e.stopPropagation();
    } else if (this.overflowY !== false) {
      this.y += e.deltaY;

      e.stopPropagation();
    }
  }


  get scrollWidth() {
    return this.element ? this.element.scrollWidth : 0;
  }

  set scrollWidth(scrollWidth) {
    const me = this;
    let stretcher = me.widthStretcher;

    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: 'b-scroller-stretcher'
        });
      }

      stretcher.style.transform = `translateX(${scrollWidth - 1}px)`;

      if (me.element && me.element.lastChild !== stretcher) {
        me.element.appendChild(stretcher);
      }
    }
  }

  get scrollHeight() {
    return this.element ? this.element.scrollHeight : 0;
  }


  set scrollHeight(scrollHeight) {
    const me = this,
      stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
        className: 'b-scroller-stretcher'
      }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;

    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
  }


  get clientWidth() {
    return this.element ? this.element.clientWidth : 0;
  }


  get clientHeight() {
    return this.element ? this.element.clientHeight : 0;
  }


  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId('scroller-');
      }
    }

    return this._id;
  }

}

Scroller._$name = 'Scroller';

const localeName = 'En',
  localeDesc = 'English';
const locale$1 =  locale_zh.locale$1
LocaleManagerSingelton.registerLocale(localeName, {
  desc: localeDesc,
  locale: locale$1
});


const isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/,
  textInputTypes = {
    INPUT: 1,
    TEXTAREA: 1
  },

  widgetTriggerPaint = w => {
    w.isVisible && w.triggerPaint();
  },
  negationPseudo = /^:not\((.+)\)$/,
  dragGhost = DomHelper.createElement({ 
    html: '\xa0',
    style: 'position:absolute;top:-10000em;left:-10000em'
  });


class Widget extends Delayable(Events(Localizable(Base))) {

  static get $name() {
    return 'Widget';
  }

  static get defaultConfig() {
    return {

      element: true,
      callOnFunctions: true,


      id: '',


      html: null,


      hasGeneratedId: null,


      cls: null,


      style: null,


      disabled: null,


      adopt: null,


      appendTo: null,


      insertBefore: null,


      insertFirst: null,


      dataset: null,


      tooltip: null,


      preventTooltipOnTouch: null,


      monitorResize: null,
      cache: {},


      floating: null,


      positioned: null,


      draggable: null,


      align: 't-b',


      centered: null,


      constrainTo: null,


      anchor: null,


      scrollAction: null,


      hideAnimation: null,


      showAnimation: null,


      x: null,


      y: null,


      scrollable: null,


      scrollerClass: Scroller,


      defaultBindProperty: 'html',


      defaultAction: null,


      width: null,


      height: null,

      scaleToFitWidth: null,
      allowGrowWidth: true,


      margin: null,


      flex: null,


      alignSelf: null,


      ripple: null,


      title: null,
      localizableProperties: ['title'],

      requireSize: false,


      ref: null,


      hidden: null
    };
  }


  construct(config = {}, ...args) {
    const me = this;

    me.alignConstrained = 0;
    me.afterHideShowAnimate = me.afterHideShowAnimate.bind(me);
    me.callRealign = me.realign.bind(me);
    me.doHideOrRealign = me.doHideOrRealign.bind(me);
    me.initialRender = true;
    me._isUserAction = false;

    super.construct(config, args);
    me.finalizeInit();
  }

  isType(type, deep) {
    return IdHelper.isType(this, type, deep);
  }

  startConfigure(config) {
    const me = this,
      {
        adopt,
        element
      } = me;

    if (adopt) {
      const adoptElement = typeof adopt === 'string' ? document.getElementById(adopt) : adopt,
        previousHolder = IdHelper.fromElement(adoptElement);


      if (previousHolder && previousHolder !== me) {
        previousHolder.destroy();
      }

      me.preExistingElements = Array.from(adoptElement.childNodes);
      me.adoptedElementClassName = adoptElement.className;
      me.adoptedElementCssText = adoptElement.style.cssText;


      if (adoptElement.id && !config.id) {
        me.id = element.id = adoptElement.id;
      }

      DomHelper.syncAttributes(element, adoptElement);

      for (let i = 0, {
        length
      } = element.childNodes; i < length; i++) {
        adoptElement.appendChild(element.childNodes[0]);
      }

      me._element = adoptElement;
      delete me._contentRange;
    }

    super.startConfigure(config);
  }

  set title(title) {
    if (this._title !== title) {
      this._title = title;

      if (this.titleElement) {
        this.titleElement.innerHTML = title;
      }
    }
  }

  get title() {
    return this._title;
  }


  get element() {
    return this._element;
  }

  set element(element) {
    const me = this;

    if (typeof element === 'string') {
      element = DomHelper.createElementFromTemplate(element);
    } else if (element.constructor.name === 'Object') {
      element = DomHelper.createElement(element);
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }

    me._element = element;
    const classList = element.classList;
    element.id = me.id;


    element.className += ' ' + me.widgetClassList.join(' ');

    if (me._hidden) {
      classList.add('b-hidden');
    }


    if (!me.parent) {
      if (!me.floating && !me.owner) {
        classList.add('b-outer');
      }

      if (BrowserHelper.isTouchDevice) {
        classList.add('b-touch-events');
      }

      if (DomHelper.scrollBarWidth) {
        classList.add('b-visible-scrollbar');
      } else {
        classList.add('b-overlay-scrollbar');
      }

      if (BrowserHelper.isChrome) {
        classList.add('b-chrome');
      } else if (BrowserHelper.isSafari) {
        classList.add('b-safari');
      } else if (BrowserHelper.isFirefox) {
        classList.add('b-firefox');
      } else if (BrowserHelper.isIE11) {
        classList.add('b-ie');
      } else if (BrowserHelper.isEdge) {
        classList.add('b-edge');
      }
    }

    const namedElements = element.querySelectorAll('[reference]');

    for (const el of namedElements) {
      const name = el.getAttribute('reference');
      el.removeAttribute('reference');


      me[name] = el;

      el.dataset && (el.dataset.ownerCmp = me.id);
    }
  }

  set constrainTo(constrainTo) {
    this._constrainTo = constrainTo;
  }

  get constrainTo() {
    return '_constrainTo' in this ? this._constrainTo : window;
  }

  set centered(value) {
    this._centered = value;

    if (value && !this.floating) {
      throw new Error('`centered` is only relevant when a Widget is `floating`');
    }

    if (value) {
      this.element.classList.add('b-centered');
    } else {
      this.element.classList.remove('b-centered');
    }
  }

  get centered() {
    return this._centered;
  }


  get contentElement() {
    return this.element;
  }

  get contentRange() {
    const me = this,
      {
        contentElement
      } = me,
      contentRange = me._contentRange || (me._contentRange = BrowserHelper.isIE11 ? document.createRange() : new Range());


    if (contentRange.collapsed) {
      contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
      contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
    }

    return contentRange;
  }


  get id() {
    return this._id;
  }

  set id(id) {
    const me = this,
      oldId = me._id;

    if (id) {
      me.hasGeneratedId = false;
    } else {
      id = IdHelper.generateId(`b-${me.$name.toLowerCase()}-`);
      me.hasGeneratedId = true;
    }

    if (oldId) {
      const refEls = me.element.querySelectorAll(`[data-owner-cmp="${oldId}"]`);
      IdHelper.unregister(me);

      for (let i = 0, {
        length
      } = refEls; i < length; i++) {
        refEls[i].dataset.ownerCmp = id;
      }

      me.element.id = id;
    }

    me._id = id;
    IdHelper.register(me);
  }


  get style() {
    return this.element ? this.element.ownerDocument.defaultView.getComputedStyle(this.element) : this._style;
  }

  set style(style) {
    this._style = style;
    this.element && DomHelper.applyStyle(this.element, this._style);
  }


  get dataset() {
    return this.element.dataset;
  }

  set dataset(dataset) {
    Object.assign(this.dataset, dataset);
  }


  finalizeInit() {
    if (this.insertBefore || this.appendTo || this.insertFirst || this.adopt) {
      this.render();
    }
  }

  doDestroy() {
    const me = this,
      element = me._element,
      {
        tooltip,
        preExistingElements
      } = me;
    me.scrollable && me.scrollable.destroy();

    if (tooltip) {

      if (me._tooltip) {
        tooltip.destroy();
      } else if (tooltip.activeTarget === element && tooltip.isVisible) {
        tooltip.hide();
      }
    }

    me.unmask();

    if (element) {


      me.removeTransientListeners();

      if (me.floating || me.positioned) {
        me.hide();
      } else {
        me.revertFocus();
      }

      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);

      if (me.adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, {
          length
        } = nodes; i < length; i++) {
          const el = nodes[i];

          if (!preExistingElements.includes(el) && el !== Widget.floatRoot) {
            el.remove();
          }
        }

        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      } else {
        element.remove();
      }

      me.dragEventDetacher && me.dragEventDetacher();
      me.dragOverEventDetacher && me.dragOverEventDetacher();
      dragGhost.remove();
    }

    IdHelper.unregister(me);
    super.doDestroy();
  }


  render(appendToElement, triggerPaint = true) {
    const me = this,
      {
        element
      } = me;
    ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
    ResizeMonitor.removeResizeListener(element, me.onElementResize);
    me.emptyCache();

    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {

      if (appendToElement) {
        me.appendTo = typeof appendToElement === 'string' ? document.getElementById(appendToElement) : appendToElement;
        me.appendTo.appendChild(element);
      } else if (me.insertBefore) {
        me.insertBefore = typeof me.insertBefore === 'string' ? document.getElementById(me.insertBefore) : me.insertBefore;
        me.insertBefore.parentElement.insertBefore(element, me.insertBefore);
      } else if (me.insertFirst) {
        me.insertFirst = typeof me.insertFirst === 'string' ? document.getElementById(me.insertFirst) : me.insertFirst;

        if (me.insertFirst.firstChild) {
          me.insertFirst.insertBefore(element, me.insertFirst.firstChild);
        } else {
          me.insertFirst.appendChild(element);
        }
      } else if (me.appendTo) {
        me.appendTo = typeof me.appendTo === 'string' ? document.getElementById(me.appendTo) : me.appendTo;
        me.appendTo.appendChild(element);
      }

      me.currentElement = element;
    }

    me.rendered = true;

    if (triggerPaint) {
      me._thisIsAUsedExpression(me.contentRange);

      me.triggerPaint();
    }
  }


  template(me) {
    return `<div class="${me.html ? 'b-html' : ''}" ${me.name ? `data-name="${me.name}"` : ''}>${me.html || ''}</div>`;
  }


  alignTo(spec) {


    if (spec.nodeType === 1 || spec instanceof Widget || spec instanceof Point) {
      spec = {
        target: spec
      };
    }

    this.releaseSizeConstraints();
    const me = this,
      {
        scrollable,
        element
      } = me,
      passedTarget = spec.target,
      target = passedTarget && (passedTarget instanceof Rectangle ? passedTarget : passedTarget.element || passedTarget),
      myPosition = Rectangle.from(element, me.positioned ? element.offsetParent : null, true),
      aligningToElement = target && target.nodeType === 1;
    spec = ObjectHelper.assign({


      constrainTo: me.positioned ? null : me.constrainTo,
      axisLock: me.axisLock,
      anchor: me.anchor
    }, typeof me.align === 'object' ? me.align : {
      align: me.align
    }, spec);


    myPosition.minWidth = spec.minWidth || me.minWidth;
    myPosition.minHeight = spec.minHeight || me.minHeight;


    me.lastAlignSpec = spec;

    if (aligningToElement && target.offsetParent) {


      spec = Object.setPrototypeOf({}, spec);
      spec.target = Rectangle.from(target, me.positioned ? element.offsetParent : null, !me.positioned);

      spec.target.height = Math.max(spec.target.height, 1);
      spec.target.width = Math.max(spec.target.width, 1);


      const clippedBy = me.clippedBy;

      if (clippedBy) {
        const clippedTarget = spec.target.intersect(clippedBy);

        if (clippedTarget) {
          spec.target = clippedTarget;
        } else {
          const result = me.hide();


          me.lastAlignSpec.targetHidden = true;
          return result;
        }
      }


      me.anchoredTo = target;
    } else {
      me.anchoredTo = null;
    }

    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      element.appendChild(me.anchorElement);
    }

    me.isAligning = true;

    me.trigger('beforeAlign', spec);
    me.isAligning = false;


    const {
        constrainTo
      } = spec,
      result = myPosition.alignTo(spec);

    let {
      align,
      anchor,
      x,
      y,
      width,
      height,
      bottom,
      right
    } = result;

    me.lastAlignSpec.zone = result.zone;


    if (height !== myPosition.height) {
      if (!('configuredHeight' in me)) {
        me.configuredHeight = element.style.height;
      }

      me.height = height;
      me.alignConstrained = me.alignConstrained | 1;

      if (scrollable) {
        scrollable.overflowY = true;
      }
    }

    if (width !== myPosition.width) {
      if (!('configuredWidth' in me)) {
        me.configuredWidth = element.style.width;
      }

      me.width = width;
      me.alignConstrained = me.alignConstrained | 2;

      if (scrollable) {
        scrollable.overflowX = scrollable.clientWidth > scrollable.scrollWidth;
      }
    }


    if (align && me.alignConstrained) {
      spec.align = align;
      const newResult = Rectangle.from(element, me.positioned ? element.offsetParent : null, true).alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
      bottom = newResult.bottom;
      right = newResult.right;
    }

    me.setXY(x, y);

    if (anchor) {
      const {
          edge
        } = anchor,
        {
          anchorElement
        } = me,
        colorMatchPoint = [],
        stylePointerEvents = element.style.pointerEvents;

      element.style.pointerEvents = 'all';

      if (edge === 'top' || edge === 'bottom') {
        colorMatchPoint[0] = x + anchor.x;
        colorMatchPoint[1] = edge === 'top' ? y + 1 : bottom - 1;
      } else {
        colorMatchPoint[0] = edge === 'left' ? x + 1 : right - 1;
        colorMatchPoint[1] = y + anchor.y;
      }

      const colourSource = document.elementFromPoint(...colorMatchPoint);
      element.style.pointerEvents = stylePointerEvents || null;


      if (colourSource) {
        const fillColour = DomHelper.getStyleValue(colourSource, 'background-color');

        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute('fill', fillColour);
        }
      }

      anchorElement.classList.remove('b-hide-display');
      anchorElement.style.transform = '';
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
    } else if (me._anchorElement) {
      me.anchorElement.classList.add('b-hide-display');
    }


    if (me.scrollAction === 'hide' && !aligningToElement) {


      element.style.pointerEvents = 'none';
      me.anchoredTo = document.elementFromPoint(x, y);
      element.style.pointerEvents = '';
    }


    if ((me.scrollAction === 'realign' && aligningToElement || me.scrollAction === 'hide') && !me.documentScrollListener) {


      me.setTimeout(() => {
        document.addEventListener('scroll', me.doHideOrRealign, true);
        me.documentScrollListener = true;
      }, me.scrollAction === 'hide' ? 100 : 0);
    }


    if (!BrowserHelper.isAndroid) {
      if (!me.constrainListeners && !(constrainTo instanceof Rectangle)) {


        ResizeMonitor.addResizeListener(constrainTo || window, me.callRealign);
        me.constrainListeners = true;
      }
    }
  }

  realign(el) {
    const me = this;

    if (me.isVisible && (me.floating || me.positioned) && me.lastAlignSpec) {
      const target = me.lastAlignSpec.target;


      if (target && target.nodeType === 1) {
        const targetRect = Rectangle.from(target);


        targetRect.minHeight = targetRect.minWidth = 1;

        if (target !== document.body && !target.offsetParent || el && el.nodeType === 1 && el.contains(target) && !Rectangle.from(el).intersect(targetRect)) {
          return me.hide();
        }
      }

      me.alignTo(me.lastAlignSpec);
    }
  }

  releaseSizeConstraints() {
    const me = this,
      scroller = me.scrollable;

    if (me.alignConstrained & 1) {
      me.height = me.configuredHeight;

      if (scroller) {
        scroller.overflowY = scroller.config.overflowY;
      }
    }

    if (me.alignConstrained & 2) {
      me.width = me.configuredWidth;

      if (scroller) {
        scroller.overflowX = scroller.config.overflowX;
      }
    }

    me.alignConstrained = 0;
  }


  toFront() {
    if (this.element && this.element.nextSibling) {
      this.element.parentNode.appendChild(this.element);
    }
  }


  set ref(ref) {
    this._ref = ref;
    this.element.dataset.ref = ref;
  }

  get ref() {
    return this._ref;
  }

  set clippedBy(clippedBy) {
    this._clippedBy = Array.isArray(clippedBy) ? clippedBy : clippedBy ? [clippedBy] : null;
  }

  get clippedBy() {
    const clippedBy = this._clippedBy;

    if (clippedBy) {
      let result = Rectangle.from(clippedBy[0], null, true),
        i;

      for (i = 1; i < clippedBy.length; i++) {
        result = result.intersect(Rectangle.from(clippedBy[i], null, true));
      }

      return result;
    }
  }

  get overflowElement() {
    return this.contentElement;
  }

  get maxHeightElement() {
    return this.element;
  }

  set scrollable(scrollable) {
    const overflowElement = this.overflowElement;

    if (typeof scrollable === 'boolean') {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }

    if (overflowElement) {
      scrollable.element = overflowElement;
    }

    scrollable.widget = this;
    this._scrollable = new this.scrollerClass(scrollable);
  }


  get scrollable() {
    return this._scrollable;
  }


  get html() {


    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }

    return this.contentElement.innerHTML;
  }

  set html(html) {
    const me = this,
      isClearing = html == null,
      {
        element,
        contentElement
      } = me;

    if (me._html !== html) {
      me._html = html;

      if (element) {
        const anchorEl = contentElement === element && me._anchorElement;

        element.classList[isClearing ? 'remove' : 'add']('b-html');


        if (anchorEl) {
          me.element.removeChild(anchorEl);
        }

        me.contentElement.innerHTML = isClearing ? '' : html;

        if (anchorEl) {
          element.appendChild(anchorEl);
        }

        if (me.floating || me.positioned) {

          if (!me.isAligning) {
            me.realign();
          }
        }
      }
    }
  }


  set content(html) {
    const me = this,
      isClearing = html == null,
      {
        element
      } = me;

    if (me._html !== html) {
      me._html = html;

      if (element) {
        const {
          contentRange
        } = me;

        element.classList[isClearing ? 'remove' : 'add']('b-html');

        if (isInDocument(element)) {

          contentRange.deleteContents();

          if (!isClearing) {
            contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
              fragment: true
            }));
          }
        } else {
          me.contentElement.innerHTML = html;
        }

        me.contentRangeStartOffset = contentRange.startOffset;
        me.contentRangeEndOffset = contentRange.endOffset;

        if (!me.isAligning || me.positioned) {
          me.realign();
        }
      }
    }
  }

  onThemeChange() {


    if (this.anchorElement && this.anchorElement.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }


  get anchorSize() {
    const me = this;
    let result = this._anchorSize;

    if (!result) {


      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, 'border-top-width')),
        borderColour = DomHelper.getStyleValue(me.element, 'border-top-color'),
        anchorElement = me.anchorElement,
        svgEl = anchorElement.firstElementChild,
        pathElement = me.anchorPathElement = svgEl.lastElementChild,
        hidden = me._hidden;
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, 'background-color');

      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, 'background-color');
      }

      me.defaultAnchorBackgroundColor = backgroundColour;
      result = anchorElement.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      svgEl.setAttribute('height', height + borderWidth);
      svgEl.setAttribute('width', width);
      pathElement.setAttribute('d', `M0,${height}L${width / 2},0.5L${width},${height}`);

      if (borderWidth) {
        pathElement.setAttribute('stroke-width', borderWidth);
        pathElement.setAttribute('stroke', borderColour);
      }

      result[1] -= borderWidth;

      if (hidden) {
        me.element.classList.add('b-hidden');
      }

      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents.on({
          theme: 'onThemeChange',
          thisObj: me
        });
      }
    }

    me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
    return result;
  }

  get anchorElement() {
    let result = this._anchorElement;

    if (!result) {
      result = this._anchorElement = DomHelper.createElement({
        parent: this.element,
        className: 'b-anchor b-anchor-top',
        children: [{
          tag: 'svg',
          ns: 'http://www.w3.org/2000/svg',
          version: '1.1',
          class: 'b-pointer-el',
          children: [{
            tag: 'defs',
            children: [{
              tag: 'filter',
              id: 'shadow-filter',
              children: [{
                tag: 'feDropShadow',
                dx: 0,
                dy: -1,
                stdDeviation: 2,
                'flood-opacity': 0.05
              }]
            }]
          }, {
            tag: 'path',
            filter: BrowserHelper.isIE11 || BrowserHelper.isEdge ? null : 'url(#shadow-filter)'
          }]
        }]
      });
    }

    return result;
  }

  set anchor(anchor) {
    this._anchor = anchor;

    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? 'remove' : 'add']('b-hide-display');
    }
  }

  get draggable() {
    return this._draggable;
  }

  set draggable(draggable) {
    const me = this,
      {
        element
      } = me;
    me._draggable = draggable;
    element.setAttribute('draggable', Boolean(draggable));

    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element: me.element,
        dragstart: me.onWidgetDragStart,
        dragend: me.onWidgetDragEnd,
        thisObj: me
      });
    } else {
      me.dragEventDetacher && me.dragEventDetacher();
      me.dragOverEventDetacher && me.dragOverEventDetacher();
    }
  }

  onWidgetDragStart(e) {
    const me = this,
      actualTarget = document.elementFromPoint(e.clientX, e.clientY),

      {
        handleSelector
      } = me.draggable;

    if (handleSelector) {
      const blacklist = negationPseudo.exec(handleSelector)[1];


      if (blacklist) {
        if (actualTarget.closest(`#${me.element.id} ${blacklist}`)) {
          e.preventDefault();
          return;
        }
      } else if (!actualTarget.closest(`#${me.element.id} ${handleSelector}`)) {
        e.preventDefault();
        return;
      }
    }

    me.removeTransientListeners();
    const dragStartX = e.clientX,
      dragStartY = e.clientY,
      scrollingPageElement = document.scrollingElement || document.body,
      widgetX = me.getXY()[0],
      widgetY = me.getXY()[1];
    document.body.appendChild(dragGhost);

    if (e.dataTransfer.setDragImage) {

      e.dataTransfer.setData('application/node type', '');

      e.dataTransfer.setDragImage(dragGhost, 0, 0);
    }

    e.dataTransfer.effectAllowed = 'none';
    me.dragOverEventDetacher = EventHelper.addListener({
      element: document.body,
      dragover: event => me.setXY(widgetX + event.clientX - dragStartX - scrollingPageElement.scrollLeft, widgetY + event.clientY - dragStartY - scrollingPageElement.scrollTop)
    });

    me.anchor = null;
  }

  onWidgetDragEnd(e) {
    dragGhost.remove();
    this.dragOverEventDetacher();
  }

  get anchor() {
    return this._anchor;
  }

  get floating() {
    return this._floating;
  }

  set floating(floating) {

    floating = Boolean(floating);

    if (Boolean(this.floating) !== floating) {
      this._floating = floating;
    }
  }

  get positioned() {
    return this._positioned;
  }

  set positioned(positioned) {

    positioned = Boolean(positioned);

    if (Boolean(this.positioned) !== positioned) {
      this.element.classList[positioned ? 'add' : 'remove']('b-positioned');
      this._positioned = positioned;
    }
  }

  getXY() {
    return [DomHelper.getPageX(this.element), DomHelper.getPageY(this.element)];
  }


  setXY(x, y) {
    const me = this;

    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
        me.centered = false;
      }

      if (y != null) {
        me._y = y;
        me.centered = false;
      }

      DomHelper.setTranslateXY(me.element, me._x || 0, me._y || 0);
    }
  }


  set x(x) {
    this.setXY(x);
  }

  get x() {
    return this.getXY()[0];
  }


  set y(y) {
    this.setXY(null, y);
  }

  get y() {
    return this.getXY()[1];
  }


  get width() {
    const me = this,
      element = me.element;

    if (me.monitorResize) {

      if (me._width == null) {
        me._width = element.offsetWidth;
      }

      return me._width;
    }

    return element.offsetWidth;
  }

  set width(width) {
    DomHelper.setLength(this.element, 'width', width);

    this._width = null;

    this._flex = null;
    this.element.style.flex = BrowserHelper.isIE11 ? '' : null;
  }


  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }

  set maxWidth(maxWidth) {
    DomHelper.setLength(this.element, 'maxWidth', maxWidth);
  }


  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }

  set minWidth(minWidth) {
    DomHelper.setLength(this.element, 'minWidth', minWidth);
  }

  get flex() {
    return this._flex;
  }


  set flex(flex) {
    this._flex = flex;

    if (typeof flex === 'number' || typeof flex === 'string' && flex.split(/\s/).length === 1) {
      flex = `${flex} ${flex}`;
    }

    this.element.style.flex = flex;
    this.element.style.width = BrowserHelper.isIE11 ? '' : null;
  }


  get alignSelf() {
    return this._alignSelf;
  }

  set alignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }


  get margin() {
    return this._margin;
  }

  set margin(margin) {

    this.element.style.margin = this._margin = this.parseTRBL(margin).join(' ');
  }


  get height() {
    const me = this,
      element = me.element;

    if (me.monitorResize) {

      if (me._height == null) {
        me._height = element.offsetHeight;
      }

      return me._height;
    }

    return element.offsetHeight;
  }

  set height(height) {
    DomHelper.setLength(this.element, 'height', height);

    this._height = null;
  }


  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }

  set maxHeight(maxHeight) {
    const me = this,
      {
        element
      } = me;
    DomHelper.setLength(me.maxHeightElement, 'maxHeight', maxHeight);


    if (BrowserHelper.isIE11 && me.contentElement !== element) {
      if (maxHeight == null) {
        ResizeMonitor.removeResizeListener(element, me.boundMaxHeightBugHandler);
      } else {
        ResizeMonitor.addResizeListener(element, me.boundMaxHeightBugHandler || (me.boundMaxHeightBugHandler = me.fixIEMaxHeightBug.bind(me)));

        if (document.body.contains(element)) {
          me.fixIEMaxHeightBug();
        }
      }
    }
  }

  fixIEMaxHeightBug() {
    const {
      element,
      contentElement
    } = this;


    if (DomHelper.getStyleValue(element, 'flex-direction') === 'column') {

      contentElement.style.maxHeight = '';
      let availableHeight = Rectangle.client(element).height;
      const siblings = element.childNodes,
        len = siblings.length;


      for (let i = 0; i < len; i++) {
        const sibling = siblings[i];

        if (sibling !== contentElement && !sibling.classList.contains('b-resize-monitors')) {
          availableHeight -= sibling.offsetHeight;
        }
      }

      this.contentElement.style.maxHeight = `${availableHeight}px`;
    }
  }


  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }

  set minHeight(minHeight) {
    DomHelper.setLength(this.element, 'minHeight', minHeight);
  }


  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    const el = this.element,
      focusEl = this.focusElement;
    disabled && this.revertFocus();

    if (el) {
      el.classList[disabled ? 'add' : 'remove']('b-disabled');

      if (focusEl) {
        focusEl.disabled = disabled;
      }
    }

    this._disabled = disabled;
    this.onDisabled(disabled);
  }


  onDisabled(disabled) {
  }


  disable() {
    this.disabled = true;
  }


  enable() {
    this.disabled = false;
  }

  get tooltip() {
    if (this._tooltip) {
      return this._tooltip;
    } else {
      const source = this.constructor.tooltip;

      source && source.trigger('pointerOver', {
        source,
        target: this.element
      });
      return source;
    }
  }


  set tooltip(config) {
    const me = this;

    if (me._tooltip) {
      me._tooltip.destroy();

      me._tooltip = null;
    }

    delete me.element.dataset.btip;

    if (config) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (config.constructor.name !== 'Object') {
          config = {
            html: typeof config === 'string' ? config : me.placeholder,
            textContent: true
          };
        }

        if (config.newInstance) {
          config.type = 'tooltip';
          if (!config.forElement) config.forElement = me.element;
          if (!('showOnHover' in config) && !config.forSelector) config.showOnHover = true;
          if (!('autoClose' in config)) config.autoClose = true;
          me._tooltip = WidgetHelper.createWidget(config);
        } else {
          me.element.dataset.btip = true;
          me.tipConfig = config;
        }
      }
    }
  }


  get isVisible() {
    const me = this,
      {
        element
      } = me;

    return Boolean(element && !me._hidden && !me.isDestroying && isInDocument(element) && (!me.requireSize || hasLayout(element)) && (!me.owner || me.owner.isVisible));
  }


  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }


  get focusElement() {
  }

  get isFocusable() {
    const focusElement = this.focusElement;


    return focusElement && this.isVisible && !this.disabled && (focusElement === document.body || focusElement.offsetParent);
  }


  show() {
    return new Promise(resolve => {
      const me = this,
        {
          showAnimation,
          element
        } = me,
        floatRoot = Widget.floatRoot,
        style = element.style;
      let styleProp, animProps;


      if (!me.isVisible && me.trigger('beforeShow') !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {

        me.cancelHideShowAnimation();

        if (showAnimation) {

          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          me.currentAnimation = {
            styleProp,
            resolve
          };
          me.isAnimating = true;
          element.addEventListener('transitionend', me.afterHideShowAnimate);

          style[styleProp] = animProps.from;
        }

        if (me.floating) {
          if (!floatRoot.contains(element)) {

            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {


              me.render(floatRoot, false);
            }
          }
        }

        me._hidden = false;
        element.classList.remove('b-hidden');

        if (showAnimation) {
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          me.requestAnimationFrame(() => {
            style[styleProp] = animProps.to;
          });
        }

        me.afterShow(!showAnimation && resolve);


        if (!me.inShowBy && me.floating && me.forElement && !me.hidden) {
          me.alignTo(me.forElement);
        }
      } else {
        resolve();
      }
    });
  }


  showBy(spec) {
    const me = this;

    me.inShowBy = true;
    const result = me.show();
    me.inShowBy = false;

    if (me.isVisible) {
      me.alignTo(spec);
    }

    return result;
  }


  showByPoint(x, y, options) {
    const xy = arguments.length === 1 ? x : [x, y];
    return this.showBy(Object.assign({
      target: new Rectangle(xy[0], xy[1], 1, 1),
      align: 't-b'
    }, options));
  }

  afterShow(resolveFn) {


    if (this.boundMaxHeightBugHandler) {
      this.boundMaxHeightBugHandler();
    }

    this.trigger('show');
    this.triggerPaint();
    resolveFn && resolveFn();
  }

  triggerPaint() {
    const me = this,
      {
        element
      } = me,
      firstPaint = !me.isPainted;

    if (me.isVisible) {
      if (firstPaint) {

        if (me.scaleToFitWidth) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);

          if (me.isVisible) {
            me.updateScale();
          }
        } else if (me.monitorResize) {
          me.onElementResize = me.onElementResize.bind(me);
          ResizeMonitor.addResizeListener(element, me.onElementResize);
        }
      }

      if (me.eachWidget) {


        me.eachWidget(widgetTriggerPaint, false);
      }


      me.trigger('paint', {
        firstPaint
      });

      if (firstPaint) {


        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{
            target: me.element
          }]);
        }
      }

      me.isPainted = true;
    }
  }

  cancelHideShowAnimation() {
    const me = this,
      element = me.element,
      style = element.style;

    if (me.currentAnimation) {
      me.isAnimating = false;
      element.classList.remove('b-hiding');
      element.removeEventListener('transitionend', me.afterHideShowAnimate);
      style.transition = style[me.currentAnimation.styleProp] = '';
      me.currentAnimation = null;
    }
  }

  afterHideShowAnimate(event) {

    if (this.isDestroyed) {
      return;
    }

    const me = this,
      element = me.element,
      style = element.style,
      {
        styleProp,
        resolve
      } = me.currentAnimation;

    if (event.target === element && event.propertyName === styleProp) {
      element.classList.remove('b-hiding');
      me.isAnimating = false;
      me.currentAnimation = null;
      element.removeEventListener('transitionend', me.afterHideShowAnimate);
      style.transition = style[styleProp] = '';

      if (me._hidden) {
        me.afterHideAnimation();
      }

      resolve();
    }
  }


  hide(animate = true) {
    return new Promise(resolve => {
      const me = this,
        element = me.element,
        style = element.style,
        hideAnimation = animate && me.hideAnimation;

      if (!me._hidden && me.trigger('beforeHide') !== false) {
        me._hidden = true;
        if (!element) return;
        me.revertFocus();


        if (me.isDestroyed) {
          resolve();
          return;
        }

        me.cancelHideShowAnimation();

        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0],
            animProps = hideAnimation[styleProp];

          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            me.currentAnimation = {
              styleProp,
              resolve
            };


            element.classList.add('b-hiding');
            me.isAnimating = true;
            element.addEventListener('transitionend', me.afterHideShowAnimate);
            style[styleProp] = animProps.from;
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            me.requestAnimationFrame(() => {
              style[styleProp] = animProps.to;
            });
          } else {
            element.classList.add('b-hidden');
          }
        } else {
          element.classList.add('b-hidden');
        }

        me.afterHide(!hideAnimation && resolve);
      }
    });
  }

  doHideOrRealign(event) {
    const me = this,
      {
        anchoredTo,
        lastAlignSpec
      } = me,
      target = lastAlignSpec && lastAlignSpec.target,
      activeEl = document.activeElement,
      [x, y] = me.getXY();

    if (me.element.contains(event.target)) {
      return;
    }


    if (!event.isTrusted || event.target.nodeType === 9 && me.element.contains(activeEl) && textInputTypes[activeEl] && window.innerHeight < document.body.offsetHeight) {
      return;
    }

    me.realign(event.target);

    if (!me.isDestroyed && me.scrollAction === 'hide') {
      const [newX, newY] = me.getXY(),
        moved = newX !== x || newY !== y;


      if ((moved || target instanceof Point) && (!anchoredTo || DomHelper.isDescendant(event.target, anchoredTo))) {
        me.hide();
      }
    }
  }

  afterHide(resolveFn = null) {
    const me = this,
      {
        lastAlignSpec
      } = me;


    if (lastAlignSpec) {
      lastAlignSpec.targetHidden = null;
    }


    me.removeTransientListeners();


    if (!me.hideAnimation) {
      me.afterHideAnimation();
    }

    me.trigger('hide');
    resolveFn && resolveFn();
  }

  removeTransientListeners() {
    const me = this;

    if (me.documentScrollListener) {
      document.removeEventListener('scroll', me.doHideOrRealign, true);
      me.documentScrollListener = false;
    }

    if (me.constrainListeners) {
      ResizeMonitor.removeResizeListener(me.lastAlignSpec.constrainTo || window, me.callRealign);
      me.constrainMutationMonitor && me.constrainMutationMonitor.disconnect();
      me.constrainListeners = false;
    }
  }

  afterHideAnimation() {
    const me = this,
      {
        element
      } = me;

    if (me.floating && Widget.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add('b-hidden');
    }
  }


  set visible(show) {
    this.hidden = !show;
  }


  set hidden(hide) {
    if (this.isConfiguring) {
      this._hidden = hide;
      this.element.classList[hide ? 'add' : 'remove']('b-hidden');
    } else {
      if (hide) {
        this.hide();
      } else {
        this.show();
      }
    }
  }

  get hidden() {
    return Boolean(this._hidden);
  }


  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }


  get owner() {
    return this.parent || this._owner || this._element && IdHelper.fromElement(this.forElement || this.element.parentNode);
  }

  set owner(owner) {
    this._owner = owner;
  }


  get previousSibling() {
    return this.getSibling(-1);
  }


  get nextSibling() {
    return this.getSibling(1);
  }

  getSibling(increment) {
    const me = this,
      {
        parent
      } = me,
      siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll('.b-widget'));
    return parent ? siblings[siblings.indexOf(me) + increment] : IdHelper.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }


  up(selector, deep, limit) {
    const limitType = typeof limit,
      numericLimit = limitType === 'number',
      selectorLimit = limitType === 'string';

    for (let result = this.owner, steps = 1; result; result = result.owner, steps++) {
      if (widgetMatches(result, selector, deep)) {
        return result;
      }

      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }


  owns(target) {
    if (target) {

      if (target.eventPhase) {
        target = target.target;
      }

      if (target.nodeType === 1) {
        if (this.element.contains(target)) {
          return true;
        }

        target = IdHelper.fromElement(target);
      }

      while (target) {
        if (target === this) {
          return true;
        }

        target = target.owner;
      }
    }

    return false;
  }

  onFocusIn(e) {
    const me = this,
      {
        element
      } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    element.classList.add('b-contains-focus');

    if (element.contains(e.target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: 'onInternalKeyDown',
        thisObj: me
      });
    }


    me.trigger('focusin', e);
  }

  onFocusOut(e) {
    const me = this;

    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }

    if (!me.isDestroyed) {

      if (!e.relatedTarget) {
        me.revertFocus(true);
      }

      me.containsFocus = false;
      me.element.classList.remove('b-contains-focus');


      me.trigger('focusout', e);
    }
  }


  revertFocus(force) {
    let target = this.focusInEvent && this.focusInEvent.relatedTarget;

    if (force || this.containsFocus && target && target.nodeType === 1 && this.element.contains(document.activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = this.getFocusRevertTarget();
      }

      if (target && DomHelper.isFocusable(target)) {
        DomHelper.focusWithoutScrolling(target);
      }
    }
  }


  getFocusRevertTarget() {
    const me = this,
      {
        owner,
        focusInEvent
      } = me,
      searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && IdHelper.fromElement(target);


    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      target = null;


      if (owner.eachWidget) {
        const siblings = [];


        owner.eachWidget(w => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);

        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }

      if (!target && owner.isFocusable) {
        target = owner;
      }


      target = target ? target.focusElement : owner.getFocusRevertTarget();
    }

    return target;
  }


  get widgetClassList() {
    const me = this;
    const myCls = me.cls,
      result = me.classHierarchy(Widget).reduce((target, cls) => {
        const widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, 'widgetClass');
        let widgetClass;

        if (widgetClassProperty && widgetClassProperty.get) {
          widgetClass = widgetClassProperty.get.call(me);
        } else {


          const name = Object.prototype.hasOwnProperty.call(cls, '$name') || Object.prototype.hasOwnProperty.call(cls, '_$name') ? cls.$name : cls.name;


          if (name.length < 3 || name.includes('$')) {
            console.warn(`Widget class ${name} with no $name getter found`);
          }

          widgetClass = `b-${name.toLowerCase()}`;
        }

        if (widgetClass) {

          target.push(...widgetClass.split(' '));
        }

        return target;
      }, myCls ? myCls.split(' ') : []);

    if (me.floating) {
      result.push('b-floating');
    }

    if (BrowserHelper.isTouchDevice) {
      result.push('b-touch');
    }

    return result;
  }


  fromCache(query, children = false, element = this.element) {
    if (!element) return null;
    const me = this;

    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }

    return me.cache[query];
  }


  emptyCache() {
    this.cache = {};
  }


  mask(msg) {
    const me = this;

    if (me.maskInstance) {
      me.maskInstance.destroy();
    }

    if (typeof msg === 'string') {
      return me.maskInstance = WidgetHelper.mask(me.element, msg);
    }

    msg.element = me.element;
    return me.maskInstance = WidgetHelper.mask(msg);
  }


  unmask() {
    if (this.maskInstance) {
      WidgetHelper.unmask(this.element);
      this.maskInstance = null;
    }
  }


  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }

  onElementResize(resizedElement) {
    const me = this,
      element = me.element,
      oldWidth = me._width,
      oldHeight = me._height,
      newWidth = element.offsetWidth,
      newHeight = element.offsetHeight;

    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);


      me.trigger('resize', {
        width: newWidth,
        height: newHeight,
        oldWidth,
        oldHeight
      });
    }
  }

  updateScale() {
    const me = this,
      element = me.element,
      parentElement = element.parentElement;


    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }

    if (!me.parentHeight) {
      me.parentHeight = parentElement.offsetHeight;
    }


    element.style.display = 'none';
    const scale = parentElement.offsetWidth / me.configuredWidth,
      adjustedScale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = 'top left';
    element.style.display = '';
    parentElement.style.height = me.parentHeight * adjustedScale + 'px';

    if (me.allowGrowWidth && scale > 1) {

      me.width = me.configuredWidth * scale;
    }
  }

  onParentElementResize(event) {
    this.updateScale();
  }


  parseTRBL(values, units = 'px') {
    values = values || 0;

    if (typeof values === 'number') {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }

    const parts = values.split(' '),
      len = parts.length;

    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }

    return [isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0], isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2], isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3], isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]];
  }

  static get floatRoot() {
    const me = this;

    if (!me._floatRoot) {

      me._floatRoot = document.querySelector('.b-float-root');
    }

    if (!me._floatRoot) {
      me._floatRoot = DomHelper.createElement({
        className: 'b-float-root',
        parent: document.body
      });

      if (BrowserHelper.isAndroid) {
        me._floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: window,
          orientationchange: () => me._floatRoot.style.height = `${screen.height}px`
        });
      }
    } else if (!document.body.contains(me._floatRoot)) {

      document.body.appendChild(me._floatRoot);
    }

    return me._floatRoot;
  }

  get isAnimating() {
    return this._animating;
  }

  set isAnimating(value) {
    const me = this;

    if (me.isPainted && value !== me.isAnimating) {
      me.element.classList[value ? 'add' : 'remove']('b-animating');
      me._animating = value;
    }
  }

}

Widget._$name = 'Widget';
BryntumWidgetAdapterRegister.register('widget', Widget);

let globaltouchStart,
  focusEventsSuspended = false,
  GlobalEvents = (window.bryntum || (window.bryntum = {})).GlobalEvents = new class extends Events(Base) {
    suspendFocusEvents() {
      focusEventsSuspended = true;
    }

    resumeFocusEvents() {
      focusEventsSuspended = false;
    }

    get lastInteractionType() {
      return lastInteractionType;
    }

  }(),
  lastInteractionType,
  isTopVisibleModal = w => w.isVisible && w.isTopModal;

function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  Object.defineProperty(result, 'target', {
    get() {
      return target;
    }

  });
  Object.defineProperty(result, 'relatedTarget', {
    get() {
      return relatedTarget;
    }

  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}

function getCommonAncestor(from, to) {
  if (from === to) {
    return from;
  }

  const isWidget = from instanceof Widget;

  while (from && !(from[isWidget ? 'owns' : 'contains'](to) || from === to)) {
    from = from[isWidget ? 'owner' : 'parentNode'];
  }

  return from;
}

const listeners = {
  element: document,

  touchstart(touchstart) {
    if (!globaltouchStart && touchstart.changedTouches.length === 1) {
      globaltouchStart = touchstart.changedTouches[0];
    } else {
      globaltouchStart = null;
    }
  },


  touchend: {
    handler: event => {
      if (globaltouchStart) {


        if (globaltouchStart.identifier === EventHelper.contextMenuTouchId) {
          event.stopImmediatePropagation();
          event.preventDefault();
        } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
          GlobalEvents.trigger('globaltap', {
            event
          });
        }

        globaltouchStart = null;
      }
    },
    passive: false
  },
  mousedown: {
    handler: event => {
      lastInteractionType = 'mouse';

      if (!globaltouchStart) {
        GlobalEvents.trigger('globaltap', {
          event
        });
      }
    },
    passive: false
  },

  keydown() {
    lastInteractionType = 'key';
  },

  keypress() {
    lastInteractionType = 'key';
  },

  focusin(focusin) {


    Widget.floatRoot.scrollTop = Widget.floatRoot.scrollLeft = 0;

    if (focusEventsSuspended) {
      return;
    }

    const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body,
      toElement = focusin.target || document.body,
      fromWidget = IdHelper.fromElement(fromElement),
      toWidget = IdHelper.fromElement(toElement),
      commonAncestor = getCommonAncestor(fromWidget, toWidget),

      backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4),
      topVisibleModal = IdHelper.query(isTopVisibleModal),
      currentFocus = document.activeElement;


    if (topVisibleModal && (!toWidget || !topVisibleModal.owns(toWidget))) {
      topVisibleModal.focus();
      return;
    }

    let event = createWidgetEvent('focusout', fromElement, focusin.target, fromWidget, toWidget, backwards);

    for (let target = fromWidget; target && target !== commonAncestor; target = target.owner) {
      if (!(target.isDestroyed || target.isDestroying) && target.onFocusOut) {
        target.onFocusOut(event);


        if (currentFocus !== document.activeElement) {


          return;
        }
      }
    }


    if (commonAncestor && focusin.target === commonAncestor.element) {


      if (document.activeElement === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {

        commonAncestor.setTimeout(() => commonAncestor.focus && commonAncestor.focus(), 0);
      }
    } else {
      event = createWidgetEvent('focusin', toElement, fromElement, fromWidget, toWidget, backwards);

      for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
        if (!(target.isDestroyed || target.isDestroying)) {
          target.onFocusIn && target.onFocusIn(event);
        }
      }
    }

    const commonAncestorEl = getCommonAncestor(fromElement && fromElement.nodeType === 1 ? fromElement : null, toElement) || toElement.parentNode;
    event = createWidgetEvent('focusmove', toElement, fromElement, fromWidget, toWidget, backwards, {
      bubbles: true
    });
    commonAncestorEl.dispatchEvent(event);
  },

  focusout(focusout) {
    if (focusEventsSuspended) {
      return;
    }

    if (!focusout.relatedTarget || !IdHelper.fromElement(focusout.relatedTarget)) {
      listeners.focusin({
        target: focusout.relatedTarget,
        relatedTarget: focusout.target
      });
    }
  },

  capture: true,
  passive: true
};

function setupFocusListeners(element = document) {
  const config = ObjectHelper.assign({}, listeners, {
    element
  });
  EventHelper.on(config);
}

setupFocusListeners();


class Mask extends Delayable() {

  static get $name() {
    return 'Mask';
  }

  static get defaultConfig() {
    return {

      mode: 'dark',


      icon: 'b-icon b-icon-spinner',


      text: null,
      type: null,
      progress: null,
      maxProgress: null,
      useTransition: false
    };
  }


  construct(config) {
    super.construct(config);

    if (!this.element) {
      this.element = document.body;
    }

    this.show();
  }

  doDestroy() {
    const me = this;

    if (me.maskElement) {
      me.maskElement.remove();
      me.maskElement = null;

      if (me.mode.endsWith('blur')) {
        DomHelper.forEachChild(me.element, child => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }

      me.elementMask = null;
    }

    super.doDestroy();
  }

  get typeName() {
    return typeof this.type === 'string' ? this.type.trim() : '';
  }

  get maskName() {
    return `mask${this.typeName}`;
  }

  get elementMask() {
    return this.element && this.element[this.maskName];
  }

  set elementMask(value) {
    if (this.element) {
      this.element[this.maskName] = value;
    }
  }


  create() {
    const me = this;
    me.elementMask = me;
    Object.assign(me, DomHelper.createElement({
      parent: me.element,
      className: {
        'b-mask': 1,
        'b-mask-type': 1,
        'b-widget': 1,
        [`b-mask-${me.mode}`]: 1,
        'b-progress': me.maxProgress,
        'b-prevent-transitions': !me.useTransition
      },
      reference: 'maskElement',
      children: [{
        className: 'b-mask-content',
        reference: 'maskContent',
        children: [me.maxProgress ? {
          className: 'b-mask-progress-bar',
          reference: 'progressElement',
          style: {
            width: Math.round(me.progress / me.maxProgress * 100) + '%'
          }
        } : null, {
          className: 'b-mask-text',
          reference: 'maskText'
        }]
      }]
    }));
    me.text = me._text;
  }


  static mask(text, element = document.body) {
    return new Mask(typeof text !== 'string' ? Object.assign({
      element
    }, text) : {
      element,
      text
    });
  }


  static unmask(element = document.body) {
    return element.mask && element.mask.close();
  }


  set text(txt) {
    const me = this;
    me._text = txt || '';

    if (me.maskText) {
      me.maskText.innerHTML = `<i class="b-mask-icon ${me.icon}"></i>${me._text}`;
    }
  }

  get text() {
    return this._text;
  }

  set progress(progress) {
    this._progress = progress;

    if (this.progressElement && progress != null) {
      this.progressElement.style.width = Math.round(progress / this._maxProgress * 100) + '%';
    }
  }

  get progress() {
    return this._progress;
  }

  set maxProgress(max) {
    this._maxProgress = max;

    this.progress = this.progress;
  }

  get maxProgress() {
    return this._maxProgress;
  }


  show() {
    const me = this;

    if (me.hasTimeout('hide')) {

      me.resolve();
      me.clearTimeout('hide');
    }

    if (!me.elementMask) {
      me.create();
    }

    const {
      element,
      maskElement
    } = me;
    if (!maskElement) return;

    element.classList.add('b-masked');
    maskElement.classList.add('b-visible');
    maskElement.classList.remove('b-hidden');
    me.shown = true;

    if (me.mode.endsWith('blur')) {
      DomHelper.forEachChild(element, child => {
        if (child !== maskElement) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }


  hide() {
    const me = this,
      {
        element,
        maskElement
      } = me;
    return new Promise(resolve => {
      if (me.shown) {
        me.shown = false;
        maskElement.classList.remove('b-visible');
        maskElement.classList.add('b-hidden');
        element.classList.remove('b-masked');

        if (me.mode.endsWith('blur')) {
          DomHelper.forEachChild(element, child => {
            if (child !== maskElement) {
              child.classList.remove(`b-masked-${me.mode}`);
            }
          });
        }

        me.resolve = resolve;
        me.setTimeout(() => resolve(), 500, 'hide');
      } else {
        resolve();
      }
    });
  }


  close() {
    return new Promise(resolve => {
      this.hide().then(() => {
        this.destroy();
        resolve();
      });
    });
  }

}

Mask._$name = 'Mask';


class Tool extends Widget {
  static get $name() {
    return 'Tool';
  }

  template() {
    return `<div class="b-icon"></div>`;
  }

  construct(config) {
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: 'onClick',
      mousedown: 'onMousedown',
      thisObj: this
    });
  }

  onClick(e) {
    const me = this,
      panel = me.panel,
      handler = typeof me.handler === 'function' ? me.handler : panel[me.handler];

    if (panel.trigger('toolclick', {
      tool: me
    }) !== false) {
      handler && me.callback(handler, panel, [e]);
    }
  }

  onMousedown(e) {
    const panel = this.panel,
      focusEl = panel.focusElement;
    e.preventDefault();

    if (focusEl && document.activeElement !== focusEl) {
      panel.focus();
    }
  }

  get panel() {
    return this.parent;
  }

}

Tool._$name = 'Tool';
BryntumWidgetAdapterRegister.register('tool', Tool);


class Layout extends Events(Base) {
  static get defaultConfig() {
    return {

      containerCls: null,


      itemCls: null
    };
  }

  static getLayout(layout, owner) {
    if (layout instanceof Layout) {
      return layout;
    }

    const isString = typeof layout === 'string',
      config = {
        owner
      };
    return new (isString ? layoutClasses[layout] : layout)(isString ? config : Object.assign(config, layout));
  }

  static registerLayout(cls, name = cls.$name.toLowerCase()) {
    layoutClasses[name] = cls;
  }

  renderChildren() {
    const {
        owner,
        containerCls,
        itemCls
      } = this,
      {
        contentElement,
        items
      } = owner,
      ownerItemCls = owner.itemCls,
      itemCount = items && items.length;
    contentElement.classList.add('b-content-element');

    if (containerCls) {
      contentElement.classList.add(containerCls);
    }

    if (itemCount) {
      owner.textContent = false;

      for (let i = 0; i < itemCount; i++) {
        const item = items[i],
          {
            element
          } = item;
        element.dataset.itemIndex = i;

        if (itemCls) {
          element.classList.add(itemCls);
        }

        if (ownerItemCls) {
          element.classList.add(ownerItemCls);
        }


        element.classList.remove('b-outer');


        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
  }

  removeChild(child) {
    const {
        element
      } = child,
      {
        owner,
        itemCls
      } = this,
      {
        contentElement
      } = owner,
      ownerItemCls = owner.itemCls;
    contentElement.removeChild(element);
    delete element.dataset.itemIndex;

    if (itemCls) {
      element.classList.remove(itemCls);
    }

    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }

    this.fixChildIndices();
  }

  appendChild(child) {
    const {
        element
      } = child,
      childIndex = this.owner.indexOfChild(child),
      {
        owner,
        itemCls
      } = this,
      {
        contentElement
      } = owner,
      ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = childIndex;
    owner.textContent = false;

    if (itemCls) {
      element.classList.add(itemCls);
    }

    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }

    contentElement.appendChild(element);
  }

  insertChild(toAdd, childIndex) {
    const {
        element
      } = toAdd,
      {
        owner,
        itemCls
      } = this,
      {
        contentElement
      } = owner,
      prevSibling = contentElement.querySelector(`[data-item-index="${childIndex - 1}"]`),
      ownerItemCls = owner.itemCls;
    owner.textContent = false;

    if (itemCls) {
      element.classList.add(itemCls);
    }

    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }

    contentElement.insertBefore(element, prevSibling && prevSibling.nextSibling);
    this.fixChildIndices();
  }

  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }


}

const layoutClasses = {
  default: Layout
};
Layout._$name = 'Layout';

let lastTouchTime = 0;

const hasRipple = w => w.ripple,
  Ripple = window.Ripple = new class Ripple extends Widget {
    static get defaultConfig() {
      return {
        id: 'bryntum-ripple',
        old_element: {
          children: [{
            className: 'b-ripple-inner',
            reference: 'rippleElement'
          }]
        },
        element: {
          children: [{
            tag: 'svg',
            class: 'b-ripple-inner',
            reference: 'rippleElement',
            ns: 'http://www.w3.org/2000/svg',
            version: '1.1',
            viewBox: '0 0 100 100',
            children: [{
              reference: 'circleElement',
              tag: 'circle',
              cx: '0',
              cy: '0',
              r: 10
            }]
          }]
        },
        floating: true,
        hideAnimation: false,
        showAnimation: false,
        scrollAction: 'realign',
        color: 'rgba(0,0,0,.3)',
        startRadius: 10,
        radius: 100
      };
    }

    static get $name() {
      return 'Ripple';
    }

    afterConstruct() {
      super.afterConstruct();
      EventHelper.on({
        element: document,
        mousedown: 'onRippleControllingEvent',
        thisObj: this,
        capture: true,
        once: true
      });
    }

    onRippleControllingEvent(event) {
      const me = this;
      me.show();
      const rippleAnimation = DomHelper.getStyleValue(me.circleElement, 'animationName');
      me.hide();
      me.listenerDetacher && me.listenerDetacher();

      if (rippleAnimation && rippleAnimation !== 'none') {
        me.listenerDetacher = EventHelper.on({

          mousedown: {
            element: document,
            capture: true,
            handler: 'onDocumentMousedown'
          },
          touchstart: {
            element: document,
            capture: true,
            handler: 'onDocumentTouchStart'
          },

          animationend: {
            element: me.circleElement,
            handler: 'onAnimationEnd'
          },
          thisObj: me
        });

        if (event.type === 'mousedown') {
          me.onDocumentMousedown(event);
          GlobalEvents.on({
            theme: 'onRippleControllingEvent',
            thisObj: this
          });
        }
      }
    }

    onDocumentTouchStart(event) {
      lastTouchTime = performance.now();
      this.handleTriggerEvent(event);
    }

    onDocumentMousedown(event) {


      if (performance.now() - lastTouchTime > 200) {
        this.handleTriggerEvent(event);
      }
    }

    handleTriggerEvent(event) {
      const targetWidget = IdHelper.fromElement(event.target, hasRipple);

      if (targetWidget) {
        const rippleCfg = targetWidget.ripple,
          target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;

        if (target) {
          const ripple = ObjectHelper.assign({
            event,
            target,
            radius: this.radius
          }, rippleCfg);

          if (typeof ripple.clip === 'string') {
            ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);

            if (!ripple.clip) {
              return;
            }
          }

          this.ripple(ripple);
        }
      }
    }

    ripple({
             event,
             point = EventHelper.getClientPoint(event),
             target = event.target,
             clip = target,
             radius = this.radius,
             color = this.color
           }) {
      this.clip = clip;
      clip = Rectangle.from(clip, null, true);
      const me = this,
        centreDelta = clip.getDelta(point),
        rippleStyle = me.rippleElement.style,
        circleElement = me.circleElement;
      me.hide();
      me.alignTo(clip);
      rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
      rippleStyle.height = rippleStyle.width = `${radius}px`;
      circleElement.setAttribute('r', radius);
      circleElement.setAttribute('fill', color);
      me.show();


      me.requestAnimationFrame(() => {
        document.addEventListener('scroll', me.callRealign, true);
        me.documentScrollListener = true;
      });
    }

    alignTo(clip) {
      if (clip.nodeType === 1) {
        clip = Rectangle.from(clip, null, true);
      }

      const me = this,
        {
          x,
          y,
          width,
          height
        } = clip;
      me.x = x;
      me.y = y;
      me.height = height;
      me.width = width;
    }

    onAnimationEnd(event) {
      if (event.animationName === 'b-ripple-expand') {
        this.hide();
      }
    }

    realign() {
      if (this.isVisible) {
        this.alignTo(this.clip);
      }
    }

  }();


class Bag {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = new Set();
    me.idMap = {};
    me.idProperty = 'id';

    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }

      if (config.values) {
        me.values = config.values;
      }
    }
  }


  get(key) {
    return this.idMap[safeIndexKey(key)];
  }


  get count() {
    return this.items.size;
  }


  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }

    const me = this,
      {
        items,
        idMap,
        idProperty
      } = me,
      len = toAdd.length;

    for (let i = 0; i < len; i++) {
      const item = toAdd[i],
        key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
        existingItem = idMap[key];

      if (existingItem == null) {
        idMap[key] = item;
        items.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items.delete(existingItem);
        items.add(item);
      }
    }
  }


  remove(toRemove) {
    if (!Array.isArray(toRemove)) {
      toRemove = [toRemove];
    }

    const {
        items,
        idMap,
        idProperty
      } = this,
      len = toRemove.length;

    for (let i = 0; i < len; i++) {
      const item = toRemove[i],
        key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
        existingItem = idMap[key];

      if (existingItem != null) {
        items.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }

  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }


  changeId(item, newId) {
    const me = this,
      {
        idMap,
        idProperty
      } = me,
      oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
      member = me.get(oldId);

    if (member) {
      const existingMember = me.get(newId);

      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }

      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }


  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }


  map(fn, thisObj) {
    const {
        items
      } = this,
      result = new Array(items.size);

    let i = 0;
    items.forEach(item => {
      result[i] = fn.call(thisObj, item, i++, items);
    });
    return result;
  }


  forEach(fn, thisObj) {
    return this.items.forEach(fn, thisObj);
  }


  find(fn) {
    for (const div of this.items) {
      if (fn(div)) {
        return div;
      }
    }

    return undefined;
  }


  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }

  indexOf(item) {
    return this.values.indexOf(item);
  }


  get values() {
    return [...this.items];
  }

  set values(values) {
    if (!Array.isArray(values)) {
      values = [values];
    }

    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }


  sort(fn) {
    this.values = this.values.sort(fn);
  }

  some(fn, thisObj) {
    return this.values.some(fn, thisObj);
  }

}

Bag._$name = 'Bag';


const emptyObject$1 = Object.freeze({}),
  returnWeight = i => i.weight,
  sortByWeight = (a, b) => (a.weight || 0) - (b.weight || 0);


class Container extends Widget {
  static get $name() {
    return 'Container';
  }

  static get defaultConfig() {
    return {

      items: null,


      widgets: null,


      defaults: null,
      defaultType: 'widget',


      layoutStyle: null,


      itemCls: null,


      layout: 'default',


      namedItems: null,


      textContent: true
    };
  }

  setConfig(config, isConstructing) {

    if (config.widgets) {
      config.items = config.widgets;
    }

    super.setConfig(config, isConstructing);
  }

  startConfigure(config) {


    const {
      items
    } = this;
    this.hasItems = Boolean(items && items.length);
    super.startConfigure(config);
  }


  remove(...toRemove) {
    let returnArray = true;

    if (toRemove.length === 1) {
      if (Array.isArray(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }

    const me = this,
      result = [];

    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];

      if (me._items.includes(childToRemove)) {
        me._items.remove(childToRemove);

        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.unregisterReference(childToRemove);
      }
    }

    return returnArray ? result : result[0];
  }


  removeAll() {
    return this.remove(this.items);
  }


  add(...toAdd) {
    let returnArray = true;

    if (toAdd.length === 1) {
      if (Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }

    const me = this,
      result = [];

    for (let i = 0; i < toAdd.length; i++) {
      let childToAdd = toAdd[i];

      if (!(childToAdd instanceof Widget)) {
        childToAdd = me.createWidget(childToAdd);
      } else {
        childToAdd.parent = me;
      }

      if (!me._items.includes(childToAdd)) {
        me.registerReference(childToAdd);

        me._items.add(childToAdd);

        me.layout.appendChild(childToAdd);
        result.push(childToAdd);
      }
    }

    return returnArray ? result : result[0];
  }


  insert(toAdd, index) {
    const me = this,
      {
        _items
      } = me;

    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }

    if (_items.includes(index)) {
      index = me.indexOfChild(index);
    }

    index = Math.min(index, _items.count);
    const newValues = _items.values;
    newValues.splice(index, 0, toAdd);
    _items.values = newValues;

    me.registerReference(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }

  indexOfChild(child) {
    return this._items.indexOf(child);
  }

  set widgets(widgets) {
    console.warn('`widgets` was deprecated in 2.1, please change your code to use `items`');
  }

  get widgets() {
    console.warn('`widgets` was deprecated in 2.1, please change your code to use `items`');
    return this.items;
  }

  set items(items) {
    this.configuredItems = items;
  }


  get items() {
    const me = this,
      items = me._items || (me._items = new Bag()),
      {
        configuredItems
      } = me;


    if (configuredItems) {
      me.configuredItems = false;

      if (Array.isArray(configuredItems)) {
        me.processItemsArray(configuredItems, items);
      } else if (configuredItems) {
        me.processItemsObject(configuredItems, me.namedItems, items);
      }

      if (items.some(returnWeight)) {
        items.sort(sortByWeight);
      }

      items.forEach(me.registerReference, me);
    }

    return items.values;
  }

  processItemsArray(items, result) {
    const len = items.length;
    let i, item;

    for (i = 0; i < len; i++) {
      item = items[i];

      if (item instanceof Widget) {
        item.parent = this;
      } else {
        item = this.createWidget(item);
      }

      if (item) {
        result.add(item);
      }
    }
  }

  processItemsObject(items, namedItems = emptyObject$1, result) {
    let item, ref;

    for (ref in items) {
      item = items[ref];

      if (item) {


        if (ref in namedItems) {
          item = typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }

        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            item = this.createWidget(item);
          }

          if (item) {
            item.ref = ref;
            result.add(item);
          }
        }
      }
    }
  }

  registerReference(item) {
    const ref = item.ref || item.id;

    if (ref) {
      for (let current = this; current; current = current.parent) {
        if (!current.widgetMap[ref]) {
          current.widgetMap[ref] = item;
        }
      }
    }
  }

  unregisterReference(item) {
    const ref = item.ref || item.id;

    if (ref) {
      for (let current = this; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
  }


  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }


    this._thisIsAUsedExpression(this.items);

    return this._widgetMap;
  }

  set record(record) {
    this._record = record;
    this.setValues(record, true);
  }


  get record() {
    return this._record;
  }

  getValues(filterFn) {
    const me = this,
      widgets = me.queryAll(w => w.name),
      len = widgets.length;
    const result = {};

    for (let i = 0; i < len; i++) {
      const widget = widgets[i],
        name = widget.name;

      if (!filterFn || filterFn(widget)) {
        result[name] = widget.value;
      }
    }

    return result;
  }

  set textContent(value) {
    this._textContent = value;
    this.element.classList[value ? 'add' : 'remove']('b-text-content');
  }

  get textContent() {
    return this._textContent;
  }


  set layoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
    this._layoutStyle = layoutStyle;
  }

  get layoutStyle() {
    return this._layoutStyle;
  }

  set layout(layout) {
    this._layout = Layout.getLayout(layout, this);
  }

  get layout() {
    return this._layout || (this._layout = new Layout());
  }

  get childItems() {
    return this.items;
  }


  eachWidget(fn, deep = true) {
    const widgets = this.childItems,
      length = widgets ? widgets.length : 0;

    for (let i = 0; i < length; i++) {
      const widget = widgets[i];

      if (fn(widget) === false) {
        return false;
      }

      if (deep && widget.eachWidget) {

        if (widget.eachWidget(fn, deep) === false) {
          return false;
        }
      }
    }

    return true;
  }


  queryAll(filter) {
    const result = [];
    this.eachWidget(w => {
      if (filter(w)) {
        result.push(w);
      }
    });
    return result;
  }


  query(filter) {
    let result = null;
    this.eachWidget(w => {
      if (filter(w)) {
        result = w;
        return false;
      }
    });
    return result;
  }


  getWidgetById(id) {
    return this.widgetMap[id];
  }


  processWidgetConfig(widget) {
  }


  createWidget(widget) {
    const me = this;

    if (typeof widget === 'string') {
      widget = {
        html: widget
      };
    } else if (widget.nodeType === 1) {
      widget = {
        element: widget,
        id: widget.id
      };
    }


    widget = Object.setPrototypeOf({
      parent: me
    }, widget);

    if (!widget.type) {
      widget.type = me.defaultType;
    }

    for (let ancestor = widget.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widget) === false) {
        return null;
      }
    }

    if (me.trigger('beforeWidgetCreate', {
      widget
    }) === false) {
      return null;
    }

    return WidgetHelper.createWidget(ObjectHelper.assign({}, me.defaults, widget), me.defaultType || 'widget');
  }

  render() {
    this.layout.renderChildren();
    super.render(...arguments);
  }

  get focusElement() {
    const firstFocusable = this.query(this.defaultFocus || (w => w.isFocusable));

    if (firstFocusable) {
      return firstFocusable.focusElement;
    }

    return super.focusElement;
  }

  doDestroy() {

    if (!this.configuredItems && this.items) {
      this.items.forEach(widget => widget.destroy && widget.destroy());
    }

    super.doDestroy();
  }


  get isValid() {
    let valid = true;
    this.eachWidget(widget => {
      if ('isValid' in widget && !widget.isValid) {
        return valid = false;
      }
    }, true);
    return valid;
  }


  get values() {
    const values = {};
    this.eachWidget(widget => {
      if ('value' in widget) {
        values[widget.name || widget.ref || widget.id] = widget.value;
      }
    }, true);
    return values;
  }

  set values(values) {
    this.setValues(values);
  }


  get isSettingValues() {

    return this._isSettingValues || this.parent && this.parent.isSettingValues;
  }

  setValues(values, onlyName = false) {

    this._isSettingValues = true;
    this.eachWidget(widget => {
      const hec = widget.highlightExternalChange,
        key = onlyName ? widget.name : widget.name || widget.ref || widget.id;

      if ('value' in widget && key) {

        widget.highlightExternalChange = false;

        widget.value = values && key in values ? values[key] : null;
        widget.highlightExternalChange = hec;
      }
    }, true);
    this._isSettingValues = false;
  }

}

Container._$name = 'Container';
BryntumWidgetAdapterRegister.register('container', Container);


class Toolbar extends Container {
  static get $name() {
    return 'Toolbar';
  }

  static get defaultConfig() {
    return {
      defaultType: 'button',


      widgetCls: null,
      layout: 'default'
    };
  }

  createWidget(widget) {
    if (widget === '->') {
      widget = {
        type: 'widget',
        cls: 'b-toolbar-fill'
      };
    } else if (widget === '|') {
      widget = {
        type: 'widget',
        cls: 'b-toolbar-separator'
      };
    } else if (typeof widget === 'string') {
      widget = {
        type: 'widget',
        cls: 'b-toolbar-text',
        html: widget
      };
    }

    const result = super.createWidget(widget);

    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }

    return result;
  }

}

Toolbar._$name = 'Toolbar';
BryntumWidgetAdapterRegister.register('toolbar', Toolbar);


const acceptNode = e => !e.classList.contains('b-focus-trap') && DomHelper.isFocusable(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,
  byWeight = (l, r) => (l.weight || 0) - (r.weight || 0),
  byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);


acceptNode.acceptNode = acceptNode;


class Panel extends Container {

  static get $name() {
    return 'Panel';
  }

  static get defaultConfig() {
    return {

      trapFocus: null,


      title: null,


      header: null,


      footer: null,


      tools: null,


      tbar: null,


      bbar: null
    };
  }


  set element(element) {
    const me = this,
      headerFromTitle = me.title && (!me.parent || !me.parent.suppressChildHeaders),

      header = me.header || (me.tools || headerFromTitle ? {} : null),
      footer = me.footer,
      title = header && (typeof header === 'string' ? header : me.title || header.title),
      titleAlign = header && (header.titleAlign || 'start'),
      headerClass = me.classHierarchy(Panel).map(cls => `b-${cls.$name.toLowerCase()}-header`).join(' '),
      tbar = me.tbar,
      bbar = me.bbar || me.buttons,
      children = [{
        reference: 'topFocusTrap',
        className: 'b-focus-trap',
        tabIndex: 0
      }],
      startTools = [],
      endTools = [],
      result = {
        children
      };

    if (me.hasItems || me.focusable) {
      result.tabIndex = 0;
    }

    if (header) {
      const headerChildren = [{
        reference: 'titleElement',
        className: `b-header-title b-align-${titleAlign}`,
        html: title
      }];

      for (const toolRef in me.tools) {
        const tool = me.tools[toolRef];

        if (tool.align === 'start') {
          startTools.unshift(tool);
        } else {
          endTools.push(tool);
        }
      }


      startTools.sort(byWeight);
      endTools.sort(byWeightReverse);
      headerChildren.unshift(...startTools.map(t => t.element));
      headerChildren.push(...endTools.map(t => t.element));
      children.push({
        tag: 'header',
        reference: 'headerElement',
        className: `${headerClass} b-dock-${header.dock || 'top'} ${header.cls || ''}`,
        children: headerChildren
      });
    }

    if (tbar) {
      tbar.layout.renderChildren();
      children.push(tbar.element);
    }

    children.push(me.bodyConfig);

    if (bbar) {
      bbar.layout.renderChildren();
      children.push(bbar.element);
    }

    if (footer) {
      children.push({
        tag: 'footer',
        reference: 'footerElement',
        className: `${headerClass} b-dock-${footer.dock || 'bottom'} ${footer.cls || ''}`
      });
    }

    children.push({
      reference: 'bottomFocusTrap',
      className: 'b-focus-trap',
      tabIndex: 0
    });
    super.element = result;
  }

  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }

  get bodyConfig() {
    return this._bodyConfig || {
      reference: 'bodyElement',
      className: this.classHierarchy(Panel).map(cls => `b-${cls.$name.toLowerCase()}-content`).join(' '),
      html: this.html
    };
  }

  get element() {
    return super.element;
  }


  get tbar() {
    return this._tbar;
  }

  set tbar(tbar) {
    if (tbar instanceof Toolbar) {
      tbar.parent = this;
    } else {
      if (Array.isArray(tbar)) {
        tbar = {
          items: tbar
        };
      }

      tbar = new Toolbar(Object.assign({
        parent: this
      }, tbar));
    }

    this.hasItems = this.hasItems || tbar.hasItems;
    tbar.element.classList.add('b-top-toolbar', `b-dock-${tbar.dock || 'top'}`);
    this._tbar = tbar;
  }


  get bbar() {
    return this._bbar;
  }

  set bbar(bbar) {
    if (bbar instanceof Toolbar) {
      bbar.parent = this;
    } else {
      if (Array.isArray(bbar)) {
        bbar = {
          items: bbar
        };
      }

      bbar = WidgetHelper.createWidget(Object.assign({
        type: 'toolbar',
        parent: this
      }, bbar));
    }

    this.hasItems = this.hasItems || bbar.hasItems;
    bbar.element.classList.add('b-bottom-toolbar', `b-dock-${bbar.dock || 'bottom'}`);
    this._bbar = bbar;
  }

  get childItems() {
    const me = this,
      items = me.items ? me.items.slice() : [];

    if (me.tools) {
      items.unshift(...Object.values(me.tools));
    }

    if (me.tbar) {
      items.unshift(me.tbar);
    }

    if (me.bbar) {
      items.push(me.bbar);
    }

    return items;
  }


  set tools(tools) {
    const me = this,
      myTools = me._tools = {};

    for (const toolRef in tools) {
      const tool = myTools[toolRef] = WidgetHelper.createWidget(ObjectHelper.assign({
        type: 'tool',
        ref: toolRef,

        reference: toolRef,
        parent: me
      }, tools[toolRef]), me.defaultToolType || 'tool');
      me.registerReference(tool, tool.ref);
    }
  }

  get tools() {
    return this._tools;
  }

  set trapFocus(trapFocus) {
    const me = this;
    me.element.classList[trapFocus ? 'add' : 'remove']('b-focus-trapped');

    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: 'onFocusTrapped',
        delegate: '.b-focus-trap',
        thisObj: me
      });

      if (!me.treeWalker) {
        me.treeWalker = document.createTreeWalker(me.element, NodeFilter.SHOW_ELEMENT, acceptNode, false);
      }
    } else {
      if (me.focusTrapListener) {
        me.focusTrapListener();
        me.focusTrapListener = null;
      }
    }

    me._trapFocus = trapFocus;
  }

  get trapFocus() {
    return this._trapFocus;
  }

  onFocusTrapped(e) {
    const me = this,
      treeWalker = me.treeWalker;


    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    } else {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    }

    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }

  get focusElement() {


    return this.hasItems && (super.focusElement || this.element);
  }

  get contentElement() {
    return this.element && this.bodyElement;
  }

  get widgetClassList() {
    const me = this,
      result = super.widgetClassList,
      header = me.header;

    if (header || me.title || me.tools) {
      result.push(`b-panel-has-header b-header-dock-${header && header.dock || 'top'}`);
    }

    if (me.tbar) {
      result.push(`b-panel-has-top-toolbar`);
    }

    if (me.bbar) {
      result.push(`b-panel-has-bottom-toolbar`);
    }

    return result;
  }

  doDestroy() {
    const {
      tools
    } = this;

    if (tools) {
      for (const t of Object.values(tools)) {
        t.destroy();
      }
    }

    if (this.tbar) {
      this.tbar.destroy();
    }

    if (this.bbar) {
      this.bbar.destroy();
    }

    super.doDestroy();
  }

}

Panel._$name = 'Panel';
BryntumWidgetAdapterRegister.register('panel', Panel);


class Popup extends Panel {

  static get $name() {
    return 'Popup';
  }

  static get defaultConfig() {
    return {

      autoShow: true,


      autoClose: true,


      showOnClick: false,


      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,

      hideAnimation: BrowserHelper.isIE11 ? null : {
        opacity: {
          from: 1,
          to: 0,
          duration: '.3s',
          delay: '0s'
        }
      },
      showAnimation: BrowserHelper.isIE11 ? null : {
        opacity: {
          from: 0,
          to: 1,
          duration: '.4s',
          delay: '0s'
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },


      closeAction: 'hide',


      trapFocus: true,


      focusOnToFront: true,


      closable: null,


      modal: null
    };
  }

  startConfigure(config) {


    this._thisIsAUsedExpression(this.closable);

    super.startConfigure(config);
  }

  finalizeInit() {
    const me = this;
    me.anchoredTo = me.forElement;
    me.initialAnchor = me.anchor;

    if (me.forElement && me.showOnClick) {

      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }

      EventHelper.on({
        element: me.forElement,
        click: 'onElementUserAction',
        thisObj: me
      });
    }

    super.finalizeInit();

    if (me.autoShow) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }

  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }


  close() {

    if (!this._hidden && this.trigger('beforeClose') !== false ||
      this._hidden && this.closeAction == 'destroy') {
      return this[this.closeAction]();
    }
  }


  onElementResize(resizedElement, lastRect, myRect) {
    const me = this,
      {
        lastAlignSpec
      } = me;


    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height,
        widthChange = !lastRect || myRect.width !== lastRect.width;


      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1) {


        me.requestAnimationFrame(() => me.realign());
      }
    }

    super.onElementResize(resizedElement);
  }

  onInternalKeyDown(event) {

    if (event.key === 'Escape') {
      event.stopImmediatePropagation();
      this.close(true);
    }
  }

  onDocumentMouseDown({
                        event
                      }) {
    const me = this;


    me.setTimeout(() => document.body.classList.add('b-using-keyboard'), 0);

    if (me.modal && event.target === Popup.modalMask) {
      event.preventDefault();

      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    } else if (!me.owns(event.target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }

  get isTopModal() {
    return DomHelper.isVisible(Popup.modalMask) && this.element.previousElementSibling === Popup.modalMask;
  }

  onFocusIn(e) {
    const activeEl = document.activeElement;
    super.onFocusIn(e);


    if (document.activeElement === activeEl && e.target === this.element) {
      this.focus();
    }
  }

  onFocusOut(e) {
    if (!this.modal && this.autoClose) {
      this.close();
    }

    super.onFocusOut(e);
  }

  onShow() {
    const me = this;

    if (me.autoClose) {
      me.addDocumentMouseDownListener();
    }


    if (me.focusOnToFront) {
      me.focus();
    }

    super.onShow && super.onShow();

    me.syncModalMask();
  }

  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents.on({
        globaltap: 'onDocumentMouseDown',
        thisObj: this
      });
    }
  }

  syncModalMask() {
    const me = this,
      {
        modal
      } = me,
      {
        modalMask
      } = Popup;

    if (modal && me.isVisible) {

      if (!me._x && !me._y) {
        me.centered = true;
      }

      modalMask.classList.remove('b-hide-display');
      modalMask.parentNode.insertBefore(modalMask, me.element);
      me.element.classList.add('b-modal');
    } else {
      me.element.classList.remove('b-modal');
      const remaningModals = me.constructor.floatRoot.querySelectorAll('.b-modal');

      if (remaningModals.length) {
        const topModal = remaningModals[remaningModals.length - 1];
        modalMask.classList.remove('b-hide-display');
        modalMask.parentNode.insertBefore(modalMask, topModal);
      } else {
        modalMask.classList.add('b-hide-display');
      }
    }
  }

  onHide() {
    const me = this;

    if (me.mouseDownRemover) {
      me.mouseDownRemover();
      me.mouseDownRemover = null;
    }

    super.onHide && super.onHide();

    me.syncModalMask();
  }

  onElementUserAction() {
    this.show();
  }

  set closable(closable) {
    this._closable = closable;

    if (!this.tools) {
      this.tools = {};
    }
  }

  get closable() {
    return this._closable;
  }

  set tools(tools) {
    const me = this;

    if (me.closable) {
      (tools || (tools = {})).close = {
        cls: 'b-popup-close',
        handler: 'close',
        weight: -1000
      };
    }

    super.tools = tools;
  }

  get tools() {
    return super.tools;
  }

  static get modalMask() {
    const me = this;

    if (!me._modalMask) {
      me._modalMask = DomHelper.createElement({
        className: 'b-modal-mask b-hide-display',
        parent: me.floatRoot
      });
    } else if (!me.floatRoot.contains(me._modalMask)) {

      me.floatRoot.appendChild(me._modalMask);
    }

    return me._modalMask;
  }

}

Popup._$name = 'Popup';
BryntumWidgetAdapterRegister.register('popup', Popup);


const tagSpaceRe = />[ \t\r\n]+</g,
  multiSpaceRe = /\s\s+/g;


class TemplateHelper {

  static tpl(strings, ...values) {
    let count = 0,
      output = values.map((val, i) => {

        let ret = strings[i];

        if (Array.isArray(val)) {
          ret += val.reduce((ack, item) => ack += (typeof item === 'string' ? item.trim() : item) + '\n', '');
        } else {
          if (val === undefined) {
            val = '';
          }

          ret += typeof val === 'string' ? val.trim() : val;
        }

        count++;
        return ret;
      }).join('');

    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }


    return output.replace(tagSpaceRe, '><').replace(multiSpaceRe, ' ').trim();
  }


  static docsTpl(strings, ...values) {
    let count = 0,
      output = values.map((val, i) => {

        let str = strings[i],
          ret = str;

        if (Array.isArray(val)) {
          ret += val.reduce((ack, item) => ack += (typeof item === 'string' ? item.trim() : item) + '\n', '');
        } else {
          if (val === undefined) {
            val = '';
          }

          ret += typeof val === 'string' ? val.trim() : val;
        }

        count++;
        return ret;
      }).join('');

    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }


    return output.replace(tagSpaceRe, '><').trim();
  }

  static repeat(times) {
    return function (...args) {
      return TemplateHelper.tpl(...args).repeat(times);
    };
  }

  static loop(times) {
  }

}

TemplateHelper._$name = 'TemplateHelper';


const bIcon = /^b-icon-/,
  bFa = /^b-fa-/;


class MenuItem extends Widget {

  static get $name() {
    return 'MenuItem';
  }

  static get defaultConfig() {
    return {

      menu: null,


      icon: null,


      text: null,


      checked: null,


      closeParent: null,


      href: null,


      target: null,
      localizableProperties: ['text']
    };
  }


  doAction(event) {
    const item = this,
      menu = this.parent,
      itemEvent = {
        menu,
        item,
        element: item.element,
        bubbles: true
      };

    if (typeof item.checked === 'boolean') {
      item.checked = !item.checked;
    }


    item.trigger('beforeItem', itemEvent);


    item.trigger('item', itemEvent);

    if (item.closeParent && menu) {
      menu.rootMenu.close();

      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }

  doDestroy() {
    const menu = this._menu;

    if (menu instanceof Widget) {
      menu.destroy();
    }

    super.doDestroy();
  }

  template(me) {
    const icon = me.icon || (typeof me.checked === 'boolean' ? `b-fw-icon b-icon-${me.checked ? '' : 'un'}checked` : ''),
      iconExtraCls = bIcon.test(icon) ? ' b-icon' : bFa.test(icon) ? ' b-fa' : '',
      tag = me.href ? 'a' : 'div';
    return TemplateHelper.tpl`
            <${tag} ${tag === 'a' ? `href="${me.href}"` : ''} ${tag === 'a' && me.target ? `target="${me.target}"` : ''} class="${me.hasMenu ? 'b-has-submenu' : ''}" ${me.name ? `data-name="${me.name}"` : ''} tabIndex="-1">
                ${icon ? `<i class="b-menuitem-icon ${icon}${iconExtraCls}" reference="iconElement"></i>` : ''}
                <span class="b-menu-text" reference="textElement">${me.text}</span>
                ${me.hasMenu ? '<i class="b-fw-icon b-icon-sub-menu" reference="subMenuIcon"></i>' : ''}
            </${tag}>`;
  }

  get focusElement() {
    return this.element;
  }

  get contentElement() {
    return this.textElement;
  }

  get isFocusable() {
    const focusElement = this.focusElement;


    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }

  onFocusIn(e) {
    super.onFocusIn(e);

    if (!this.disabled && this.menu) {
      this.openMenu();
    }
  }

  onFocusOut(e) {
    super.onFocusOut(e);
    this.closeMenu();
  }

  openMenu(andFocus) {
    const menu = this.menu;

    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
      this.owner.currentSubMenu = menu;
    }
  }

  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }


  set checked(checked) {
    const me = this,
      {
        isConfiguring
      } = me;

    if (!isConfiguring && !(typeof me._checked === 'boolean')) {
      return;
    }

    checked = !!checked;

    if (checked !== me._checked) {
      me._checked = checked;


      if (!isConfiguring) {
        me.iconElement.classList[checked ? 'add' : 'remove']('b-icon-checked');
        me.iconElement.classList[checked ? 'remove' : 'add']('b-icon-unchecked');


        me.trigger('toggle', {
          menu: me.owner,
          item: me,
          checked: me._checked,
          element: me.element,
          bubbles: true
        });
      }
    }
  }

  get checked() {
    return this._checked;
  }

  set menu(menu) {
    this._menu = menu;
  }

  get text() {
    return this.html;
  }

  set text(text) {
    this.html = text;
  }


  get menu() {
    const me = this;
    let result = me._menu;

    if (result && !(result instanceof Widget)) {


      if (typeof result === 'object' && !('items' in result || 'widgets' in result || 'html' in result)) {
        result = {
          items: result
        };
      }

      result = me.menu = WidgetHelper.createWidget(Object.assign({
        type: 'menu',
        autoShow: false,
        autoClose: true,
        scrollAction: me.owner.scrollAction,
        constrainTo: me.owner.constrainTo,
        forElement: me.element,
        align: 'l0-r0',
        anchor: true,
        owner: me,
        cls: 'b-sub-menu'

      }, result));
    }

    return result;
  }

  set closeParent(closeParent) {
    this._closeParent = closeParent;
  }

  get closeParent() {
    const result = typeof this.checked === 'boolean' ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }

  get hasMenu() {
    const menu = this.isConfiguring ? this.initialConfig.menu : this._menu;
    return menu && (menu instanceof Widget || typeof menu === 'object' || menu.length > 0);
  }

}

MenuItem._$name = 'MenuItem';
BryntumWidgetAdapterRegister.register('menuitem', MenuItem);

const validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};


class Menu extends Popup {

  static get $name() {
    return 'Menu';
  }

  static get defaultConfig() {
    return {
      align: 't-b',
      scrollAction: 'hide',


      focusOnHover: null,


      scrollable: false,
      defaultType: 'menuitem'
    };
  }


  construct(config) {
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }

    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: 'onMouseClick',
      mouseover: 'onMouseOver',
      mouseleave: 'onMouseLeave',
      thisObj: this
    });
  }

  afterShow(resolveFn) {


    const hasSubmenu = this.items.some(item => Boolean(item._menu));


    if (hasSubmenu) {
      this.element.classList.add('b-menu-with-submenu');
    }

    const hasIcon = this.items.some(item => item.icon);

    if (hasIcon) {
      this.element.classList.add('b-menu-with-icon');
    }

    super.afterShow(resolveFn);
  }

  createWidget(item) {
    if (typeof item === 'string') {
      item = {
        text: item
      };
    }

    return super.createWidget(item);
  }

  get focusElement() {
    const fromParentMenu = this.parentMenu && this.parentMenu.element.contains(document.activeElement),
      firstWidget = this.items[0];

    if (fromParentMenu || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }

    return this.element;
  }

  onDocumentMouseDown(event) {

    if (!this.parentMenu || !this.parentMenu.owns(event.event.target)) {
      super.onDocumentMouseDown(event);
    }
  }

  hide(animate) {


    super.hide(animate);

    if (this.currentSubMenu && !this.currentSubMenu.isDestroyed) {
      this.currentSubMenu.hide(animate);
    }

    if (this.parentMenu) {
      this.parentMenu.currentSubMenu = null;
    }
  }


  onMouseClick(event) {
    const me = this,
      menuItem = event.target.closest('.b-menuitem');

    if (menuItem) {
      me.triggerElement(menuItem, event);

      event.stopImmediatePropagation();
    }
  }


  onMouseOver(event) {
    const me = this;

    if (this.focusOnHover !== false) {
      const fromItemElement = DomHelper.up(event.relatedTarget, '.b-widget'),
        toItemElement = DomHelper.up(event.target, '.b-widget'),
        overItem = IdHelper.fromElement(toItemElement);

      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        me.setTimeout({
          fn: 'handleMouseOver',
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }

  handleMouseOver(overItem) {
    overItem.focus();
  }

  onMouseLeave(event) {
    const me = this,
      {
        relatedTarget
      } = event,
      leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget && relatedTarget instanceof HTMLElement && IdHelper.fromElement(relatedTarget),
      shouldHideMenu = !leavingToChild;

    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }


      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }

    if (!leavingToChild && shouldHideMenu) {
      me.currentSubMenu && me.currentSubMenu.hide();
      me.currentSubMenu = me.selectedElement = null;

      if (me.element.contains(document.activeElement) && document.activeElement.matches('.b-menuitem')) {
        me.focusElement.focus();
      }
    }
  }


  onInternalKeyDown(event) {
    const sourceWidget = IdHelper.fromElement(event),
      isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);

    if (event.key === 'Escape') {

      (isFromWidget ? this : this.rootMenu).close();
      return;
    }

    super.onInternalKeyDown(event);

    if (isFromWidget) {
      return;
    }

    if (validKeys[event.key]) {
      event.preventDefault();
    }

    const active = document.activeElement,
      el = this.element;
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }

  navigateFrom(active, key, event) {
    const me = this,
      treeWalker = me.treeWalker,
      item = active && me.getItem(active);
    let toActivate;

    switch (key) {
      case 'ArrowUp':
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;

      case 'ArrowDown':
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;

      case ' ':
        if (active && !active.classList.contains('b-disabled')) {
          if (item && item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }

        break;

      case 'ArrowRight':
        if (active && item && item.menu && !active.classList.contains('b-disabled')) {

          const openedMenu = me.openSubMenu(active, item);


          if (openedMenu) {
            openedMenu.focus();
          }
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }

        break;

      case 'ArrowLeft':
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }

        break;

      case 'Enter':
        if (active && !active.classList.contains('b-disabled')) {
          me.triggerElement(active, event);
        }

        break;
    }

    if (toActivate) {

      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, 'ArrowUp', event);
      } else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, 'ArrowDown', event);
      } else {
        toActivate.focus();
      }
    }
  }


  getItem(item) {

    if (item != null) {

      if (typeof item === 'number') {
        return this.items[item];
      }

      if (item.nodeType === 1) {
        return IdHelper.fromElement(item, 'menuitem', this.contentElement);
      } else {
        return this.items.find(c => c.id == item);
      }
    }
  }


  triggerElement(menuItemElement, event) {
    const menu = this,
      item = menu.getItem(menuItemElement);


    if (item && !item.disabled) {
      item.doAction(event);
    }
  }


  get isSubMenu() {
    return this.owner && this === this.owner.menu;
  }


  openSubMenu(element, item) {
    const me = this,
      subMenu = item.menu;

    if (subMenu) {
      if (!subMenu.isVisible) {
        const event = {
          item,
          element
        };

        if (me.trigger('beforeSubMenu', event) === false) {
          return;
        }

        if (item.onBeforeSubMenu && item.onBeforeSubMenu(event) === false) {
          return;
        }

        subMenu.show();
      }


      return me.currentSubMenu = subMenu;
    }
  }


  set selectedElement(element) {
    const me = this,
      lastSelected = me._selectedElement;

    if (lastSelected) {
      const lastItem = me.getItem(lastSelected),
        lastItemMenu = lastItem && lastItem.menu;

      if (lastItemMenu) {
        lastItemMenu.hide();
      }

      lastSelected.classList.remove('b-active');
    }

    me._selectedElement = element;

    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add('b-active');
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }

  get selectedElement() {
    return this._selectedElement;
  }

  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();


    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }


  get parentMenu() {
    let result = this.owner;

    if (result instanceof MenuItem) {
      result = result.owner;
    }

    if (result instanceof Menu) {
      return result;
    }
  }


  get rootMenu() {
    let menu = this;

    while (menu.parentMenu && menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }

    return menu;
  }

}

Menu._$name = 'Menu';
BryntumWidgetAdapterRegister.register('menu', Menu);


class Toast extends Widget {
  static get $name() {
    return 'Toast';
  }

  static get defaultConfig() {
    return {
      testConfig: {
        timeout: 100,
        destroyTimeout: 1
      },
      floating: true,


      timeout: 2500,

      destroyTimeout: 200,


      showProgress: true,


      color: null,
      bottomMargin: 20
    };
  }

  doDestroy() {
    const index = Toast.toasts.indexOf(this);

    if (index > -1) {
      Toast.toasts.splice(index, 1);
    }

    super.doDestroy();
  }

  set element(element) {
  }

  get element() {

    if (!this._element && !this.isConfiguring) {
      const me = this,
        topToast = Toast.toasts.length && Toast.toasts[0].element,
        bottom = topToast ? topToast._nextBottom : me.bottomMargin,
        element = super.element = DomHelper.createElement({
          parent: me.appendTo || Widget.floatRoot,
          children: me.showProgress ? [{
            className: 'b-toast-progress',
            style: `animation-duration:${me.timeout / 1000}s;`
          }] : null,
          html: me._html,
          className: me.color || '',
          style: me._style || ''
        });
      EventHelper.on({
        element,
        click: 'hide',
        thisObj: me
      });
      Toast.toasts.unshift(me);
      element._nextBottom = bottom + element.offsetHeight + me.bottomMargin;

      element.style.cssText += `;bottom:${bottom}px;transform:translateY(0)`;
    }

    return super.element;
  }


  show() {
    super.show();

    if (this.timeout > 0) {
      this.hideTimeout = this.setTimeout('hide', this.timeout);
    }
  }


  hide() {
    const me = this;

    if (!me.destroyTimer) {
      me.element.classList.add('b-toast-hide');
      me.element.style.bottom = '';
      me.destroyTimer = me.setTimeout('destroy', me.destroyTimeout);
    }
  }


  static hideAll() {
    Toast.toasts.reverse().forEach(toast => toast.hide());
  }


  static show(msgOrConfig) {
    const toast = new Toast(typeof msgOrConfig === 'string' ? {
      html: msgOrConfig
    } : msgOrConfig);
    toast.show();
    return toast;
  }

}

Toast.toasts = [];
Toast._$name = 'Toast';
BryntumWidgetAdapterRegister.register('toast', Toast);

const realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};


class Tooltip extends Popup {

  static get $name() {
    return 'Tooltip';
  }

  static get defaultConfig() {
    return {

      mouseOffsetX: 15,


      mouseOffsetY: 15,
      floating: true,


      getHtml: null,


      forElement: null,
      trackMouse: null,


      updateContentOnMouseMove: false,


      forSelector: null,


      hideOnDelegateChange: null,


      anchorToTarget: true,


      showOnHover: false,


      hoverDelay: 500,


      autoShow: false,


      dismissDelay: 0,


      hideDelay: 500,


      loadingMsg: 'Loading...',


      allowOver: false,
      anchor: true,
      align: 'b-t',
      axisLock: true,
      showAnimation: null,
      hideAnimation: null,
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100
      }
    };
  }


  afterConstruct() {
    const me = this,
      {
        forSelector
      } = me;

    if (forSelector) {
      me.showOnHover = true;

      if (!me.forElement) {
        me.trackMouse = true;
        me.forElement = document.body;
      }
    }

    super.afterConstruct();

    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        mouseover: 'internalOnPointerOver',
        mouseout: 'internalOnPointerOut',
        thisObj: me
      });
    }

    if (me.autoShow) {
      me.show();
    }

    if (me.allowOver) {
      EventHelper.on({
        element: me.element,
        mouseenter: 'onOwnElementMouseEnter',
        mouseleave: 'internalOnPointerOut',
        thisObj: me
      });
    }
  }

  doDestroy() {
    this.pointerOverOutDetacher && this.pointerOverOutDetacher();
    super.doDestroy();
  }

  get focusElement() {
    const result = super.focusElement;

    if (result !== this.element) {
      return result;
    }
  }

  get anchorToTarget() {
    return this._anchorToTarget;
  }

  set anchorToTarget(anchorToTarget) {
    this._anchorToTarget = anchorToTarget;
    if (!anchorToTarget) this.anchor = false;
  }

  set trackMouse(trackMouse) {
    this._trackMouse = trackMouse;
  }

  get trackMouse() {

    return this._trackMouse && !this.anchorToTarget;
  }


  onDocumentMouseDown({
                        event
                      }) {
    const me = this,
      {
        pointerEvent
      } = me;


    if (pointerEvent && DomHelper.isTouchEvent) {
      if (event.pageX === pointerEvent.pageX && event.pageY === pointerEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - pointerEvent.timeStamp < 500) {
        return;
      }
    }

    me.abortDelayedShow();
    super.onDocumentMouseDown({
      event
    });
  }

  internalOnPointerOver(event) {
    const me = this,
      forElement = me.forElement,
      forSelector = me.forSelector,
      activeTarget = me.activeTarget;
    let newTarget;

    if (me.disabled) {
      return;
    }


    if (me.allowOver && me.element.contains(event.target)) {
      return;
    }


    if (forSelector) {

      if (activeTarget && activeTarget.contains(event.target) && activeTarget.contains(event.relatedTarget)) {
        return;
      }

      newTarget = event.target.closest(forSelector);

      if (newTarget && event.relatedTarget && event.relatedTarget.closest(forSelector) === newTarget) {
        return;
      }
    } else if (!forElement.contains(event.relatedTarget)) {
      newTarget = forElement;
    } else {
      return;
    }

    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    } else if (activeTarget) {
      me.handleForElementOut();
    }
  }


  onTransitionEnd(event) {
    const me = this,
      currOver = Tooltip.currentOverElement;

    if (realignTransitions[event.propertyName]) {


      if (me.allowOver && me.element.contains(currOver)) {
        return;
      }

      if (me.activeTarget && me.activeTarget.contains(currOver) && !me.trackMouse) {
        me.realign();
      }
    }
  }

  async handleForElementOver(event, newTarget) {
    const me = this;

    if (me.trigger('pointerOver', {
      event,
      target: newTarget
    }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.pointerEvent = event;
      me.abortDelayedHide();


      if (me.isVisible && !me.hideOnDelegateChange) {
        me.updateActiveTarget(newTarget);

        if (me.trigger('beforeShow') === false) {
          return me.hide();
        }

        const result = me.updateContent();

        if (result instanceof Promise && !me.loadingMsg) {
          await result;
        }

        me.alignTo({
          target: me.anchorToTarget ? newTarget : new Point(me.pointerEvent.pageX - window.pageXOffset + me.mouseOffsetX, me.pointerEvent.pageY - window.pageYOffset + me.mouseOffsetY),
          overlap: !(me.anchorToTarget && me.anchor)
        });
        me.trigger('show');
        me.afterShowByTarget();
      } else {
        if (me.hideOnDelegateChange) {
          me.hide();
        }

        me.updateActiveTarget(newTarget);
        me.delayShow(newTarget);
      }
    }
  }

  async delayShow(target) {
    const me = this;

    if (me.currentAnimation) {
      me.cancelHideShowAnimation();
      me._hidden = true;
    }

    if (!me.isVisible && !me.hasTimeout('show')) {

      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();

        if (result instanceof Promise && !me.loadingMsg) {
          await result;
        }

        me.showByTarget(target);
      } else {

        me.addDocumentMouseDownListener();


        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: document,
            mousemove: 'onMouseMove',
            thisObj: me
          });
        }

        me.setTimeout(async () => {
          if (!DomHelper.isOrphaned(target)) {
            const result = me.updateContent();

            if (result instanceof Promise && !me.loadingMsg) {
              await result;
            }

            me.showByTarget(target);
          }
        }, !me.pointerEvent || me.pointerEvent.type === 'mouseover' ? me.hoverDelay : 0, 'show');
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }

  async updateContent() {
    const me = this;

    if (me.getHtml) {
      const result = me.getHtml({
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.pointerEvent
      });
      me.html = result;
      return result;
    }
  }


  get hasContent() {
    return Boolean(typeof this.html === 'string' && this.html.length || this.items.length);
  }

  internalBeforeShow() {

    return this.updateContentOnMouseMove || this.hasContent;
  }


  showAsyncMessage(message = this.L(this.loadingMsg)) {

    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${message}
                </div>
            `;
    }
  }

  showByTarget(target) {
    const me = this;

    if (me.mouseMoveRemover) {
      me.mouseMoveRemover();
      me.mouseMoveRemover = null;
    }


    me.showBy({
      target: me.anchorToTarget ? target : new Point(me.pointerEvent.pageX - window.pageXOffset + me.mouseOffsetX, me.pointerEvent.pageY - window.pageYOffset + me.mouseOffsetY),
      overlap: !(me.anchorToTarget && me.anchor)
    });
  }

  afterShowByTarget() {
    const me = this,
      dismissDelay = me.dismissDelay;
    me.abortDelayedShow();

    if (dismissDelay) {
      me.setTimeout('hide', dismissDelay);
    }

    me.toFront();
  }

  updateActiveTarget(newTarget) {
    const me = this,
      lastTarget = me.activeTarget;
    me.activeTarget = newTarget;

    if (!me.isConfiguring) {
      me.trigger('overtarget', {
        newTarget,
        lastTarget
      });
    }
  }

  internalOnPointerOut(event) {
    const me = this,
      toElement = event.relatedTarget;


    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }


    if (me.element.contains(event.target) && me.activeTarget && me.activeTarget.contains(toElement)) {
      return;
    }

    if (me.activeTarget && !me.activeTarget.contains(event.relatedTarget)) {
      me.handleForElementOut();
    }
  }

  handleForElementOut() {

    const me = this,
      {
        hideDelay
      } = me;

    if (me.trigger('pointerOut') === false) {
      me.activeTarget = null;
      return;
    }

    me.abortDelayedShow();


    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();

      if (hideDelay > 0) {
        me.setTimeout('hide', hideDelay);
      } else {


        me.hide();
      }
    }
  }

  show() {
    const me = this;


    if (me.forElement && me.anchorToTarget && !me.forSelector && !me.inShowBy) {
      me.showByTarget(me.forElement);
    } else {
      if (me.inShowBy) {
        me.y = -10000;
      }

      super.show();
    }

    me.afterShowByTarget();

    if (!me.mouseMoveRemover && !me._hidden && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: document,
        [BrowserHelper.supportsPointerEvents ? 'pointermove' : 'touchmove']: 'onMouseMove',
        thisObj: me
      });
    }

    if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
      me.transitionEndDetacher = EventHelper.on({
        element: me.forElement,
        transitionend: 'onTransitionEnd',
        thisObj: me
      });
    }
  }

  hide(...args) {
    const me = this;

    me.abortDelayedShow();

    if (me.isVisible) {
      me.abortDelayedHide();
      super.hide(...args);
      me.lastHidden = Date.now();
      me.activeTarget = null;

      if (me.mouseMoveRemover) {
        me.mouseMoveRemover();
        me.mouseMoveRemover = null;
      }

      if (me.transitionEndDetacher) {
        me.transitionEndDetacher();
        me.transitionEndDetacher = null;
      }

      me.listeningForMouseMove = false;
    }
  }

  abortDelayedShow() {
    const me = this;

    if (me.hasTimeout('show')) {


      if (me.mouseDownRemover) {
        me.mouseDownRemover();
        me.mouseDownRemover = null;
      }

      me.clearTimeout('show');

      if (me.mouseMoveRemover) {
        me.mouseMoveRemover();
        me.mouseMoveRemover = null;
      }

      if (me.transitionEndDetacher) {
        me.transitionEndDetacher();
        me.transitionEndDetacher = null;
      }
    }
  }


  abortDelayedHide() {
    this.clearTimeout('hide');
  }

  realign(el) {
    const me = this,
      spec = me.lastAlignSpec,
      clippedBy = me.clippedBy;


    if (!me.isConfiguring && clippedBy && !me.isVisible && spec && spec.targetHidden) {
      const target = Rectangle.from(spec.target, me.positioned ? me.element.offsetParent : null, !me.positioned),
        clippedTarget = target.intersect(clippedBy);

      if (clippedTarget) {
        me.show();
        spec.targetHidden = false;
      }
    }

    super.realign(el);
  }

  alignTo(spec) {
    const me = this;
    if (!me.isVisible) return;


    if (!(me.pointerEvent && me.element.contains(me.pointerEvent.target))) {
      if (spec.nodeType === 1) {
        spec = {
          target: spec
        };
      }
    }

    super.alignTo(spec);
  }


  set html(htmlOrPromise) {
    const me = this,
      isAsync = htmlOrPromise instanceof Promise;

    if (htmlOrPromise === false) {
      VersionHelper.deprecate('Grid', '5.0.0', 'Setting false to indicate loading is deprecated, in favor of `showAsyncMessage`. Please see https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
      this.showAsyncMessage();
      return;
    } else if (isAsync) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then(html => {

        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    } else {

      htmlOrPromise = htmlOrPromise != null ? me.L(String(htmlOrPromise)) : '';
    }

    super.html = htmlOrPromise;

    if (me.hasContent) {
      if (me.isVisible) {
        me.realign();
      }

      if (!isAsync) {
        me.trigger('innerHtmlUpdate');
      }
    } else {

      me.hide();
    }
  }


  get html() {
    return super.html;
  }


  onMouseMove(event) {
    const me = this,
      x = event.pageX - window.pageXOffset + me.mouseOffsetX,
      y = event.pageY - window.pageYOffset + me.mouseOffsetY,


      isHiding = me.hasTimeout('hide'),
      target = event.target;


    me.pointerEvent = event;

    if (!me._hidden) {
      let hideVetoed;
      const isElementOut = me.forSelector && me.activeTarget && !isHiding && target.nodeType === 1 && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target));


      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }

      if (hideVetoed || !isHiding || me.forElement.contains(target)) {

        if (me.dismissDelay && !isHiding) {
          me.setTimeout('hide', me.dismissDelay);
        }

        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.getHtml({
            tip: me,
            element: me.element,
            forElement: me.activeTarget,
            event: event
          });
        }

        if (me.trackMouse) {
          me.alignTo({
            position: new Point(x, y),
            ignorePageScroll: true
          });
        }
      }
    }
  }

  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }

}

EventHelper.on({
  element: document,
  mouseenter: event => Tooltip.currentOverElement = event.target,
  capture: true
});


Tooltip._$name = 'Tooltip';
BryntumWidgetAdapterRegister.register('tooltip', Tooltip);
Widget.tooltip = new Tooltip({
  id: 'bryntum-tooltip',
  forElement: window,
  forSelector: '[data-btip]',
  header: true,

  resetCfg: {},
  listeners: {

    pointerOver({
                  source: me,
                  target
                }) {

      for (const key in me.resetCfg) {
        if (key === 'listeners') {
          me.un(me.resetCfg[key].set);
        } else {
          if ('was' in me.resetCfg[key]) {
            me[key] = me.resetCfg[key].was;
          } else {
            delete me[key];
          }
        }
      }

      me.resetCfg = {};
      const forComponent = IdHelper.get(target.id);


      const config = forComponent ? forComponent.tipConfig : me.gatherDataConfigs(target.dataset);

      for (const key in config) {
        me.resetCfg[key] = {
          set: config[key]
        };

        if (Object.prototype.hasOwnProperty.call(me, key)) {
          me.resetCfg[key].was = me[key];
        }

        if (key === 'listeners') {
          me.on(config[key]);
        } else {
          me[key] = config[key];
        }
      }

      me.headerElement.style.display = me.title ? '' : 'none';
    }

  },

  gatherDataConfigs(dataset) {
    const me = this,
      config = {};

    for (const key in dataset) {
      if (key.startsWith('btip')) {
        if (key.length > 4) {
          const configProp = StringHelper.lowercaseFirstLetter(key.substr(4));


          if (configProp in me.getDefaultConfiguration()) {
            const value = dataset[key];

            config[configProp] = isNaN(value) ? value : parseInt(value, 10);
          }
        } else {
          config.html = dataset[key];
        }
      }
    }

    return config;
  }

});


var Badge = (Target => class Badge extends (Target || Base) {
  construct(config) {
    super.construct(config);

    if (this._badge) this.badge = this._badge;
  }


  set badge(badge) {
    const {
      element
    } = this;
    this._badge = badge;

    if (element) {
      if (badge != null && badge !== '') {
        element.dataset.badge = badge;
        element.classList.add('b-badge');
      } else {
        if (element.dataset.badge) delete element.dataset.badge;
        element.classList.remove('b-badge');
      }
    }
  }

  get badge() {
    return this._badge;
  }


  get widgetClass() {

    if (this.badge) {
      return 'b-badge';
    }
  }

});


const bIcon$1 = /^b-icon-/,
  bFa$1 = /^b-fa-/;


class Button extends Badge(Widget) {

  static get $name() {
    return 'Button';
  }

  static get defaultConfig() {
    return {

      icon: null,


      pressedIcon: null,


      iconAlign: 'start',


      text: '',


      color: null,


      toggleable: false,


      pressed: false,


      toggleGroup: null,
      ripple: {
        radius: 75
      },
      defaultBindProperty: 'text',
      localizableProperties: ['text'],


      menu: null,


      href: null,


      target: null,
      onMenuHideTimeout: 300,
      testConfig: {
        onMenuHideTimeout: 0
      }
    };
  }

  template() {
    const me = this,
      tag = me.href ? 'a' : 'button';
    return TemplateHelper.tpl`
            <${tag} ${tag === 'a' ? `href="${me.href}"` : ''} ${tag === 'a' && me.target ? `target="${me.target}"` : ''} class="${me.color || ''} ${me.toggleable && me.pressed ? 'b-pressed' : ''}" ${me.toggleGroup ? `data-group="${me.toggleGroup}"` : ''}>
                <label reference="label">\xa0</label>
            </${tag}>
        `;
  }


  construct(config = {}, ...args) {
    if (config.toggleGroup) {
      config.toggleable = true;
    }

    super.construct(config, ...args);
    EventHelper.on({
      element: this.element,
      click: 'onInternalClick',
      thisObj: this
    });
  }

  doDestroy() {
    this.destroyProperties('menu');
    super.doDestroy();
  }

  eachWidget(fn, deep = true) {
    const {
      menu
    } = this;

    if (menu) {
      if (fn(menu) === false) {
        return;
      }

      if (deep && menu.eachWidget) {
        menu.eachWidget(fn, deep);
      }
    }
  }

  onFocusOut(e) {
    super.onFocusOut(e);

    if (this.menu) {
      this.menu.hide();
    }
  }

  get focusElement() {
    return this.element;
  }


  get text() {
    return this._text;
  }

  set text(text) {
    const {
      element,
      label
    } = this;

    if (text == null) {
      text = '';
    }

    label.innerText = this._text = text;
    element.classList[String(text).length ? 'add' : 'remove']('b-text');
  }


  get menu() {
    const me = this;
    let result = me._menu;

    if (result && !(result instanceof Widget)) {


      if (typeof result === 'object' && !('type' in result || 'items' in result || 'widgets' in result || 'html' in result)) {
        result = {
          items: result
        };
      }

      result = me.menu = WidgetHelper.createWidget(Object.assign({
        type: 'menu',
        floating: true,
        autoShow: false,
        autoClose: true,
        scrollAction: 'realign',
        constrainTo: document.body,
        forElement: me.element,
        align: 't0-b0',
        owner: me,

        onHide() {


          me.setTimeout(() => me.toggle(false), me.onMenuHideTimeout);
        }

      }, result));
    }

    return result;
  }

  set menu(menu) {
    this._menu = menu;


    this.toggleable = Boolean(menu);
  }


  set pressed(pressed) {
    const me = this;

    if (pressed && me.toggleGroup) {
      DomHelper.forEachSelector(`button[data-group=${me.toggleGroup}]`, btnEl => {
        if (btnEl !== me.element) {
          WidgetHelper.getById(btnEl.id).toggle(false);
        }
      });
    }

    me._pressed = pressed;
    if (me.element) me.element.classList[pressed ? 'add' : 'remove']('b-pressed');
  }

  get pressed() {
    return this._pressed;
  }


  set icon(icon) {
    this._icon = icon;
    this.syncIconCls();
  }

  get icon() {
    return this._icon;
  }


  set pressedIcon(icon) {
    this._pressedIcon = icon;
    this.syncIconCls();
  }

  get pressedIcon() {
    return this._pressedIcon;
  }


  set iconAlign(iconAlign) {
    const me = this,
      oldAlign = me._iconAlign;

    if (iconAlign !== oldAlign) {
      if (oldAlign) {
        me.element.classList.remove(`b-icon-align-${oldAlign}`);
      }

      me.element.classList.add(`b-icon-align-${iconAlign}`);
      me._iconAlign = iconAlign;
    }
  }

  get iconAlign() {
    return this._iconAlign;
  }


  onInternalClick(event) {
    const me = this,
      bEvent = {
        event
      };

    if (me.toggleable) {

      if (me.toggleGroup && me.pressed) {
        return;
      }

      me.toggle(!me.pressed);
    }


    me.trigger('click', bEvent);


    if (!me.isDestroyed) {
      me.trigger('action', bEvent);
    }

    if (!this.href) {

      event.preventDefault();
      event.stopPropagation();
    }
  }


  toggle(pressed = null) {
    const me = this,
      {
        menu
      } = me;

    if (!me.toggleable) {
      return;
    }

    if (pressed === null) {
      pressed = !me.pressed;
    }

    me.pressed = pressed;

    me.toggling = true;

    if (menu) {
      menu.minWidth = me.width;
      menu[pressed ? 'show' : 'hide']();
    }

    me.syncIconCls();


    me.trigger('toggle', {
      pressed
    });
    me.toggling = false;
  }


  syncIconCls() {
    const me = this;
    let iconEl = me._iconEl;

    if (me.icon) {
      if (!iconEl) {
        iconEl = me._iconEl = DomHelper.createElement({
          tag: 'i',
          nextSibling: me.element.firstChild
        });
      }

      const iconCls = me.pressed && me.pressedIcon ? me.pressedIcon : me.icon;
      me._iconEl.className = iconCls;


      if (bIcon$1.test(iconCls)) {
        iconEl.classList.add('b-icon');
      } else if (bFa$1.test(iconCls)) {
        iconEl.classList.add('b-fa');
      }
    } else {
      iconEl && iconEl.remove();
    }
  }

}

Button._$name = 'Button';
BryntumWidgetAdapterRegister.register('button', Button);


class ButtonGroup extends Container {
  static get $name() {
    return 'ButtonGroup';
  }

  static get defaultConfig() {
    return {
      defaultType: 'button',


      cls: null,


      items: null,


      color: null,


      toggleGroup: null,
      valueSeparator: ',',
      columns: null
    };
  }

  construct(config = {}) {
    super.construct(config);

    this.items.forEach(w => w.on('click', this.onItemClick, this));
  }

  onItemClick() {

    this._value = null;
  }

  createWidget(widget) {
    const me = this;

    if (me.color && !widget.color) {
      widget.color = me.color;
    }

    if (me.toggleGroup && !widget.toggleGroup) {
      if (typeof me.toggleGroup === 'boolean') {
        me.toggleGroup = IdHelper.generateId('toggleGroup');
      }

      widget.toggleGroup = me.toggleGroup;
    }

    if (me.columns) {
      widget.width = `${100 / me.columns}%`;
    }

    const button = super.createWidget(widget);

    if (!(button instanceof Button)) {
      throw new Error('A ButtonGroup can only contain buttons');
    }

    return button;
  }

  get value() {


    if (!this._value) {
      const values = [];

      this.items.forEach(w => {
        if (w.pressed && w.value !== undefined) values.push(w.value);
      });

      this._value = values.join(this.valueSeparator);
    }

    return this._value;
  }

  set value(value) {
    if (!Array.isArray(value)) {
      if (value === undefined || value === null) {
        value = [];
      } else if (typeof value == 'string') {
        value = value.split(this.valueSeparator);
      } else {
        value = [value];
      }
    }

    this._value = value;

    this.items.forEach(w => {
      if (w.value !== undefined) {
        w.pressed = value.indexOf(w.value) > -1;
      }
    });
  }

  get disabled() {
    return super.disabled;
  }

  set disabled(state) {
    super.disabled = state;
    this.items.forEach(w => w.disabled = state);
  }

  get widgetClassList() {
    const classList = super.widgetClassList;

    if (this.columns) classList.push('b-columned');
    return classList;
  }

}

ButtonGroup._$name = 'ButtonGroup';
BryntumWidgetAdapterRegister.register('buttonGroup', ButtonGroup);


class ClickRepeater extends Delayable(Base) {
  static get defaultConfig() {
    return {

      element: null,


      delegate: null,


      delay: 500,


      startRate: 2,


      endRate: 20,


      accelerateDuration: 4000
    };
  }

  doDestroy() {
    this.mousedownRemover && this.mousedownRemover();
    super.doDestroy();
  }

  set element(element) {
    this._element = element;
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: 'onMouseDown',
      thisObj: this
    });
  }

  get element() {
    return this._element;
  }

  onMouseDown(e) {
    const me = this,
      target = me.delegate ? e.target.closest(me.delegate) : me.element;

    if (target) {
      me.triggerEvent = e;
      EventHelper.lockComposedPath(me.triggerEvent);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          handler: 'onMouseUp'
        },
        mousemove: {
          element: target,
          handler: 'onTargetMouseMove'
        },
        mouseleave: {
          element: target,
          handler: 'onTargetMouseLeave'
        },
        mouseenter: {
          element: target,
          handler: 'onTargetMouseEnter'
        },
        thisObj: me
      });
      me.setTimeout('startAutoRepeat', me.delay);
    }
  }

  onMouseUp(e) {
    const me = this;
    me.acceleration && me.acceleration.cancel();
    me.activeListenerRemover && me.activeListenerRemover();
    me.clearTimeout('startAutoRepeat');
    me.clearTimeout(me.repeatTimer);
  }

  onTargetMouseLeave() {
    this.clearInterval(this.repeatTimer);
  }

  onTargetMouseEnter(e) {
    this.triggerEvent = e;
    this.fireClick();
  }

  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }

  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1000 / me.startRate;
    me.accelerationDelta = me.startInterval - 1000 / me.endRate;

    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, 'easeOutQuad');
  }

  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }

  fireClick() {
    const me = this,
      clickEvent = new MouseEvent('click', me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }

}

ClickRepeater._$name = 'ClickRepeater';


const byWeight$1 = (l, r) => (l.weight || 0) - (r.weight || 0),
  byWeightReverse$1 = (l, r) => (r.weight || 0) - (l.weight || 0),
  arrayOption = {
    array: true
  };


class Field extends Badge(Widget) {

  static get $name() {
    return 'Field';
  }

  static get defaultConfig() {
    return {


      value: '',


      name: null,


      label: null,


      labels: null,


      required: null,


      clearable: null,


      revertOnEscape: null,


      labelWidth: null,


      inputWidth: null,


      keyStrokeChangeDelay: 0,


      readOnly: null,


      editable: true,
      defaultAction: 'change',


      triggers: null,


      highlightExternalChange: true,
      localizableProperties: ['label', 'title', 'placeholder'],
      autoSelect: false,


      autoComplete: 'off',


      inputAttributes: null,
      updatedClsDuration: 1500,
      testConfig: {
        updatedClsDuration: 10
      }
    };
  }

  doDestroy() {
    const me = this,
      {
        triggers
      } = me,
      errorTip = Field._errorTip;
    me.inputListenerRemover && me.inputListenerRemover();
    me.keyListenerRemover && me.keyListenerRemover();
    super.doDestroy();

    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }

    if (errorTip && errorTip.field === me) {
      errorTip.hide();
    }
  }


  get errorTip() {
    return this.constructor.errorTip;
  }


  static get errorTip() {
    return Field._errorTip || (Field._errorTip = new Tooltip({
      id: 'bryntum-field-errortip',
      cls: 'b-field-error-tip',
      forSelector: '.b-field.b-invalid .b-field-inner',
      align: 'l-r',
      scrollAction: 'realign',

      onBeforeShow() {
        const tip = this,
          field = IdHelper.fromElement(tip.activeTarget);

        if (field) {
          const errors = field.getErrors();

          if (errors) {
            tip.html = errors.join('<br>');
            tip.field = field;
            return true;
          }
        }

        return false;
      }

    }));
  }


  construct(config) {
    const me = this;
    me.highlightChanged = me.createOnFrame('addUpdatedCls');
    super.construct(config);

    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }

  onFocusIn(e) {
    this.valueOnFocus = ObjectHelper.clone(this.value);
    super.onFocusIn(e);
  }

  onFocusOut(e) {
    super.onFocusOut(e);

    this.updateRequired();

    this.onEditComplete();
  }


  onEditComplete() {
  }

  set element(element) {
    const me = this,
      value = me.initialConfig.value,
      innerElements = DomHelper.createElementFromTemplate(me.inputTemplate(me), arrayOption),
      children = [{
        className: 'b-field-inner',
        reference: 'inputWrap',
        children: innerElements
      }],
      startTriggers = [],
      endTriggers = [];
    const labels = me.labels || [];

    if (me.label) {
      labels.push({
        reference: 'labelElement',
        html: me.label
      });
    }

    if (labels) {
      labels.forEach(label => {
        const entry = Object.assign({
          tag: 'label',
          htmlFor: `${me.id}_input`,
          className: `b-align-${label.align || 'start'}`
        }, label);

        if (!label.align || label.align === 'start') {
          children.unshift(entry);
        } else {
          children.push(entry);
        }
      });
    }


    me._thisIsAUsedExpression(me.clearable);

    for (const triggerRef in me.triggers) {
      const trigger = me.triggers[triggerRef];

      if (trigger.align === 'start') {
        startTriggers.unshift(trigger);
      } else {
        endTriggers.push(trigger);
      }
    }


    startTriggers.sort(byWeight$1);
    endTriggers.sort(byWeightReverse$1);
    innerElements.unshift(...startTriggers.map(t => t.element));
    innerElements.push(...endTriggers.map(t => t.element));
    super.element = {
      className: labels.length ? 'b-has-label' : '',
      children
    };


    if (value != null) {
      me.value = value;
    }

    me.updateEmpty();
    me.updateInvalid();
    const keyEventElement = me.input || me.focusElement;

    if (keyEventElement) {
      me.keyListenerRemover = EventHelper.on({
        element: keyEventElement,
        thisObj: me,
        keydown: 'internalOnKeyPress',
        keypress: 'internalOnKeyPress',
        keyup: 'internalOnKeyPress'
      });
    }
  }

  get element() {
    return super.element;
  }


  get focusElement() {
    return this.input;
  }


  select(start, end) {


    const input = this.focusElement;

    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }

      if (!this.supportsTextSelection) {
        return;
      }

      if (BrowserHelper.isIE11) {


        input.focus();
        input.setSelectionRange(start, end);


      } else {
        input.setSelectionRange(start, end);
      }
    }
  }

  moveCaretToEnd() {
    const input = this.input;

    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {

      this.select(input.value.length, input.value.length);
    }
  }

  selectAll() {
    this.focusElement.select();
  }

  updateEmpty() {
    const {
        isEmptyInput,
        isEmpty,
        element,
        clearIcon
      } = this,
      empty = isEmptyInput && isEmpty;

    if (element) {
      if (clearIcon) {

        clearIcon.classList[empty ? 'add' : 'remove']('b-icon-hidden');
      }

      element.classList[empty ? 'add' : 'remove']('b-empty');
    }
  }

  updateInvalid() {
    this.updatingInvalid = true;
    const {
      isValid,
      element,
      errorTip,
      inputWrap
    } = this;

    if (element) {
      element.classList[isValid ? 'remove' : 'add']('b-invalid');

      if (isValid) {
        if (errorTip.isVisible && errorTip.field === this) {
          errorTip.hide();
        }
      } else if (inputWrap.contains(Tooltip.currentOverElement)) {

        if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
          errorTip.onBeforeShow();
        } else {
          errorTip.activeTarget = inputWrap;
          errorTip.showBy(inputWrap);
        }
      }
    }

    this.updatingInvalid = false;
  }


  get attributeString() {
    const me = this;
    let attributeString = me.attributes.map(attr => me[attr] != null ? `${attr.toLowerCase()}="${me[attr]}"` : '').join(' ');

    if (me.inputAttributes) {
      attributeString += Object.keys(me.inputAttributes).map(key => `${key}="${me.inputAttributes[key]}"`).join(' ');
    }

    return attributeString;
  }

  get editable() {
    return this._editable;
  }

  set editable(editable) {
    const me = this,
      input = me.input;
    me._editable = editable;


    if (input) {
      input.readOnly = editable === false ? 'readOnly' : null;

      if (editable !== false) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: 'internalOnInputFocus',
          change: 'internalOnChange',
          input: 'internalOnInput'
        });
      } else {
        me.inputListenerRemover && me.inputListenerRemover();
      }
    }
  }

  set clearable(clearable) {
    this._clearable = clearable;

    if (clearable && !this.triggers) {
      this.triggers = {};
    }
  }

  get clearable() {
    return this._clearable;
  }


  set triggers(triggers) {
    const me = this,
      myTriggers = me._triggers = {};

    if (me.clearable) {
      (triggers || (triggers = {})).clear = {
        cls: 'b-icon-remove',

        handler() {
          me._isUserAction = true;
          me.clear();
          me._isUserAction = false;
        },

        weight: 1000
      };
    }

    for (const triggerRef in triggers) {
      myTriggers[triggerRef] = WidgetHelper.createWidget(ObjectHelper.assign({
        type: 'trigger',
        reference: triggerRef,
        parent: me
      }, triggers[triggerRef]), me.defaultTriggerType || 'trigger');
    }
  }

  get triggers() {
    return this._triggers;
  }

  set labelWidth(labelWidth) {
    if (this.labelElement) {
      this.labelElement.style.flex = `0 0 ${DomHelper.setLength(labelWidth)}`;

      this.inputWrap.style.flexBasis = labelWidth == null ? '' : 0;
    }
  }


  get label() {
    return this._label;
  }

  set label(label) {
    if (label === null || label === undefined) label = '';
    this._label = label;


    if (this.labelElement) {

      this.labelElement.innerHTML = label;
    }
  }


  get readOnly() {


    return this._readOnly || this.disabled;
  }

  set readOnly(readOnly) {
    const me = this;
    readOnly = Boolean(readOnly);

    if (Boolean(me._readOnly) !== readOnly) {
      me._readOnly = readOnly;
      me.element.classList[readOnly ? 'add' : 'remove']('b-readonly');


      if (readOnly) {
        me.readWriteEditability = me.editable;

        me.editable = false;
      } else {


        me.editable = me.readWriteEditability;
      }
    }
  }


  get isValid() {
    const me = this;

    if (!me.disabled) {
      me.updateRequired();

      if (me.errors && ObjectHelper.getTruthyValues(me.errors).length) {
        return false;
      }

      if (me.input && me.input.validity) {
        return me.input.validity.valid;
      }
    }

    return true;
  }


  get isEmpty() {
    return this.value == null || this.value === '';
  }


  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === '';
  }


  get value() {
    return this._value;
  }

  set value(value) {
    const me = this,
      oldValue = me._value;

    if (me.hasChanged(oldValue, value)) {
      me._value = value;

      if (!me.isConfiguring) {
        me.updateRequired();


        if (!me.inputting) {


          me.triggerChange();
        }
      }

      if (!me.inputting) {
        me._lastValue = value;
      }

      me.syncInputFieldValue();
    } else if (value === '') {
      me.updateRequired();
    }
  }


  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }


  syncInputFieldValue(skipHighlight = false) {
    const me = this,
      {
        input
      } = me;

    if (input && !me.inputting) {

      me.input.value = me.inputValue;

      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove('b-field-updated');
        me.clearTimeout('removeUpdatedCls');

        if (!skipHighlight && (!me.parent || !me.parent.isSettingValues)) {
          me.highlightChanged();
        }
      }
    }

    me.updateEmpty();
    me.updateInvalid();
  }

  addUpdatedCls() {
    this.input.classList.add('b-field-updated');
    this.setTimeout('removeUpdatedCls', this.updatedClsDuration);
  }

  removeUpdatedCls() {
    this.input.classList.remove('b-field-updated');
  }


  get inputValue() {


    return this.value == null ? '' : this.value;
  }

  get supportsTextSelection() {
    const input = this.focusElement;

    return input && (input.tagName.toLowerCase() === 'textarea' || input.type && (/text|search|password|tel|url/.test(input.type) || BrowserHelper.isEdge));
  }


  internalOnInputFocus() {
    const length = this.input.value.length;

    if (BrowserHelper.isIE11 && length && !this.autoSelect) {
      this.select(length, length);
    }
  }


  internalOnChange(event) {
    const me = this;

    if (me.isValid && me.hasChanged(me._lastValue, me.value)) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }

  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this,
      {
        value,
        _lastValue: oldValue,

        isValid: valid
      } = me;

    me.trigger('change', {
      value,
      oldValue,
      event,
      userAction,
      valid
    });

    if (me.defaultAction === 'change') {
      me.trigger('action', {
        value,
        oldValue,
        event,
        userAction,
        valid
      });
    }

  }


  internalOnInput(event) {
    const me = this;

    me.inputting = true;
    me.value = me.input.value;
    me.inputting = false;
    me.trigger('input', {
      value: me.value,
      event
    });
    me.changeOnKeyStroke && me.changeOnKeyStroke(event);
  }

  internalOnKeyPress(event) {
    const me = this,
      {
        value
      } = me;
    let stopEvent = false;

    if (event.type === 'keydown') {
      if (event.key === 'Escape' && !me.readOnly) {


        const initialValue = 'initialValue' in me ? me.initialValue : me.valueOnFocus,
          valueChanged = me.hasChanged(initialValue, value),
          needsInputSync = me.input.value !== String(me.inputValue);


        if (me.revertOnEscape && (!me.isValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }

          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }

          me.clearError();
          stopEvent = true;
        } else if (me.clearable && (value || me.input.value)) {
          me.clear();
        }
      } else if (event.key === 'Enter' && BrowserHelper.isIE11) {
        me.internalOnChange(event);
      }
    }

    if (!me.isDestroyed) {


      if (stopEvent) {
        event.stopImmediatePropagation();
      }

      me.trigger(event.type, {
        event
      });
    }
  }

  clear() {
    this.value = null;
    this.trigger('clear');
  }


  onDisabled() {
    this.updateInvalid();
  }


  updateRequired() {
    const me = this;

    if (!me.isConfiguring && me.required && (me.value === '' || me.value == null)) {
      me.setError('fieldRequired', me.updatingInvalid);
    } else {
      me.clearError('fieldRequired', me.updatingInvalid);
    }
  }


  setError(error, silent) {
    (this.errors || (this.errors = {}))[error] = this.L(error);

    if (!silent) {
      this.updateInvalid();
    }
  }


  clearError(error, silent) {
    if (this.errors) {
      if (error) {
        delete this.errors[error];
      } else {
        this.errors = {};
      }
    }

    if (!silent) {
      this.updateInvalid();
    }
  }


  getErrors() {
    const me = this;

    if (!me.isValid) {
      const validity = me.input.validity,

        stateName = ObjectHelper.allKeys(validity).find(key => key !== 'valid' && key !== 'customError' && validity[key]);
      let errors;

      if (me.errors) {
        errors = ObjectHelper.getTruthyValues(me.errors);
      } else if (validity.customError) {
        errors = [me.input.validationMessage];
      } else if (stateName) {
        errors = [me.L(stateName, {

          min: me.min,
          max: me.max
        })];
      } else {
        errors = [me.L('invalidValue')];
      }

      if (errors && errors.length) {
        return errors;
      }
    }
  }

}


Field.Trigger = class FieldTrigger extends Widget {
  static get $name() {
    return 'FieldTrigger';
  }

  static get defaultConfig() {
    return {
      align: null
    };
  }

  template() {
    return `<div class="b-icon b-align-${this.align || 'end'}"></div>`;
  }

  construct(config) {
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: {
        handler: 'onClick',
        thisObj: this
      },
      mousedown: {
        handler: 'onMousedown',
        thisObj: this
      }
    });
  }

  onClick(e) {
    const me = this,
      field = me.field,
      handler = typeof me.handler === 'function' ? me.handler : field[me.handler];

    if (field.disabled || field.readOnly) {
      return;
    }

    if (handler && field.trigger('trigger', {
      trigger: me
    }) !== false) {
      handler.call(field, e);
    }
  }

  onMousedown(e) {
    const field = this.field,
      isKeyEvent = ('key' in e);


    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }

    e.preventDefault();

    if (document.activeElement !== field.input) {
      field.focus();
    }
  }

  get field() {
    return this.parent;
  }

};
Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get $name() {
    return 'SpinTrigger';
  }

  static get defaultConfig() {
    return {
      repeat: true
    };
  }

  doDestroy() {
    this.clickRepeater && this.clickRepeater.destroy();
    super.doDestroy();
  }

  template() {
    return `<div class="b-icon b-align-${this.align || 'end'}">
                    <div reference="upButton" class="b-icon b-spin-up"></div>
                    <div reference="downButton" class="b-icon b-spin-down"></div>
                </div>`;
  }

  set repeat(repeat) {
    const me = this;

    if (repeat) {
      me.clickRepeater = new ClickRepeater(Object.assign({
        element: me.element
      }, repeat));
    } else if (me.clickrepeater) {
      me.clickRepeater.destroy();
      me.clickrepeater = null;
    }
  }

  onClick(e) {
    const me = this,
      field = me.field;

    if (field.disabled) {
      return;
    }

    if (e.target === me.upButton) {
      field.doSpinUp();
    } else if (e.target === me.downButton) {
      field.doSpinDown();
    }
  }

};
Field._$name = 'Field';
BryntumWidgetAdapterRegister.register('trigger', Field.Trigger);
BryntumWidgetAdapterRegister.register('spintrigger', Field.SpinTrigger);


class Checkbox extends Field {

  static get $name() {
    return 'Checkbox';
  }

  static get defaultConfig() {
    return {

      text: '',


      color: null,


      value: '',
      toggleGroup: null,
      defaultBindProperty: 'value',
      localizableProperties: ['label', 'text']
    };
  }


  construct(config) {
    super.construct(config);
    const me = this;
    if (me.initialConfig.readOnly) me.readOnly = true;
    me.isConfiguring = true;
    if (me.initialConfig.checked) me.checked = true;
    me.isConfiguring = false;
  }

  inputTemplate() {
    const me = this;
    return TemplateHelper.tpl`
            <input type="checkbox" id="${me.id}_input" reference="input" ${me.toggleGroup ? `data-group="${me.toggleGroup}"` : ``}/>
            <label class="b-checkbox-label" for="${me.id}_input" reference="textLabel">${me.text || ''}</label>
        `;
  }

  set element(element) {
    const me = this;
    super.element = element;

    if (me.color) {
      me.element.classList.add(me.color);
    }

    if (me.text) {
      me.element.classList.add('b-text');
    }
  }

  get element() {
    return super.element;
  }


  get text() {
    return this._text;
  }

  set text(value) {
    this._text = value;

    if (this.textLabel) {
      this.textLabel.innerHTML = value;
    }
  }


  get value() {
    return this.checked;
  }

  set value(value) {
    this.checked = value === 'false' ? false : Boolean(value);
  }


  get checked() {
    return this.input.checked;
  }

  set checked(checked) {
    const me = this;
    checked = Boolean(checked);

    if (!me.inputting && me.input.checked !== checked) {
      me.input.checked = checked;
      me.uncheckToggleGroupMembers();

      if (!me.isConfiguring) {
        me.triggerChange(false);
      }
    }
  }

  getToggleGroupMembers() {
    const me = this,
      {
        checked,
        toggleGroup,
        input: checkedElement
      } = me,
      result = [];

    if (checked && toggleGroup) {
      DomHelper.forEachSelector(`input[type=checkbox][data-group=${toggleGroup}]`, inputEl => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = WidgetHelper.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }

    return result;
  }

  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach(widget => widget.checked = false);
    }
  }


  get readOnly() {
    return this._readOnly;
  }

  set readOnly(readOnly) {
    this._readOnly = readOnly;
    this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');
    this.input.disabled = readOnly;
  }


  check() {
    this.checked = true;
  }


  uncheck() {
    this.checked = false;
  }


  toggle() {
    this.checked = !this.checked;
  }


  internalOnChange(event) {


    this.triggerChange(true);
  }


  triggerChange(userAction) {
    const me = this,
      {
        checked
      } = me.input;

    const prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter(widget => widget.isVisible && !widget.disabled).length ||
      !me.callPreventable('change', {
        checked,
        value: checked,
        userAction
      }, eventObject => {
        if (userAction) {
          me.uncheckToggleGroupMembers();
        }


        me.trigger('action', eventObject);
        return true;
      });

    if (prevented) {


      me.input.checked = !me.input.checked;
    }
  }

}

Checkbox._$name = 'Checkbox';
BryntumWidgetAdapterRegister.register('checkbox', Checkbox);
BryntumWidgetAdapterRegister.register('check', Checkbox);


class InstancePlugin extends Localizable(Events(Base)) {

  static get defaultConfig() {
    return {

      disabled: false
    };
  }


  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});

    for (const PluginClass of plugins) {
      property[PluginClass.$name] = new PluginClass(plugInto);
    }
  }


  get client() {
    return this._client;
  }

  set client(client) {
    this._client = client;
  }


  construct(plugInto, config) {
    this.pluggedInto = this.client = plugInto;
    super.construct(config);
    this.applyPluginConfig(plugInto);
  }


  applyPluginConfig(plugInto) {
    const me = this,
      config = me.pluginConfig || me.constructor.pluginConfig;

    if (config) {
      const {
        assign,
        chain,
        after,
        before,
        override
      } = config;
      assign && me.applyAssign(plugInto, assign);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }


  applyAssign(plugInto, fnNames) {
    fnNames.forEach(fnName => this.assign(plugInto, fnName));
  }


  applyChain(plugInto, fnNames, after = true) {
    fnNames.forEach(fnName => {
      if (plugInto[fnName]) {
        this.chain(plugInto, fnName, after);
      } else {
        this.assign(plugInto, fnName);
      }
    });
  }


  applyOverride(plugInto, fnNames) {
    const me = this;

    if (!me.overridden) {
      me.overridden = {};
    }

    fnNames.forEach(fnName => {
      if (!me[fnName]) {
        throw new Error(this.L('overrideFnMissing', {
          plugIntoName: plugInto.$name,
          pluginName: me.$name,
          fnName: fnName
        }));
      }

      if (typeof plugInto[fnName] === 'function') {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }

      plugInto[fnName] = me[fnName].bind(me);
    });
  }


  assign(plugInto, fnName) {
    const me = this,
      property = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);

    if (property && (property.get || property.set)) {

      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }


  chain(plugInto, key, after = true) {
    const me = this,
      chain = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {});

    if (!chain[key]) {
      chain[key] = [plugInto[key].bind(plugInto)];
    }

    if (!me[key]) {
      throw new Error(this.L('fnMissing', {
        plugIntoName: plugInto.$name,
        pluginName: me.$name,
        fnName: key
      }));
    }

    chain[key][after ? 'push' : 'unshift'](me[key].bind(me));

    plugInto[key] = (...params) => me.functionChainRunner(key, ...params);
  }


  functionChainRunner(fnName, ...params) {
    const chain = this.client.pluginFunctionChain[fnName];
    let returnValue;

    for (let i = 0; i < chain.length; i++) {
      returnValue = chain[i](...params);

      if (returnValue === false) {
        return false;
      }
    }

    return returnValue;
  }


  doDisable(disable) {
    const {
        constructor
      } = this,
      cls = 'featureClass' in constructor ? constructor.featureClass : `b-${constructor.$name.toLowerCase()}`;

    if (cls) {
      this.client && this.client.element && this.client.element.classList[disable ? 'remove' : 'add'](cls);
    }

    if (disable) {

      this.trigger('disable');
    } else {

      this.trigger('enable');
    }
  }


  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;
    this.doDisable(disabled);
  }

}

InstancePlugin._$name = 'InstancePlugin';


var Pluggable = (Target => class Pluggable extends (Target || Base) {


  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }

    return this._plugins;
  }

  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins)) plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }

    this.initPlugins();
  }


  initPlugins() {
  }


  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }


  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }


  getPlugin(pluginClassOrName) {
    if (typeof pluginClassOrName === 'function') pluginClassOrName = pluginClassOrName.$name;
    return this.plugins && this.plugins[pluginClassOrName];
  }


  get widgetClass() {
  }

});


var State = (Target => class State extends (Target || Base) {


  get state() {
    this._state = this.getState();
    return this._state;
  }

  set state(state) {
    this._state = state;
    this.applyState(state);
  }


  get widgetClass() {
  }

});


const STM_PROP = Symbol('STM_PROP'),
  unrecordedFields = {


    parentIndex: 1
  };


var ModelStm = (Target => class ModelStm extends (Target || Base) {
  static get defaultConfig() {
    return {
      stm: null
    };
  }

  joinStore(store) {
    super.joinStore && super.joinStore(store);

    if (!this.stm) {
      this.stm = store.stm;
    }
  }

  unJoinStore(store) {
    if (this.stm === store.stm) {
      this.stm = null;
    }

    super.unJoinStore && super.unJoinStore(store);
  }


  get stm() {
    return this[STM_PROP];
  }

  set stm(stm) {
    this[STM_PROP] = stm;
  }


  beforeSet(field, value, silent, fromRelationUpdate) {
    const preResult = super.beforeSet ? super.beforeSet(field, value, silent, fromRelationUpdate) : [];
    const stm = this.stm;

    if (stm && !stm.disabled && !unrecordedFields[field]) {
      let newDataCandidate, oldDataCandidate;

      if (typeof field == 'object') {
        [newDataCandidate, oldDataCandidate] = Object.keys(field).reduce((data, fName) => {
          data[0][fName] = field[fName];
          data[1][fName] = this.get(fName);
          return data;
        }, [{}, {}]);
      } else {
        newDataCandidate = {
          [field]: value
        };
        oldDataCandidate = {
          [field]: this.get(field)
        };
      }

      preResult.push([newDataCandidate, oldDataCandidate]);
    }

    return preResult;
  }


  afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet) {
    const stm = this.stm;

    if (stm && !stm.disabled && !unrecordedFields[field]) {
      const preResult = beforeResult.pop();

      if (wasSet) {
        let [newDataCandidate, oldDataCandidate] = preResult;
        let [newData, oldData] = Object.keys(wasSet).reduce((data, fName) => {
          data[0][fName] = newDataCandidate[fName];
          data[1][fName] = oldDataCandidate[fName];
          return data;
        }, [{}, {}]);
        stm.onModelUpdate(this, newData, oldData);
      }
    }

    super.afterSet && super.afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet);
  }


  beforeInsertChild(childRecords) {
    const preResult = super.beforeInsertChild ? super.beforeInsertChild(childRecords) : [];
    const stm = this.stm;

    if (stm && !stm.disabled) {
      preResult.push(childRecords.reduce((result, childRecord) => {


        if (childRecord.root === this.root) {
          result.set(childRecord, {
            parent: childRecord.parent,
            index: childRecord.parent ? childRecord.parentIndex : undefined
          });
        }

        return result;
      }, new Map()));
    }

    return preResult;
  }


  afterInsertChild(index, childRecords, beforeResult, inserted) {
    const stm = this.stm;

    if (stm && !stm.disabled) {
      const context = beforeResult.pop();

      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }

    super.afterInsertChild && super.afterInsertChild(index, childRecords, beforeResult, inserted);
  }


  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [];
    const stm = this.stm;

    if (stm && !stm.disabled && !isMove) {


      preResult.push(childRecords.reduce((result, childRecord) => {
        result.set(childRecord, childRecord.parentIndex);
        return result;
      }, new Map()));
    }

    return preResult;
  }


  afterRemoveChild(childRecords, beforeResult, isMove) {
    const stm = this.stm;

    if (stm && !stm.disabled && !isMove) {
      const context = beforeResult.pop();

      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }

    super.afterRemoveChild && super.afterRemoveChild(childRecords, beforeResult, isMove);
  }

});


var TreeNode = (Target => class TreeNode extends (Target || Base) {

  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }

    this._convertEmptyParentToLeaf = value;
  }

  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || {
      onLoad: false,
      onRemove: false
    };
  }


  ingestChildren(childRecord, stores = this.stores) {
    const {
        inProcessChildren,
        constructor: MyClass
      } = this,
      store = stores[0];

    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }

      return [];
    }

    if (childRecord) {
      if (!Array.isArray(childRecord)) {
        childRecord = [childRecord];
      }

      const len = childRecord.length,
        result = [];

      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child instanceof Model ? child : store ? store.createRecord(child) : new MyClass(child, null, null, true);
        result.push(child);
      }

      return result;
    }
  }


  processChildren(stores = this.stores) {
    const me = this,
      {
        meta
      } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);

    if (children) {
      if (children.length) {
        meta.isLeaf = false;

        if (me.children === true) {
          me.children = [];
        }

        me.appendChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }

    me.inProcessChildren = false;
  }


  ancestorsExpanded(store) {
    const {
      parent
    } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }


  isExpanded(store) {
    const mapMeta = this.instanceMeta(store.id);


    if (!Object.prototype.hasOwnProperty.call(mapMeta, 'collapsed')) {
      mapMeta.collapsed = !this.expanded;
    }

    return !mapMeta.collapsed;
  }


  get expanded() {
    return this.data.expanded;
  }


  get childLevel() {
    return this.parent ? this.parent.childLevel + 1 : this.isRoot ? -1 : 0;
  }


  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }


  get isParent() {
    return !this.isLeaf;
  }


  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }


  get descendantCount() {
    return this.getDescendantCount();
  }


  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }


  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const children = this.children;

    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }

    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }


  get allChildren() {
    const children = this.children;
    if (!children) return [];
    return children.reduce((all, child) => {
      all.push(child);


      all.push.apply(all, child.allChildren);
      return all;
    }, []);
  }


  get firstChild() {
    const children = this.children;
    return children && children.length && children[0] || null;
  }


  get lastChild() {
    const children = this.children;
    return children && children.length && children[children.length - 1] || null;
  }


  get previousSiblingsTotalCount() {
    let task = this.previousSibling,
      count = this.parentIndex;

    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }

    return count;
  }

  get root() {
    return this.parent && this.parent.root || this;
  }


  get parentId() {
    return this.parent && !this.parent.isRoot ? this.parent.id : null;
  }

  set parentId(parentId) {
    const me = this,
      {
        parent
      } = me,
      newParent = parentId && me.firstStore.getById(parentId);


    if (!(newParent === parent || !parent && !newParent)) {


      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }

  static set parentIdField(parentIdField) {


    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function (parentId) {


        this.parentId = parentId;
      },
      get: function () {


        return this.parentId;
      }
    });
  }

  static get parentIdField() {
    return this._parentIdField || 'parentId';
  }


  traverse(fn, skipSelf = false) {
    const {
      children
    } = this;

    if (!skipSelf) {
      fn.call(this, this);
    }


    for (let i = 0, l = children && children.length; i < l; i++) {
      children[i].traverse(fn);
    }
  }


  traverseBefore(fn, skipSelf = false) {
    const {
      children
    } = this;


    for (let i = 0, l = children && children.length; i < l; i++) {
      children[i].traverse(fn);
    }

    if (!skipSelf) {
      fn.call(this, this);
    }
  }


  traverseWhile(fn, skipSelf = false) {
    const me = this;
    let goOn = true;

    if (!skipSelf) {
      goOn = fn.call(me, me) !== false;
    }

    if (goOn && me.isLoaded) {
      goOn = me.children.every(child => child.traverseWhile(fn));
    }

    return goOn;
  }


  bubble(fn, skipSelf = false) {
    let me = this;

    if (!skipSelf) {
      fn.call(me, me);
    }

    while (me.parent) {
      me = me.parent;
      fn.call(me, me);
    }
  }


  bubbleWhile(fn, skipSelf = false) {
    let me = this,
      goOn = true;

    if (!skipSelf) {
      goOn = fn.call(me, me);
    }

    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn.call(me, me);
    }

    return goOn;
  }


  contains(childOrId) {
    if (childOrId && typeof childOrId === 'object') {
      childOrId = childOrId.id;
    }

    return !this.traverseWhile(node => node.id != childOrId);
  }

  getTopParent(all) {
    let result;

    if (all) {
      result = [];
      this.bubbleWhile(t => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile(t => {
        if (!t.parent) {
          result = t;
        }

        return t.parent && !t.parent.isRoot;
      });
    }

    return result;
  }


  appendChild(childRecord, silent = false) {
    return this.insertChild(childRecord, null, silent);
  }


  insertChild(childRecord, beforeRecord = null, silent = false) {

    if (typeof childRecord === 'number') {
      const index = childRecord;
      childRecord = beforeRecord;
      beforeRecord = this.children[index];
    }

    const me = this,
      wasLeaf = me.isLeaf,
      returnArray = Array.isArray(childRecord);
    if (!Array.isArray(childRecord)) childRecord = [childRecord];

    if (!silent) {
      if (!me.stores.every(s => s.trigger('beforeAdd', {
        records: childRecord,
        parent: me
      }) !== false)) {
        return null;
      }
    }

    childRecord = me.ingestChildren(childRecord);

    const index = beforeRecord ? beforeRecord.parentIndex : me.children ? me.children.length : 0,
      preResult = me.beforeInsertChild ? me.beforeInsertChild(childRecord) : undefined,
      inserted = me.internalAppendInsert(childRecord, beforeRecord, silent);

    if (wasLeaf && inserted.length) {
      me.meta.isLeaf = false;
    }


    if (me.isLeaf !== wasLeaf && !me.root.isLoading && !silent) {
      me.stores.forEach(s => {
        const changes = {
          isLeaf: {
            value: false,
            oldValue: true
          }
        };
        s.trigger('update', {
          record: me,
          changes
        });
        s.trigger('change', {
          action: 'update',
          record: me,
          changes
        });
      });
    }

    me.afterInsertChild && me.afterInsertChild(index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }

  tryInsertChild() {
    return this.insertChild(...arguments);
  }

  internalAppendInsert(recordsToInsert, beforeRecord, silent) {
    const me = this,
      {
        stores,
        root
      } = me,
      {
        firstStore: rootStore
      } = root,
      isMove = {};
    let isNoop, start, i, newRecordsCloned;

    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }


    if (me.children) {
      const children = me.children,
        insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;

      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }


    if (isNoop) {
      return recordsToInsert;
    }

    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i],
        oldParent = newRecord.parent;


      isMove[newRecord.id] = newRecord.root === root;

      rootStore && newRecord.traverse(r => {
        if (r.root === root) {
          isMove[r.id] = true;
        }
      });


      if (oldParent && oldParent.removeChild(newRecord, isMove[newRecord.id]) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }

        recordsToInsert.splice(i--, 1);
      } else {
        const {
            parentIdField
          } = newRecord.constructor,
          parentId = me.isAutoRoot ? null : me.id;
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;


        if (!(me.inProcessChildren || me.isLoading)) {
          const toSet = {
              parentId
            },
            {
              modified
            } = newRecord.meta,
            oldParentId = oldParent ? oldParent.id : null,
            wasSet = {
              [parentIdField]: {
                value: me.id,
                oldValue: oldParentId
              }
            };

          if (modified[parentIdField] === me.id) {
            delete modified[parentIdField];
          } else if (!('parentId' in modified)) {
            modified[parentIdField] = oldParentId;
          }

          newRecord.afterChange(toSet, wasSet);
        }
      }
    }

    if (recordsToInsert.length) {

      const insertAt = me.addToChildren(me.children || (me.children = []), beforeRecord, recordsToInsert);

      me.addToChildren(me.unfilteredChildren, beforeRecord, recordsToInsert, true);
      stores.forEach(store => {
        if (!store.isChained) {
          recordsToInsert.forEach(record => {

            record.joinStore(store);
          });

          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
        }
      });
    }

    return recordsToInsert;
  }


  removeChild(childRecords, isMove = false, silent = false) {
    const me = this,
      wasLeaf = me.isLeaf,
      {
        children,
        stores
      } = me;

    if (!Array.isArray(childRecords)) {
      childRecords = [childRecords];
    }

    childRecords = childRecords.filter(r => r.parent === me);

    if (!silent) {

      for (const store of stores) {
        if (!store.isChained) {
          if (store.trigger('beforeRemove', {
            parent: me,
            records: childRecords,
            isMove
          }) === false) {
            return false;
          }
        }
      }
    }

    const preResult = me.beforeRemoveChild ? me.beforeRemoveChild(childRecords, isMove) : undefined;

    for (const childRecord of childRecords) {
      const index = me.removeFromChildren(children, childRecord);
      me.removeFromChildren(me.unfilteredChildren, childRecord, true);
      stores.forEach(store => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, [childRecord], index, {
            isMove,
            silent
          });
        }
      });
      childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
    }

    if (!children.length && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }


    if (me.isLeaf !== wasLeaf && !silent) {
      me.stores.forEach(s => {
        const changes = {
          isLeaf: {
            value: true,
            oldValue: false
          }
        };
        s.trigger('update', {
          record: me,
          changes
        });
        s.trigger('change', {
          action: 'update',
          record: me,
          changes
        });
      });
    }

    me.afterRemoveChild && me.afterRemoveChild(childRecords, preResult, isMove);
  }

  clearChildren(silent = false) {
    const me = this,
      {
        children,
        stores
      } = me;

    if (children) {
      me.children = [];
      stores.forEach(store => {
        if (!store.isChained) {

          store.onNodeRemoveChild(me, children, 0, {
            unfiltered: true,
            silent
          });
        }
      });

      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }


  clear() {
    const me = this,
      {
        stores
      } = me,
      children = me.children && me.children.slice();

    if (!me.isRoot || !children) {
      return;
    }

    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger('beforeRemove', {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }

    me.children.length = 0;
    stores.forEach(store => {
      children.forEach(child => {
        if (child.stores.includes(store)) {

          child.unJoinStore(store);
        }

        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger('removeAll');
      store.trigger('change', {
        action: 'removeall'
      });
    });
  }

  updateChildrenIndex(children, unfiltered = false) {
    const indexName = unfiltered ? 'unfilteredIndex' : 'parentIndex';
    let previousSibling = null;

    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      child[indexName] = i;

      if (!unfiltered) {
        child.previousSibling = previousSibling;

        if (previousSibling) {
          previousSibling.nextSibling = child;
        }

        if (i === children.length - 1) {
          child.nextSibling = null;
        }

        previousSibling = child;
      }
    }
  }

  addToChildren(children, beforeRecord, newRecords, unfiltered = false) {
    if (children) {
      const indexName = unfiltered ? 'unfilteredIndex' : 'parentIndex',
        index = beforeRecord ? beforeRecord[indexName] : children.length;
      children.splice(index, 0, ...newRecords);
      this.updateChildrenIndex(children, unfiltered);
      return index;
    }
  }

  removeFromChildren(children, childRecord, unfiltered = false) {
    if (children) {
      const indexName = unfiltered ? 'unfilteredIndex' : 'parentIndex',
        index = childRecord[indexName];

      if (index > -1) {
        children.splice(index, 1);
        this.updateChildrenIndex(children, unfiltered);
      }

      return index;
    }
  }

});


const internalProps = {
    children: 1,
    data: 1,
    meta: 1
  },
  _undefined = undefined,
  emptyObject$2 = {},
  convertDate = function (date) {
    if (!(date instanceof Date)) {

      date = DateHelper.parse(date, this.format || this.dateFormat || DateHelper.defaultParseFormat);
    }


    return date || _undefined;
  },
  isEqual = (field, oldValue, value) => {

    return field && field.isEqual ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);
  },
  nullFn = () => {
  };


class Model extends TreeNode(ModelStm()) {

  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }

  static get idField() {
    return this._idField;
  }


  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }

  static get childrenField() {
    return this._childrenField || 'children';
  }


  get indexPath() {
    const indices = [];

    for (let task = this; task && !task.isRoot; task = task.parent) {
      indices.unshift(task.parentIndex + 1);
    }

    return indices;
  }


  construct(data = {}, store = null, meta = null, skipExpose = false) {
    const me = this,
      {
        constructor
      } = me,
      {
        fieldMap
      } = constructor,
      stores = store ? Array.isArray(store) ? store : [store] : [];

    let configs = null;
    store = stores[0];
    me.meta = Object.assign({
      modified: {}
    }, constructor.metaConfig, meta);

    if (constructor.applyConfigs) {

      const defaultConfig = constructor.getDefaultConfiguration(),
        configKeys = [...new Set(ObjectHelper.allKeys(defaultConfig))];

      if (configKeys.length) {
        if (!me.useRawData || !me.useRawData.enabled) {

          data = Object.assign({}, data);
        }

        configs = {};
        configKeys.forEach(key => {

          configs[key] = data[key] || defaultConfig[key];

          delete data[key];
        });
      }
    }

    super.construct(configs);

    if (skipExpose) {
      if (!constructor.hasOwnProperty('fieldMap')) {
        constructor.exposeProperties();
      }
    } else {
      constructor.exposeProperties(data);
    }

    if (!constructor.hasOwnProperty('idFieldProcessed')) {


      let overriddenIdField = me.meta.idField;

      if (!overriddenIdField) {

        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }

      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: 'id',
          dataSource: overriddenIdField
        });
      }

      constructor.idFieldProcessed = true;
    }

    me._internalId = Model._internalIdCounter++;

    me.stores = [];
    me.unjoinedStores = [];

    if (!me.originalData) {
      me.originalData = data;
    }

    me.data = constructor.processData(data, false, store);

    if (me.id == null) {

      me.setData('id', me.generateId(store));
    }

    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }

    me.generation = 0;
  }


  equals(other) {
    if (other instanceof this.constructor) {
      for (let {
        fields
      } = this, i = 0, {
        length
      } = fields; i < length; i++) {
        const field = fields[i],
          {
            name
          } = field;

        if (name !== 'id' && !isEqual(field, this[name], other[name])) {
          return false;
        }
      }

      return true;
    }

    return false;
  }

  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }


  static processData(data, ignoreDefaults = false, store) {
    const {
        fieldMap,
        defaultValues
      } = this,
      {
        useRawData = {
          enabled: false
        }
      } = store || {},


      processed = useRawData.enabled ? data : Object.assign({}, data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue;

    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        if (processed[fieldName] === _undefined) processed[fieldName] = defaultValues[fieldName];
      }
    }

    if (!useRawData.disableTypeConversion) {

      for (fieldName in fieldMap) {
        const fieldDefinition = fieldMap[fieldName],
          {
            name,
            dataSource
          } = fieldDefinition,


          useNameForValue = dataSource !== name && !ObjectHelper.pathExists(data, dataSource) && name in data,
          convert = !useRawData.disableTypeConversion && fieldDefinition.convert;

        if (useNameForValue || convert) {
          const value = useNameForValue ? data[name] : data[dataSource];

          if (!ignoreDefaults || useNameForValue && name in data || !useNameForValue && dataSource in data) {
            ObjectHelper.setPath(processed, dataSource, convert ? fieldDefinition.convert(value) : value);

            if (useNameForValue) {
              delete processed[name];
            }
          }
        }
      }
    }

    return processed;
  }


  static exposeProperties(data) {
    const me = this,
      superclass = me.superclass,
      rawFields = me.hasOwnProperty('fields') && me.fields;

    if (superclass.exposeProperties && !superclass.hasOwnProperty('fieldMap')) {
      superclass.exposeProperties();
    }

    if (!me.hasOwnProperty('propertiesExposed')) {


      me.defaultValues = Object.assign({}, superclass.defaultValues, me.hasOwnProperty('defaults') ? me.defaults : null);


      me.fieldMap = Object.setPrototypeOf({}, superclass.fieldMap || emptyObject$2);
      me.fieldDataSourceMap = Object.setPrototypeOf({}, superclass.fieldDataSourceMap || emptyObject$2);

      me.propertiesExposed = Object.setPrototypeOf({}, superclass.propertiesExposed || emptyObject$2);

      if (me.hasOwnProperty('idField')) {
        me.addField({
          name: 'id',
          dataSource: me.idField
        });
        me.propertiesExposed[me.idField] = true;
      }

      if (rawFields && rawFields.length) {
        rawFields.map(me.addField, me);
      }
    }


    if (me.autoExposeFields && data && !me.hasOwnProperty('propertiesExposedForData')) {
      for (const dataProperty in data) {
        if (!me.propertiesExposed[dataProperty]) {

          me.addField({
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          });
        }
      }

      me.propertiesExposedForData = true;
    }

    me.exposeRelations();
  }


  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }

    if (typeof fieldDef === 'string') {
      fieldDef = {
        name: fieldDef
      };
    }

    const me = this,
      {
        propertiesExposed,
        defaultValues
      } = me,
      {
        name
      } = fieldDef,
      dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);

    if (!fieldDef.hasOwnProperty('persist')) {
      fieldDef.persist = true;
    }

    if (fieldDef.type === 'date') {
      fieldDef.convert = convertDate;
    }

    me.fieldMap[name] = fieldDef;

    if (!me.fieldDataSourceMap[dataSource]) {
      me.fieldDataSourceMap[dataSource] = fieldDef;
    }

    if (dataSource.includes('.') || fieldDef.type === 'model') {
      fieldDef.complexMapping = true;
      propertiesExposed[dataSource.split('.')[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }

    if ('defaultValue' in fieldDef) {
      defaultValues[dataSource] = fieldDef.defaultValue;
    }


    me.createFieldProperty(name, dataSource, fieldDef);
    return fieldDef;
  }


  static removeField(fieldName) {
    const definition = this.fieldMap[fieldName];

    if (definition) {
      const {
        dataSource
      } = definition;
      delete this.fieldMap[fieldName];
      delete this.fieldDataSourceMap[dataSource];
      delete this.prototype[fieldName];
      this._internalFields = null;
    }
  }


  static createFieldProperty(fieldName, propertyName, fieldDef) {
    const me = this;


    if (!internalProps[propertyName]) {
      if (!(fieldName in me.prototype)) {
        Object.defineProperty(me.prototype, fieldName, {
          enumerable: true,
          configurable: true,


          get() {


            return this.get(fieldName);
          },


          set: fieldDef && fieldDef.readOnly ? nullFn : function (value) {


            this.set(fieldName, value);
          }
        });
      }
    }
  }


  static exposeRelations() {
    const me = this;
    if (me.hasOwnProperty('relationsExposed')) return;

    if (me.relationConfig) {
      me.relationsExposed = true;
      me.relations = [];
      me.relationConfig.forEach(relation => {
        me.relations.push(relation);
        const name = relation.relationName;

        if (!Reflect.ownKeys(me.prototype).includes(name)) {
          Object.defineProperty(me.prototype, name, {
            enumerable: true,
            get: function () {

              return this.getForeign(name);
            },
            set: function (value) {

              this.setForeign(name, value, relation);
            }
          });
        }
      });
    }
  }


  static get autoExposeFields() {
    return true;
  }


  static get fields() {
    return [];
  }

  static get internalFields() {
    const {
      fieldMap
    } = this;
    let result = this._internalFields;


    if (this.hasOwnProperty('fieldMap') && !result) {
      result = this._internalFields = [];

      for (const fieldName in fieldMap) {
        result.push(fieldMap[fieldName]);
      }
    }

    return result;
  }


  get fields() {
    return this.constructor.internalFields || this.constructor.fields;
  }


  getFieldDefinition(fieldName) {
    return this.constructor.getFieldDefinition(fieldName);
  }

  getFieldDefinitionFromDataSource(dataSource) {
    return this.constructor.fieldDataSourceMap[dataSource];
  }


  get fieldNames() {
    return Object.keys(this.data);
  }


  static getFieldDefinition(fieldName) {
    return this.fieldMap[fieldName];
  }


  static getFieldDataSource(fieldName) {
    return this.getFieldDefinition(fieldName).dataSource;
  }


  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    if (def) return def.dataSource || def.name;
  }


  static processField(fieldName, value) {
    const field = this.fieldMap[fieldName];

    if (field && field.convert) {
      return field.convert(value);
    }

    return value;
  }


  initRelations() {
    const me = this,
      relations = me.constructor.relations;
    if (!relations) return;


    me.stores.forEach(store => {
      if (!store.modelRelations) store.initRelations();

      const relatedRecords = [];
      store.modelRelations && store.modelRelations.forEach(config => {
        relatedRecords.push({
          related: me.initRelation(config),
          config
        });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }


  initRelation(config) {
    const me = this,
      keyValue = me.get(config.fieldName),
      foreign = keyValue !== _undefined && typeof config.store !== 'string' && config.store.getById(keyValue),
      placeHolder = {
        id: keyValue,
        placeHolder: true
      };
    if (!me.meta.relationCache) me.meta.relationCache = {};

    me.meta.relationCache[config.relationName] = foreign || (keyValue != null ? placeHolder : null);
    return foreign;
  }

  removeRelation(config) {

    if (this.meta.relationCache[config.relationName]) {
      delete this.meta.relationCache[config.relationName];

      if (config.nullFieldOnRemove) {

        this.setData(config.fieldName, null);
      }
    }
  }

  getForeign(name) {
    return this.meta.relationCache && this.meta.relationCache[name];
  }

  setForeign(name, value, config) {
    const id = Model.asId(value);
    return this.set(config.fieldName, id);
  }


  get(fieldName) {
    const me = this,
      batchChanges = me.meta.batchChanges,
      recData = me.data;
    let field = me.constructor.fieldMap[fieldName];
    const dataSource = field ? field.dataSource : fieldName;

    if (batchChanges) {
      if (Object.prototype.hasOwnProperty.call(batchChanges, fieldName)) {
        return batchChanges[fieldName];
      }
    }

    if (dataSource) {

      if (!field && fieldName.includes('.')) {
        const nestedName = fieldName.split('.')[0];
        field = me.constructor.fieldMap[nestedName];
      }

      if (field && field.complexMapping) {
        return ObjectHelper.getPath(recData, dataSource);
      }

      return dataSource in recData ? recData[dataSource] : recData[fieldName];
    }
  }


  setData(fieldName, value) {
    const field = this.constructor.fieldMap[fieldName],
      dataSource = field ? field.dataSource : fieldName;

    if (dataSource) {
      ObjectHelper.setPath(this.data, dataSource, value);
    }
  }


  syncId(value) {
    const oldValue = this.id;

    if (oldValue !== value) {
      this.setData('id', value);
      const data = {
        id: {
          value,
          oldValue
        }
      };
      this.afterChange(data, data);
    }
  }


  set(field, value, silent = false, fromRelationUpdate = false) {
    const me = this;


    if (me.isBatchUpdating) {
      me.inBatchSet(field, value);
      return null;
    } else {
      const preResult = me.beforeSet ? me.beforeSet(field, value, silent, fromRelationUpdate) : _undefined,
        wasSet = me.inSet(field, value, silent, fromRelationUpdate);
      me.afterSet && me.afterSet(field, value, silent, fromRelationUpdate, preResult, wasSet);
      return wasSet;
    }
  }

  fieldToKeys(field, value) {
    let result;

    if (typeof field !== 'string') {
      result = {};

      Reflect.ownKeys(field).forEach(key => result[key] = field[key]);
    } else {
      result = {
        [field]: value
      };
    }

    return result;
  }

  inBatchSet(field, value) {
    if (typeof field !== 'string') {
      const toSet = this.fieldToKeys(field, value);
      Object.keys(toSet).forEach(key => {

        this.meta.batchChanges[key] = this.constructor.processField(key, toSet[key]);
      });
    } else {

      this.meta.batchChanges[field] = value;
    }
  }

  inSet(field, value, silent, fromRelationUpdate) {
    const me = this,
      fieldMap = me.constructor.fieldMap,
      myProto = me.constructor.prototype,
      data = me.data,
      wasSet = {},
      toSet = me.fieldToKeys(field, value);
    let changed = false;

    if (!silent && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }

    Object.keys(toSet).forEach(key => {

      if (key === me.constructor.childrenField) {
        return;
      }

      const field = fieldMap[key],
        readOnly = field && field.readOnly,
        mapping = field ? field.dataSource : key,
        useProp = !field && key in myProto,
        oldValue = useProp ? me[mapping] : ObjectHelper.getPath(data, mapping),
        value = me.constructor.processField(key, toSet[key]),
        val = toSet[key] = {
          value
        },
        relation = me.getRelationConfig(key);

      if (!readOnly && !isEqual(field, oldValue, value)) {

        me.generation++;
        val.oldValue = oldValue;
        changed = true;


        if (isEqual(field, me.meta.modified[key], value)) {
          delete me.meta.modified[key];
        } else {

          me.meta.modified[key] = oldValue;

          if (val.oldValue === _undefined && 'oldValue' in val) {
            delete val.oldValue;
          }
        }

        wasSet[key] = val;


        if (useProp) {
          me[key] = value;
        } else {
          ObjectHelper.setPath(data, mapping, value);
        }

        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach(store => store.cacheRelatedRecord(me, value, relation.relationName, val.oldValue));
        }
      } else {
        delete toSet[key];
      }
    });

    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate);
    }

    return changed ? wasSet : null;
  }

  afterChange(toSet, wasSet, silent, fromRelationUpdate) {
    this.stores.forEach(store => {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate);
    });
  }

  get isPersistable() {
    return true;
  }


  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }


  isFieldModified(fieldName) {
    return this.isModified && this.meta.modified[fieldName];
  }


  getFieldPersistentValue(name) {
    const field = this.getFieldDefinition(name);
    let result;

    if (!field || field.persist) {
      result = this[name];

      if (field && field.serialize) {
        result = field.serialize.call(this, result, this);
      }
    }

    return result;
  }


  get modifications() {
    const data = this.rawModifications;

    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }

    return data;
  }

  get rawModifications() {
    const me = this,
      data = {};

    if (!me.isModified) {
      return null;
    }

    Object.keys(me.meta.modified).forEach(key => {

      const value = me.getFieldPersistentValue(key);

      if (value !== _undefined) {
        data[key] = value;
      }
    });
    return data;
  }


  get modificationData() {
    const data = this.rawModificationData;

    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.getFieldDefinition(this.constructor.idField).dataSource, this.id);
    }

    return data;
  }

  get rawModificationData() {
    const me = this,
      {
        fieldMap
      } = me.constructor,
      data = {};

    if (!me.isModified) {
      return null;
    }

    Object.keys(me.meta.modified).forEach(fieldName => {

      const field = fieldMap[fieldName];

      if (field) {
        const value = me.getFieldPersistentValue(fieldName);

        if (value !== _undefined) {
          ObjectHelper.setPath(data, field.dataSource, value);
        }
      }
    });
    return data;
  }


  get persistableData() {
    const me = this,
      data = {};
    me.fields.forEach(field => {
      const value = me.getFieldPersistentValue(field.name);

      if (value !== _undefined) {
        ObjectHelper.setPath(data, field.dataSource, value);
      }
    });
    return data;
  }


  get isCommitting() {
    return Boolean(this.meta.committing);
  }


  clearChanges(removeFromStoreChanges = true, includeDescendants = true) {
    const me = this,
      {
        meta
      } = me;
    meta.modified = {};
    meta.committing = false;

    if (removeFromStoreChanges) {
      me.stores.forEach(store => {
        store.modified.remove(me);
        store.added.remove(me);

        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          store.modified.remove(descendants);
        }
      });
    }
  }


  get internalId() {
    return this._internalId;
  }


  get isPhantom() {
    return this.id === '' || this.id == null || this.hasGeneratedId;
  }

  get isModel() {
    return true;
  }


  get hasGeneratedId() {
    return this.id && typeof this.id === 'string' && this.id.startsWith('_generated');
  }


  generateId() {
    if (!this.constructor.generatedIdIndex) this.constructor.generatedIdIndex = 0;
    return '_generated' + this.$name + ++this.constructor.generatedIdIndex;
  }


  static asId(model) {
    return model && model.isModel ? model.id : model;
  }


  get json() {
    return JSON.stringify(this.data);
  }


  toJSON() {
    return this.data;
  }


  get isBatchUpdating() {
    return Boolean(this.batching);
  }


  beginBatch() {
    const me = this;

    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }

    me.batching++;
  }


  endBatch(silent = false) {
    const me = this,
      {
        parentIdField
      } = me.constructor;

    if (!me.batching) {
      return;
    }

    me.batching--;

    if (me.batching > 0) {
      return;
    }

    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      const batchChanges = Object.assign({}, me.meta.batchChanges);
      me.meta.batchChanges = null;

      if (batchChanges[parentIdField]) {
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }

      me.set(batchChanges, _undefined, silent);
      me.cancelBatch();
    }
  }


  cancelBatch() {
    this.batching = null;
    this.meta.batchChanges = null;
  }


  triggerBeforeUpdate(changes) {
    return !this.stores.some(s => {
      if (s.trigger('beforeUpdate', {
        record: this,
        changes
      }) === false) {
        return true;
      }
    });
  }


  copy(newId = null) {
    const me = this,
      data = Object.assign({}, me.data),
      idField = me.constructor.idField;
    let returnInstance = true,
      deep,
      id,
      copy;

    if (newId && typeof newId === 'object') {
      deep = newId.deep;
      id = newId.id;

      delete newId.id;
    } else {
      id = newId;
    }

    if (deep && me.children) {
      returnInstance = false;
      data.children = me.children.map(child => child.copy(newId));
    } else {
      delete data.children;
      delete data.expanded;
    }

    if (id) {
      data[idField] = id;
    } else if (id == null) {
      data[idField] = me.generateId(me.firstStore);
    }

    if (returnInstance) {
      copy = new me.constructor(data);
    } else {
      copy = data;
    }

    copy.originalInternalId = me.internalId;
    return copy;
  }


  remove(silent = false) {
    const me = this,
      {
        parent
      } = this;


    if (parent) {
      parent.removeChild(me);
    } else if (me.stores.length) {

      if (!me.meta.specialRow) {
        me.stores.forEach(s => s.remove(me, silent, false, true));
      }
    }
  }


  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }


  getRelationConfig(name) {

    return this.firstStore && this.firstStore.modelRelations && this.firstStore.modelRelations.find(r => r.fieldName === name);
  }


  get isValid() {
    return true;
  }


  joinStore(store) {
    const me = this,
      {
        stores,
        unjoinedStores
      } = me;

    if (!stores.includes(store)) {
      super.joinStore && super.joinStore(store);
      store.register(me);
      stores.push(store);

      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }

      me.isLoaded && me.children.forEach(child => child.joinStore(store));
      me.initRelations();

      if (store.tree && !me.isRoot) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }


  unJoinStore(store) {
    const me = this,
      {
        stores,
        unjoinedStores
      } = me;

    if (stores.includes(store)) {
      store.unregister(me);
      me.children && me.children.forEach(child => child.unJoinStore(store));
      stores.splice(stores.indexOf(store), 1);

      unjoinedStores.push(store);
      super.unJoinStore && super.unJoinStore(store);

      store.uncacheRelatedRecord(me);
    }

    if (!stores.length) {
      me.meta.removed = true;
    }
  }


  isPartOfStore(store) {
    if (store) {
      return store.indexOf(this) >= 0;
    }

    return this.stores.length > 0;
  }


  instanceMeta(instanceOrId) {
    const {
        meta
      } = this,
      id = instanceOrId.id || instanceOrId;
    if (!meta.map) meta.map = {};
    return meta.map[id] || (meta.map[id] = {});
  }

}

Model._idField = 'id';
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = 'Model';

const base = baseClass => ({
  mixes: (...mixins) => {
    return mixins.reduce((result, mixin) => mixin(result), baseClass || Base);
  }
});


class StoreBag extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }

    return super.add(...toAdd.filter(record => record.isPersistable));
  }

}

StoreBag._$name = 'StoreBag';


var StoreCRUD = (Target => class StoreCRUD extends (Target || Base) {

  static get defaultConfig() {
    return {

      autoCommit: false
    };
  }


  remove(records, silent = false, fromRemoveChild) {
    const me = this,
      {
        storage
      } = me;

    records = (Array.isArray(records) ? records : [records]).reduce((result, r) => {
      r = me.getById(r);

      if (r) {
        result.push(r);
      }

      return result;
    }, []);

    if (records.length) {
      if (me.tree) {

        const removeChildArgs = records.reduce((result, child) => {
          const parent = child.parent;

          if (parent) {
            if (!result[parent.id]) {
              result[parent.id] = [parent, []];
            }

            result[parent.id][1].push(child);
          }

          return result;
        }, {});

        for (const argBlock of Object.values(removeChildArgs)) {
          argBlock[0].removeChild(argBlock[1], false, silent);
        }

        return records;
      } else if (me.isGrouped) {
        const oldCount = storage.count,
          recordsInCollapsedGroups = [],
          changedGroupParents = new Set();


        for (const rec of records) {
          const {
            groupParent
          } = rec.instanceMeta(me);

          if (groupParent && groupParent.meta.collapsed) {
            recordsInCollapsedGroups.push(rec);
          }

          ArrayHelper.remove(groupParent.groupChildren, rec);
          groupParent.meta.childCount--;
          changedGroupParents.add(groupParent);
        }


        for (const groupParent of changedGroupParents) {
          me.onModelChange(groupParent, {}, {});
        }

        if (recordsInCollapsedGroups.length) {
          storage.trigger('change', {
            action: 'splice',
            removed: recordsInCollapsedGroups,
            added: [],
            replaced: [],
            oldCount
          });
        }
      }

      if (!records.length || !silent && me.trigger('beforeRemove', {
        records
      }) === false) {
        return null;
      }

      if (silent) {
        me.suspendEvents();
      }

      storage.remove(records);

      if (silent) {
        me.resumeEvents();
      }

      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }

    return records;
  }


  clear(removing = true) {
    const me = this,
      {
        storage
      } = me;

    if (me.storage.totalCount) {

      if (removing && me.trigger('beforeRemove', {
        records: storage.allValues,
        removingAll: true
      }) === false) {
        return null;
      }

      if (!removing) {


        const allRecords = me.registeredRecords;

        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];

          if (rec && !rec.isDestroyed) {
            rec.unJoinStore(me);
          }
        }

        me.removed.clear();
      }

      if (!removing) storage.suspendEvents();

      storage.clear();
      if (!removing) storage.resumeEvents();
      me.added.clear();
      me.modified.clear();
    }
  }


  removeAll(silent = false) {
    const me = this,
      storage = me.storage;

    if (silent) {
      storage.suspendEvents();


      const allRecords = me.registeredRecords;

      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];

        if (rec && !rec.isDestroyed) {
          rec.unJoinStore(me);
        }
      }
    }

    if (me.tree) {
      me.rootNode.clear();
    } else {
      me.clear();
    }

    if (silent) {
      storage.resumeEvents();
    }
  }


  add(records, silent = false) {
    const me = this,
      storage = me.storage,
      added = [];

    if (!Array.isArray(records)) {
      records = [records];
    } else if (!records.length) {

      return;
    }

    me.tree = me.tree || Boolean(me.autoTree && records[0].children);

    if (me.tree) {
      const
        parentIdMap = new Map(),
        added = [];
      records.forEach(node => {
        const parentId = node[me.modelClass.parentIdField];

        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, []);
        }

        parentIdMap.get(parentId).push(node);
      });
      parentIdMap.forEach((nodes, parentId) => {
        const parentNode = parentId == null ? me.rootNode : me.getById(parentId);

        if (!parentNode) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }

        added.push(...parentNode.appendChild(nodes, silent));
      });
      return added;
    }

    if (!silent) {
      if (me.trigger('beforeAdd', {
        records
      }) === false) {
        return null;
      }
    }

    me.tree = me.tree || Boolean(me.autoTree && records[0].children);

    if (me.tree) {
      return me.rootNode.appendChild(records);
    }

    records.forEach(data => {
      added.push(data instanceof Model ? data : me.createRecord(data));
    });

    if (silent) {
      me.suspendEvents();
    }

    storage.add(added);

    if (silent) {
      me.resumeEvents();
    }

    if (me.autoCommit) {
      me.doAutoCommit();
    }

    return added;
  }


  insert(index, records, silent = false) {
    const me = this,
      storage = me.storage,
      added = [],
      insertBefore = me.getAt(index),
      _records = storage.values,
      removeIndices = [];
    if (!Array.isArray(records)) records = [records];

    if (me.trigger('beforeAdd', {
      records
    }) === false) {
      return null;
    }

    let isNoop, start, i;


    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }

    if (isNoop) {
      return null;
    }

    records.forEach(data => {
      const record = data instanceof Model ? data : me.createRecord(data),
        removedAtIndex = storage.indexOf(record);

      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }

      added.push(record);

      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore) index--;
        removeIndices.push(removedAtIndex);
      }

      record.meta.previousIndex = removedAtIndex;
    });

    if (me.tree) {
      const root = me.rootNode;
      return root.insertChild(records, root.children && root.children[index]);
    }


    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();

    if (silent) {
      me.suspendEvents();
    }

    storage.splice(index, 0, ...added);

    if (silent) {
      me.resumeEvents();
    }

    if (me.autoCommit) {
      me.doAutoCommit();
    }

    return added;
  }


  move(item, beforeItem) {
    this.storage.move(item, beforeItem);
  }


  setMultiple(filterFn, field, value) {
    const me = this,
      records = [],
      changes = [];
    me.forEach(r => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });

    me.trigger('updateMultiple', {
      records,
      all: me.records.length === records.length
    });
    me.trigger('change', {
      action: 'updatemultiple',
      records,
      all: me.records.length === records.length
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
  }

  setAll(field, value) {
    const me = this,
      changes = [];
    me.forEach(r => {
      changes.push(r.set(field, value, true));
    });
    me.trigger('updateMultiple', {
      records: me.records,
      all: true
    });
    me.trigger('change', {
      action: 'updatemultiple',
      records: me.records,
      all: true
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
  }


  acceptChanges() {
    const me = this;

    me.added.forEach(r => r.clearChanges(false));
    me.modified.forEach(r => r.clearChanges(false));

    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }


  commit(silent = false) {

    const {
      changes
    } = this;
    return this.callPreventable('commit', {
      changes
    }, () => {
      this.acceptChanges();
      return changes;
    }, [], silent);
  }


  clearChanges() {
    const me = this;
    me.remove(me.added.values, true);
    me.modified.forEach(r => r.clearChanges(false));

    me.added.clear();
    me.modified.clear();
    me.removed.clear();
    me.trigger('change', {
      action: 'clearchanges'
    });
  }


  get changes() {
    const me = this;
    return me.added.count || me.modified.count || me.removed.count ? {

      added: me.added.values.slice(),
      modified: me.modified.values.slice(),
      removed: me.removed.values.slice()
    } : null;
  }


  get autoCommit() {
    return this._autoCommit;
  }

  set autoCommit(auto) {
    this._autoCommit = auto;

    if (auto && this.changes) {
      this.commit();
    }
  }

  doAutoCommit() {
    this.commit();
  }


  applyChangesFromStore(otherStore) {
    const me = this,
      changes = otherStore.changes;
    if (!changes) return;

    if (changes.added) {
      me.add(changes.added);
    }

    if (changes.removed) {

      me.remove(changes.removed.map(r => r.id));
    }

    if (changes.modified) {
      changes.modified.forEach(record => {
        const localRecord = me.getById(record.id);
        localRecord.set(record.modifications);
      });
    }
  }

});


var StoreFilter = (Target => class StoreFilter extends (Target || Base) {

  static get defaultConfig() {
    return {

      filters: null,


      reapplyFilterOnAdd: false,


      reapplyFilterOnUpdate: false
    };
  }


  set filters(filters) {
    const me = this,
      collection = me.filters;
    collection.clear();

    me._filtersFunction = null;

    if (filters) {
      if (filters.constructor.name === 'Object') {
        for (const f of Object.entries(filters)) {


          if (f[0] === 'filterBy' && typeof f[1] === 'function') {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === 'Object' ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {

        collection.add(...filters.map(filterConfig => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }

          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {

        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }

      collection.forEach(item => item.owner = me);
    }
  }

  get filters() {
    return this._filters || (this._filters = new Collection({
      extraKeys: ['property']
    }));
  }

  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }

  get filtersFunction() {
    const me = this,
      {
        filters,
        isGrouped
      } = me;

    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);

        me._filtersFunction = candidate => {

          if (isGrouped && candidate.meta.specialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          } else {
            return generatedFilterFunction(candidate);
          }
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }

    return me._filtersFunction;
  }


  get isFiltered() {
    return this.filters.values.some(filter => !filter.disabled);
  }

  traverseFilter(record) {
    const me = this,
      hitsCurrent = !record.isRoot && me.filtersFunction(record),
      children = record.unfilteredChildren || record.children;

    if (!children || !children.length) {
      return hitsCurrent;
    }

    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }

    record.children = record.unfilteredChildren.filter(r => {
      return me.traverseFilter(r);
    });
    return hitsCurrent || Boolean(record.children.length);
  }

  traverseClearFilter(record) {
    const me = this;

    if (record.unfilteredChildren) {
      record.children = record.unfilteredChildren.slice();
      record.unfilteredChildren = null;
    }

    if (record.children) {
      record.children.forEach(r => me.traverseClearFilter(r));
    }
  }


  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }

  processFieldFilter(filter, value) {
    if (typeof filter === 'string') {
      filter = {
        property: filter,
        value: value
      };
    }

    filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);

    filter.owner = this;

    this.filters.add(filter);
  }


  filter(newFilters) {
    const me = this,
      {
        filters
      } = me;
    let silent = false;

    if (newFilters) {
      let fieldType = typeof newFilters;

      if (fieldType === 'object') {
        if ('silent' in newFilters || 'replace' in newFilters) {
          silent = newFilters.silent;

          if (newFilters.replace) {
            filters.clear();
          }

          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }

      if (newFilters) {

        me.isConfiguring = true;


        if (Array.isArray(newFilters)) {
          newFilters.forEach(me.processFieldFilter, me);
        } else if (fieldType === 'function') {
          filters.add(new CollectionFilter(newFilters));
        } else if (fieldType === 'string') {
          me.processFieldFilter(newFilters, arguments[1]);
        } else {
          me.processFieldFilter(newFilters);
        }

        me.isConfiguring = false;

        if (!me.isFiltered) {
          return;
        }
      }
    }

    me.filtersFunction = null;

    me.performFilter(silent);
  }


  performFilter(silent) {
    const me = this,
      {
        storage,
        filters,
        rootNode
      } = me,
      oldCount = me.count;

    if (me.tree) {
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }

      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else {
      if (me.isFiltered) {
        storage.addFilter({
          id: 'primary-filter',
          filterBy: me.filtersFunction
        });
      } else {
        storage.filters.clear();
      }
    }

    me.afterPerformFilter(silent ? null : {
      action: 'filter',
      filters,
      oldCount,
      records: me.storage.values
    });
  }

  afterPerformFilter(event) {
    this.resetRelationCache();

    if (event) {
      this.triggerFilterEvent(event);
    }
  }

  get filtered() {
    return this.storage.isFiltered;
  }

  triggerFilterEvent(event) {
    this.trigger('filter', event);


    if (!this.filterParamName) {
      this.trigger('refresh', event);
      this.trigger('change', event);
    }
  }


  filterBy(fn) {
    this.filter(fn);
  }


  removeFilter(idOrInstance, silent) {
    const me = this,
      filter = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);

    if (filter) {
      me.filters.remove(filter);

      me._filtersFunction = null;

      if (!silent) {
        me.filter();
      }
    }
  }


  clearFilters() {
    this.filters.clear();
    this.filter();
  }

  convertFilterToString(field) {
    const filter = this.filters.getBy('property', field);
    return filter && !filter.filterBy ? String(filter) : '';
  }

  get filterState() {
    return this.filters.values.map(filter => ObjectHelper.cleanupProperties(filter.config));
  }

});


const resortActions = {
  add: 1,
  replace: 1
};


var StoreGroup = (Target => class StoreGroup extends (Target || Base) {

  static get defaultConfig() {
    return {

      groupers: null
    };
  }


  construct(config) {
    super.construct(config);


    this.on('change', this.onDataChanged);
  }


  get groupers() {
    return this._groupers;
  }

  set groupers(groupers) {
    const me = this;

    if (groupers && groupers.length) {
      me._groupers = groupers;
    } else if (me.groupers) {
      delete me._groupers;
      me.groupRecords.forEach(r => {
        if (r.meta.collapsed) {
          me.includeGroupRecords(r);
        }
      });
      me.storage.replaceValues({
        values: me.removeHeadersAndFooters(me.storage._values),
        filteredValues: me.storage.isFiltered ? me.removeHeadersAndFooters(me.storage._filteredValues) : null,
        silent: true
      });
      me.group(null, null, null, false);

      if ('groupRecords' in me) {
        delete me.groupRecords;
      }
    }
  }

  storeCollapsedGroups() {
    const me = this;
    me.collapsedGroupsHash = {};

    if (me.groupRecords && me.groupRecords.length) {
      me.groupRecords.forEach(rec => {
        if (me.expand(rec)) {
          me.collapsedGroupsHash[rec.id] = true;
        }
      });
      return true;
    }

    return false;
  }

  restoreCollapsedGroups() {
    const me = this;
    Object.keys(me.collapsedGroupsHash).forEach(id => me.collapse(me.getById(id)));
  }

  onDataChange({
                 source: storage,
                 action,
                 removed
               }) {
    const me = this,
      {
        groupers
      } = me;


    if (groupers) {
      const records = storage.values;


      if (groupers.length) {
        if (action === 'splice' && removed && removed.length) {

          if (me.storeCollapsedGroups()) {
            me.storage.replaceValues({
              values: me.removeHeadersAndFooters(records),
              silent: true
            });
          }

          me.storage.replaceValues({
            values: me.prepareGroupRecords(records),
            silent: true
          });

          me.restoreCollapsedGroups();
        }
      } else {
        storage.replaceValues({
          values: me.removeHeadersAndFooters(records),
          silent: true
        });
      }
    }

    super.onDataChange && super.onDataChange(...arguments);
  }


  collapse(groupRecord) {
    if (groupRecord && !groupRecord.meta.collapsed) {
      this.excludeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = true;
      return true;
    }

    return false;
  }


  expand(groupRecord) {
    if (groupRecord && groupRecord.meta.collapsed) {
      this.includeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = false;
      return true;
    }

    return false;
  }

  removeHeadersAndFooters(records) {
    const me = this;
    return records.filter(r => {
      if (r.meta.specialRow) {
        me.unregister(r);
        return false;
      } else {
        return true;
      }
    }, true);
  }

  prepareGroupRecords(records) {
    const me = this;
    records = me.removeHeadersAndFooters(records);

    if (!me.isGrouped) {
      return records;
    }

    const groupedRecords = [],
      field = me.groupers[0].field,
      groupRecords = [];
    let curGroup = null,
      curGroupRecord = null,
      childCount = 0;

    function addFooter() {
      const val = curGroupRecord.meta.groupRowFor,
        id = `group-footer-${typeof val === 'number' ? val : StringHelper.createId(val)}`,
        footer = me.getById(id) || new me.modelClass({
          id
        }, me, {
          specialRow: true,
          groupFooterFor: val,
          groupRecord: curGroupRecord
        });
      me.register(footer);
      footer.groupChildren = curGroupRecord.groupChildren;
      groupRecords.push(footer);
      groupedRecords.push(footer);
      me.allRecords.push(footer);
      curGroupRecord.groupChildren.push(footer);
      childCount++;
      return footer;
    }

    records.forEach(record => {
      const val = record[field] == undefined ? '__novalue__' : record[field],
        id = `group-header-${typeof val === 'number' ? val : StringHelper.createId(val)}`;


      if (record.groupChildren && !record.groupChildren.length) {
        me.unregister(record);
        return;
      }

      if (!ObjectHelper.isEqual(val, curGroup)) {
        if (curGroupRecord) {

          if (me.useGroupFooters) {
            addFooter();
          }

          curGroupRecord.meta.childCount = childCount;
        }

        curGroupRecord = me.getById(id) || new me.modelClass({
          id
        }, me, {
          specialRow: true,
          groupRowFor: val,
          groupField: field
        });
        me.register(curGroupRecord);
        curGroupRecord.groupChildren = [];
        groupedRecords.push(curGroupRecord);
        me.allRecords.push(curGroupRecord);
        groupRecords.push(curGroupRecord);
        curGroup = val;
        childCount = 0;
      }

      record.instanceMeta(me.id).groupParent = curGroupRecord;
      groupedRecords.push(record);
      curGroupRecord.groupChildren.push(record);
      childCount++;
    });

    if (curGroupRecord) {
      curGroupRecord.meta.childCount = childCount;

      if (me.useGroupFooters) {
        addFooter();
      }
    }

    me.groupRecords = groupRecords;
    return groupedRecords;
  }


  get isGrouped() {
    return Boolean(this.groupers && this.groupers.length);
  }


  group(field, ascending, add = false, performSort = true, silent = false) {
    const me = this;
    let newGrouper;

    if (add) {
      me.groupers.push(newGrouper = {
        field: field,
        ascending: ascending,
        complexMapping: field.includes('.')
      });
    } else if (field) {
      if (ascending == undefined) {
        ascending = me.groupInfo && me.groupInfo.field === field ? !me.groupInfo.ascending : true;
      }

      me.groupInfo = newGrouper = {
        field: field,
        ascending: ascending,
        complexMapping: field.includes('.')
      };
      me.groupers = [me.groupInfo];
    }

    if (newGrouper) {
      const {
        prototype
      } = me.modelClass;

      if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype, field)) {
        Object.defineProperty(prototype, field, {
          get() {
            return ObjectHelper.getPath(this, field);
          }

        });
      }
    }

    if (performSort !== false) {
      me.sort(null, null, false, true);
    }

    if (!silent) {

      me.trigger('group', {
        isGrouped: me.isGrouped,
        groupers: me.groupers,
        records: me.storage.values
      });
      me.trigger('refresh', {
        action: 'group',
        isGrouped: me.isGrouped,
        groupers: me.groupers,
        records: me.storage.values
      });
    }
  }


  addGrouper(field, ascending = true) {
    this.group(field, ascending, true);
  }


  removeGrouper(field) {
    const me = this,
      index = me.groupers.findIndex(grouper => grouper.field === field);

    if (index > -1) {
      me.groupers.splice(index, 1);
      me.group();
    }
  }


  clearGroupers() {
    this.groupers = null;
  }


  isRecordInGroup(record, groupValue) {
    if (!this.isGrouped) return null;
    const me = this,
      groupField = me.groupers[0] && me.groupers[0].field;
    return record[groupField] === groupValue && !record.meta.specialRow;
  }

  isInCollapsedGroup(record) {
    const parentGroupRec = record.instanceMeta(this).groupParent;
    return parentGroupRec && parentGroupRec.meta.collapsed;
  }


  getGroupRecords(groupValue) {
    const me = this;
    if (!me.isGrouped) return null;
    return me.storage.values.filter(record => me.isRecordInGroup(record, groupValue));
  }


  getGroupTitles() {
    const me = this;
    if (!me.isGrouped) return null;
    return me.getDistinctValues(me.groupers[0] && me.groupers[0].field);
  }

  onDataChanged(event) {
    if (this.isGrouped && (
      !event.changes && resortActions[event.action] ||
      event.changes && this.groupers.some(grouper => grouper.field in event.changes))) {

      this.sort();
    }
  }


  internalIncludeExcludeGroupRecords(groupRecord, include) {
    const me = this,
      index = me.indexOf(groupRecord),
      mapId = me.id;

    if (index === -1) {
      return;
    }

    if (groupRecord.meta.collapsed && !include || !groupRecord.meta.collapsed && include) {
      return;
    }

    groupRecord.groupChildren.forEach(child => child.instanceMeta(mapId).hiddenByCollapse = !include);

    if (include) {

      const groupChildren = groupRecord.groupChildren.filter(r => !me.isAvailable(r));
      me.storage.values.splice(index + 1, 0, ...groupChildren);
    } else {
      me.storage.values.splice(index + 1, groupRecord.groupChildren.length);
    }

    me.storage._indicesInvalid = true;
    me._idMap = null;
  }


  excludeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, false);
  }


  includeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, true);
  }


  collectGroupRecords() {
    return this.records.reduce((records, record) => {
      if (record.meta.specialRow) {
        records.push(record);

        if ('groupRowFor' in record.meta) {
          records.push.apply(records, record.groupChildren);
        }
      }

      return records;
    }, []);
  }

});


var StoreRelation = (Target => class StoreRelation extends (Target || Base) {


  initRelations(reset) {
    const me = this,
      relations = me.modelClass.relations;

    if (reset && me.modelRelations) {

      me.modelRelations.forEach(relation => {
        if (relation.storeDetacher) relation.storeDetacher();
      });
    }

    if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
      me.modelRelations = [];

      relations && relations.forEach(modelRelationConfig => {
        const config = Object.assign({}, modelRelationConfig),
          relatedStore = typeof config.store === 'string' ? me[config.store] : config.store;
        config.dependentStore = me;
        me.modelRelations.push(config);

        if (relatedStore) {
          config.storeProperty = config.store;
          config.store = relatedStore;

          const dependentStoreConfigs = relatedStore.dependentStoreConfigs;

          if (dependentStoreConfigs.has(me)) {
            dependentStoreConfigs.get(me).push(config);
          } else {
            dependentStoreConfigs.set(me, [config]);
          }

          if (config.collectionName) {
            relatedStore.initRelationCollection(config, me);
          }

          if (relatedStore.count > 0) {
            relatedStore.updateDependentStores('dataset', relatedStore.records);
          }
        }
      });
    }
  }


  initRelationCollection(config, collectionStore) {

    const me = this,
      name = config.collectionName;

    if (!me.collectionStores) {
      me.collectionStores = {};
    }

    me.collectionStores[name] = {
      store: collectionStore,
      config: config
    };

    if (!me[name + 'Store']) {
      me[name + 'Store'] = collectionStore;
    }

    if (me.count > 0) {
      me.initModelRelationCollection(name, me.records);
    }
  }

  initModelRelationCollection(name, records) {
    const me = this;

    records.forEach(record => {

      record.traverse(node => {
        !(name in node) && Object.defineProperty(node, name, {
          enumerable: true,
          get: function () {
            return me.getCollection(this, name);
          },
          set: function (value) {
            return me.setCollection(this, name, value);
          }
        });
      });
    });
  }


  resetRelationCache() {
    this.relationCache = {};
    this.forEach(record => record.initRelations());
  }


  updateRecordRelationCache(record, relations) {
    const me = this;
    relations && relations.forEach(relation => {

      const foreignId = relation.related ? relation.related.id : record.get(relation.config.fieldName);

      foreignId !== undefined && me.cacheRelatedRecord(record, foreignId, relation.config.relationName, foreignId);
    });
  }


  getCollection(model, name) {
    const {
      config,
      store
    } = this.collectionStores[name];
    return store.relationCache[config.relationName] && store.relationCache[config.relationName][model.id] || [];
  }


  setCollection(model, name, records) {
    const {
      config,
      store
    } = this.collectionStores[name];
    if (!store.relationCache[config.relationName]) store.relationCache[config.relationName] = {};
    const old = (store.relationCache[config.relationName][model.id] || []).slice(),
      added = [],
      removed = [];
    store.suspendEvents();

    old.forEach(record => {
      if (!records.includes(record)) {
        record[config.fieldName] = null;
        store.remove(record);
        removed.push(record);
      }
    });

    records.forEach(record => {
      if (record instanceof Model) {
        if (!record.stores.includes(store)) {
          store.add(record);
          added.push(record);
        }
      } else {
        [record] = store.add(record);
        added.push(record);
      }

      record[config.fieldName] = model.id;
    });
    store.resumeEvents();

    if (removed.length) {
      store.trigger('remove', {
        records: removed
      });
      store.trigger('change', {
        action: 'remove',
        records: removed
      });
    }

    if (added.length) {
      store.trigger('add', {
        records: added
      });
      store.trigger('change', {
        action: 'add',
        records: added
      });
    }
  }


  cacheRelatedRecord(record, id, name, uncacheId = null) {
    const me = this,
      cache = me.relationCache[name] || (me.relationCache[name] = {});

    if (uncacheId !== null) {
      me.uncacheRelatedRecord(record, name, uncacheId);
    }

    if (id != null) {

      ArrayHelper.include(cache[id] || (cache[id] = []), record);
    }
  }


  uncacheRelatedRecord(record, name = null, id = null) {
    const me = this;

    function remove(relationName, relatedId) {
      const cache = me.relationCache[relationName],
        oldCache = cache && cache[relatedId];


      if (oldCache) {
        const uncacheIndex = oldCache.indexOf(record);
        uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);

        if (oldCache.length === 0) {
          delete cache[relatedId];
        }
      }
    }

    if (id != null) {
      remove(name, id);
    } else {
      if (record.meta.relationCache) {
        Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) => {
          const relatedId = relatedRecord && relatedRecord.id;
          remove(relationName, relatedId);
        });
      }
    }
  }


  updateDependentStores(action, records) {
    this.dependentStoreConfigs.forEach(configs => {
      configs.forEach(config => {
        const dependentStore = config.dependentStore,
          cache = dependentStore.relationCache[config.relationName];

        if (action === 'dataset') {
          config.collectionName && this.initModelRelationCollection(config.collectionName, records);
          dependentStore.forEach(record => {
            const foreign = record.initRelation(config);
            foreign && dependentStore.cacheRelatedRecord(record, foreign.id, config.relationName, foreign.id);
          });
          return;
        }

        if (action === 'removeall') {
          dependentStore.forEach(record => {
            record.removeRelation(config);
          });
          delete dependentStore.relationCache[config.relationName];
          return;
        }

        if (action === 'add') {
          config.collectionName && this.initModelRelationCollection(config.collectionName, records);
        }

        if (action === 'add' || action === 'remove') {
          records.forEach(record => {
            const dependentRecords = cache && cache[record.id];

            switch (action) {
              case 'remove':

                if (dependentRecords) {
                  dependentRecords.forEach(dependentRecord => dependentRecord.removeRelation(config));

                }

                break;

              case 'add':


                dependentStore.forEach(dependentRecord => {
                  if (dependentRecord.get(config.fieldName) == record.id) {
                    dependentRecord.initRelation(config);
                    dependentStore.cacheRelatedRecord(dependentRecord, record.id, config.relationName);
                  }
                });
                break;
            }
          });
        }
      });
    });
  }


  updateDependentRecordIds(oldValue, value) {
    this.dependentStoreConfigs && this.dependentStoreConfigs.forEach(configs => {
      configs.forEach(config => {
        const dependentStore = config.dependentStore,
          cache = dependentStore.relationCache[config.relationName],
          localRecords = cache && cache[oldValue] && cache[oldValue].slice();
        localRecords && localRecords.forEach(localRecord => {
          localRecord.set(config.fieldName, value, false, true);
          dependentStore.cacheRelatedRecord(localRecord, value, config.relationName, oldValue);
        });
      });
    });
  }

});


var StoreSum = (Target => class StoreSum extends (Target || Base) {

  sum(field, records = this.storage.values) {
    if (!records) return 0;
    return records.reduce((sum, record) => {
      if (record.meta.specialRow) return sum;
      const v = Number(record[field]);
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }


  min(field, records = this.storage.values) {
    if (!records || !records.length) return 0;
    return records.reduce((min, record) => {
      if (typeof record[field] === 'number' && record[field] < min) min = record[field];
      return min;
    }, records[0][field]);
  }


  max(field, records = this.storage.values) {
    if (!records || !records.length) return 0;
    return records.reduce((max, record) => {
      if (typeof record[field] === 'number' && record[field] > max) max = record[field];
      return max;
    }, records[0][field]);
  }


  average(field, records = this.storage.values) {
    if (!records || !records.length) return 0;
    let count = 0;
    const sum = records.reduce((sum, record) => {
      if (record.meta.specialRow) return sum;
      const v = parseFloat(record[field]);

      if (!isNaN(v)) {
        count++;
        return sum + v;
      } else {
        return sum;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }


  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }

});


const stringFound = (value, find) => String(value).toLowerCase().indexOf(find) !== -1,
  comparisons = {
    string: stringFound,
    number: stringFound,
    boolean: stringFound,
    date: (value, find) => {
      if (value instanceof Date && find instanceof Date) {
        return String(value) === String(find);
      }

      return String(value.getMonth() + 1).indexOf(find) !== -1 || String(value.getDate()).indexOf(find) !== -1 || String(value.getFullYear()).indexOf(find) !== -1;
    }
  };


var StoreSearch = (Target => class StoreSearch extends (Target || Base) {


  search(find, fields = null) {
    const records = this.storage.values,
      len = records.length,
      found = [];

    if (find == null) {
      return null;
    }

    if (typeof find === 'string') {
      find = String(find).toLowerCase();
    }

    let i, record, value, valueType, comparison;

    for (i = 0; i < len; i++) {
      record = records[i];

      for (const key of fields || record.fieldNames) {
        value = record[key];
        valueType = value instanceof Date ? 'date' : typeof value;
        comparison = comparisons[valueType];

        if (value && comparison && comparison(value, find)) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
      }
    }

    return found;
  }


  findByField(field, value) {
    let records = this.storage.values,
      i,
      len = records.length,
      record,
      found = [],
      fieldValue;

    if (value !== null && value !== undefined) {
      value = String(value).toLowerCase();
    }

    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record[field];
      const type = fieldValue instanceof Date ? 'date' : typeof fieldValue,
        comparison = {
          date: () => Boolean(fieldValue) && fieldValue.toLocaleString().includes(value),
          string: () => Boolean(fieldValue) && fieldValue.toLowerCase().includes(value),
          number: () => typeof fieldValue === 'number' && fieldValue.toString().includes(value),
          object: () => fieldValue === value,

          undefined: () => fieldValue === value
        };

      if ((value === null || value === undefined) && fieldValue === value || value && comparison[type]()) {
        found.push({
          id: record.id,
          index: i,
          data: record
        });
      }
    }

    return found;
  }


  find(fn) {
    return this.storage.values.find(fn);
  }


  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = r => ObjectHelper.isEqual(r[fieldName], value);

    if (this.tree) {
      return this.query(matchFn)[0];
    }

    return (searchAllRecords ? this.storage.allValues : this.storage.values).find(matchFn);
  }


  query(fn, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse(node => {
        if (fn(node)) {
          matches.push(node);
        }
      });
      return matches;
    }

    return (searchAllRecords ? this.storage.allValues : this.storage.values).filter(fn);
  }


  some(fn) {
    return this.storage.values.some(fn);
  }

});


var StoreSort = (Target => class StoreSort extends (Target || Base) {

  static get defaultConfig() {
    return {

      sorters: [],


      useLocaleSort: null
    };
  }


  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }


  sort(field, ascending, add = false, silent = false) {
    const me = this,
      records = me.allRecords,
      currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null,
      curSort;

    if (field) {
      if (Array.isArray(field)) {

        me.sorters = field.map(sorter => me.normalizeSorterConfig(sorter, typeof sorter === 'string' ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending);

        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);

          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }

    if (!silent && me.trigger('beforeSort', {
      sorters: me.sorters,
      records,
      currentSorters
    }) === false) {

      me.sorters = currentSorters;

      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }

      return;
    }

    return me.performSort(silent);
  }

  normalizeSorterConfig(field, ascending) {
    const me = this,
      sorter = {
        ascending
      };

    if (typeof field === 'object') {
      sorter.field = field.field;
      sorter.sortFn = field.fn || field.sortFn;
      sorter.useLocaleSort = field.useLocaleSort;
      sorter.ascending = field.ascending != null ? field.ascending : ascending;
    } else if (typeof field === 'function') {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }

    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }

    return sorter;
  }

  getCurrentSorterByField(field) {
    return typeof field === 'string' && this.sorters.find(s => s.field === field) || null;
  }


  addSorter(field, ascending = true) {
    this.sort(field, ascending, true);
  }


  removeSorter(field) {
    let me = this,
      sorterIndex = me.sorters.findIndex(sorter => sorter.field == field);

    if (sorterIndex > -1) {
      me.sorters.splice(sorterIndex, 1);
      me.sort();
    }
  }


  clearSorters() {
    const me = this;
    me.sorters.length = 0;
    me.sort();
  }


  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {


      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i],
          {
            field,
            ascending = true,
            useLocaleSort = storeLocaleSort
          } = sorter,
          fn = sorter.fn || sorter.sortFn,
          direction = ascending ? 1 : -1;

        if (fn) {
          const val = fn(lhs, rhs);

          if (val !== null) {
            return val * direction;
          }
        }

        const lhsValue = lhs[field],
          rhsValue = rhs[field];

        if (lhsValue == null) {
          return -direction;
        }

        if (rhsValue == null) {
          return direction;
        }

        if (useLocaleSort) {

          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }

          if (typeof useLocaleSort === 'string') {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }

          if (typeof useLocaleSort === 'object') {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }

        if (lhsValue > rhsValue) {
          return direction;
        }

        if (lhsValue < rhsValue) {
          return -direction;
        }
      }

      return 0;
    };
  }


  performSort(silent) {
    const me = this,
      {
        rootNode,
        storage,
        sorters
      } = me,
      sorter = me.createSorterFn(me.isGrouped ? me.groupers.concat(sorters) : sorters);

    if (me.isGrouped) {

      if (me.storeCollapsedGroups()) {
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage.values),
          silent: true
        });
      }
    }

    if (me.tree) {
      rootNode.traverse(node => {
        if (node.isLoaded && node.isParent) {
          node.children = node.children.sort(sorter);

          node.updateChildrenIndex(node.children);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }

    me.afterPerformSort(silent);
  }

  afterPerformSort(silent) {
    const me = this,
      {
        storage
      } = me;
    me._idMap = null;

    if (me.isGrouped) {
      storage.replaceValues({
        values: me.prepareGroupRecords(storage.values),
        silent: true
      });

      me.restoreCollapsedGroups();
    }

    if (!silent) {
      const event = {
        action: 'sort',
        sorters: me.sorters,
        records: me.allRecords
      };
      me.trigger('sort', event);


      if (!me.sortParamName) {
        me.trigger('refresh', event);
      }
    }
  }

});


const returnTrue = () => true;


var StoreChained = (Target => class StoreChained extends (Target || Base) {

  static get defaultConfig() {
    return {

      chainedFilterFn: null,


      chainedFields: null,


      masterStore: null,


      doRelayToMaster: ['add', 'remove', 'insert'],


      dontRelayToMaster: [],


      keepUncommittedChanges: false,


      excludeCollapsedRecords: true
    };
  }

  construct(config) {
    const me = this;
    super.construct(config);

    if (me.masterStore) {
      me.methodNamesToRelay.forEach(fnName => me[fnName] = (...params) => me.relayToMaster(fnName, params));

      me.removeAll = (...params) => {
        me.masterStore.remove(me.getRange(), ...params);
      };

      me.masterStore.on({
        change: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });

      if (!me.masterStore.chainedStores) {
        me.masterStore.chainedStores = [];
      }

      me.masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }


  get isChained() {
    return Boolean(this.masterStore);
  }

  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }

  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }

  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster),
      dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter(name => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }


  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach(store => store.fillFromMaster());
    }
  }


  fillFromMaster() {
    const me = this,
      {
        masterStore,
        isTree
      } = me;

    if (!me.isChained) {
      throw new Error('fillFromMaster only allowed on chained store');
    }

    if (me.keepUncommittedChanges) {
      if (isTree) {
        throw new Error('Cannot use keepUncommittedChanges on a chained tree store');
      }

      me.data = [].concat(me.added.values.filter(r => !me.removed.includes(r)), masterStore.allRecords.filter(r => !me.removed.includes(r) && !me.added.includes(r) && me.chainedFilterFn(r)));
    } else {
      let records = masterStore.allRecords.filter(me.chainedFilterFn);

      if (isTree) {

        me.idRegister = {};
        me.internalIdRegister = {};


        records.forEach(r => {
          if (r.stores.includes(me)) {
            me.register(r);
          } else {
            r.joinStore(me);
          }
        });


        if (me.excludeCollapsedRecords) {
          const children = me.getChildren(me.rootNode);
          records = me.doIncludeExclude(children, true);
        }
      }

      me.data = records;
    }
  }


  commitToMaster() {
    const me = this,
      master = me.masterStore;

    if (!me.isChained) {
      throw new Error('commitToMaster only allowed on chained store');
    }

    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }


  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }


  onMasterDataChanged({
                        action,
                        changes
                      }) {
    const me = this;

    if (action === 'update') {


      const refilter = me.chainedFields && me.chainedFields.some(field => field in changes);
      if (!refilter) return;
    }

    me.fillFromMaster();
  }

});


var StoreState = (Target => class StoreState extends (Target || Base) {

  getState() {
    const me = this,
      state = {};
    if (me.sorters && me.sorters.length) state.sorters = me.sorters.slice();
    if (me.groupers && me.groupers.length) state.groupers = me.groupers.slice();
    if (me.filters && me.filters.values.length) state.filters = me.filterState;
    return state;
  }


  applyState(state) {
    const me = this;
    if ('sorters' in state) me.sorters = state.sorters.slice();
    if ('groupers' in state) me.groupers = state.groupers.slice();
    if ('sorters' in state || 'groupers' in state) me.sort();

    if ('filters' in state) {
      me.filters = state.filters.slice();
      me.filter();
    }
  }

});


const emptyArray$2 = Object.freeze([]);


var StoreTree = (Target => class StoreTree extends (Target || Base) {


  get isTree() {
    return this.tree || this.masterStore && this.masterStore.tree;
  }


  get leaves() {
    const me = this,
      result = [];

    if (me.isTree) {
      me.traverse(record => {
        if (record.isLeaf) {
          result.push(record);
        }
      });
      return result;
    } else {
      me.allRecords.forEach(r => {
        if (r.isLeaf) {
          result.push(r);
        }

        r.traverse(record => {
          if (record.isLeaf) {
            result.push(record);
          }
        }, true);
      });
    }

    return result;
  }


  async loadChildren(parentRecord) {
  }


  onNodeAddChild(parent, children, index, isMove, silent = false) {
    const me = this,
      isRootLoad = parent === me.rootNode && parent.isLoading,
      {
        storage
      } = me,
      toAddToUI = [],
      toAdd = [],
      previousSibling = children[0].previousSibling;
    let storeInsertionPoint;
    me.collectDescendants(children, toAddToUI, toAdd, {
      inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me))
    });

    if (!isRootLoad && toAdd.length) {
      for (const record of toAdd) {

        if (!me.modified.includes(record) && !isMove[record.id]) {
          me.added.add(record);
          me.removed.remove(record);
        }
      }
    }

    if (isRootLoad && me.rootVisible) {
      toAddToUI.unshift(parent);
      toAdd.unshift(parent);
    }

    if (toAddToUI.length) {


      if (index === 0 || !previousSibling) {
        storeInsertionPoint = storage.indexOf(parent);
      } else {
        storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
      }


      storage.suspendEvents();
      me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
      storage.resumeEvents();
    }


    me.updateDependentStores('add', children);

    if (isRootLoad && toAddToUI.length) {


      if (me.sorters.length) {
        me.sort(null, null, false, true);
      }

      if (!silent) {
        const event = {
          action: 'dataset',
          data: me._data,
          records: toAddToUI
        };
        me.trigger('refresh', event);
        me.trigger('change', event);
      }
    } else if (!silent) {
      const event = {
        action: 'add',
        parent,
        isChild: true,
        isMove,
        records: children,
        allRecords: toAdd,
        index: storeInsertionPoint
      };
      me.trigger('add', event);
      me.trigger('change', event);
    }
  }

  onNodeRemoveChild(parent, children, index, flags = {
    isMove: false,
    silent: false,
    unfiltered: false
  }) {
    const me = this,
      {
        storage
      } = me,
      toRemoveFromUI = [],
      toRemove = [],
      {
        isMove,
        silent,
        unfiltered
      } = flags,
      removeUnfiltered = unfiltered && me.isFiltered,
      childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
    me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, {
      inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
      unfiltered: removeUnfiltered
    });


    if (!isMove) {

      for (let record of children) {
        record.unJoinStore(me);
      }

      if (toRemove.length) {
        for (let record of toRemove) {
          if (record.stores.includes(me)) {
            record.unJoinStore(me);
          }

          if (me.added.includes(record)) {
            me.added.remove(record);
          } else {
            me.removed.add(record);
          }
        }

        me.modified.remove(toRemove);
      }
    }

    if (toRemoveFromUI.length) {
      index = storage.indexOf(toRemoveFromUI[0]);

      if (index > -1) {
        storage.suspendEvents();
        storage.splice(index, toRemoveFromUI.length);
        storage.resumeEvents();
      }
    } else {

      index = -1;
    }

    if (!silent) {
      const event = {
        action: 'remove',
        parent,
        isChild: true,
        isMove,
        records: children,
        allRecords: toRemove,
        index
      };
      me.trigger('remove', event);
      me.trigger('change', event);
    }
  }

  collectDescendants(node, visible = [], all = [], flags = {
    inCollapsedBranch: false,
    unfiltered: false
  }) {
    const me = this,
      {
        inCollapsedBranch,
        unfiltered
      } = flags,
      children = Array.isArray(node) ? node : me.getChildren(node, unfiltered);

    if (children) {
      for (let i = 0, len = children.length, child; i < len; i++) {
        child = children[i];

        if (!inCollapsedBranch) {
          visible.push(child);
        }

        all.push(child);
        me.collectDescendants(child, visible, all, {
          inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
          unfiltered
        });
      }
    }

    return {
      visible,
      all
    };
  }


  getChildren(parent, unfiltered = false) {

    const children = (unfiltered || this.isChained) && parent.unfilteredChildren || parent.children;
    return children && children.length ? this.isChained ? children.filter(this.chainedFilterFn) : children : emptyArray$2;
  }


  internalToggleTreeSubRecords(parentRecord, include) {
    const me = this,
      {
        storage
      } = me,
      index = storage.indexOf(parentRecord),
      children = me.doIncludeExclude(me.getChildren(parentRecord), include);


    if (children.length && index !== false) {


      storage.suspendEvents();

      if (include) {
        storage.splice(index + 1, 0, ...children);
        const event = {
          action: 'add',
          isExpand: true,
          records: children,
          index: index + 1
        };
        me.trigger('add', event);
        me.trigger('change', event);
      } else {
        storage.splice(index + 1, children.length);
        const event = {
          action: 'remove',
          isCollapse: true,
          records: children,
          index: index + 1
        };
        me.trigger('remove', event);
        me.trigger('change', event);
      }

      storage.resumeEvents();
    }
  }

  doIncludeExclude(children, include, result = []) {
    const me = this,
      childCount = children && children.length;

    for (let i = 0; i < childCount; i++) {
      const child = children[i];


      if (!me.isChained || me.chainedFilterFn(child)) {
        const mapMeta = child.instanceMeta(me.id);

        if (include) {

          result.push(child);
        } else if (!mapMeta.hidden) {
          result.push(child);
        }

        mapMeta.hidden = !include;

        if (child.isExpanded(me)) {
          me.doIncludeExclude(me.getChildren(child), include, result);
        }
      }
    }

    return result;
  }


  async toggleCollapse(idOrRecord, collapse) {
    const me = this,
      record = me.getById(idOrRecord),
      meta = record.instanceMeta(me);

    if (collapse === undefined) {
      collapse = !meta.collapsed;
    }

    if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
      me.trigger('beforeToggleNode', {
        record,
        collapse
      });
      meta.collapsed = collapse;

      if (meta.collapsed) {
        me.onNodeCollapse(record);
        return true;
      } else {
        me.onNodeExpand(record);
        let success = true;


        if (!record.isLoaded) {
          meta.isLoadingChildren = true;

          try {
            await me.loadChildren(record);
          } catch (exception) {

            meta.collapsed = true;
            success = false;
            me.trigger('loadChildrenException', {
              record,
              exception
            });
          } finally {
            meta.isLoadingChildren = false;
          }
        }

        return success;
      }
    }
  }


  onNodeCollapse(parentRecord) {

    if (parentRecord.ancestorsExpanded(this)) {
      return this.internalToggleTreeSubRecords(parentRecord, false);
    }
  }


  onNodeExpand(parentRecord) {

    if (parentRecord.ancestorsExpanded(this)) {
      return this.internalToggleTreeSubRecords(parentRecord, true);
    }
  }

});


class WalkHelper {

  static preWalk(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;

    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);

      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }


  static preWalkWithParent(data, childrenFn, fn) {
    const walkStack = [{
      node: data,
      parent: null
    }];

    while (walkStack.length) {
      const {
        parent,
        node
      } = walkStack.pop();
      fn(parent, node);
      const children = childrenFn(node);

      if (children) {
        walkStack.push(...children.slice().reverse().map(child => ({
          node: child,
          parent: node
        })));
      }
    }
  }


  static preWalkUnordered(data, childrenFn, fn) {
    let walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      fn(node);
      children = childrenFn(node);

      if (children) {
        walkStack.splice(walkStack.length - 1, 1, ...children);
      } else {
        walkStack.length = walkStack.length - 1;
      }
    }
  }


  static postWalk(data, childrenFn, fn) {
    let visited = new Map(),
      walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];

      if (visited.has(node)) {
        fn(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);

        if (children) {
          walkStack = walkStack.concat(children.slice().reverse());
        }

        visited.set(node, node);
      }
    }
  }


  static prePostWalk(data, childrenFn, inFn, outFn) {
    let visited = new Map(),
      walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];

      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);

        if (children) {
          walkStack = walkStack.concat(children.slice().reverse());
        }

        visited.set(node, node);
      }
    }
  }

}

WalkHelper._$name = 'WalkHelper';


var StoreSync = (Target => class StoreSync extends (Target || Base) {
  static get defaultConfig() {
    return {

      syncDataOnLoad: null
    };
  }


  syncDataset(data) {
    const me = this,
      {
        storage
      } = me,
      {
        toAdd,
        toRemove,
        updated
      } = me.tree ? me.syncTreeDataset(data) : me.syncFlatDataset(data);
    let {
        threshold
      } = me.syncDataOnLoad,
      surpassed = false;

    if (threshold) {

      if (typeof threshold === 'string') {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }

      surpassed = toAdd.length + toRemove.length + updated.length > threshold;
    }

    if (me.tree) {


      if (toAdd.length) {

        const added = me.add(toAdd, surpassed);

        added.forEach(node => {
          delete node.data.parentId;
          delete node.originalData.parentId;
          node.meta.modified && delete node.meta.modified.parentId;
        });
      }

      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        storage.suspendEvents();
      }

      storage.splice(me.count - toRemove.length, toRemove, toAdd);

      if (surpassed) {
        storage.resumeEvents();
      }
    }


    if (threshold && !surpassed) {
      updated.forEach(({
                         record,
                         toSet,
                         wasSet
                       }) => me.onModelChange(record, toSet, wasSet));
    }

    me.acceptChanges();
    const event = {
      added: toAdd,
      removed: toRemove,
      updated,
      thresholdSurpassed: surpassed
    };

    if (surpassed) {
      this.trigger('refresh', {
        action: 'batch',
        data: data,
        records: storage.values,
        syncInfo: event
      });
    }

    if (me.isFiltered) {

      me.filter();
    }

    if (me.isGrouped) {

      me.group();
    } else if (me.isSorted) {

      me.sort();
    }

    me.trigger('loadSync', event);
  }

  syncFlatDataset(data) {
    if (!data) {
      return;
    }

    const me = this,
      idField = me.modelClass.idField,
      toRemove = [],
      toAdd = [],
      updated = [],
      usedIds = {};
    let {
        threshold
      } = me.syncDataOnLoad,
      hitCount = 0;
    data.forEach(rawData => {
      const id = rawData[idField],
        record = me.getById(id);

      if (record) {

        const wasSet = record.set(rawData, null, Boolean(threshold));

        if (wasSet) {
          updated.push({
            record,
            wasSet,
            toSet: rawData
          });
        }

        hitCount++;
      } else {
        toAdd.push(me.createRecord(rawData));
      }

      usedIds[id] = 1;
    });

    if (hitCount < me.allCount) {
      me.forEach(record => {
        if (!usedIds[record.id]) {
          toRemove.push(record);
        }
      });
    }

    return {
      toAdd,
      toRemove,
      updated
    };
  }

  syncTreeDataset(data) {
    if (!data) {
      return;
    }

    const me = this,
      {
        idField,
        parentIdField
      } = me.modelClass,
      toRemove = [],
      toAdd = [],
      updated = [],
      usedIds = {};
    let {
      threshold
    } = me.syncDataOnLoad;
    WalkHelper.preWalkWithParent({
      isRoot: true,
      children: data
    }, n => n.children, (parent, rawData) => {
      if (parent) {
        const id = rawData[idField],
          node = me.getById(id);

        if (node) {

          const wasSet = node.set(rawData, null, Boolean(threshold));

          if (wasSet) {
            updated.push({
              record: node,
              wasSet,
              toSet: rawData
            });
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push(rawData);
        }

        usedIds[id] = 1;
      }
    });
    me.traverse(node => {
      if (!usedIds[node.id]) {
        toRemove.push(node);
      }
    });
    return {
      toAdd,
      toRemove,
      updated
    };
  }

});


const STM_PROP$1 = Symbol('STM_PROP');


var StoreStm = (Target => class StoreStm extends (Target || Base) {
  static get defaultConfig() {
    return {

      stm: null
    };
  }

  get stm() {
    return this[STM_PROP$1];
  }

  set stm(stm) {
    const me = this;

    if (me.stm != stm) {
      if (me.stm && me.stm.hasStore(me)) {
        me.stm.removeStore(me);
      }

      me[STM_PROP$1] = stm;

      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }


  add(records, silent = false) {
    let result;
    const stm = this.stm;


    if (!this.tree && stm && !stm.disabled) {


      result = super.add(records, silent);


      if (result && result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent);
    }

    return result;
  }


  insert(index, records, silent = false) {
    let result;
    const stm = this.stm;


    if (!this.tree && stm && !stm.disabled) {


      const context = (Array.isArray(records) ? records : [records]).reduce((context, r) => {
        const index = r instanceof Model ? this.indexOf(r) : undefined;

        if (index !== undefined && index !== -1) {
          context.set(r, index);
        }

        return context;
      }, new Map());


      result = super.insert(index, records);


      if (result && result.length) {


        index = this.indexOf(result[0]);


        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }

    return result;
  }


  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const stm = this.stm;


    if (!this.tree && stm && !stm.disabled) {


      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map(r => this.getById(r)).filter(r => !!r);
      const context = recordsOrIdsNormalized.reduce((context, r) => {
        const index = this.indexOf(r);

        if (index !== undefined && index != -1) {
          context.set(r, index);
        }

        return context;
      }, new Map());

      result = super.remove(recordsOrIds, silent, fromRemoveChild);


      if (result && result.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }

    return result;
  }


  removeAll(silent) {
    const stm = this.stm;

    if (stm && !stm.disabled) {


      const {
          tree,
          rootNode,
          allRecords
        } = this,
        wasNotEmpty = allRecords.length,

        records = tree ? rootNode.children.slice() : allRecords.slice();
      super.removeAll(silent);


      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      super.removeAll(silent);
    }
  }

});


class Store extends base(Base).mixes(Events, Pluggable, State, StoreFilter, StoreCRUD, StoreRelation, StoreSum, StoreSearch, StoreSort, StoreGroup, StoreChained, StoreState, StoreTree, StoreStm, StoreSync) {

  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: new Map()
    };
  }

  static get defaultConfig() {
    return {

      storeId: null,


      id: true,


      fields: null,


      autoTree: true,


      modelClass: Model,


      data: null,


      tree: false,
      callOnFunctions: true,


      storage: null,


      useRawData: false,


      allowNoId: true,


      preventSubClassingModel: null
    };
  }


  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {}
    });
    super.construct(config);
    me.initRelations();
  }

  doDestroy() {
    const me = this,
      allRecords = me.registeredRecords;

    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      rec = allRecords[i];

      if (rec && !rec.isDestroyed) {
        rec.unJoinStore(me);
      }
    }

    me.storage.destroy();
    delete Store.storeMap[me.id];

    if (me.stm) {
      me.stm.removeStore(me);
    }

    super.doDestroy();
  }


  beginBatch() {
    this.suspendEvents();
  }


  endBatch() {
    if (this.resumeEvents()) {
      this.trigger('refresh', {
        action: 'batch',
        data: this.storage.values,
        records: this.storage.values
      });
    }
  }

  set storage(storage) {
    const me = this;

    if (storage && storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }

    me._storage.autoFilter = me.reapplyFilterOnAdd;

    for (const r of me._storage) {
      r.joinStore(me);
    }

    me._storage.on({
      change: 'onDataChange',
      thisObj: me
    });
  }

  get storage() {
    if (!this._storage) {
      this.storage = {};
    }

    return this._storage;
  }

  get allRecords() {
    const me = this;

    if (me.isTree) {
      const result = me.collectDescendants(me.rootNode, undefined, undefined, {
        unfiltered: true
      }).all;

      if (me.rootVisible) {
        result.unshift(me.rootNode);
      }

      return result;
    } else {
      return me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
    }
  }


  onDataChange({
                 source: storage,
                 action,
                 added,
                 removed,
                 replaced,
                 oldCount,
                 item,
                 from,
                 to
               }) {
    const me = this,
      addedCount = added && added.length,
      removedCount = removed && removed.length;
    let record, filtersWereReapplied;
    me._idMap = null;

    if (addedCount) {
      added.forEach(added => {
        added.joinStore(me);
      });
    }

    replaced && replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unJoinStore(me);
      newRecord.joinStore(me);
    });


    super.onDataChange(...arguments);


    if (!me.isTree) {
      if (addedCount) {
        for (record of added) {
          record.joinStore(me);
        }

        me.added.add(added);
        me.removed.remove(added);


        filtersWereReapplied = !me.filterParamName && me.filtered && me.reapplyFilterOnAdd;

        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }

      if (removedCount) {
        for (record of removed) {
          record.unJoinStore(me);

          if (me.added.includes(record)) {
            me.added.remove(record);
          } else {
            me.removed.add(record);
          }
        }

        me.modified.remove(removed);


        filtersWereReapplied = !me.filterParamName && me.filtered;

        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }

    switch (action) {
      case 'clear':

        me.relationCache = {};

        me.updateDependentStores('removeall');
        me.trigger('removeAll');
        me.trigger('change', {
          action: 'removeall'
        });
        break;

      case 'splice':
        if (addedCount) {
          me.updateDependentStores('add', added);
          const

            oldIndex = added.reduce((lowest, record) => {
              const {
                previousIndex
              } = record.meta;
              if (previousIndex > -1 && previousIndex < lowest) lowest = previousIndex;
              return lowest;
            }, added[0].meta.previousIndex),
            index = storage.indexOf(added[0], !storage.autoFilter),
            params = {
              records: added,
              index
            };

          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }

          me.trigger('add', params);
          me.trigger('change', Object.assign({
            action: 'add'
          }, params));

          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: 'filter',
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
        }

        if (removed.length) {
          me.updateDependentStores('remove', removed);
          me.trigger('remove', {
            records: removed
          });
          me.trigger('change', {
            action: 'remove',
            records: removed
          });
        }

        if (replaced.length) {


          me.trigger('replace', {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger('change', {
            action: 'replace',
            replaced,
            all: me.records.length === replaced.length
          });
        }

        break;

      case 'filter':

        if (me.isGrouped) {
          me.group(null, null, null, null, true);
        } else if (me.isSorted) {
          me.performSort(true);
        }

        break;

      case 'move':

        for (let allRecords = me.storage.allValues, i = Math.min(from, to); i <= Math.max(from, to); i++) {
          allRecords[i].parentIndex = i;
        }


        me.trigger('move', {
          record: item,
          from,
          to
        });
        me.trigger('change', {
          action,
          record: item,
          from,
          to
        });
    }
  }


  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this,
      idField = record.constructor.idField,
      event = {
        record,
        changes: wasSet,


        batch: record.batching != null,
        fromRelationUpdate
      };

    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record)) {


        if (record.isPartOfStore(me) && record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }

        if (me.autoCommit) {
          me.commit();
        }
      }
    } else {
      me.modified.remove(record);
    }

    if (!silent) {
      if (idField in wasSet) {
        const {
          oldValue,
          value
        } = toSet[idField];
        me.updateDependentRecordIds(oldValue, value);
        me.onRecordIdChange(record, oldValue, value);
        me.trigger('idChange', {
          store: me,
          record,
          oldValue,
          value
        });
      }

      me.onUpdateRecord(record, wasSet);
      me.trigger('update', event);
      me.trigger('change', Object.assign({
        action: 'update'
      }, event));
    }
  }

  get idMap() {
    const me = this,
      processedRecords = me.storage.values,
      needsRebuild = !me._idMap,
      idMap = me._idMap || (me._idMap = {});

    if (needsRebuild) {
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = {
          index,
          visibleIndex,
          record
        };

        if (!record.meta.specialRow) {
          visibleIndex++;
        }
      }
    }

    return idMap;
  }


  get modelClass() {
    return this._modelClass;
  }

  set modelClass(ClassDef) {
    const fields = this.fields;

    let ClassDefEx = null;

    if (fields && fields.length) {
      ClassDefEx = class extends ClassDef {
        static get fields() {
          return fields;
        }

      };
      ClassDefEx.exposeProperties();
    } else if (!this.preventSubClassingModel) {
      ClassDefEx = class extends ClassDef {
      };
    } else {
      ClassDefEx = ClassDef;
    }

    ClassDefEx.exposeRelations();
    this._modelClass = ClassDefEx;
  }


  set storeId(storeId) {
    this.id = storeId;
  }

  get storeId() {
    return this.id;
  }


  set id(id) {
    const me = this;

    if (me._id) {
      delete Store.storeMap[me._id];
    }

    me._id = id === true ? IdHelper.generateId('store-') : id;

    if (id) {
      Store.storeMap[id] = me;
    }
  }

  get id() {
    return this._id;
  }

  get tree() {
    return this._tree;
  }

  set tree(tree) {
    this._tree = tree;

    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
    }
  }

  buildRootNode() {
    return {};
  }


  static getStore(id, storeClass) {
    if (id instanceof Store) {
      return id;
    }

    if (this.storeMap[id]) {
      return this.storeMap[id];
    }

    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map(item => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === 'string') {
          item = {
            text: item
          };
        }

        return item;
      });
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel || class extends Model {
        },
        allowNoId: true

      };

      if (!storeClass) {
        storeClass = Store;
      }
    }

    if (storeClass) {
      return new storeClass(id);
    }
  }


  static get stores() {
    return Object.values(this.storeMap);
  }


  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }

  set rootNode(rootNode) {
    const me = this,
      oldRoot = me._rootNode;

    if (rootNode === oldRoot) {
      return;
    }

    if (oldRoot) {
      me.clear(false);
    }

    if (rootNode instanceof Model) {

      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
      rootNode.isAutoRoot = true;
    }

    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);


    if (rootNode.children && rootNode.children.length || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }

    me.trigger('rootChange', {
      oldRoot,
      rootNode
    });
  }


  set data(data) {
    const me = this;


    me._thisIsAUsedExpression(me.plugins);

    me.processConfiguredListeners();

    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && data && data.some(r => r[me.modelClass.childrenField])));

    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;

      if (me.tree) {
        const root = me.rootNode;

        root.clearChildren(true);
        root.isLoading = true;

        root.appendChild(data);
        me.updateDependentStores('dataset', [root]);
        root.isLoading = false;

        if (data.length === 0) {
          me.trigger('refresh', {
            action: 'dataset',
            data: [],
            records: []
          });
        } else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }

      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }

  loadData(data, action = 'dataset') {
    const me = this,
      {
        storage,
        allowNoId
      } = me,
      idField = me.modelClass.fieldMap.id.dataSource;


    me.storeCollapsedGroups();

    me.removeHeadersAndFooters(me.storage.values);

    if (me.allCount) {

      me.clear(false);
    }

    me._idMap = null;

    if (data) {
      const isRaw = !(data[0] instanceof Model);

      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length,
          records = new Array(count);

        for (let i = 0; i < count; i++) {
          const recordData = data[i];

          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }

          records[i] = me.createRecord(recordData, true);
          records[i].parentIndex = i;
        }


        storage.replaceValues({
          values: records,
          silent: true,
          isNewDataset: true
        });
      } else {
        storage.replaceValues({
          values: data.slice(),
          silent: true,
          isNewDataset: true
        });
      }

      me.storage.allValues.forEach(r => {
        r.joinStore(me);
      });

      me.prepareGroupRecords(me.storage.values);

      me.restoreCollapsedGroups();


      if (!me.filterParamName && me.isFiltered) {
        me.filter({
          silent: true
        });
      }

      if (me.isGrouped) {
        me.group(null, null, false, !me.sorters.length, true);
      }

      if (!me.sortParamName && me.sorters.length) {
        me.sort(null, null, false, true);
      }

      if (!me.useRawData.disableDuplicateIdCheck) {
        const idMap = me.idMap;

        if (Object.keys(idMap).length < me.storage.values.length) {

          const collisions = [];
          me.storage.values.forEach(r => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
          throw new Error(`Id collision on ${collisions.map(r => r.id)}`);
        }
      }

      const event = {
        action,
        data,
        records: me.storage.values
      };
      me.updateDependentStores(event.action, event.records);
      me.trigger('refresh', event);
      me.trigger('change', event);
    } else {
      me._data = null;
    }
  }

  get data() {
    return this._data;
  }


  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }


  createRecord(data, skipExpose = false) {
    return new this.modelClass(data, this, null, skipExpose);
  }

  refreshData() {
    this.filter();
    this.sort();
  }

  onRecordIdChange(record, oldValue, value) {
    const me = this,
      idMap = me._idMap,
      {
        idRegister
      } = me;
    me.storage._indicesInvalid = true;

    if (idMap) {
      delete idMap[oldValue];
      idMap[value] = record;
    }

    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }

  onUpdateRecord(record, changes) {
    const {
        internalId
      } = changes,
      {
        internalIdRegister
      } = this;

    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }

    if (this.reapplyFilterOnUpdate && this.isFiltered) {
      this.filter();
    }
  }

  get useRawData() {
    return this._useRawData;
  }

  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, {
        enabled: true
      }) : {
        enabled: false
      };
    }
  }


  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }


  get originalCount() {
    return this.storage.totalCount;
  }


  get count() {
    return this.storage.count;
  }


  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }


  get records() {
    return this.storage.values;
  }


  get first() {
    return this.storage.values[0];
  }


  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }


  getAt(index, all = false) {

    return this.storage.getAt(index, all);
  }


  register(record) {
    const me = this,


      existingRec = me.isTree && me.idRegister[record.id];

    if (existingRec && existingRec !== record) {
      throw new Error(`Id collision on ${record.id}`);
    }

    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }

  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }

  get registeredRecords() {
    return Object.values(this.idRegister);
  }


  getById(id) {


    if (id && id.isModel) {
      return id;
    }

    return this.idRegister[id];
  }


  isVisible(recordOrId) {
    return this.isAvailable(recordOrId);
  }


  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }


  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }


  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }

    return this.indexOf(recordOrId) > -1;
  }


  indexOf(recordOrId, visibleRecords = false) {
    const id = Model.asId(recordOrId);

    if (id == null) {
      return -1;
    }

    if (this.isTree) {
      return this.storage.indexOf(id);
    }

    const found = this.idMap[id];
    return found ? found[visibleRecords ? 'visibleIndex' : 'index'] : -1;
  }

  allIndexOf(recordOrId) {
    if (this.isTree) {
      const record = this.getById(recordOrId);
      let result = -1;

      if (record) {
        record.bubble(n => {
          if (n.parent) {
            result += n.parentIndex + 1;
          } else if (n === this.rootNode && this.rootVisible) {
            result += 1;
          }
        });
      }

      return result;
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }


  getDistinctValues(field) {
    const me = this,
      values = [],
      keys = {};
    let value;
    me.forEach(r => {
      if (!r.meta.specialRow && !r.isRoot) {
        value = r.get(field);

        if (!keys[value]) {
          values.push(value);
          keys[value] = 1;
        }
      }
    });
    return values;
  }


  getValueCount(field, value) {
    let count = 0;
    this.forEach(r => {
      if (ObjectHelper.isEqual(r.get(field), value)) count++;
    });
    return count;
  }


  get json() {
    return JSON.stringify(this, null, 4);
  }

  toJSON() {


    return (this.isTree ? this.rootNode.children : this).map(record => record.toJSON());
  }


  forEach(fn, thisObj = this) {
    const callback = (r, i) => {
      if (!r.isRoot && !r.meta.specialRow) {
        return fn.call(thisObj, r, i);
      }
    };

    if (this.isTree) {
      this.rootNode.traverseWhile(callback);
    } else {

      const records = this.storage.values;

      for (let i = 0; i < records.length; i++) {
        if (callback(records[i], i) === false) {
          return;
        }
      }
    }
  }


  map(fn, thisObj = this) {
    return this.storage.values.map(fn, thisObj);
  }


  reduce(fn, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn = fn.bind(thisObj);
    }

    return this.storage.values.reduce(fn, initialValue, thisObj);
  }


  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }


  traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode) {
    const me = this;

    if (me.isTree) {

      if (typeof topNode === 'boolean') {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }

      if (me.isChained) {
        const passedFn = fn;

        fn = node => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }

      topNode.traverse(fn, skipTopNode);
    } else {
      for (const record of me.storage) {
        record.traverse(fn);
      }
    }
  }


  traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode) {
    const me = this;

    if (me.isTree) {

      if (typeof topNode === 'boolean') {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }

      if (me.isChained) {
        const passedFn = fn;

        fn = node => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }

      topNode.traverseWhile(fn, skipTopNode);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn) === false) {
          break;
        }
      }
    }
  }


  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this,
      records = me.storage.values;
    let idx = me.indexOf(recordOrId);

    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }

    const record = records[idx + 1];

    if (skipSpecialRows && record && record.meta.specialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }

    return record;
  }


  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this,
      records = me.storage.values;
    let idx = me.indexOf(recordOrId);

    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }

    const record = records[idx - 1];

    if (skipSpecialRows && record && record.meta.specialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }

    return record;
  }


  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }


  getNextLeaf(recordOrId, wrap = false) {
    const me = this,
      records = me.leaves,
      record = me.getById(recordOrId);
    let idx = records.indexOf(record);

    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }

    return records[idx + 1];
  }


  getPrevLeaf(recordOrId, wrap = false) {
    const me = this,
      records = me.leaves,
      record = me.getById(recordOrId);
    let idx = records.indexOf(record);

    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }

    return records[idx - 1];
  }


  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }


  makeChained(chainedFilterFn = () => true, chainedFields, config) {
    return new this.constructor(Object.assign(config || {}, {
      tree: false,
      autoTree: false,
      masterStore: this,
      chainedFilterFn,
      chainedFields
    }));
  }


  chain() {
    return this.makeChained(...arguments);
  }

}

Store.storeMap = {};
Store._$name = 'Store';


const processParamEntry = (paramArray, entry) => {
    if (Array.isArray(entry[1])) {
      entry[1].forEach(value => paramArray.push(entry[0] + '=' + value));
    } else {
      paramArray.push(entry[0] + '=' + entry[1]);
    }

    return paramArray;
  },
  immediatePromise$2 = new Promise(resolve => resolve());


class AjaxStore extends Store {


  static get defaultConfig() {
    return {

      headers: null,


      fetchOptions: null,


      sendAsFormData: false,


      writeAllFields: null,


      parentIdParamName: 'id',


      responseDataProperty: 'data',


      responseTotalProperty: 'total',


      filterParamName: null,


      sortParamName: null,


      pageParamName: null,


      pageStartParamName: null,


      pageSizeParamName: 'pageSize',


      pageSize: 50,


      useRestfulMethods: false,


      httpMethods: {
        create: 'POST',
        read: 'GET',
        update: 'PUT',
        delete: 'DELETE'
      }
    };
  }


  afterConstruct(config) {
    super.afterConstruct(config);

    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }


  get isLoading() {
    return this._isLoading;
  }


  get isCommitting() {
    return Boolean(this.commitPromise);
  }

  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error('Paging cannot be supported for tree stores');
    }

    if (this.pageStartParamName) {
      throw new Error('Configs pageStartParamName and pageParamName are mutually exclusive');
    }

    this._pageParamName = pageParamName;
  }

  get pageParamName() {
    return this._pageParamName;
  }

  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error('Paging cannot be supported for tree stores');
    }

    if (this.pageParamName) {
      throw new Error('Configs pageParamName and pageStartParamName are mutually exclusive');
    }

    this._pageStartParamName = pageStartParamName;
  }

  get pageStartParamName() {
    return this._pageStartParamName;
  }


  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }


  get allCount() {
    return 'remoteTotal' in this ? this.remoteTotal : super.allCount;
  }


  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }

  buildQueryString(...paramObjects) {
    const queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join('&');
    return queryString ? '?' + queryString : '';
  }

  performSort(silent) {
    const me = this;

    if (me.sortParamName) {
      const {
          groupRecords
        } = me,

        collapsed = {};

      if (me.isGrouped && groupRecords && groupRecords.length) {
        groupRecords.forEach(r => {
          if (r.meta.collapsed) {
            me.includeGroupRecords(r);
            collapsed[r.id] = true;
          }
        });
      }

      return me.internalLoad({}, '', event => {
        me.data = event.data;
        me.afterPerformSort(silent, collapsed);
      });
    } else {
      super.performSort(silent);
    }
  }

  performFilter(silent) {
    const me = this;


    if (me.filterParamName) {
      const oldCount = me.count,
        {
          filters
        } = me;

      me.currentPage = 1;

      return me.internalLoad({}, '', event => {
        me.data = event.data;
        me.afterPerformFilter(silent ? null : {
          action: 'filter',
          filters,
          oldCount,
          records: me.storage.values
        });
      });
    } else {
      super.performFilter();
    }
  }


  encodeFilterParams(filters) {
    const result = [];

    for (const {
      property,
      operator,
      value,
      caseSensitive
    } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }

    return JSON.stringify(result);
  }


  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.map(sorter => sorter));
  }

  internalLoad(params, eventName, successFn) {
    const me = this,
      allParams = Object.assign({}, me.params, params),
      event = {
        action: 'read' + eventName,
        params: allParams
      };
    return me.readUrl ? new Promise((resolve, reject) => {
      if (me.trigger('beforeLoad' + eventName, event) === false) {
        return reject(false);
      }

      me._isLoading = true;


      me.trigger(`load${eventName}Start`, event);
      me.trigger('beforeRequest', event);

      if (me.filterParamName && me.isFiltered) {
        allParams[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }


      if (me.sortParamName && me.isSorted) {
        allParams[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }


      if (me.isPaged) {
        if (!(allParams[me.pageParamName] || allParams[me.pageStartParamName])) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);

          if (me.pageParamName) {
            allParams[me.pageParamName] = page;
          } else {
            allParams[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }

        allParams[me.pageSizeParamName] = me.pageSize;
      }

      const options = {
        headers: me.headers,
        parseJson: true
      };

      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
      }

      AjaxHelper.get(me.readUrl + me.buildQueryString(allParams), Object.assign(options, me.fetchOptions)).then(response => {
        const data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && data.success !== false;
        me._isLoading = false;
        event.response = response;
        event.json = data;

        if (success) {
          if (me.responseTotalProperty in data) {
            me.remoteTotal = parseInt(data[me.responseTotalProperty], 10);
          }


          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? allParams[me.pageParamName] : allParams[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error('A paged store must receive its responseTotalProperty in each data packet');
            }
          }

          event.data = isArray ? data : data[me.responseDataProperty];
          successFn(event);
          me.trigger('load' + eventName, event);
          resolve(event);
        } else {
          event.exception = true;
          event.exceptionType = 'server';
          me.trigger('exception', event);
          reject(event);
        }

        me.trigger('afterRequest', event);
      }).catch(responseOrError => {
        me._isLoading = false;
        event.exception = true;

        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }

        me.trigger('exception', event);
        reject(event);

        me.trigger('afterRequest', event);
      });
    }) : null;
  }


  load(params) {
    const me = this;

    if (me.isPaged) {
      return me.loadPage((me.currentPage || 0) + 1, params);
    } else {
      return me.internalLoad(params, '', event => {

        me.data = event.data;
      });
    }
  }


  async loadChildren(parentRecord) {
    const me = this;
    return me.internalLoad({
      [me.parentIdParamName]: parentRecord.id
    }, 'Children', event => {
      event.parentRecord = parentRecord;

      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    });
  }


  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }

    const me = this,
      pageParam = me.pageParamName ? {
        [me.pageParamName]: page
      } : {
        [me.pageStartParamName]: (page - 1) * me.pageSize
      };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(Object.assign(pageParam, params), 'Page', event => {


      me.loadData(event.data, 'pageLoad');
    });
  }


  async nextPage(params) {
    return this.isPaged && this.currentPage !== this.lastPage ? this.loadPage(this.currentPage + 1, params) : immediatePromise$2;
  }


  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise$2;
  }


  commit() {
    const me = this,
      changes = me.changes,
      allPromises = [];


    if (me.commitPromise) return false;

    if (!changes) {
      return immediatePromise$2;
    }

    [...changes.added, ...changes.modified, ...changes.removed].forEach(record => record.meta.committing = true);

    if (!me.disabled && me.trigger('beforeCommit', {
      changes
    }) !== false) {
      const commitState = {
        action: 'commit',
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);

      if (p) {
        allPromises.push(p);
      }

      p = me.commitAdded(commitState);

      if (p) {
        allPromises.push(p);
      }

      p = me.commitModified(commitState);

      if (p) {
        allPromises.push(p);
      }

      if (!allPromises.length) {
        me.modified.forEach(r => r.clearChanges(false));
        me.modified.clear();
        me.added.forEach(r => r.clearChanges(false));
        me.added.clear();
        me.removed.clear();
        me.trigger('commit', {
          changes
        });
        return immediatePromise$2;
      }


      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;

          if (commitState.exception) {
            me.trigger('exception', commitState);
            reject(commitState);
          } else {
            me.trigger('commit', {
              changes
            });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }

  doAutoCommit() {
    this.commit().catch(commitState => {
      const {
        response
      } = commitState;


      if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
        throw commitState;
      }
    });
  }


  commitAdded(commitState) {
    const me = this,
      added = me.added,
      event = {
        action: 'create',
        params: me.params
      };
    return added.count && me.createUrl ? new Promise(resolve => {
      const toAdd = added.values.map(r => r.persistableData);
      commitState.create = event;
      let dataToSend = event.body = {
        data: toAdd
      };
      me.trigger('beforeRequest', event);

      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append('data', JSON.stringify(toAdd));
        dataToSend = formData;
      }

      const options = {
        headers: me.headers,
        parseJson: true
      };

      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }

      AjaxHelper.post(me.createUrl + me.buildQueryString(me.params), dataToSend, Object.assign(options, me.fetchOptions)).then(response => {
        const data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;

        if (success) {


          me.processReturnedData(added.values, isArray ? data : data[me.responseDataProperty]);

          added.clear();
          me.trigger('commitAdded');


          me.trigger('refresh', event);
          resolve(commitState);
        } else {

          added.forEach(r => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = 'server';
          me.trigger('exception', event);
          resolve(commitState);
        }

        me.trigger('afterRequest', event);
      }).catch(responseOrError => {

        added.forEach(r => r.meta.committing = false);
        commitState.exception = event.exception = true;

        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }

        me.trigger('exception', event);
        resolve(commitState);

        me.trigger('afterRequest', event);
      });
    }) : null;
  }


  commitModified(commitState) {
    const me = this,
      modified = me.modified,
      event = {
        action: 'update',
        params: me.params
      };
    return modified.count && me.updateUrl ? new Promise(resolve => {


      const modifications = modified.map(r => me.writeAllFields ? r.persistableData : r.modificationData);
      commitState.update = event;
      let dataToSend = event.body = {
        data: modifications
      };
      me.trigger('beforeRequest', event);

      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append('data', JSON.stringify(modifications));
        dataToSend = formData;
      }

      const options = {
        headers: me.headers,
        parseJson: true
      };

      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }

      AjaxHelper.post(me.updateUrl + me.buildQueryString(me.params), dataToSend, Object.assign(options, me.fetchOptions)).then(response => {
        const data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;

        if (success) {


          me.processReturnedData(me.modified.values, isArray ? data : data[me.responseDataProperty], true);

          modified.clear();
          me.trigger('commitModified');


          me.trigger('refresh', event);
          resolve(commitState);
        } else {

          modified.forEach(r => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = 'server';
          me.trigger('exception', event);
          resolve(commitState);
        }

        me.trigger('afterRequest', event);
      }).catch(responseOrError => {

        modified.forEach(r => r.meta.committing = false);
        commitState.exception = event.exception = true;

        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }

        me.trigger('exception', event);
        resolve(commitState);

        me.trigger('afterRequest', event);
      });
    }) : null;
  }

  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this,
      Model = me.modelClass,
      idDataSource = Model.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];

      record.clearChanges(false);

      record.syncId(recData[idDataSource]);


      Object.assign(localRecords[i].data, Model.processData(recData, isUpdating));
    });
  }


  commitRemoved(commitState) {
    const me = this,
      removed = me.removed,
      event = {
        action: 'delete',
        params: me.params
      };
    return removed.count && me.deleteUrl ? new Promise(resolve => {
      commitState.delete = event;
      let dataToSend = event.body = {
        ids: removed.map(r => r.id)
      };
      me.trigger('beforeRequest', event);

      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append('id', JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }

      const options = {
        headers: me.headers,
        parseJson: true
      };

      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }

      AjaxHelper.post(me.deleteUrl + me.buildQueryString(me.params), dataToSend, Object.assign(options, me.fetchOptions)).then(response => {
        const data = response.parsedJson,
          isArray = Array.isArray(data),
          success = isArray || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;

        if (success) {
          removed.forEach(record => record.meta.committing = false);

          removed.clear();
          me.trigger('commitRemoved');
          me.trigger('refresh', event);
          resolve(commitState);
        } else {

          removed.forEach(r => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = 'server';
          me.trigger('exception', event);
          resolve(commitState);
        }

        me.trigger('afterRequest', event);
      }).catch(responseOrError => {

        removed.forEach(r => r.meta.committing = false);
        commitState.exception = event.exception = true;

        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? 'server' : 'network';
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = 'server';
          event.error = responseOrError;
        }

        me.trigger('exception', event);
        resolve(commitState);

        me.trigger('afterRequest', event);
      });
    }) : null;
  }

}

AjaxStore._$name = 'AjaxStore';


class TextField extends Field {
  static get defaultConfig() {
    return {


      attributes: ['placeholder', 'autoComplete', 'minLength', 'maxLength', 'pattern', 'tabIndex'],
      localizableProperties: ['label', 'title', 'placeholder']
    };
  }

  static get $name() {
    return 'TextField';
  }

  inputTemplate() {
    const me = this,
      style = 'inputWidth' in me ? `style="width:${DomHelper.setLength(me.inputWidth)}"` : '';
    return TemplateHelper.tpl`<input type="${me.inputType || 'text'}"
            reference="input"
            class="${me.inputCls || ''}"
            name="${me.name || me.id}"
            id="${me.id + '_input'}"
            ${style}
            ${me.attributeString}/>`;
  }

  construct(config) {
    if (config.inputType === 'hidden') {
      config.hidden = true;
    }

    super.construct(...arguments);
  }

  set value(value) {
    super.value = this.$name === 'TextField' && value == null ? '' : value;
  }

  get value() {
    return super.value;
  }

  set placeholder(value) {
    this._placeholder = value;

    if (this.input) {
      this.input.placeholder = value;
    }
  }

  get placeholder() {
    return this._placeholder;
  }

}

TextField._$name = 'TextField';
BryntumWidgetAdapterRegister.register('textfield', TextField);
BryntumWidgetAdapterRegister.register('text', TextField);


class PickerField extends TextField {

  static get $name() {
    return 'PickerField';
  }

  static get defaultConfig() {
    return {

      editable: true,


      pickerAlignElement: 'inputWrap',

      value: null,
      triggers: {
        expand: {
          cls: 'bars'
        }
      },


      autoClose: true,


      autoExpand: null,


      picker: null,
      inputType: 'text',

      monitorResize: true
    };
  }


  doDestroy() {

    this.globalTapListener && this.globalTapListener();

    this.picker = null;
    super.doDestroy();
  }

  finalizeInit() {
    super.finalizeInit();
    const me = this,
      element = me.element;

    if (me.editable === false) {
      element.classList.add('b-not-editable');
      EventHelper.on({
        element: me.input,
        click: 'onTriggerClick',
        thisObj: me
      });
    } else {


      me.globalTapListener = GlobalEvents.on({
        globaltap: 'showKeyboard',
        thisObj: me
      });
    }
  }


  get picker() {
    let {
      _picker
    } = this;

    if (!(_picker instanceof Widget)) {
      this.picker = _picker = this.createPicker(_picker || {});
    }

    return _picker;
  }

  set picker(picker) {
    const {
      _picker
    } = this;

    if (_picker && _picker.destroy) {
      _picker.hide();

      _picker.destroy();
    }

    this._picker = picker;
  }

  createPicker() {
    throw new Error('createPicker must be implemented in PickerField subclass implementations');
  }


  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }

  onElementResize(resizedElement) {
    const me = this;


    if (me.pickerVisible) {


      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }

    super.onElementResize(resizedElement);
  }


  internalOnKeyPress(event) {
    const me = this;
    let callSuper = true;

    if (event.type === 'keydown' && !me.disabled) {
      if (me.pickerVisible) {
        const {
          picker
        } = me;

        if (event.key === 'Escape') {
          event.stopImmediatePropagation();
          me.hidePicker();


          callSuper = false;
        } else if (picker.onInternalKeyDown) {

          picker.onInternalKeyDown(event);
        } else if (event.key === 'ArrowDown') {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === 'ArrowDown') {

        event.stopImmediatePropagation();
        me.onTriggerClick(event);
      }
    }

    if (callSuper) {
      super.internalOnKeyPress(event);
    }
  }

  onFocusIn(e) {
    super.onFocusIn(e);

    if (this.autoExpand) {


      this.minChars = 0;
      this.onTriggerClick(e);
    }
  }

  onFocusOut(e) {
    this.autoClosePicker();
    super.onFocusOut(e);
  }


  onTriggerClick(event) {
    if (!this.disabled) {

      this.togglePicker('key' in event);
    }
  }


  showKeyboard({
                 event
               }) {
    const input = this.input;

    if (DomHelper.isTouchEvent && document.activeElement === input && event.target === input) {
      GlobalEvents.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents.resumeFocusEvents();
    }
  }


  togglePicker(focusPicker) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focusPicker);
    }
  }


  showPicker(focusPicker) {
    const me = this,
      picker = me.picker;

    if (!me.pickerHideShowListenersAdded) {
      picker.on({
        show: 'onPickerShow',
        hide: 'onPickerHide',
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }

    picker.autoClose = me.autoClose;
    picker.show();

    if (picker.isVisible) {
      if (focusPicker) {
        me.focusPicker();
      }
    }
  }

  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add('b-open');
    me.trigger('togglePicker', {
      show: true
    });
    me.pickerTapOutRemover = GlobalEvents.on({
      globaltap: 'onPickerTapOut',
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
  }

  onPickerHide() {
    const me = this;
    me.pickerVisible = false;
    me.element.classList.remove('b-open');
    me.trigger('togglePicker', {
      show: false
    });
    me.pickerTapOutRemover && me.pickerTapOutRemover();
    me.pickerKeyDownRemover && me.pickerKeyDownRemover();
  }

  onPickerTapOut({
                   event
                 }) {
    if (!this.owns(event.target)) {
      this.autoClosePicker();
    }
  }

  onPickerKeyDown(event) {
    if (event.key === 'Tab') {
      const activeEl = document.activeElement,
        forwardedEvent = new KeyboardEvent('keydown', event);


      this.input.dispatchEvent(forwardedEvent);


      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }


      if (document.activeElement === activeEl) {
        this.input.focus();
      } else {
        event.preventDefault();
      }

      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }


  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }


  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }

  focusPicker() {
  }

  focus() {
    const input = this.input;


    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }

    super.focus();
  }

}

PickerField._$name = 'PickerField';


class Navigator extends Events(Base) {
  static get defaultConfig() {
    return {

      ownerCmp: null,


      target: null,


      keyEventTarget: null,


      processEvent: null,


      itemSelector: null,


      focusCls: 'b-active',


      keys: null,


      allowCtrlKey: null,


      allowShiftKey: null,
      scrollDuration: 50,
      testConfig: {
        scrollDuration: 1
      }
    };
  }

  set itemSelector(itemSelector) {
    this._itemSelector = itemSelector;
  }

  get itemSelector() {

    return this._itemSelector || `.${this.ownerCmp.itemCls}`;
  }

  onKeyDown(keyEvent) {
    const me = this,
      ownerCmp = me.ownerCmp,
      activeItem = me.activeItem,
      firstItem = me.target.querySelector(me.itemSelector),

      keyName = (keyEvent.key || '').trim() || keyEvent.code,
      composedKeyName = `${keyEvent.ctrlKey ? 'CTRL+' : ''}${keyEvent.shiftKey ? 'SHIFT+' : ''}${keyEvent.altKey ? 'ALT+' : ''}${keyName}`;

    if (firstItem && me.target.offsetParent) {

      if (me.inlineFlow == null) {
        const itemContainer = firstItem.parentNode,
          itemPositionStyle = DomHelper.getStyleValue(firstItem, 'position'),
          itemDisplayStyle = DomHelper.getStyleValue(firstItem, 'display'),
          itemFloatStyle = DomHelper.getStyleValue(firstItem, 'float');


        me.inlineFlow = itemPositionStyle === 'absolute' || itemDisplayStyle === 'inline' || itemDisplayStyle === 'inline-block' || itemFloatStyle === 'left' || itemFloatStyle === 'right' || DomHelper.getStyleValue(itemContainer, 'display') === 'flex' && DomHelper.getStyleValue(itemContainer, 'flex-direction') === 'row';

        if (me.inlineFlow) {
          me.prevKey = 'ArrowLeft';
          me.nextKey = 'ArrowRight';
        } else {
          me.prevKey = 'ArrowUp';
          me.nextKey = 'ArrowDown';
        }
      }

      if (me.processEvent) {
        keyEvent = me.processEvent.call(ownerCmp, keyEvent);

        if (!keyEvent) {
          return;
        }
      }

      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }

            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }

            keyEvent.preventDefault();
            me.navigatePrevious(keyEvent);
            break;

          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }

            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }

            keyEvent.preventDefault();
            me.navigateNext(keyEvent);
            break;

          default:
            let keyHandler = me.keys && me.keys[composedKeyName];

            if (keyHandler && !me.disabled) {
              me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]);
            } else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }

        }
      } else {
        me.activeItem = me.previousActiveItem || me.getDefaultNavigationItem(keyEvent);
      }

      if (me.activeItem !== activeItem) {

        me.trigger('navigate', {
          event: keyEvent,
          item: me.activeItem
        });
      }
    }
  }

  getDefaultNavigationItem(keyEvent) {
    const {
      target,
      itemSelector,
      prevKey,
      nextKey
    } = this;

    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }

    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }

  navigatePrevious(keyEvent) {
    const me = this,
      previous = me.previous;
    keyEvent.preventDefault();

    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = previous;
        me.trigger('navigate', {
          event: keyEvent,
          item: me.activeItem
        });
      });
    }
  }

  navigateNext(keyEvent) {
    const me = this,
      next = me.next;
    keyEvent.preventDefault();

    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = next;
        me.trigger('navigate', {
          event: keyEvent,
          item: me.activeItem
        });
      });
    }
  }

  get owner() {
    return this.ownerCmp;
  }

  get previous() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.activeItem;
    treeWalker.previousNode();

    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }

  get next() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.activeItem;
    treeWalker.nextNode();

    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }

  onTargetFocusIn(focusInEvent) {
    if (focusInEvent.target.matches(this.itemSelector)) {


      this.skipScrollIntoView = true;
      this.activeItem = focusInEvent.target;
      this.skipScrollIntoView = false;
    }
  }

  onTargetFocusOut(focusOutEvent) {
    if (!focusOutEvent.relatedTarget || !this.target.contains(focusOutEvent.relatedTarget)) {
      this.activeItem = null;
    }
  }

  onTargetMouseDown(mousedownEvent) {


    if (this.ownerCmp.itemsFocusable === false) {
      this.onFocusGesture(mousedownEvent);
    } else {
      const target = mousedownEvent.target.closest(this.itemSelector);

      if (target) {
        mousedownEvent.preventDefault();
        DomHelper.focusWithoutScrolling(target);
      }
    }
  }

  onTargetClick(clickEvent) {
    const me = this;

    if (me.disabled) {
      return;
    }


    me.skipScrollIntoView = true;

    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }

    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.trigger('navigate', {
        event: clickEvent,
        item: me.activeItem
      });
    }

    me.skipScrollIntoView = false;
  }


  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }

  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  }

  get activeItem() {
    return this._activeItem;
  }

  set activeItem(activeItem) {
    const me = this,
      {
        ownerCmp
      } = me,
      currentActiveItem = me.activeItem,
      isActive = currentActiveItem && me.target.contains(currentActiveItem);

    if (isActive) {
      me.previousActiveItem = currentActiveItem;
    }


    if (activeItem != null) {

      if (ownerCmp.getItem) {
        activeItem = me.ownerCmp.getItem(activeItem);
      }

      if (!activeItem) {
        return;
      }

      if (!me.skipScrollIntoView) {
        ownerCmp.scrollable.scrollIntoView(activeItem, {
          block: 'nearest',


          focus: DomHelper.isFocusable(activeItem) && activeItem !== document.activeElement,
          silent: me.scrollSilently
        });
      }

      if (activeItem === currentActiveItem && isActive) {
        return;
      }

      if (currentActiveItem) {
        me.activeItem.classList.remove(me.focusCls);
      }

      activeItem.classList.add(me.focusCls);
      me._activeItem = activeItem;
    } else {
      if (currentActiveItem) {
        currentActiveItem.classList.remove(me.focusCls);


        if (currentActiveItem === document.activeElement) {
          me.ownerCmp.revertFocus();
        }
      }

      me._activeItem = null;
    }
  }

  get target() {
    return this._target;
  }

  set target(target) {
    const me = this,
      listeners = {
        element: target,
        thisObj: me,
        focusin: 'onTargetFocusIn',
        focusout: 'onTargetFocusOut',
        mousedown: 'onTargetMouseDown',
        click: 'onTargetClick'
      };
    me._target = target;

    if (!me.hasOwnProperty('acceptNode')) {
      me.acceptNode = me.acceptNode.bind(me);


      me.acceptNode.acceptNode = me.acceptNode;
    }

    EventHelper.on(listeners);

    me.treeWalker = document.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, me.acceptNode, false);


    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }

    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true
    });
  }

  onTargetChildListChange() {
    const activeItem = this.activeItem;

    if (activeItem && !this.target.contains(activeItem)) {
      this.activeItem = this.target.querySelector(`${this.itemSelector}[data-id="${activeItem.dataset.id}"]`);
    }
  }

  get keyEventTarget() {
    return this._keyEventTarget;
  }

  set keyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: 'onKeyDown',
      thisObj: this
    });
  }

}

Navigator._$name = 'Navigator';


const itemRange = document.createRange();


class List extends Widget {

  static get $name() {
    return 'List';
  }

  static get defaultConfig() {
    return {
      itemCls: 'b-list-item',
      selectedCls: 'b-selected',


      items: null,


      store: null,
      navigator: true,
      scrollable: {
        x: false,
        y: true
      },
      itemsFocusable: true,
      multiSelect: false,


      itemTpl: record => record.text,


      selected: {},


      activateOnMouseover: null
    };
  }


  construct(config, ...args) {
    const me = this;

    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }

    super.construct(config, ...args);
    const element = me.element,
      classList = element.classList;

    if (me.multiSelect) {
      classList.add('b-multiselect');
    }

    if (me.store.count) {
      me.refresh();
    } else {
      classList.add('b-empty');
    }

    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: 'onMouseOver',
      click: 'onClick',
      thisObj: me
    });
  }

  doDestroy() {
    this.detachListeners('store');
    super.doDestroy();
  }

  contentTpl() {
    return TemplateHelper.tpl`${this.store.records.map((record, i) => this.itemWrapperTpl(record, i))}`;
  }

  itemWrapperTpl(record, i) {
    return TemplateHelper.tpl`<div class="${this.getItemClasses(record, i)}" data-index="${i}" data-id="${record.id}" ${this.itemsFocusable ? 'tabindex="-1"' : ''}>
            ${this.itemContentTpl(record, i)}
            </div>`;
  }

  itemContentTpl(record, i) {
    return TemplateHelper.tpl`${this.multiSelect ? '<div class="b-selected-icon b-icon b-icon-check"></div>' : ''}${this.itemTpl(record, i)}`;
  }

  getItemClasses(record) {
    const me = this,
      activeItem = me._navigator && me._navigator.activeItem,
      isActive = activeItem && activeItem.dataset.id == record.id,
      isSelected = me.selected.includes(record);
    return `${me.itemCls} ${record.cls || ''} ${isSelected ? me.selectedCls : ''} ${isActive ? me.navigator.focusCls : ''}`;
  }

  onBeforeStoreLoad() {
    this.mask(this.L('loading'));
  }

  onAfterStoreRequest() {
    this.unmask();
  }

  onStoreChange({
                  source: store,
                  action,
                  records,
                  record
                }) {
    switch (action) {
      case 'remove':
        this.selected.remove(records);
        break;

      case 'clear':
        this.selected.clear();
        break;

      case 'update':
        this.refreshItem(record);
        return;
    }

    this.refresh();
  }

  onStoreRefresh() {
    this.refresh();
  }

  refresh() {
    const me = this;

    if (me.isVisible) {
      const {
        activeItem
      } = me.navigator;

      me.paintListener = null;
      me.clearItems().insertNode(DomHelper.createElementFromTemplate(me.contentTpl(), {
        fragment: true
      }));


      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }

      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? 'remove' : 'add']('b-empty');
    } else if (!me.paintListener) {
      me.paintListener = me.on({
        paint: 'refresh',
        thisObj: me,
        once: true
      });
    }
  }

  clearItems() {
    const me = this,
      firstItem = me.contentElement.querySelector(me.itemSelector),
      lastChild = me.contentElement.lastChild;

    if (firstItem) {


      const items = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items[items.length - 1]);
      itemRange.deleteContents();
    } else {

      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }

    return itemRange;
  }

  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);


      if (item) {
        const index = this.store.indexOf(record),
          newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }

  getItem(recordOrId) {

    if (recordOrId != null) {
      if (typeof recordOrId === 'number') {
        return this.contentElement.querySelector(`[data-index="${recordOrId}"]`);
      } else if (recordOrId.nodeType === 1) {
        recordOrId = recordOrId.dataset.id;
      }

      if (recordOrId.id != null) {
        recordOrId = recordOrId.id;
      }

      return this.contentElement.querySelector(`[data-id="${recordOrId}"]`);
    }
  }

  getRecord(dom) {
    if (dom.target) {
      dom = dom.target;
    }

    dom = dom.closest(this.itemSelector);
    return this.store.getAt(parseInt(dom.dataset.index));
  }


  set items(items) {
    const me = this;

    if (me.store && me.store.autoCreated) {
      me.store.destroy();
    }

    me.store = Store.getStore(items);
  }

  set selected(selected) {
    if (!(selected && selected instanceof Collection)) {
      selected = new Collection(selected);
    }

    this._selected = selected;
    selected.on({
      change: 'onSelectionChange',
      thisObj: this
    });
  }

  get itemSelector() {
    return `.${this.itemCls}`;
  }

  get selected() {
    return this._selected;
  }


  get store() {

    this._thisIsAUsedExpression(this.items);

    return this._store;
  }

  set store(store) {
    const me = this;

    if (!(store instanceof Store)) {
      store = new Store(store);
    }

    me._store = store;
    me.detachListeners('store');

    if (store) {
      const storeListeners = {
        name: 'store',
        change: 'onStoreChange',
        refresh: 'onStoreRefresh',
        thisObj: me
      };

      if (store.readUrl) {
        storeListeners.beforeLoad = 'onBeforeStoreLoad';
        storeListeners.afterRequest = 'onAfterStoreRequest';
      }

      me.store.on(storeListeners);
    }

    me.refresh();
  }

  get navigator() {
    return this._navigator;
  }

  set navigator(navigator) {
    const me = this,
      {
        element
      } = me;

    if (element) {
      me._navigator = new (navigator.class || Navigator)(Object.assign({
        ownerCmp: me,
        target: element,
        keyEventTarget: element
      }, navigator));
    } else {
      me._navigator = navigator;
    }
  }

  get minHeight() {
    return super.minHeight;
  }

  set minHeight(minHeight) {
    super.minHeight = this._minHeight = minHeight;
  }

  get minAlignHeight() {
    const lastItem = this.element.lastElementChild,
      minHeight = this.minHeight;

    if (minHeight != null) {
      return this.store.count ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }


  alignTo(...args) {

    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }

  hide(...args) {
    this.navigator.activeItem = null;
    super.hide(...args);
  }

  show() {
    const {
        refreshCount
      } = this,
      {
        previousActiveItem
      } = this.navigator;

    super.minHeight = this._minHeight;
    super.show();


    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
  }


  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = 'nearest') {
    const me = this,
      {
        navigator,
        lastAlignSpec
      } = me;


    if (activeItem != null) {
      if (typeof block !== 'string') {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;


        block = alignZone & 1 ? 'nearest' : alignZone ? 'start' : 'end';
      }

      activeItem = me.getItem(activeItem);

      if (activeItem) {


        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator.activeItem = activeItem;
      }
    }
  }


  onMouseOver(event) {
    const me = this,
      itemElement = event.currentTarget;

    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: 'handleMouseOver',
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }

  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }


  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);

    if (itemElement) {
      this.onItemClick(itemElement, event);
    }
  }


  onInternalKeyDown(event) {
    const me = this,
      active = me.navigator.activeItem;

    switch (event.key) {
      case ' ':
        if (!event.target.readOnly) {
          break;
        }

      case 'Enter':

        if (active) {
          this.onItemClick(active, event);


          event.stopImmediatePropagation();
          event.preventDefault();
        }

    }
  }

  onItemClick(item, event) {
    const me = this,
      index = parseInt(item.dataset.index),
      record = me.store.getAt(index),
      selected = me.selected,
      isSelected = selected.includes(record);
    me.trigger('item', {
      item,
      record,
      index,
      event
    });

    if (!item.contains(event.target.closest('[data-noselect]'))) {
      if (me.multiSelect) {
        selected[isSelected ? 'remove' : 'add'](record);
      } else {
        selected.splice(0, selected.count, record);
      }
    }

    me.lastClicked = record;
  }


  onSelectionChange({
                      action,
                      removed,
                      added,
                      replaced
                    }) {
    const me = this,
      {
        selectedCls
      } = me;
    let record, item;

    if (action === 'clear') {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
      }
    } else {
      for (record of removed) {
        item = me.getItem(record);
        item && item.classList.remove(selectedCls);
      }

      for (record of added) {
        item = me.getItem(record);
        item && item.classList.add(selectedCls);
      }
    }
  }

}

List.prototype.navigatorClass = Navigator;
List._$name = 'List';
BryntumWidgetAdapterRegister.register('list', List);


class ChipView extends List {

  static get $name() {
    return 'ChipView';
  }

  static get defaultConfig() {
    return {
      itemCls: 'b-chip',


      closable: true,


      iconTpl: null,


      closeHandler: null
    };
  }

  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ''}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ''}`;
  }

  onInternalKeyDown(event) {
    if (event.key === 'Delete' || event.key === 'Backspace' && this.selected.count) {
      this.callback(this.closeHandler, this.owner, [this.selected.values, {
        isKeyEvent: true
      }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }

  onClick(event) {
    const me = this,
      item = event.target.closest(`.${me.itemCls}`);

    if (me.closable && event.target.classList.contains('b-close-icon')) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      me.callback(me.closeHandler, me.owner, [[record]]);
    } else {
      super.onClick(event);
    }
  }

}

ChipView._$name = 'ChipView';
BryntumWidgetAdapterRegister.register('chipview', ChipView);

const comboQueryAll = Symbol('Combo.queryAll'),
  comboQueryLast = Symbol('Combo.queryLast'),
  fieldRequiredErrorName = 'fieldRequired',
  fieldvalidateFilterErrorName = 'validateFilter';


class Combo extends PickerField {

  static get $name() {
    return 'Combo';
  }

  static get defaultConfig() {
    return {

      items: null,


      store: null,


      valueField: null,


      displayField: 'text',


      pickerWidth: null,


      minChars: null,
      selected: null,


      listItemTpl: null,


      displayValueRenderer: null,


      listCls: null,
      triggers: {
        expand: {
          cls: 'b-icon-picker',
          handler: 'onTriggerClick'
        }
      },


      filterParamName: null,


      encodeFilterParams: null,


      hideTrigger: null,


      overlayAnchor: null,


      keyStrokeFilterDelay: null,
      defaultAction: 'select',


      triggerAction: comboQueryAll,


      filterOperator: 'startsWith',


      caseSensitive: false,


      multiSelect: null,


      hidePickerOnSelect: null,


      chipView: null,


      filterSelected: null,


      emptyText: null,


      value: null,


      validateFilter: true,


      clearTextOnPickerHide: true
    };
  }

  afterConfigure() {
    super.afterConfigure();

    if (!('_value' in this)) {
      this._value = this.valueField === this.displayField ? '' : null;
    }
  }

  encodeFilterParams(filters) {
    return filters.map(f => f.value);
  }

  eachWidget(fn, deep = true) {
    for (const widget of [this.chipView, this._picker]) {
      if (widget) {
        if (fn(widget) === false) {
          return;
        }

        if (deep && widget.eachWidget) {
          widget.eachWidget(fn, deep);
        }
      }
    }
  }

  set element(element) {
    const me = this;
    super.element = element;


    if (me.multiSelect) {
      me.element.classList.add('b-multiselect');
      me.chipView = new MultiSelectChipView(ObjectHelper.assign({
        parent: me,
        insertBefore: me.input,
        store: me.chipStore = new Store({
          storage: me.valueCollection
        }),
        navigator: {
          class: MultiSelectChipNavigator,
          keyEventTarget: me.input
        }
      }, me.chipView));

      me.chipView.element.appendChild(me.input);

      EventHelper.on({
        element: me.chipView.element,
        mousedown: 'onChipViewMousedown',
        thisObj: me
      });
    }
  }

  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();

    if (!this.containsFocus) {
      this.focus();
    }
  }

  onChipClose(records, options = {}) {


    if (options.isKeyEvent && this.input.value === '' || !options.isKeyEvent) {
      this.valueCollection.remove(records);
    }
  }

  get element() {
    return super.element;
  }

  set filterParamName(filterParamName) {
    this._filterParamName = filterParamName;

    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }

  get filterParamName() {
    return this._filterParamName;
  }

  set hideTrigger(hideTrigger) {
    this._hideTrigger = hideTrigger;
    this.element.classList[hideTrigger ? 'add' : 'remove']('b-hide-trigger');
  }

  get hideTrigger() {
    return this._hideTrigger;
  }

  set keyStrokeFilterDelay(delay) {
    const me = this;

    if (delay) {
      me.filterList = me.buffer(me.doFilter, delay);
    }

    me._keyStrokeFilterDelay = delay;
  }

  get keyStrokeFilterDelay() {
    return this._keyStrokeFilterDelay;
  }

  set minChars(minChars) {
    this._minChars = minChars;
  }

  get minChars() {
    if ('_minChars' in this) {
      return this._minChars;
    }

    return this.filterParamName ? 4 : 1;
  }


  set items(items) {
    const me = this;

    if (items == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }

      items = [];
    }

    if (items instanceof Store) {
      return me.store = items;
    }

    const displayField = me.displayField;
    let itemModel,
      valueField = me.valueField,
      storeData;

    if (Array.isArray(items)) {
      storeData = items.map(item => {
        let result = item;

        if (item instanceof Model) {
          itemModel = item.constructor;

          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === 'string' || typeof item === 'number') {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }

            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = 'value';
            }

            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }

        if (result.selected) {
          me.value = result;
        }

        return result;
      });
    } else {
      if (!valueField) {
        me.valueField = valueField = 'value';
      }

      storeData = [];
      Object.entries(items).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }

    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: 'value',
        dataSource: displayField
      } : valueField;
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        modelClass: itemModel || class extends Model {
          static get idField() {


            return me.valueField;
          }

          static set idField(idField) {
            super.idField = idField;
          }

          static get fields() {
            return [valueFieldDefinition, displayField];
          }

        }
      });
    }
  }

  get items() {
    return this.store.allRecords;
  }


  set value(value) {
    const me = this;

    if (value === me.value) {

      me.syncInputFieldValue(true);
      return;
    }

    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error('Multiple values cannot be set to a non-multiselect Combo');
    }

    me._thisIsAUsedExpression(me.items);

    const {
      valueField,
      displayField,
      store,
      valueCollection
    } = me;


    if (me.filterParamName) {

      if (value != null) {
        const wasConfiguring = me.isConfiguring;
        me.primaryFilter.setConfig({
          value,
          disabled: false
        });
        return store.performFilter(true).then(() => {
          const {
            isConfiguring
          } = me;


          me.isConfiguring = wasConfiguring;
          valueCollection.splice(0, valueCollection.count, store.allRecords);
          me.isConfiguring = isConfiguring;
        });
      }
    } else if (store.filtered) {
      me.primaryFilter.disabled = true;
      store.filter();
    }

    let record;

    if (value != null) {

      const values = Array.isArray(value) ? value.slice() : [value];

      for (let i = 0, len = values.length; i < len; i++) {
        let value = values[i];

        if (value instanceof Model) {

          if (!store.storage.includes(value)) {
            store.add(value);
          }
        } else {
          const isObject = value instanceof Object;

          if (isObject) {
            value = value[valueField];
          }

          record = store.storage.getBy(displayField, value) || store.storage.getBy(valueField, value);

          if (record) {

            if (isObject) {
              record.set(values[i]);
            }

            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }

      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);

      if (valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }


      if (!values.length) {
        me._value = value;
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue = me._value;


        me._value = null;
        me.syncInputFieldValue();
        me.updateEmpty();

        if (!me.isConfiguring) {
          me.trigger('change', {
            value,
            oldValue,
            userAction: me._isUserAction,
            valid: me.isValid
          });
        }
      }
    }
  }

  get value() {
    const me = this;
    return me.multiSelect ? me.valueCollection.map(r => r[me.valueField]) : me.valueCollection.count ? me.valueCollection.first[me.valueField] : me._value;
  }

  syncInputFieldValue(skipHighlight) {


    if (!this.multiSelect) {
      super.syncInputFieldValue(skipHighlight);
    }
  }

  get isEmpty() {
    return this.valueCollection.count === 0;
  }

  get isValid() {
    const me = this;

    if (!me.isConfiguring && me.required && !me.valueCollection.count) {
      me.setError(fieldRequiredErrorName, true);
    } else {
      me.clearError(fieldRequiredErrorName, true);
    }

    return super.isValid;
  }

  get inputValue() {


    let me = this,
      result = me.value;
    result = me.selected ? me.selected[me.displayField] : result;

    if (me.displayValueRenderer) {
      result = me.displayValueRenderer(me.selected);
    }

    return result == null ? '' : result;
  }

  set displayValueRenderer(value) {
    this._displayValueRenderer = value;
  }

  get displayValueRenderer() {
    return this._displayValueRenderer;
  }


  get valueCollection() {
    if (!this._valueCollection) {
      this._valueCollection = new Collection({
        listeners: {
          noChange: 'onValueCollectionNoChange',
          change: 'onValueCollectionChange',
          prio: -1000,

          thisObj: this
        }
      });
    }

    return this._valueCollection;
  }


  set store(store) {
    const me = this,
      {
        filterParamName
      } = me,
      storeFilters = [],
      storeListeners = {
        thisObj: this
      };

    if (Array.isArray(store)) {
      me.initialConfig.store = null;
      return me.items = store;
    }

    if (store && !(store instanceof Store)) {
      store = new (store.readUrl ? AjaxStore : Store)(store);
    }

    if (filterParamName) {
      store.filterParamName = filterParamName;

      if (me.encodeFilterParams) {
        store.encodeFilterParams = me.encodeFilterParams;
      }

      storeListeners.filter = 'onRemoteFilter';
    }

    if (!me.valueField) {
      me.valueField = store.modelClass.idField;
    }

    if (!me.primaryFilter) {


      const id = 'primary';
      me.primaryFilter = new CollectionFilter({
        id,
        property: me.displayField,
        operator: me.filterOperator,
        disabled: true,
        caseSensitive: me.caseSensitive
      });
    }

    storeFilters.push(me.primaryFilter);

    if (filterParamName) {
      if (me.filterSelected) {
        store.storage.autoFilter = true;
        store.storage.addFilter({
          id: `${me.id}-selected-filter`,
          filterBy: r => !me.valueCollection.includes(r)
        });
      }
    } else {
      if (me.filterSelected) {
        me.selectedItemsFilter = r => !me.valueCollection.includes(r);

        storeFilters.push(me.selectedItemsFilter);
        store.reapplyFilterOnAdd = true;
      }
    }

    store.filter(storeFilters);
    me._store = store;

    if (me._picker) {
      me.picker.store = store;
    }

    store.storage.addIndex(me.displayField);
    store.storage.addIndex(me.valueField);

    if (me.displayValueRenderer) {
      storeListeners.change = 'syncInputFieldValue';
      me.syncInputFieldValue();
    }

    store.on(storeListeners);
  }

  get store() {
    return this._store;
  }


  get record() {
    return this.selected;
  }


  get records() {
    return this.valueCollection.values.slice();
  }

  get selected() {
    return this.valueCollection.first;
  }


  onEditComplete() {
    const me = this,
      selectionCount = me.valueCollection.count;
    super.onEditComplete();

    if (selectionCount) {
      me.clearError(fieldvalidateFilterErrorName);
      me.syncInputFieldValue();
    }

    if (me.required && !selectionCount) {
      me.setError(fieldRequiredErrorName);
    }
  }


  onTriggerClick() {
    const me = this;

    if (me.pickerVisible) {
      me.hidePicker();
    } else {
      if (!me.readOnly && !me.disabled) {
        switch (me.triggerAction) {
          case comboQueryAll:
            me.doFilter(null);
            break;

          case comboQueryLast:
            me.doFilter(me.lastQuery);
            break;

          default:
            me.doFilter(me.input.value);
        }
      }
    }
  }


  internalOnInput(event) {
    const me = this,
      value = me.input.value,
      inputLen = value.length;

    if (!me.editable) {
      return;
    }

    me.updateEmpty();
    me.syncInputWidth();

    if (inputLen >= me.minChars) {
      me.filterList(value);
    } else {

      if (me.validateFilter && !me.filterParamName) {
        me[inputLen ? 'setError' : 'clearError'](fieldvalidateFilterErrorName);
      }

      me.hidePicker();
    }


    me.trigger('input', {
      value,
      event
    });
  }

  syncInputWidth() {
    const me = this;

    if (me.multiSelect) {
      const input = me.input,

        inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, 'padding', 'lr')),
        value = input.value || '',
        width =
          DomHelper.measureText(value + 'W', input, false, me.element) + inputPadding.width;


      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }


  filterList(queryString) {
    this.doFilter(queryString);
  }

  doFilter(queryString) {
    const me = this,
      {
        store,
        filterParamName
      } = me,
      disableFilter = queryString == null || queryString == '';
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });

    if (filterParamName) {
      store.clear(true);
    }

    store.filter();
    me.showPicker();

    if (store.count) {

      if (!disableFilter) {
        me.picker.navigator.activeItem = 0;
      }
    } else if (!filterParamName && !disableFilter && me.validateFilter) {
      me.setError(fieldvalidateFilterErrorName);
    }
  }

  onRemoteFilter() {
    const me = this,
      picker = me._picker;

    if (me.store.count) {
      if (picker) {
        picker.navigator.activeItem = 0;
      }
    } else {
      if (me.validateFilter) {
        me.setError(fieldvalidateFilterErrorName);
      }
    }

    if (me.filterSelected && me.valueCollection.count) {
      me.store.storage.onFiltersChanged();


      if (picker) {
        picker.refresh();
      }
    }
  }


  onValueCollectionChange({
                            source: valueCollection
                          }) {
    const me = this,
      {
        multiSelect
      } = me,
      hidePicker = 'hidePickerOnSelect' in me ? me.hidePickerOnSelect : !multiSelect,
      record = multiSelect ? valueCollection.values.slice() : valueCollection.first,
      records = valueCollection.values.slice(),
      isUserAction = me._isUserAction || hidePicker && me.pickerVisible || false,
      oldValue = me._value;

    if (hidePicker) {
      me.hidePicker();
    }

    if (!valueCollection.count && me.required) {
      me.setError(fieldRequiredErrorName);
    } else {
      me.clearError(fieldRequiredErrorName);
      me.clearError(fieldvalidateFilterErrorName);
    }

    if (me.validateFilter && record) {
      me.clearError(fieldvalidateFilterErrorName);
    }


    if (me.filterSelected) {
      if (me.filterParamName) {
        me.store.storage.onFiltersChanged();


        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
    }

    me._value = null;


    const value = me._value = me.value;
    me.syncInputFieldValue();
    me.updateEmpty();

    if (!me.isConfiguring) {
      me.trigger('change', {
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });


      me.trigger('select', {
        record,
        records,
        userAction: me.containsFocus
      });


      if (me.defaultAction === 'select') {
        me.trigger('action', {
          value,
          record,
          records
        });
      }
    }
  }


  onValueCollectionNoChange({
                              toAdd
                            }) {
    if (!this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
    }
  }


  showPicker() {
    const me = this,
      {
        picker
      } = me;
    super.showPicker();

    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }


    if (!me.multiSelect && me.selected) {
      picker.restoreActiveItem(me.selected, true);
    }

    me.input.focus();
  }


  createPicker(pickerConfig) {
    const me = this,
      {
        multiSelect
      } = me,
      pickerWidth = me.pickerWidth || pickerConfig.width,
      picker = WidgetHelper.createWidget(ObjectHelper.merge({
        type: 'list',
        owner: me,
        floating: true,
        scrollAction: 'realign',
        itemsFocusable: false,
        activateOnMouseover: true,
        store: me.store,
        selected: me.valueCollection,
        multiSelect,
        cls: me.listCls,
        itemTpl: me.listItemTpl || (item => item[me.displayField]),
        forElement: me[me.pickerAlignElement],
        align: {
          align: 't-b',
          axisLock: true,
          matchSize: pickerWidth == null,
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement]
        },
        width: pickerWidth,
        navigator: {
          keyEventTarget: me.input
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      }, pickerConfig));
    picker.element.dataset.emptyText = me.emptyText || me.L('No results');
    return picker;
  }

  onPickerHide() {
    const me = this;
    super.onPickerHide();

    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = '';
    }
  }

}


Combo.queryAll = comboQueryAll;


Combo.queryLast = comboQueryLast;

class MultiSelectChipView extends ChipView {
  static get $name() {
    return 'MultiSelectChipView';
  }

  static get defaultConfig() {
    return {
      itemsFocusable: false,
      multiSelect: true,
      closeHandler: 'up.onChipClose',
      itemTpl: function (record) {
        return record[this.owner.displayField];
      }
    };
  }

}

class MultiSelectChipNavigator extends Navigator {
  static get defaultConfig() {
    return {
      allowShiftKey: true
    };
  }

  onTargetClick(clickEvent) {
    const item = clickEvent.target.closest(this.itemSelector);

    if (item && !clickEvent.shiftKey && !item.contains(clickEvent.target.closest('[data-noselect]'))) {
      this.ownerCmp.selected.clear();
    }


    super.activeItem = item;
  }

  onKeyDown(keyEvent) {


    if (keyEvent.key !== 'Enter') {
      super.onKeyDown(keyEvent);
    }
  }

  set activeItem(activeItem) {
    const chipView = this.ownerCmp;

    activeItem = chipView.getItem(activeItem);
    super.activeItem = activeItem;

    if (activeItem) {
      chipView.selected.add(chipView.getRecord(activeItem));
    }
  }

  get activeItem() {
    return super.activeItem;
  }

  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;

    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }

    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }

  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;

    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }

    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }

}

Combo._$name = 'Combo';
BryntumWidgetAdapterRegister.register('combo', Combo);
BryntumWidgetAdapterRegister.register('combobox', Combo);
BryntumWidgetAdapterRegister.register('dropdown', Combo);


class Month {

  constructor(config) {
    let {
      date,
      weekStartDay,
      sixWeeks
    } = config;
    this.constructor.updateDayNumbers(weekStartDay);
    this.sixWeeks = sixWeeks;
    this.date = date;
  }

  set date(date) {
    const isString = typeof date === 'string';
    date = new Date(date);


    if (isString) {
      if (isNaN(date)) {
        throw new Error('CalendarPanel date ingestion must be passed a Date, or a valid argument to the Date constructor');
      }

      date = DateHelper.add(date, date.getTimezoneOffset(), 'minute');
    }

    const me = this,
      monthStart = DateHelper.getFirstDateOfMonth(date),
      monthEnd = DateHelper.getLastDateOfMonth(monthStart),
      startWeekDay = me.dayNumbers[monthStart.getDay()],
      endWeekDay = me.dayNumbers[monthEnd.getDay()];
    me._date = date;


    me.startDayOfMonth = 1 - startWeekDay;


    me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);

    if (me.sixWeeks) {
      while (me.weekCount < 6) {
        me.endDayOfMonth += 7;
      }
    }

    const jan1 = new Date(me.year, 0, 1),
      dec31 = new Date(me.year, 1, 31),
      january = me.month ? new Month({
        date: jan1,
        weekStartDay: me.weekStartDay
      }) : me;


    if (me.dayNumbers[jan1.getDay()] > 3) {

      me.weekBase = january.startDate;
    } else {

      me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
    }

    me.has53weeks = dec31.getDay() < 4;
  }

  set year(year) {
    this.date.setFullYear(year);
    this.date = this.date;
  }

  get year() {
    return this.date.getFullYear();
  }

  set month(month) {
    this.date.setMonth(month);
    this.date = this.date;
  }

  get month() {
    return this.date.getMonth();
  }

  get date() {
    return this._date;
  }


  get dayCount() {


    return this.endDayOfMonth + 1 - this.startDayOfMonth;
  }


  get weekCount() {
    return this.dayCount / 7;
  }


  get startDate() {
    return new Date(this.year, this.month, this.startDayOfMonth);
  }


  get endDate() {
    return new Date(this.year, this.month, this.endDayOfMonth);
  }


  eachDay(fn) {
    const me = this;

    for (let dayOfMonth = me.startDayOfMonth; dayOfMonth <= me.endDayOfMonth; dayOfMonth++) {
      fn(new Date(me.year, me.month, dayOfMonth));
    }
  }


  eachWeek(fn) {
    const me = this,
      {
        weekCount
      } = me;

    for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
      const weekDates = [],
        weekOfYear = me.getWeekNumber(new Date(me.year, me.month, Math.max(dayOfMonth, 1)));

      for (let day = 0; day < 7; day++, dayOfMonth++) {
        weekDates.push(new Date(me.year, me.month, dayOfMonth));
      }

      fn(weekOfYear, weekDates);
    }
  }

  getWeekNumber(date) {
    const me = this,
      {
        weekStartDay
      } = me;
    date = DateHelper.clearTime(date);


    if (date < me.startDate || date > me.endDate) {
      return new Month({
        date,
        weekStartDay
      }).getWeekNumber(date);
    }

    let weekNo = Math.floor((date - me.weekBase) / 86400000 / 7),
      year = date.getFullYear();

    if (!weekNo) {
      const lastDec31 = new Date(me.year, 0, 0);

      return new Month({
        date: lastDec31,
        weekStartDay
      }).getWeekNumber(lastDec31);
    } else if (weekNo === 53 && !me.has53weeks) {
      weekNo = 1;
      year++;
    }

    return [year, weekNo];
  }

  static applyLocale() {
    this.updateDayNumbers();
  }

  static updateDayNumbers(weekStartDay = DateHelper.weekStartDay) {
    const me = this.prototype,
      dayNumbers = me.dayNumbers = [],
      canonicalDayNumbers = me.canonicalDayNumbers = [];
    me.weekStartDay = weekStartDay;


    for (let i = 0; i < 7; i++) {
      const canonicalDay = (weekStartDay + i) % 7;
      canonicalDayNumbers[i] = canonicalDay;
      dayNumbers[canonicalDay] = i;
    }
  }

}

LocaleManagerSingelton.on({
  locale: 'applyLocale',
  thisObj: Month
});
Month._$name = 'Month';


class CalendarPanel extends Panel {
  static get $name() {
    return 'CalendarPanel';
  }

  static get defaultConfig() {
    return {

      weekStartDay: null,


      sixWeeks: true,


      showWeekNumber: false,


      disabledDates: null,


      headerRenderer: null,


      weekRenderer: null,


      cellRenderer: null,


      disableWeekends: null,


      tip: null,


      cellCls: 'b-calendar-cell',


      disabledCls: 'b-disabled-date',


      otherMonthCls: 'b-other-month',


      weekendCls: 'b-weekend',


      todayCls: 'b-today'
    };
  }

  construct(config) {
    LocaleManagerSingelton.on({
      locale: calculateDayNames
    });
    calculateDayNames();
    super.construct(config);
    this.refresh();
  }

  doDestroy() {
    this.tip && this.tip.destroy();
    super.doDestroy();
  }

  ingestDate(date) {
    if (!(date instanceof Date)) {
      date = new Date(date);

      if (isNaN(date)) {
        throw new Error('CalendarPanel date ingestion must be passed a Date, or a valid argument to the Date constructor');
      }


      const tzo = date.getTimezoneOffset();

      if (tzo) {
        date = DateHelper.add(date, tzo, 'minute');
      }
    }

    return DateHelper.clearTime(date);
  }

  set tip(tip) {
    this._tip = new Tooltip(Object.assign({
      forElement: this.element,
      forSelector: '.b-calendar-cell'
    }, tip));

    this._tip.on({
      pointerOver: 'onTipOverCell',
      thisObj: this
    });
  }

  get tip() {
    return this._tip;
  }

  get element() {
    return super.element;
  }

  set element(element) {
    const me = this;
    super.element = element;
    me.weekElements = Array.from(me.element.querySelectorAll('.b-calendar-week'));
    me.cellElements = Array.from(me.element.querySelectorAll('.b-calendar-week > div'));
  }


  set date(date) {
    const me = this;
    date = me._date = me.ingestDate(date);

    if (!me.month || me.month.month !== date.getMonth()) {
      me.month = new Month({
        date,
        weekStartDay: me.weekStartDay,
        sixWeeks: me.sixWeeks
      });
    }

    me.refresh();
  }

  get date() {
    return this._date;
  }

  set month(month) {
    if (month instanceof Month) {
      this._month = month;
    } else {
      this.month.month = month;
      this.refresh();
    }
  }

  get month() {
    return this._month;
  }

  set year(year) {
    this.month.year = year;
    this.refresh();
  }

  get year() {
    return this.month.year;
  }

  set showWeekNumber(showWeekNumber) {
    const me = this;
    me.element.classList[showWeekNumber ? 'add' : 'remove']('b-show-week-number');

    if (me.floating) {

      if (!me.isAligning) {
        me.realign();
      }
    }
  }

  refresh() {
    const me = this,
      today = DateHelper.clearTime(new Date()),
      {
        cellElements,
        weekElements,
        date,
        month,
        cellCls,
        disabledCls,
        otherMonthCls,
        weekendCls,
        todayCls
      } = me;

    if (!date) {
      return me.date = today;
    }

    for (let i = 0, len = cellElements.length; i < len; i++) {
      cellElements[i].className = cellElements[i].innerHTML = '';
    }

    for (let i = 0; i < 7; i++) {
      const cell = me.weekdayCells[i];
      cell.className = cell.innerHTML = '';

      if (me.headerRenderer) {
        me.headerRenderer(cell, i);
      } else {
        cell.innerHTML = shortDayNames[me.canonicalDayNumbers[i]];
      }

      cell.classList.add('b-calendar-day-header');
    }

    let weekIndex = 0,
      cellIndex = 0;
    month.eachWeek((week, dates) => {
      const weekElement = weekElements[weekIndex],
        weekCells = weekElement.children;
      weekCells[0].className = 'b-week-number-cell';

      if (me.weekRenderer) {
        me.weekRenderer(weekCells[0], week);
      } else {
        weekCells[0].innerHTML = week[1];
      }

      for (let i = 0; i < 7; i++) {
        const cellDate = dates[i],
          cellDay = cellDate.getDay(),
          cell = weekCells[i + 1],
          cellClassList = cell.classList;
        cellClassList.add(cellCls);

        if (me.isDisabledDate(cellDate)) {
          cellClassList.add(disabledCls);
        }

        if (cellDate.getMonth() !== month.month) {
          cellClassList.add(otherMonthCls);
        }

        if (cellDay === 0 || cellDay === 6) {
          cellClassList.add(weekendCls);
        }

        if (cellDate.getTime() === today.getTime()) {
          cellClassList.add(todayCls);
        }

        cell.dataset.date = DateHelper.format(cellDate, 'YYYY-MM-DD');
        cell.dataset.cellIndex = cellIndex;

        if (me.cellRenderer) {
          me.cellRenderer(cell, cellDate);
        } else {
          cell.innerHTML = cellDate.getDate();
        }

        cellIndex++;
      }

      weekIndex++;
    });

    if (me.floating) {

      if (!me.isAligning) {
        me.realign();
      }
    }
  }

  isDisabledDate(date) {
    const day = date.getDay(),
      disabledDates = this.disabledDates;

    if (this.disableWeekends && (day === 0 || day === 6)) {
      return true;
    }

    if (disabledDates) {
      if (typeof disabledDates === 'function') {
        return disabledDates(date);
      }

      if (Array.isArray(disabledDates)) {
        return disabledDates.some(d => DateHelper.clearDate(d, true).getTime() === DateHelper.clearDate(date, true).getTime());
      }
    }
  }

  get bodyConfig() {
    const result = super.bodyConfig,
      weeksContainerChildren = [];
    result.children = [{
      tag: 'div',
      className: 'b-calendar-row b-calendar-weekdays',
      children: this.dayNameCells
    }, {

      className: 'b-weeks-container notranslate',
      reference: 'weeksElement',
      children: weeksContainerChildren
    }];

    for (let i = 0; i < 6; i++) {
      let weekRow = {
        className: 'b-calendar-row b-calendar-week',
        children: []
      };

      for (let j = 0; j < 8; j++) {
        weekRow.children.push({});
      }

      weeksContainerChildren.push(weekRow);
    }

    return result;
  }


  set weekStartDay(weekStartDay) {
    const me = this;
    me.dayNames = [];
    me.dayNumbers = [];
    me.canonicalDayNumbers = [];
    me._weekStartDay = weekStartDay != null ? weekStartDay : DateHelper.weekStartDay;


    for (let i = 0; i < 7; i++) {
      const canonicalDay = (me._weekStartDay + i) % 7;
      me.canonicalDayNumbers[i] = canonicalDay;
      me.dayNumbers[canonicalDay] = i;
      me.dayNames[i] = shortDayNames[canonicalDay];
    }
  }

  get weekStartDay() {
    if (!this.hasOwnProperty('_weekStartDay')) {
      this.weekStartDay = undefined;
    }

    return this._weekStartDay;
  }

  get dayNameCells() {
    const me = this,
      weekNumberHeader = document.createElement('div'),
      result = [weekNumberHeader],
      weekdayCells = me.weekdayCells = [];
    weekNumberHeader.className = 'b-week-number-cell';

    me._thisIsAUsedExpression(me.weekStartDay);

    for (let i = 0; i < 7; i++) {
      const cell = document.createElement('div');
      result.push(cell);
      weekdayCells.push(cell);
    }

    return result;
  }

  onTipOverCell({
                  source: tip,
                  target
                }) {
    tip.date = DateHelper.parse(target.dataset.date, 'YYYY-MM-DD');
  }

}

function calculateDayNames() {
  shortDayNames.length = 0;

  for (let date = 2; date < 9; date++) {
    d.setDate(date);
    shortDayNames.push(DateHelper.format(d, 'ddd'));
  }
}


const d = new Date('2000-01-01T00:00:00'),
  shortDayNames = [];
CalendarPanel._$name = 'CalendarPanel';
BryntumWidgetAdapterRegister.register('calendarpanel', CalendarPanel);


class Fit extends Layout {
  static get $name() {
    return 'Fit';
  }

  static get defaultConfig() {
    return {
      containerCls: 'b-fit-container',
      itemCls: 'b-fit-item'
    };
  }

}


Fit._$name = 'Fit';
Layout.registerLayout(Fit);


class Editor extends Container {

  static get $name() {
    return 'Editor';
  }

  static get defaultConfig() {
    return {
      positioned: true,
      hidden: true,
      layout: 'fit',
      align: {
        align: 't0-t0',
        offset: [0, 0]
      },


      inputField: 'textfield',


      blurAction: 'complete',


      completeKey: 'Enter',


      cancelKey: 'Escape',


      allowInvalid: null,


      invalidAction: 'block',


      completeOnChange: null
    };
  }


  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);

    if (me.completeKey || me.cancelKey) {
      EventHelper.on({
        element: me.element,
        keydown: 'onKeyDown',
        thisObj: me
      });
    }

    me.on({
      hide: 'afterHide',
      thisObj: me
    });
    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      thisObj: me
    });
  }

  onLocaleChange() {
    const {
      inputField
    } = this;

    if (inputField && !inputField.isDestroyed) {


      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      }
    }
  }


  startEdit({
              target,
              align = this.align,
              hideTarget = false,
              matchSize = true,
              matchFont = true,
              fitTargetContent = false,
              value,
              record,
              field = this.inputField.name,
              focus = true
            }) {
    const me = this,
      {
        inputField
      } = me,
      targetFontSize = DomHelper.getStyleValue(target, 'font-size'),
      targetFontFamily = DomHelper.getStyleValue(target, 'font-family');

    if (me.trigger('beforestart', {
      value
    }) !== false) {
      if (record && field && value === undefined) {
        me.record = record;
        me.dataField = field;
        value = record[field];
      }

      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target);
        }


        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }

      if (inputField.input) {
        if (matchFont) {
          inputField.input.style.fontSize = targetFontSize;
          inputField.input.style.fontFamily = targetFontFamily;
        } else {
          inputField.input.style.fontSize = inputField.input.style.fontFamily = '';
        }
      }

      if (inputField.clearError) {
        inputField.clearError();
      }

      inputField.value = value;


      inputField.initialValue = inputField.value;
      me.showBy({
        target,
        ...align
      });

      if (fitTargetContent) {

        const overflow = inputField.input.scrollWidth - inputField.input.clientWidth;

        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }

      if (focus && me.inputField.focus) {
        me.inputField.focus();
      }

      if (target.nodeType === 1) {
        target.classList.add('b-editing');

        if (hideTarget) {
          target.classList.add('b-hide-visibility');
        }
      }

      me.trigger('start', {
        value: inputField.value
      });
      me.oldValue = inputField.value;


      if (Array.isArray(me.oldValue)) {
        me.oldValue = me.oldValue.slice();
      }

      return true;
    }

    return false;
  }

  refreshEdit() {
    if (this.isVisible) {
      const {
        record,
        dataField,
        inputField
      } = this;

      if (record && dataField) {
        const value = record[dataField];

        if (!ObjectHelper.isEqual(inputField.value, value)) {
          inputField.value = value;
        }
      }
    }
  }

  onKeyDown(event) {
    const me = this;

    switch (event.key) {
      case me.completeKey:
        me.completeEdit();
        event.stopImmediatePropagation();
        break;

      case me.cancelKey:
        me.cancelEdit();
        event.stopImmediatePropagation();
        break;
    }

    me.trigger('keydown', {
      event
    });
  }

  onFocusOut(event) {
    super.onFocusOut(event);

    if (!this.isFinishing) {
      const method = this[`${this.blurAction}Edit`];

      if (method) {
        method.call(this);
      }
    }
  }

  set allowInvalid(allowInvalid) {
    this._allowInvalid = allowInvalid;
    this.invalidAction = allowInvalid ? 'allow' : 'block';
  }

  get allowInvalid() {
    return this._allowInvalid;
  }


  async completeEdit(finalize) {
    const me = this,
      {
        inputField,
        oldValue,
        record
      } = me,
      invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? 'block' : me.invalidAction),
      {
        value
      } = inputField;

    if (!inputField.isValid) {
      if (invalidAction === 'block') {
        inputField.focus && inputField.focus();
        return false;
      } else if (invalidAction === 'revert') {
        me.cancelEdit();
        return true;
      }
    } else if (ObjectHelper.isEqual(value, oldValue)) {
      me.cancelEdit();
      return true;
    } else {
      const context = {
        inputField,
        record,
        value,
        oldValue
      };

      if (me.trigger('beforeComplete', context) === false) {
        inputField.focus && inputField.focus();
      } else {

        if (!finalize) {
          finalize = context.finalize || context.editorContext && context.editorContext.finalize;
        }

        if (finalize) {
          let result = await finalize(context);

          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.L('invalidValue'),
                clearError = () => {
                  listeners();
                  inputField.clearError(error);
                },
                listeners = inputField.on({
                  change: clearError,
                  input: clearError
                });


              inputField.setError(error);
            }

            if (invalidAction === 'block') {
              inputField.focus && inputField.focus();
            } else if (invalidAction === 'revert') {
              inputField.value = oldValue;
              result = true;
            }

            result = false;
          }

          return result;
        } else {
          me.onEditComplete();
          return true;
        }
      }
    }

    return false;
  }


  cancelEdit() {
    const me = this,
      {
        inputField,
        oldValue,
        lastAlignSpec
      } = me,
      {
        target
      } = lastAlignSpec,
      {
        value
      } = inputField;

    if (!me.isFinishing && me.trigger('beforeCancel', {
      value: value,
      oldValue
    }) !== false) {

      me.isFinishing = true;
      me.hide();
      me.trigger('cancel', {
        value,
        oldValue
      });

      if (target.nodeType === 1) {
        target.classList.remove('b-editing');
        target.classList.remove('b-hide-visibility');
      }

      me.isFinishing = false;
    }
  }

  onEditComplete() {
    const me = this,
      {
        record,
        dataField,
        inputField,
        oldValue,
        lastAlignSpec
      } = me,
      {
        target
      } = lastAlignSpec,
      {
        value
      } = inputField;

    if (!me.isFinishing) {

      me.isFinishing = true;
      me.hide();

      if (record) {
        const setterName = `set${StringHelper.capitalizeFirstLetter(dataField)}`;

        if (record[setterName]) {
          record[setterName](value);
        } else {
          record[dataField] = value;
        }
      }

      me.trigger('complete', {
        value,
        oldValue
      });

      if (target.nodeType === 1) {
        target.classList.remove('b-editing');
        target.classList.remove('b-hide-visibility');
      }

      me.isFinishing = false;
    }
  }

  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }

    super.doDestroy();
  }

  set owner(owner) {
    this._owner = owner;
  }


  get owner() {
    return this._owner || IdHelper.fromElement(this.element.parentNode);
  }

  set inputField(inputField) {
    const me = this;

    if (me._inputField) {
      me._inputField.destroy();
    }

    if (typeof inputField === 'string') {
      inputField = {
        type: inputField
      };
    }

    if (inputField instanceof Widget) {
      me._inputField = inputField;
    } else {
      me._inputField = WidgetHelper.createWidget(inputField);
      me.createdInputField = true;
    }

    if (me.completeOnChange) {
      me._inputField.on({
        change: 'onInputFieldChange',
        thisObj: me
      });
    }

    me._inputField.parent = me;
    me.removeAll();
    me.add(inputField);
  }

  get inputField() {
    return this.items[0];
  }

  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }

  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }

  updateSize(targetEl) {
    const rect = targetEl.getBoundingClientRect();
    this.width = rect.width - this.align.offset[0];
    this.height = rect.height;
  }

  afterHide() {
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }

}

Editor._$name = 'Editor';
BryntumWidgetAdapterRegister.register('editor', Editor);


class DatePicker extends CalendarPanel {
  static get $name() {
    return 'DatePicker';
  }

  static get defaultConfig() {
    return {
      focusable: true,
      tools: {
        prevMonth: {
          align: 'start',
          cls: 'b-icon b-icon-angle-left',
          handler: 'gotoPrevMonth'
        },
        nextMonth: {
          align: 'end',
          cls: 'b-icon b-icon-angle-right',
          handler: 'gotoNextMonth'
        }
      },
      header: {
        title: '<div class="b-editable b-datepicker-month" reference="monthElement"></div> <div class="b-editable b-datepicker-year" reference="yearElement"></div>',
        titleAlign: 'center'
      },


      minDate: null,


      maxDate: null,


      outOfRangeCls: 'b-out-of-range',


      activeCls: 'b-active-date',


      selectedCls: 'b-selected-date',


      focusDisabledDates: null,


      multiSelect: false,


      editOnHover: true
    };
  }


  construct(config) {
    const me = this;
    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      thisObj: me
    });
    me.selection = [];
    me.refresh = me.createOnFrame(me.refresh);
    super.construct(config);
    me.element.setAttribute('aria-activedescendant', `${me.id}-active-day`);
    EventHelper.on({
      element: me.element,
      mouseover: 'onPickerMouseover',
      mousedown: 'onPickerMousedown',
      click: 'onPickerClick',
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
  }

  doDestroy() {
    if (this._yearEditor) {
      this._yearEditor.destroy();
    }

    if (this._monthEditor) {
      this._monthEditor.destroy();
    }

    super.doDestroy();
  }

  get focusElement() {
    return this.element;
  }

  eachWidget(fn, deep) {
    const widgets = this.items || [];

    if (this._yearEditor) {
      widgets.unshift(this._yearEditor);
    }

    if (this._monthEditor) {
      widgets.unshift(this._monthEditor);
    }

    for (let i = 0; i < widgets.length; i++) {
      const widget = widgets[i];

      if (fn(widget) === false) {
        return;
      }

      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    }
  }

  refresh() {
    const me = this,
      sbw = DomHelper.scrollBarWidth;
    super.refresh();
    me.monthElement.style.minWidth = `calc(${me.maxMonthLength + 1}ch + ${sbw}px)`;
    me.monthElement.innerHTML = DateHelper.format(me.month.date, 'MMMM');
    me.yearElement.style.minWidth = sbw ? `calc(3ch + ${sbw}px` : '7ch';
    me.yearElement.innerHTML = DateHelper.format(me.month.date, 'YYYY');
  }

  cellRenderer(cell, cellDate) {
    const me = this,
      {
        activeCls,
        selectedCls
      } = me,
      cellClassList = cell.classList;
    cell.innerHTML = cellDate.getDate();
    cell.setAttribute('aria-label', DateHelper.format(cellDate, 'MMMM D, YYYY'));

    if (me.isActiveDate(cellDate)) {
      cellClassList.add(activeCls);
      cell.id = `${me.id}-active-day`;
    }

    if (me.isSelectedDate(cellDate)) {
      cellClassList.add(selectedCls);
    }

    if (me.minDate && cellDate < me.minDate) {
      cellClassList.add(me.outOfRangeCls);
    } else if (me.maxDate && cellDate > me.maxDate) {
      cellClassList.add(me.outOfRangeCls);
    }
  }

  onPickerMousedown(event) {
    event.preventDefault();
  }

  onPickerMouseover(event) {
    if (this.editOnHover) {
      const editable = DomHelper.up(event.target, '.b-editable');

      if (editable) {
        return this.onEditGesture(event);
      }
    }
  }

  onPickerClick(event) {
    const me = this,
      {
        target
      } = event,
      cell = DomHelper.up(target, `.${me.cellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`),
      editable = DomHelper.up(target, '.b-editable');

    if (cell) {
      return me.onCellClick(event);
    }

    if ((!me.editOnHover || DomHelper.isTouchEvent) && editable) {
      return me.onEditGesture(event);
    }

    if (me._monthEditor && !me._monthEditor.owns(event)) {
      me._monthEditor.cancelEdit();
    }

    if (me._yearEditor && !me._yearEditor.owns(event)) {
      me._yearEditor.cancelEdit();
    }
  }

  onCellClick(event) {
    this.onDateActivate(DateHelper.parse(event.target.dataset.date, 'YYYY-MM-DD'), event);
  }

  onEditGesture(event) {
    const me = this,
      {
        month
      } = me,
      {
        target
      } = event;

    if (target === me.monthElement) {
      me.monthEditor.startEdit({
        target,
        value: month.month,
        fitTargetContent: false,
        hideTarget: true
      });
    } else if (target === me.yearElement) {
      me.yearEditor.minWidth = `calc(50px + ${DomHelper.scrollBarWidth}px)`;
      me.yearEditor.startEdit({
        target,
        value: month.year,
        fitTargetContent: true,
        hideTarget: true
      });
    }
  }

  onDateActivate(date, event) {
    const me = this,
      {
        lastClickedDate,
        selection
      } = me;
    me.activeDate = date;
    me.lastClickedDate = date;


    if (me.multiSelect) {
      if (me.multiRange) ; else if (!lastClickedDate || date.getTime() !== lastClickedDate.getTime()) {
        if (lastClickedDate && event.shiftKey) {
          selection[1] = date;
          selection.sort();
        } else {
          selection.length = 0;
          selection[0] = date;
        }

        me.trigger('selectionChange', {
          selection
        });
      }
    } else {
      if (!me.value || me.value.getTime() !== date.getTime()) {
        me.value = date;
      } else {
        me.hide();
      }
    }
  }

  onPickerKeyDown(keyEvent) {
    const me = this,
      keyName = keyEvent.key.trim() || keyEvent.code,
      activeDate = me.activeDate,
      newDate = new Date(activeDate);

    if (activeDate) {
      do {
        switch (keyName) {
          case 'Escape':
            me.hide();
            break;

          case 'ArrowLeft':


            keyEvent.preventDefault();

            if (keyEvent.ctrlKey) {
              newDate.setMonth(newDate.getMonth() - 1);
            } else {
              newDate.setDate(newDate.getDate() - 1);
            }

            break;

          case 'ArrowUp':


            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() - 7);
            break;

          case 'ArrowRight':


            keyEvent.preventDefault();

            if (keyEvent.ctrlKey) {
              newDate.setMonth(newDate.getMonth() + 1);
            } else {
              newDate.setDate(newDate.getDate() + 1);
            }

            break;

          case 'ArrowDown':


            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() + 7);
            break;

          case 'Enter':
            me.onDateActivate(activeDate, keyEvent);
            break;
        }
      } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);

      if (me.minDate && newDate < me.minDate) {
        return;
      }

      if (me.maxDate && newDate > me.maxDate) {
        return;
      }

      me.activeDate = newDate;
    }
  }

  set minDate(minDate) {
    this._minDate = minDate ? this.ingestDate(minDate) : null;
    this.refresh();
  }

  get minDate() {
    return this._minDate;
  }

  set maxDate(maxDate) {
    this._maxDate = maxDate ? this.ingestDate(maxDate) : null;
    this.refresh();
  }

  get maxDate() {
    return this._maxDate;
  }

  set activeDate(activeDate) {
    const me = this;

    if (activeDate) {
      me._activeDate = me.ingestDate(activeDate);
    } else {
      me._activeDate = DateHelper.clearTime(new Date());
    }

    if (me.month.month !== me._activeDate.getMonth()) {
      me.month.date = me._activeDate;
    }

    me.refresh();
  }

  get activeDate() {
    return this._activeDate;
  }

  set value(date) {
    const me = this,
      {
        selection
      } = me;
    let changed;

    if (date) {
      date = me.ingestDate(date);

      if (!me.value || date.getTime() !== me.value.getTime()) {
        selection.length = 0;
        selection[0] = date;
        changed = true;
      }

      me.date = date;
    } else {
      changed = selection.length;
      selection.length = 0;

      me.date = new Date();
    }

    if (changed) {
      me.trigger('selectionChange', {
        selection
      });
    }
  }

  get value() {
    return this.selection[this.selection.length - 1];
  }

  gotoPrevMonth() {
    const date = this.date;
    date.setMonth(date.getMonth() - 1);
    this.date = date;
  }

  gotoNextMonth() {
    const date = this.date;
    date.setMonth(date.getMonth() + 1);
    this.date = date;
  }

  isActiveDate(date) {
    return this.activeDate && this.ingestDate(date).getTime() === this.activeDate.getTime();
  }

  isSelectedDate(date) {
    return this.selection.some(d => d.getTime() === date.getTime());
  }

  get monthEditor() {
    const me = this;

    if (!me._monthEditor) {
      me._monthEditor = new Editor({
        owner: me,
        appendTo: me.element,
        inputField: me.monthInput = new Combo({
          editable: false,
          autoExpand: !me.editOnHover,
          items: me.monthItems,
          highlightExternalChange: false,
          picker: {
            align: {
              align: 't0-b0'
            },
            cls: 'b-month-picker-list',
            scrollable: {
              overflowX: false
            }
          }
        }),
        completeOnChange: true,
        listeners: {
          complete: 'onMonthPicked',
          thisObj: me
        }
      });
    }

    return me._monthEditor;
  }

  onMonthPicked({
                  value
                }) {
    this.month = value;
  }

  get yearEditor() {
    const me = this;

    if (!me._yearEditor) {
      me._yearEditor = new Editor({
        owner: me,
        appendTo: me.element,
        inputField: me.yearInput = new Combo({
          editable: false,
          autoExpand: !me.editOnHover,
          items: me.yearItems,
          highlightExternalChange: false,
          picker: {
            cls: 'b-year-picker-list',
            scrollable: {
              overflowX: false
            }
          }
        }),
        completeOnChange: true,
        listeners: {
          complete: 'onYearPicked',
          thisObj: me
        }
      });
    }

    return me._yearEditor;
  }

  onYearPicked({
                 value
               }) {
    this.year = value;
  }

  get monthItems() {
    return DateHelper.getMonthNames().map((m, i) => [i, m]);
  }

  get yearItems() {
    const result = [],
      middle = new Date().getFullYear();

    for (let y = middle - 20; y < middle + 21; y++) {
      result.push(y);
    }

    return result;
  }

  get maxMonthLength() {
    if (!this._maxMonthLength) {
      this._maxMonthLength = 0;

      for (let i = 0, months = this.monthItems; i < 12; i++) {
        this._maxMonthLength = Math.max(this._maxMonthLength, months[i][1].length);
      }
    }

    return this._maxMonthLength;
  }

  onLocaleChange() {
    if (this._monthEditor) {
      this._monthEditor.doDestroy();

      this._monthEditor = null;
    }

    if (this._yearEditor) {
      this._yearEditor.doDestroy();

      this._yearEditor = null;
    }

    this._maxMonthLength = 0;
  }

}

DatePicker._$name = 'DatePicker';
BryntumWidgetAdapterRegister.register('datepicker', DatePicker);


class DateField extends PickerField {

  static get $name() {
    return 'DateField';
  }

  static get defaultConfig() {
    return {

      format: 'L',

      fallbackFormat: 'YYYY-MM-DD',
      timeFormat: 'HH:mm:ss:SSS',


      keepTime: false,


      pickerFormat: null,
      triggers: {
        expand: {
          cls: 'b-icon-calendar',
          handler: 'onTriggerClick',
          weight: 200
        }
      },
      stepTriggers: {
        back: {
          cls: 'b-icon-angle-left b-step-trigger',
          handler: 'onBackClick',
          align: 'start',
          weight: 100
        },
        forward: {
          cls: 'b-icon-angle-right b-step-trigger',
          handler: 'onForwardClick',
          align: 'end',
          weight: 100
        }
      },

      calendarContainerCls: '',


      min: null,


      max: null,


      step: null,


      picker: null,


      value: null
    };
  }


  inputTemplate() {
    const me = this;
    return TemplateHelper.tpl`<input type="${me.inputType || 'text'}"
            reference="input"
            class="${me.inputCls || ''}"
            min="${me.min}"
            max="${me.max}"
            placeholder="${me.placeholder}"
            name="${me.name || me.id}"
            id="${me.id + '_input'}"/>`;
  }


  createPicker(picker) {
    const me = this;
    picker = new DatePicker(Object.assign({
      owner: me,
      forElement: me[me.pickerAlignElement],
      floating: true,
      scrollAction: 'realign',
      align: {
        align: 't0-b0',
        axisLock: true,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      value: me.value,
      minDate: me.min,
      maxDate: me.max,
      onSelectionChange: ({
                            selection,
                            source: picker
                          }) => {

        if (picker.isVisible) {
          me._isUserAction = true;
          me.value = selection[0];
          me._isUserAction = false;
          picker.hide();
        }
      }
    }, picker));

    if (me.calendarContainerCls) {
      picker.element.classList.add(me.calendarContainerCls);
    }

    return picker;
  }

  set triggers(triggers) {
    super.triggers = ObjectHelper.assign(triggers, this.stepTriggers);
  }

  get triggers() {
    return super.triggers;
  }

  onBackClick() {
    const me = this,
      {
        min
      } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me._step.magnitude, me._step.unit);

      if (!min || min.getTime() <= newValue) {
        me.value = newValue;
      }
    }
  }

  onForwardClick() {
    const me = this,
      {
        max
      } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me._step.magnitude, me._step.unit);

      if (!max || max.getTime() >= newValue) {
        me.value = newValue;
      }
    }
  }


  showPicker(focusPicker) {
    this.picker.value = this.picker.activeDate = this.value;
    super.showPicker(focusPicker);
  }

  focusPicker() {
    this.picker.focus();
  }


  get isValid() {
    const me = this,
      min = me.min,
      max = me.max;
    me.clearError('minimumValueViolation', true);
    me.clearError('maximumValueViolation', true);
    let value = me.value;

    if (value) {
      value = value.getTime();

      if (min && min.getTime() > value) {
        me.setError('minimumValueViolation', true);
        return false;
      }

      if (max && max.getTime() < value) {
        me.setError('maximumValueViolation', true);
        return false;
      }
    }

    return super.isValid;
  }


  transformDateValue(value) {
    if (value != null) {
      if (!DateHelper.isDate(value)) {
        if (typeof value === 'string') {

          value = DateHelper.parse(value, this.format) || DateHelper.parse(value, this.fallbackFormat);
        } else {
          value = new Date(value);
        }
      }

      if (DateHelper.isValidDate(value)) {
        return this.transformTimeValue(value);
      }
    }

    return null;
  }

  transformTimeValue(value) {
    const keep = this.keepTime;
    value = DateHelper.clone(value);

    if (!keep) {
      DateHelper.clearTime(value, false);
    } else {
      const timeValue = DateHelper.parse(keep, this.timeFormat);

      if (DateHelper.isValidDate(timeValue)) {
        DateHelper.copyTimeValues(value, timeValue);
      } else if (DateHelper.isValidDate(this.value)) {
        DateHelper.copyTimeValues(value, this.value);
      }

    }

    return value;
  }


  set min(value) {
    const me = this;
    me._min = me.transformDateValue(value);
    me.input && (me.input.min = me._min);

    if (me._picker) {
      me._picker.minDate = me._min;
    }

    me.updateInvalid();
  }

  get min() {
    return this._min;
  }


  set max(value) {
    const me = this;
    me._max = me.transformDateValue(value);
    me.input && (me.input.max = me._max);

    if (me._picker) {
      me._picker.maxDate = me._max;
    }

    me.updateInvalid();
  }

  get max() {
    return this._max;
  }


  set value(value) {
    const me = this,
      oldValue = me.value,
      picker = me._picker,
      newValue = me.transformDateValue(value);

    if (value && !newValue) {

      me.setError('invalidDate');
      return;
    }

    me.clearError('invalidDate');

    if (!me.hasChanged(oldValue, newValue)) {


      if (!me.inputting) {
        me.syncInputFieldValue();
      }

      return;
    }

    if (picker && !me.inputting) {
      picker.value = newValue;
    }

    super.value = newValue;
  }

  get value() {
    return super.value;
  }


  set step(value) {
    const me = this;

    me.element.classList[value ? 'add' : 'remove']('b-show-steppers');

    if (typeof value === 'number') {
      value = {
        magnitude: value,
        unit: me._step ? me._step.unit : 'day'
      };
    } else if (typeof value !== 'object') {
      value = DateHelper.parseDuration(value);
    }

    if (value && value.magnitude && value.unit) {
      value.magnitude = Math.abs(value.magnitude);
      me._step = value;
      me.updateInvalid();
    }
  }

  get step() {
    return this._step;
  }

  hasChanged(oldValue, newValue) {
    if (oldValue && oldValue.getTime && newValue && newValue.getTime) {
      return oldValue.getTime() !== newValue.getTime();
    }

    return super.hasChanged(oldValue, newValue);
  }

  get inputValue() {


    const date = this.value;
    return date ? DateHelper.format(date, this.format) : '';
  }


  set format(value) {
    const me = this;
    me._format = value;
    me.syncInputFieldValue(true);
  }

  get format() {
    return this._format;
  }


  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }


  internalOnKeyPress(event) {
    super.internalOnKeyPress(event);

    if (event.key === 'Enter' && this.isValid) {
      this.picker.hide();
    }
  }

}

DateField._$name = 'DateField';
BryntumWidgetAdapterRegister.register('datefield', DateField);
BryntumWidgetAdapterRegister.register('date', DateField);


const decimalSeparators = /[.,]/;


class NumberField extends Field {

  static get $name() {
    return 'NumberField';
  }

  static get defaultConfig() {
    return {

      min: null,


      max: null,


      step: 1,


      value: 0,


      decimalPrecision: null,


      leadingZeroes: null,
      triggers: {
        spin: {
          type: 'spintrigger'
        }
      },
      attributes: ['placeholder', 'autoComplete', 'min', 'max', 'tabIndex'],


      changeOnSpin: true
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);


    me.input.addEventListener('dblclick', () => {
      me.select();
    });

    if (typeof me.changeOnSpin === 'number') {
      me.bufferedSpinChange = me.buffer(me.triggerChange, me.changeOnSpin);
    }
  }


  inputTemplate() {
    const me = this,
      style = 'inputWidth' in me ? `style="width:${me.inputWidth}${typeof me.inputWidth === 'number' ? 'px' : ''}"` : '';
    return TemplateHelper.tpl`
            <input type="number"
                reference="input"
                value="${me._value}"
                name="${me.name || me.id}"
                id="${me.id}_input"
                step="any"
                ${style}
                ${me.attributeString}/>
            `;
  }


  internalOnKeyPress(e) {

    if (e.type === 'keydown') {
      if (e.key === 'ArrowUp') {
        this.doSpinUp();
        e.preventDefault();
      } else if (e.key === 'ArrowDown') {
        this.doSpinDown();
        e.preventDefault();
      }
    }

    super.internalOnKeyPress(e);
  }

  doSpinUp() {
    const me = this,
      {
        min,
        max
      } = me;
    let newValue = (me.value || 0) + me.step;

    if (!isNaN(min) && newValue < min) {
      newValue = min;
    }

    if (isNaN(max) || newValue <= max) {
      me.applySpinChange(newValue);
    }
  }

  doSpinDown() {
    const me = this,
      {
        min,
        max
      } = me;
    let newValue = (me.value || 0) - me.step;

    if (!isNaN(max) && newValue > max) {
      newValue = max;
    }

    if (isNaN(min) || newValue >= min) {
      me.applySpinChange(newValue);
    }
  }

  applySpinChange(newValue) {
    const me = this;
    me._isUserAction = true;

    if (me.changeOnSpin !== true) {

      me.silenceChange = true;

      me.bufferedSpinChange && me.bufferedSpinChange(null, true);
    }

    me.value = newValue;
    me._isUserAction = false;
    me.silenceChange = false;
  }

  triggerChange() {
    if (!this.silenceChange) {
      super.triggerChange(...arguments);
    }
  }

  internalOnInput(event) {
    const me = this,
      {
        input
      } = me,
      value = me.formatValue(input.value);

    if (input.value !== value) {
      input.value = value;
    }

    super.internalOnInput(event);
  }

  static formatValue(value, leadingZeroes, decimalPrecision) {
    if (typeof value !== 'string') {
      return value;
    }

    let [integer, decimal] = value.split(decimalSeparators);

    if (decimalPrecision && decimal && decimal.length > decimalPrecision) {

      decimal = decimal.substr(0, decimalPrecision);
    }

    if (leadingZeroes && integer && integer.length < leadingZeroes) {

      integer = integer.padStart(leadingZeroes, '0');
    }

    return [integer, decimal].filter(v => v).join('.');
  }

  formatValue(value) {
    return NumberField.formatValue(value, this.leadingZeroes, this.decimalPrecision);
  }


  set step(step) {
    this.element.classList[step ? 'remove' : 'add']('b-hide-spinner');
    this._step = step;
  }

  get step() {
    return this._step;
  }


  set min(min) {
    this._min = min;

    if (this.input) {
      this.input.min = min;
    }
  }

  get min() {
    return this._min;
  }


  set max(max) {
    this._max = max;

    if (this.input) {
      this.input.max = max;
    }
  }

  get max() {
    return this._max;
  }


  set value(value) {
    const me = this;

    if (value || value === 0) {
      let valueIsNaN;

      if (typeof value !== 'number') {
        value = typeof value === 'string' ? parseFloat(value) : Number(value);
        valueIsNaN = isNaN(value);

        if (valueIsNaN) {
          value = '';
        }
      }

      if (!valueIsNaN && me.decimalPrecision != null) {
        value = ObjectHelper.round(value, me.decimalPrecision);
      }
    } else {
      value = undefined;
    }

    if (me.value !== value) {
      super.value = value;

      if (me.leadingZeroes) {
        me.input.value = me.formatValue(value.toString());
      }
    }
  }

  get value() {
    return super.value;
  }

}

NumberField._$name = 'NumberField';
BryntumWidgetAdapterRegister.register('numberfield', NumberField);
BryntumWidgetAdapterRegister.register('number', NumberField);


class Slider extends Widget {

  static get $name() {
    return 'Slider';
  }

  static get defaultConfig() {
    return {

      text: '',


      showValue: true,


      showTooltip: false,


      min: 0,


      max: 100,


      step: 1,


      value: null,

      thumbSize: 20,
      localizableProperties: ['text']
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);
    me.updateLabel();

    if (me.showTooltip) {
      me.tip = new Tooltip({
        forElement: me.input,
        anchor: false,

        align: 'b-t',
        axisLock: true
      });
    }

    me.input.addEventListener('input', me.onInternalInput.bind(me));
    me.input.addEventListener('change', me.onInternalChange.bind(me));
    me.input.addEventListener('mouseover', me.onInternalMouseOver.bind(me));
    me.input.addEventListener('mouseout', me.onInternalMouseOut.bind(me));
  }

  template(widget) {
    return TemplateHelper.tpl`
            <div class="${widget.text ? 'b-text b-has-label' : ''}">
                <input type="range"
                   reference="input"
                   id="${widget.id}_input"
                   min="${widget.min}"
                   max="${widget.max}"
                   step="${widget.step}"
                   value="${widget.value}">
                <label reference="label" for="${widget.id}_input">${widget.text}</label>
            </div>
        `;
  }

  get focusElement() {
    return this.input;
  }


  onInternalInput(event) {
    const me = this;
    me._value = parseInt(me.input.value);
    me.updateUI();
    me.trigger('input', {
      value: me.value
    });
  }

  onInternalChange(event) {
    const me = this;
    me.updateUI();
    me.triggerChange(true);
    me.trigger('action', {
      value: me.value
    });
  }

  onInternalMouseOver(event) {
    const me = this;
    me.updateLabel();

    if (me.tip) {
      me.tip.showBy({
        target: me.calcThumbPosition(),
        offset: 5
      });
    }
  }

  onInternalMouseOut(event) {
    if (this.tip) {
      this.tip.hide();
    }
  }

  triggerChange(userAction) {
    this.trigger('change', {
      value: this.value,
      userAction
    });
  }


  get text() {
    return this._text;
  }

  set text(text) {
    const me = this;
    me._text = text;

    if (me.label) {
      if (me.showValue) {
        text = text ? `${text} (${me.value})` : me.value;
      }

      me.label.innerHTML = text;
    }

    if (me.tip) {
      me.tip.html = me.value;
    }
  }


  get value() {
    return this.input ? parseInt(this.input.value) : this._value;
  }

  set value(value) {
    const me = this;

    if (me._value !== value) {
      if (me.input) {
        me.input.value = value;
        me.updateUI();
        me.triggerChange(false);
      }

      me._value = value;
    }
  }


  get min() {
    return this.input ? this.input.min : this._min;
  }

  set min(min) {
    const me = this;

    if (me.input) {
      me.input.min = min;

      if (me._value < min) {
        me.value = min;
        me.trigger('input', {
          value: me.value
        });
      }
    }

    me._min = min;
  }


  get max() {
    return this.input ? this.input.max : this._max;
  }

  set max(max) {
    const me = this;

    if (me.input) {
      me.input.max = max;

      if (me._value > max) {
        me.value = max;
        me.trigger('input', {
          value: me.value
        });
      }
    }

    me._max = max;
  }


  get step() {
    return this.input ? this.input.step : this._step;
  }

  set step(step) {
    if (this.input) this.input.step = step;
    this._step = step;
  }


  updateLabel() {
    this.text = this._text;
  }


  updateTooltipPosition() {
    if (this.tip) {
      this.tip.alignTo({
        target: this.calcThumbPosition(),
        offset: 5
      });
    }
  }


  updateUI() {
    this.updateLabel();
    this.updateTooltipPosition();
  }

  calcThumbPosition() {
    const me = this,
      inputRect = Rectangle.from(me.input),
      offset = (inputRect.width - me.thumbSize) * me.calcPercentProgress() / 100;
    return new Rectangle(inputRect.x + offset, inputRect.y + inputRect.height / 2 - me.thumbSize / 2, me.thumbSize, me.thumbSize);
  }

  calcPercentProgress() {
    return (this.value - this.min) / (this.max - this.min) * 100;
  }

}

Slider._$name = 'Slider';
BryntumWidgetAdapterRegister.register('slider', Slider);


const animationClasses = ['b-slide-out-left', 'b-slide-out-right', 'b-slide-in-left', 'b-slide-in-right'];


class Card extends Layout {
  static get $name() {
    return 'Card';
  }

  static get defaultConfig() {
    return {
      containerCls: 'b-card-container',
      itemCls: 'b-card-item',


      animateCardChange: true
    };
  }


  setActiveItem(activeIndex) {
    const me = this,
      {
        owner
      } = me,
      {
        contentElement,
        items
      } = owner,
      widgetPassed = activeIndex instanceof Widget,
      prevActiveIndex = parseInt(contentElement.dataset.activeIndex),
      prevActiveItem = items[prevActiveIndex],
      newActiveItem = owner.items[activeIndex = widgetPassed ? activeIndex = items.indexOf(activeIndex) : parseInt(activeIndex)],
      event = {
        prevActiveIndex,
        prevActiveItem
      };

    if (newActiveItem && newActiveItem !== prevActiveItem) {
      const prevItemElement = prevActiveItem && prevActiveItem.element,
        newActiveElement = newActiveItem && newActiveItem.element;
      event.activeIndex = activeIndex;
      event.activeItem = newActiveItem;

      if (me.animateDetacher) {
        const abortedEvent = me.animateDetacher.event;
        me.animateDetacher();
        abortedEvent.prevActiveItem.element.classList.remove(animationClasses);
        abortedEvent.activeItem.element.classList.remove('b-active', ...animationClasses);
        me.animateDetacher = null;
      }

      event.promise = new Promise((resolve, reject) => {

        if (prevItemElement && me.animateCardChange) {
          prevItemElement.classList.add(activeIndex > prevActiveIndex ? 'b-slide-out-left' : 'b-slide-out-right');
          newActiveElement.classList.add('b-active', activeIndex < prevActiveIndex ? 'b-slide-in-left' : 'b-slide-in-right');
          owner.isAnimating = true;

          newActiveItem.triggerPaint();

          me.animateDetacher = EventHelper.on({
            element: newActiveElement,
            animationend: () => {
              me.animateDetacher = null;
              owner.isAnimating = false;

              newActiveElement.classList.remove(...animationClasses);

              if (prevItemElement) {
                prevItemElement.classList.remove('b-active', ...animationClasses);
              }

              contentElement.dataset.activeIndex = activeIndex;


              newActiveItem.focus();
              resolve(event);
            },
            once: true
          });
          me.animateDetacher.reject = reject;
          me.animateDetacher.event = event;
        } else {
          if (prevItemElement) {
            prevItemElement.classList.remove('b-active');
          }

          newActiveElement.classList.add('b-active');
          contentElement.dataset.activeIndex = activeIndex;
          newActiveItem.focus();
          newActiveItem.triggerPaint();
          resolve(event);
        }
      });
    }

    return event;
  }

  renderChildren() {
    const {
        owner
      } = this,
      activeIndex = owner.activeIndex;

    if (BrowserHelper.isIE11) {
      this.animateCardChange = false;
    }

    if (owner.items && activeIndex != null && owner.items[activeIndex]) {
      owner.contentElement.dataset.activeIndex = activeIndex;
      owner.items[activeIndex].element.classList.add('b-active');
    }

    super.renderChildren();
  }


  get activeIndex() {
    return parseInt(this.owner.contentElement.dataset.activeIndex);
  }


  get activeItem() {
    return this.owner.items[parseInt(this.owner.contentElement.dataset.activeIndex)];
  }

}


Card._$name = 'Card';
Layout.registerLayout(Card);


class TabPanel extends Container {

  static get $name() {
    return 'TabPanel';
  }

  static get defaultConfig() {
    return {
      template: me => TemplateHelper.tpl`
                <div>
                    <div class="b-tabpanel-tabs" reference="tabStrip">
                        ${me.items.map((tab, i) => `
                        <div tabindex="-1" data-index="${i}" class="b-tabpanel-tab ${i === me.activeIndex ? 'b-active' : ''} ${tab.cls || ''} ${tab.hidden ? 'b-hidden' : ''}" style="${me.tabMinWidth ? 'min-width:' + DomHelper.setLength(me.tabMinWidth) + ';' : ''} ${me.tabMaxWidth ? 'max-width:' + DomHelper.setLength(me.tabMaxWidth) + ';' : ''}" >
                            <span class="b-tabpanel-tab-title">${tab.title}</span>
                        </div>
                        `)}
                    </div>
                    <div class="b-tabpanel-body" reference="tabPanelBody" data-activeIndex="${me.activeIndex}">
                    </div>
                </div>
            `,
      itemCls: 'b-tabpanel-item',
      defaultType: 'container',


      activeTab: 0,


      tabMinWidth: null,


      tabMaxWidth: null,


      animateTabChange: true,
      layout: 'card',

      suppressChildHeaders: true
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);

    me.items.forEach((tab, i) => {
      tab.titleElement = me.element.querySelector(`div.b-tabpanel-tab[data-index="${i}"] span`);
    });
    EventHelper.on({
      element: me.tabStrip,
      delegate: '.b-tabpanel-tab',
      click: 'onTabElementClick',
      thisObj: this
    });
  }

  createWidget(tab) {
    const me = this;
    tab = super.createWidget(tab);
    tab.on({
      hide: me.onTabVisibilityChange,
      show: me.onTabVisibilityChange,
      thisObj: me
    });
    return tab;
  }

  set tabMinWidth(width) {
    this._tabMinWidth = width;
    this.element && DomHelper.forEachSelector(this.element, '.b-tabpanel-tab', tab => {
      DomHelper.setLength(tab, 'minWidth', width || null);
    });
  }

  get tabMinWidth() {
    return this._tabMinWidth;
  }

  set tabMaxWidth(width) {
    this._tabMaxWidth = width;
    this.element && DomHelper.forEachSelector(this.element, '.b-tabpanel-tab', tab => {
      DomHelper.setLength(tab, 'maxWidth', width || null);
    });
  }

  get tabMaxWidth() {
    return this._tabMaxWidth;
  }

  set layout(layout) {
    super.layout = layout;
    this.layout.animateCardChange = this.animateTabChange;
  }

  get layout() {
    return super.layout;
  }

  get contentElement() {
    return this.tabPanelBody;
  }

  get focusElement() {
    const me = this,
      activeTab = me.items[me.activeTab || 0],
      tabFocusElement = activeTab && activeTab.focusElement;
    return tabFocusElement || me.tabStrip.children[me.activeTab];
  }


  set activeTab(index) {
    const me = this;

    if (index < 0 || index >= me.items.length) {
      throw new Error('Invalid tab index: ' + index);
    }

    if (me.isConfiguring) {
      me._activeTab = index;
    } else {
      const tabchangeEvent = me.layout.setActiveItem(index),
        {
          promise,
          activeIndex,
          activeItem
        } = tabchangeEvent;

      if (activeItem) {
        const {
            tabStrip
          } = me,
          prevTabElement = tabStrip.children[me._activeTab];

        me._activeTab = activeIndex;

        if (prevTabElement) {
          prevTabElement.classList.remove('b-active');
        }

        tabStrip.children[activeIndex].classList.add('b-active');
        promise.then(() => {

          me.trigger('tabchange', tabchangeEvent);
        });
      }
    }
  }


  get activeIndex() {
    return this.activeTab;
  }

  get activeTab() {
    return this._activeTab;
  }


  get activeItem() {
    return this.layout.activeItem;
  }


  onTabElementClick(event) {
    this.activeTab = event.currentTarget.dataset.index;
  }

  onTabVisibilityChange({
                          source
                        }) {
    const tabBarEl = this.element.querySelector(`div.b-tabpanel-tab[data-index="${this.items.indexOf(source)}"]`);
    tabBarEl.classList[source.hidden ? 'add' : 'remove']('b-hidden');
  }

}

TabPanel._$name = 'TabPanel';
BryntumWidgetAdapterRegister.register('tabpanel', TabPanel);
BryntumWidgetAdapterRegister.register('tabs', TabPanel);


class TextAreaField extends PickerField {
  static get $name() {
    return 'TextAreaField';
  }

  static get defaultConfig() {
    return {
      triggers: null,


      inline: true,


      resize: 'none'
    };
  }

  startConfigure(config) {

    this._thisIsAUsedExpression(this.inline);

    super.startConfigure(config);
  }

  inputTemplate() {
    const me = this;

    if (me.inline) {
      return TemplateHelper.tpl`<textarea
                reference="input"
                class="${me.inputCls || ''}"
                placeholder="${me.placeholder}"
                name="${me.name || me.id}"
                style="resize:${me.resize}"
                id="${me.id + '_input'}"></textarea>`;
    } else {
      return TemplateHelper.tpl`<input type="text"
                readOnly="readonly"
                reference="displayElement"
                placeholder="${me.placeholder}"/>`;
    }
  }

  get focusElement() {
    return this.inline || this._picker && this._picker.isVisible ? this.input : this.displayElement;
  }

  showPicker() {
    const {
      picker
    } = this;
    picker.width = this.pickerWidth || this[this.pickerAlignElement].offsetWidth;

    super.showPicker(true);
  }

  focusPicker() {
    this.input.focus();
  }

  onPickerKeyDown(keyEvent) {
    const me = this,
      realInput = me.input;

    switch (keyEvent.key.trim() || keyEvent.code) {
      case 'Escape':

        me.picker.hide();
        return;

      case 'Enter':
        if (keyEvent.ctrlKey) {
          me.syncInputFieldValue();
          me.picker.hide();
        }

        break;
    }


    me.input = me.displayElement;
    const result = super.onPickerKeyDown(keyEvent);
    me.input = realInput;
    return result;
  }

  syncInputFieldValue(skipHighlight) {
    if (this.displayElement) {
      this.displayElement.value = this.inputValue;
    }

    super.syncInputFieldValue(skipHighlight);
  }

  set value(value) {
    super.value = value == null ? '' : value;
  }

  get value() {
    return super.value;
  }

  set inline(inline) {
    this._inline = inline;

    if (!inline && !this.triggers) {
      this.triggers = {};
    }
  }

  set triggers(triggers) {
    if (!this.inline) {
      (triggers || (triggers = {})).expand = {
        cls: 'b-icon-picker',
        handler: 'onTriggerClick'
      };
    }

    super.triggers = triggers;
  }

  get triggers() {
    return super.triggers;
  }

  get inline() {
    return this._inline;
  }

  createPicker(picker) {
    const me = this;


    if (picker.width) {
      me.pickerWidth = picker.width;
    }

    picker = new Widget(ObjectHelper.merge({
      cls: 'b-textareafield-picker',
      owner: me,
      floating: true,
      scrollAction: 'realign',
      forElement: me[me.pickerAlignElement],
      align: {
        align: 't-b',
        axisLock: true,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      html: `<textarea id="${me.id + '_input'}" style="resize:${me.resize}">${me.value}</textarea>`,
      autoShow: false
    }, picker));
    const input = me.input = picker.element.querySelector(`#${me.id}_input`);
    me.inputListenerRemover = EventHelper.on({
      element: input,
      thisObj: me,
      focus: 'internalOnInputFocus',
      change: 'internalOnChange',
      input: 'internalOnInput',
      keydown: 'internalOnKeyPress',
      keypress: 'internalOnKeyPress',
      keyup: 'internalOnKeyPress'
    });
    return picker;
  }

}

TextAreaField._$name = 'TextAreaField';
BryntumWidgetAdapterRegister.register('textareafield', TextAreaField);
BryntumWidgetAdapterRegister.register('textarea', TextAreaField);


class TimePicker extends Popup {

  static get $name() {
    return 'TimePicker';
  }

  static get defaultConfig() {
    return {
      items: [{
        type: 'number',
        ref: 'fieldHours',
        min: 0,
        max: 23,
        highlightExternalChange: false
      }, {
        html: '<label>:</label>'
      }, {
        type: 'number',
        ref: 'fieldMinutes',
        min: 0,
        max: 59,
        highlightExternalChange: false
      }, {
        type: 'button',
        text: 'AM',
        toggleGroup: 'am-pm',
        ref: 'buttonAM',
        cls: 'b-blue'
      }, {
        type: 'button',
        text: 'PM',
        toggleGroup: 'am-pm',
        ref: 'buttonPM',
        cls: 'b-blue'
      }],
      float: '1',
      autoShow: false,
      trapFocus: true,


      value: DateHelper.getTime(0),


      format: null
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);
    me._pm = false;
    me.fieldHours.on('change', me.onFieldChange, me);
    me.fieldMinutes.on('change', me.onFieldChange, me);
    me.buttonAM.on('click', me.onButtonAMClick, me);
    me.buttonPM.on('click', me.onButtonPMClick, me);
    EventHelper.on({
      element: me.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
    EventHelper.on({
      element: me.fieldHours.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
    EventHelper.on({
      element: me.fieldMinutes.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
    me.refresh();
  }


  onFieldChange() {
    const me = this;

    if (me._time) {
      me.value = me.pickerToTime();
    }
  }

  onButtonAMClick() {
    const me = this;
    me._pm = false;

    if (me._time) {
      me.value = me.pickerToTime();
    }
  }

  onButtonPMClick() {
    const me = this;
    me._pm = true;

    if (me._time) {
      me.value = me.pickerToTime();
    }
  }

  onPickerKeyDown(keyEvent) {
    const me = this,
      keyName = keyEvent.key && keyEvent.key.trim() || keyEvent.code;

    switch (keyName) {
      case 'Escape':

        me.triggerTimeChange(me._initialValue);
        me.hide();
        keyEvent.preventDefault();
        break;

      case 'Enter':
        me.value = me.pickerToTime();
        me.hide();
        keyEvent.preventDefault();
        break;
    }
  }


  pickerToTime() {
    const me = this,
      pm = me._pm;
    let hours = me.fieldHours.value,
      newValue = new Date(me._time);

    if (!me._is24Hour) {
      if (pm && hours < 12) hours = hours + 12;
      if (!pm && hours === 12) hours = 0;
    }

    newValue.setHours(hours);
    newValue.setMinutes(me.fieldMinutes.value);

    if (me._min) {
      newValue = DateHelper.max(me._min, newValue);
    }

    if (me._max) {
      newValue = DateHelper.min(me._max, newValue);
    }

    return newValue;
  }

  triggerTimeChange(time) {
    this.trigger('timeChange', {
      time
    });
  }


  set value(newTime) {
    const me = this;
    let changed = false;

    if (!newTime || !me._time) {
      me._time = TimePicker.defaultConfig.value;
      changed = true;
    } else if (newTime.getTime() !== me._time.getTime()) {
      me._time = newTime;
      changed = true;
    }

    if (changed) {
      if (me.isVisible) {
        me.triggerTimeChange(me.value);
      }

      me.refresh();
    }
  }

  get value() {
    return this._time;
  }


  set format(value) {
    const me = this;
    me._format = value;
    me._is24Hour = DateHelper.is24HourFormat(me._format);
    me.refresh();
  }

  get format() {
    return this._format;
  }


  set min(value) {
    this._min = value;
  }

  get min() {
    return this._min;
  }


  set max(value) {
    this._max = value;
  }

  get max() {
    return this._max;
  }


  set initialValue(value) {
    this.value = value;
    this._initialValue = value;
  }

  get initialValue() {
    return this._initialValue;
  }


  get buttonAM() {
    return this.widgetMap.buttonAM;
  }

  get buttonPM() {
    return this.widgetMap.buttonPM;
  }

  get fieldHours() {
    return this.widgetMap.fieldHours;
  }

  get fieldMinutes() {
    return this.widgetMap.fieldMinutes;
  }


  refresh() {
    const me = this;

    if (!me.isConfiguring) {
      const time = me._time,
        is24 = me._is24Hour,
        hours = time.getHours(),
        pm = me._pm = hours >= 12,
        fieldHours = me.fieldHours;
      me.element.classList[is24 ? 'add' : 'remove']('b-24h');
      fieldHours.min = is24 ? 0 : 1;
      fieldHours.max = is24 ? 23 : 12;
      fieldHours.value = is24 ? hours : hours % 12 || 12;
      me.fieldMinutes.value = time.getMinutes();
      me.buttonAM.pressed = !pm;
      me.buttonPM.pressed = pm;
      me.buttonAM.hidden = me.buttonPM.hidden = is24;
    }
  }

}

TimePicker._$name = 'TimePicker';
BryntumWidgetAdapterRegister.register('timepicker', TimePicker);


class TimeField extends PickerField {

  static get $name() {
    return 'TimeField';
  }

  static get defaultConfig() {
    return {

      format: 'LT',
      triggers: {
        back: {
          cls: 'b-icon b-icon-angle-left',
          handler: 'onBackClick',
          align: 'start'
        },
        expand: {
          template: () => `<div class="b-align-${this.align || 'end'}"><div class="b-icon-clock-live"></div></div>`,
          handler: 'onTriggerClick',
          align: 'end'
        },
        forward: {
          cls: 'b-icon b-icon-angle-right',
          handler: 'onForwardClick',
          align: 'end'
        }
      },


      min: null,


      max: null,


      step: '5m',


      value: null
    };
  }


  createPicker(picker) {
    const me = this;
    return new TimePicker(Object.assign({
      owner: me,
      floating: true,
      forElement: me[me.pickerAlignElement],
      align: {
        align: 't0-b0',
        axisLock: true,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      value: me.value,
      format: me.format,

      onTimeChange({
                     time
                   }) {
        me._isUserAction = true;
        me.value = time;
        me._isUserAction = false;
      }

    }, picker));
  }


  onBackClick() {
    const me = this,
      {
        min
      } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me.step.magnitude, me.step.unit);

      if (!min || min.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }

  onForwardClick() {
    const me = this,
      {
        max
      } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me.step.magnitude, me.step.unit);

      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }


  get isValid() {
    const me = this;
    me.clearError('minimumValueViolation', true);
    me.clearError('maximumValueViolation', true);
    let value = me.value;

    if (value) {
      value = value.getTime();

      if (me._min && me._min.getTime() > value) {
        me.setError('minimumValueViolation', true);
        return false;
      }

      if (me._max && me._max.getTime() < value) {
        me.setError('maximumValueViolation', true);
        return false;
      }
    }

    return super.isValid;
  }

  hasChanged(oldValue, newValue) {
    if (oldValue && oldValue.getTime && newValue && newValue.getTime) {
      return oldValue.getTime() !== newValue.getTime();
    }

    return super.hasChanged(oldValue, newValue);
  }


  showPicker(focusPicker) {
    const me = this,
      picker = me.picker;
    picker.initialValue = me.value;
    picker.format = me.format;
    picker.maxTime = me.max;
    picker.minTime = me.min;

    me.value = picker.value;
    super.showPicker(focusPicker);
  }

  onPickerShow() {
    const me = this;
    super.onPickerShow();

    me.pickerKeyDownRemover && me.pickerKeyDownRemover();
  }


  focusPicker() {
    this.picker.focus();
  }


  transformTimeValue(value) {
    if (value != null) {
      if (!DateHelper.isDate(value)) {
        if (typeof value === 'string') {
          value = DateHelper.parse(value, this.format);
        } else {
          value = new Date(value);
        }
      }

      if (DateHelper.isValidDate(value)) {

        return DateHelper.getTime(value);
      }
    }

    return null;
  }


  set min(value) {
    const me = this;
    me._min = me.transformTimeValue(value);
    me.input && (me.input.min = me._min);
    me.updateInvalid();
  }

  get min() {
    return this._min;
  }


  set max(value) {
    const me = this;
    me._max = me.transformTimeValue(value);
    me.input && (me.input.max = me._max);
    me.updateInvalid();
  }

  get max() {
    return this._max;
  }


  set value(value) {
    const me = this,
      oldValue = me.value,
      newValue = me.transformTimeValue(value);

    if (value && !newValue || value === '') {

      me.setError('invalidTime');
      return;
    }

    me.clearError('invalidTime');

    if (!me.hasChanged(oldValue, newValue)) {


      if (!me.inputting) {
        me.syncInputFieldValue();
      }

      return;
    }

    if (me.triggers.expand && newValue) {
      me.triggers.expand.element.firstElementChild.style.animationDelay = -((newValue.getHours() * 60 + newValue.getMinutes()) / 10) + 's';
    }

    super.value = newValue;
  }

  get value() {
    return super.value;
  }


  set step(value) {
    const me = this;

    if (typeof value === 'number') {
      value = {
        magnitude: value,
        unit: me._step.unit
      };
    } else if (typeof value !== 'object') {
      value = DateHelper.parseDuration(value);
    }

    if (value && value.magnitude && value.unit) {
      value.magnitude = Math.abs(value.magnitude);
      me._step = value;
      me.updateInvalid();
    }
  }

  get step() {
    return this._step;
  }


  set format(value) {
    const me = this;
    me._format = value;
    me.syncInputFieldValue(true);
  }

  get format() {
    return this._format;
  }

  get inputValue() {
    return DateHelper.format(this.value, this.format);
  }


  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }

}

TimeField._$name = 'TimeField';
BryntumWidgetAdapterRegister.register('timefield', TimeField);
BryntumWidgetAdapterRegister.register('time', TimeField);


class BryntumWidgetAdapter {

  createWidget(config) {
    return BryntumWidgetAdapterRegister.createWidget(config.type, config);
  }

  getClass(type) {
    return BryntumWidgetAdapterRegister.getClass(type);
  }

  appendWidget(config) {
    return this.createWidget(config);
  }

  appendWidgets(configArray, config) {

    return configArray.map(item => this.appendWidget(ObjectHelper.assign({}, config || {}, item)));
  }


  openPopup(element, config) {

    return new Popup(ObjectHelper.assign({
      forElement: element
    }, typeof config === 'string' ? {
      html: config
    } : config));
  }


  showContextMenu(element, config) {
    const me = this;

    if (me.currentContextMenu) {
      me.currentContextMenu.destroy();
    }

    if (element instanceof HTMLElement) {
      config.forElement = element;
    } else if (Array.isArray(element)) {
      config.forElement = {
        target: new Point(...element)
      };
    } else if (element instanceof Point) {
      config.forElement = {
        target: element
      };
    }

    me.currentContextMenu = new Menu(config);
    me.currentContextMenu.on('destroy', () => {
      me.currentContextMenu = null;
    });
    return me.currentContextMenu;
  }


  attachTooltip(element, configOrText) {
    if (typeof configOrText === 'string') configOrText = {
      html: configOrText
    };


    new Tooltip(Object.assign({
      forElement: element
    }, configOrText));
    return element;
  }

  hasTooltipAttached(element) {
    return Tooltip.hasTooltipAttached(element);
  }

  destroyTooltipAttached(element) {
    return Tooltip.destroyTooltipAttached(element);
  }


  mask(config, text = 'Loading') {
    if (config) {

      if (config instanceof HTMLElement) {
        config = {
          element: config,
          text
        };
      }

      return Mask.mask(config, config.element);
    }
  }

  unmask(element, close = true) {
    if (element.mask) {
      if (close) {
        element.mask.close();
      } else {
        element.mask.hide();
      }
    }
  }


  toast(msg) {
    return Toast.show(msg);
  }


  set defaultStyle(style) {
    this._defaultStyle = style;
  }

  get defaultStyle() {
    return this._defaultStyle;
  }

}

if (!WidgetHelper._adapter) WidgetHelper.adapter = BryntumWidgetAdapter;
BryntumWidgetAdapter._$name = 'BryntumWidgetAdapter';


class DomDataStore {

  static get(element, key) {
    const result = element._domData || (element._domData = {});

    if (key != null) {
      return result[key];
    }

    return result;
  }


  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }


  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }

}

DomDataStore._$name = 'DomDataStore';


class Duration {

  constructor(magnitude, unit) {
    if (typeof magnitude === 'number') {
      this._magnitude = magnitude;
      this._unit = unit;
    } else if (typeof magnitude === 'object') {
      Object.assign(this, magnitude);
    }
  }


  get magnitude() {
    return this._magnitude;
  }

  set magnitude(value) {
    this._magnitude = typeof value === 'number' && value;
  }


  get unit() {
    return this._unit;
  }

  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }

  get isValid() {
    return this._magnitude && this._unit;
  }


  get milliseconds() {
    return this.isValid ? DateHelper.asMilliseconds(this._magnitude, this._unit) : 0;
  }


  isEqual(value) {
    return Boolean(value && this._magnitude === value.magnitude && this._unit === value.unit);
  }

  toString(useAbbreviation) {
    const me = this,
      abbreviationFn = me.useAbbreviation ? 'getShortNameOfUnit' : 'getLocalizedNameOfUnit';
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : '';
  }

}

Duration._$name = 'Duration';


const throwAbstractMethodCall = () => {
  throw new Error('Abstract method call!');
};
const throwInvalidMethodCall = () => {
  throw new Error('Method cannot be called at this state!');
};


class StateBase extends Base {
  canUndo(stm) {
    throwAbstractMethodCall();
  }

  canRedo(stm) {
    throwAbstractMethodCall();
  }

  onUndo(stm) {
    throwAbstractMethodCall();
  }

  onRedo(stm) {
    throwAbstractMethodCall();
  }

  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }

  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }

  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }

  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }

  onEnable(stm) {
    throwAbstractMethodCall();
  }

  onDisable(stm) {
    throwAbstractMethodCall();
  }

  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }

  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }

  onResetQueue(stm) {
    throwAbstractMethodCall();
  }

  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }

  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }

  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }

}

StateBase._$name = 'StateBase';


const STATE_PROP = Symbol('STATE_PROP');
const STORES_PROP = Symbol('STORES_PROP');
const QUEUE_PROP = Symbol('QUEUE_PROP');
const POS_PROP = Symbol('POS_PROP');
const TRANSACTION_PROP = Symbol('TRANSACTION_PROP');
const TRANSACTION_TIMER_PROP = Symbol('TRANSACTION_TIMER_PROP');
const AUTO_RECORD_PROP = Symbol('AUTO_RECORD_PROP');
const PROPS = Object.freeze([STATE_PROP, STORES_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, AUTO_RECORD_PROP]);


const registry = new Map();


const registerStmState = (name, state) => {
  registry.set(name, state);
};


const resolveStmState = state => {
  if (typeof state === 'string') {
    state = registry.get(state);
  }

  return state;
};


var Registry = {
  registerStmState,
  resolveStmState
};

const resetQueue = (stm, options) => {
  const {
    undo,
    redo
  } = options;
  let newProps;

  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  return [newProps, () => {
    stm.notifyStoresAboutQueueReset(options);
  }];
};


class DisabledStateClass extends StateBase {
  canUndo() {
    return false;
  }

  canRedo() {
    return false;
  }

  onUndo() {
    throwInvalidMethodCall();
  }

  onRedo() {
    throwInvalidMethodCall();
  }

  onEnable(stm) {
    return stm.autoRecord ? 'autoreadystate' : 'readystate';
  }

  onDisable() {
    throwInvalidMethodCall();
  }

  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }

  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }

  onStartTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onRejectTransaction() {
    throwInvalidMethodCall();
  }

  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }

  onModelUpdate() {
  }

  onModelInsertChild() {
  }

  onModelRemoveChild() {
  }

  onStoreModelAdd() {
  }

  onStoreModelInsert() {
  }

  onStoreModelRemove() {
  }

  onStoreRemoveAll() {
  }

}


const DisabledState = new DisabledStateClass();
Registry.registerStmState('disabledstate', DisabledState);


const ACTION_QUEUE_PROP = Symbol('ACTION_QUEUE_PROP');


class Transaction extends Base {
  get defaultConfig() {
    return {

      title: null
    };
  }

  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];
    super.construct(...args);
  }


  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }


  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }


  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }


  undo() {
    const queue = this[ACTION_QUEUE_PROP];

    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }


  redo() {
    const queue = this[ACTION_QUEUE_PROP];

    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }

}

Transaction._$name = 'Transaction';


class ReadyStateClass extends StateBase {
  canUndo(stm) {


    return 0 < stm.position && stm.position <= stm.length;
  }

  canRedo(stm) {


    return 0 <= stm.position && stm.position < stm.length;
  }

  onUndo(stm, steps) {
    const queue = stm[QUEUE_PROP];
    let curPos = stm.position,
      newPos = Math.max(0, curPos - steps);

    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();

      while (curPos != newPos) {
        queue[--curPos].undo();
      }

      return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {
        stm.notifyStoresAboutStateRestoringStop();
      }];
    };

    return [{
      [STATE_PROP]: 'restoringstate',
      [POS_PROP]: newPos
    }, next];
  }

  onRedo(stm, steps) {
    const queue = stm[QUEUE_PROP];
    let curPos = stm.position,
      newPos = Math.min(queue.length, curPos + steps);

    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();

      do {
        queue[curPos++].redo();
      } while (curPos != newPos);

      return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {
        stm.notifyStoresAboutStateRestoringStop();
      }];
    };

    return [{
      [STATE_PROP]: 'restoringstate',
      [POS_PROP]: newPos
    }, next];
  }

  onEnable() {
    throwInvalidMethodCall();
  }

  onDisable() {
    return 'disabledstate';
  }

  onAutoRecordOn() {
    return {
      [STATE_PROP]: 'autoreadystate',
      [AUTO_RECORD_PROP]: true
    };
  }

  onAutoRecordOff() {
    throwInvalidMethodCall();
  }

  onStartTransaction(stm, title) {
    const transaction = new Transaction({
      title: title
    });
    return [{
      [STATE_PROP]: 'recordingstate',
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
    }];
  }

  onStopTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onRejectTransaction() {
    throwInvalidMethodCall();
  }

  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }

  onModelUpdate() {
  }

  onModelInsertChild() {
  }

  onModelRemoveChild() {
  }

  onStoreModelAdd() {
  }

  onStoreModelInsert() {
  }

  onStoreModelRemove() {
  }

  onStoreRemoveAll() {
  }

}


let ReadyState = new ReadyStateClass();
Registry.registerStmState('readystate', ReadyState);


class RecordingStateClass extends StateBase {
  canUndo() {
    return false;
  }

  canRedo() {
    return false;
  }

  onEnable() {
  }

  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    stm.notifyStoresAboutStateRecordingStop(transaction, {
      disabled: true
    });
    return {
      [STATE_PROP]: 'disabledstate',
      [TRANSACTION_PROP]: null
    };
  }

  onAutoRecordOn(stm) {
    return [{
      [STATE_PROP]: 'autorecordingstate',
      [AUTO_RECORD_PROP]: true
    }, () => {
      stm[STATE_PROP].onStopTransactionDelayed(stm);
    }];
  }

  onAutoRecordOff() {
    throwInvalidMethodCall();
  }

  onStartTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP];
    let position = stm[POS_PROP];
    let queue = stm[QUEUE_PROP];

    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }

      queue[position] = transaction;
      queue.length = ++position;
    }

    return [{
      [STATE_PROP]: 'readystate',
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, {
        stop: true
      });
    }];
  }

  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];
    return [{
      [STATE_PROP]: 'restoringstate',
      [TRANSACTION_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }

      return ['readystate', () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, {
          rejected: true
        });
      }];
    }];
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onQueueReset() {
    throwInvalidMethodCall();
  }

  onModelUpdate(stm, model, newData, oldData) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData));
  }

  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));
  }

  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }

  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }

  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }

  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }

  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }

}


const RecordingState = new RecordingStateClass();
Registry.registerStmState('recordingstate', RecordingState);


class RestoringStateClass extends StateBase {
  canUndo() {
    return false;
  }

  canRedo() {
    return false;
  }

  onUndo() {
    throwInvalidMethodCall();
  }

  onRedo() {
    throwInvalidMethodCall();
  }

  onEnable() {
    throwInvalidMethodCall();
  }

  onDisable() {
    throwInvalidMethodCall();
  }

  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }

  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }

  onStartTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onRejectTransaction() {
    throwInvalidMethodCall();
  }

  onQueueReset() {
    throwInvalidMethodCall();
  }

  onModelUpdate() {
  }

  onModelInsertChild() {
  }

  onModelRemoveChild() {
  }

  onStoreModelAdd() {
  }

  onStoreModelInsert() {
  }

  onStoreModelRemove() {
  }

  onStoreRemoveAll() {
  }

}


const RestoringState = new RestoringStateClass();
Registry.registerStmState('restoringstate', RestoringState);


class AutoReadyStateClass extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }

  onAutoRecordOff() {
    return {
      [STATE_PROP]: 'readystate',
      [AUTO_RECORD_PROP]: false
    };
  }

  onStartTransaction(stm, title) {
    const transaction = new Transaction({
      title: title
    });
    return [{
      [STATE_PROP]: 'autorecordingstate',
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
      stm.stopTransactionDelayed();
    }];
  }

  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }

  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }

  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }

  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }

  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, silent);
  }

  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }

  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }

}


const AutoReadyState = new AutoReadyStateClass();
Registry.registerStmState('autoreadystate', AutoReadyState);


class AutoRecordingStateClass extends Delayable(RecordingStateClass) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    const timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    stm.notifyStoresAboutStateRecordingStop(transaction, {
      disabled: true
    });
    return {
      [STATE_PROP]: 'disabledstate',
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }

  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }

  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    return {
      [STATE_PROP]: 'recordingstate',
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }

  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP];
    const timer = stm[TRANSACTION_TIMER_PROP];
    let position = stm[POS_PROP];
    let queue = stm[QUEUE_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }

      queue[position] = transaction;
      queue.length = ++position;
    }

    return [{
      [STATE_PROP]: 'autoreadystate',
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, {
        stop: true
      });
    }];
  }

  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    timer = this.setTimeout(() => {
      stm.stopTransaction();
    }, stm.autoRecordTransactionStopTimeout);
    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }

  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP],
      timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    return [{
      [STATE_PROP]: 'restoringstate',
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }

      return ['autoreadystate', () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, {
          rejected: true
        });
      }];
    }];
  }

  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }

}


const AutoRecordingState = new AutoRecordingStateClass();
Registry.registerStmState('autorecordingstate', AutoRecordingState);


const throwAbstractMethodCall$1 = () => {
  throw new Error('Abstract method call!');
};


class ActionBase extends Base {

  get type() {
    return this.constructor.name;
  }


  undo() {
    throwAbstractMethodCall$1();
  }


  redo() {
    throwAbstractMethodCall$1();
  }

}

ActionBase._$name = 'ActionBase';


const MODEL_PROP = Symbol('MODEL_PROP');
const NEW_DATA_PROP = Symbol('NEW_DATA_PROP');
const OLD_DATA_PROP = Symbol('OLD_DATA_PROP');


class UpdateAction extends ActionBase {
  static get defaultConfig() {
    return {

      model: undefined,


      newData: undefined,


      oldData: undefined
    };
  }

  get type() {
    return 'UpdateAction';
  }

  get model() {
    return this[MODEL_PROP];
  }

  set model(value) {
    this[MODEL_PROP] = value;
  }

  get newData() {
    return this[NEW_DATA_PROP];
  }

  set newData(value) {
    this[NEW_DATA_PROP] = Object.assign({}, value);
  }

  get oldData() {
    return this[OLD_DATA_PROP];
  }

  set oldData(value) {
    this[OLD_DATA_PROP] = Object.assign({}, value);
  }

  undo() {


    this.model.set(this.oldData);


    if (this.model.$) {
      Object.assign(this.model, this.oldData);
    }
  }

  redo() {
    this.model.set(this.newData);

    if (this.model.$) {
      Object.assign(this.model, this.newData);
    }
  }

}

UpdateAction._$name = 'UpdateAction';


const PARENT_MODEL_PROP = Symbol('PARENT_MODEL_PROP');
const CHILD_MODELS_PROP = Symbol('CHILD_MODELS_PROP');
const INSERT_INDEX_PROP = Symbol('INSERT_INDEX_PROP');
const CONTEXT_PROP = Symbol('CONTEXT_PROP');


class InsertChildAction extends ActionBase {
  static get defaultConfig() {
    return {

      parentModel: undefined,


      childModels: undefined,


      insertIndex: undefined,


      context: undefined
    };
  }

  get type() {
    return 'InsertChildAction';
  }

  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }

  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }

  get childModels() {
    return this[CHILD_MODELS_PROP];
  }

  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }

  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }

  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }

  get context() {
    return this[CONTEXT_PROP];
  }

  set context(ctx) {
    this[CONTEXT_PROP] = ctx;
  }

  undo() {
    const {
      parentModel,
      context,
      childModels
    } = this;


    childModels.sort((lhs, rhs) => {
      const {
          lhsParent,
          lhsIndex
        } = context.get(lhs) || {},
        {
          rhsParent,
          rhsIndex
        } = context.get(rhs) || {};
      return lhsParent && lhsParent === rhsParent ? lhsIndex - rhsIndex : 0;
    });


    childModels.forEach(m => {
      const {
        parent,
        index
      } = context.get(m) || {};

      if (parent) {

        if (parent === parentModel) {
          let adjustedIndex;

          adjustedIndex = index > m.parentIndex ? index + 1 : index;

          adjustedIndex = index === parent.children.length - 1 ? null : adjustedIndex;

          const insertBefore = parent.children[adjustedIndex];
          parent.insertChild(m, insertBefore);
        } else {

          parent.insertChild(m, parent.children[index]);
        }
      } else {

        parentModel.removeChild(m);
      }
    });
  }

  redo() {
    const {
        parentModel,
        insertIndex,
        childModels
      } = this,
      insertBefore = parentModel.children[insertIndex];
    parentModel.insertChild(childModels, insertBefore);
  }

}

InsertChildAction._$name = 'InsertChildAction';

const PARENT_MODEL_PROP$1 = Symbol('PARENT_MODEL_PROP');
const CHILD_MODELS_PROP$1 = Symbol('CHILD_MODELS_PROP');
const CONTEXT_PROP$1 = Symbol('CONTEXT_PROP');

class RemoveChildAction extends ActionBase {
  static get defaultConfig() {
    return {

      parentModel: undefined,


      childModels: undefined,


      context: undefined
    };
  }

  get type() {
    return 'RemoveChildAction';
  }

  get parentModel() {
    return this[PARENT_MODEL_PROP$1];
  }

  set parentModel(model) {
    this[PARENT_MODEL_PROP$1] = model;
  }

  get childModels() {
    return this[CHILD_MODELS_PROP$1];
  }

  set childModels(models) {
    this[CHILD_MODELS_PROP$1] = models.slice(0);
  }

  get context() {
    return this[CONTEXT_PROP$1];
  }

  set context(ctx) {
    this[CONTEXT_PROP$1] = ctx;
  }

  undo() {
    const {
      parentModel,
      context,
      childModels
    } = this;


    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs),
        rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });

    childModels.forEach(m => {
      parentModel.insertChild(context.get(m), m);
    });
  }

  redo() {
    this.parentModel.removeChild(this.childModels);
  }

}

RemoveChildAction._$name = 'RemoveChildAction';


const STORE_PROP = Symbol('STORE_PROP');
const MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP');


class AddAction extends ActionBase {
  static get defaultConfig() {
    return {

      store: undefined,


      modelList: undefined,


      silent: false
    };
  }

  get type() {
    return 'AddAction';
  }

  get store() {
    return this[STORE_PROP];
  }

  set store(store) {
    this[STORE_PROP] = store;
  }

  get modelList() {
    return this[MODEL_LIST_PROP];
  }

  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }

  undo() {
    const me = this;
    me.store.remove(me.modelList, me.silent);
  }

  redo() {
    const me = this;
    me.store.add(me.modelList, me.silent);
  }

}

AddAction._$name = 'AddAction';


const STORE_PROP$1 = Symbol('STORE_PROP');
const MODEL_LIST_PROP$1 = Symbol('MODEL_LIST_PROP');
const INSERT_INDEX_PROP$1 = Symbol('INSERT_INDEX_PROP');
const CONTEXT_PROP$2 = Symbol('CONTEXT_PROP');


class InsertAction extends ActionBase {
  static get defaultConfig() {
    return {

      store: undefined,


      modelList: undefined,


      insertIndex: undefined,


      context: undefined,


      silent: false
    };
  }

  get type() {
    return 'InsertAction';
  }

  get store() {
    return this[STORE_PROP$1];
  }

  set store(store) {
    this[STORE_PROP$1] = store;
  }

  get modelList() {
    return this[MODEL_LIST_PROP$1];
  }

  set modelList(list) {
    this[MODEL_LIST_PROP$1] = list.slice(0);
  }

  get insertIndex() {
    return this[INSERT_INDEX_PROP$1];
  }

  set insertIndex(index) {
    this[INSERT_INDEX_PROP$1] = index;
  }

  get context() {
    return this[CONTEXT_PROP$2];
  }

  set context(context) {
    this[CONTEXT_PROP$2] = context;
  }

  undo() {
    const {
      store,
      modelList,
      context,
      silent
    } = this;


    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs),
        rhsIndex = context.get(rhs);
      return lhsIndex !== undefined && rhsIndex !== undefined ? lhsIndex - rhsIndex : 0;
    });
    modelList.forEach(m => {
      const index = context.get(m);

      if (index !== undefined) {

        store.insert(index, m, silent);
      } else {

        store.remove(m, silent);
      }
    });
  }

  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }

}

InsertAction._$name = 'InsertAction';


const STORE_PROP$2 = Symbol('STORE_PROP');
const MODEL_LIST_PROP$2 = Symbol('MODEL_LIST_PROP');
const CONTEXT_PROP$3 = Symbol('CONTEXT_PROP');


class RemoveAction extends ActionBase {
  static get defaultConfig() {
    return {

      store: undefined,


      modelList: undefined,


      context: undefined,


      silent: false
    };
  }

  get type() {
    return 'RemoveAction';
  }

  get store() {
    return this[STORE_PROP$2];
  }

  set store(store) {
    this[STORE_PROP$2] = store;
  }

  get modelList() {
    return this[MODEL_LIST_PROP$2];
  }

  set modelList(list) {
    this[MODEL_LIST_PROP$2] = list.slice(0);
  }

  get context() {
    return this[CONTEXT_PROP$3];
  }

  set context(context) {
    this[CONTEXT_PROP$3] = context;
  }

  undo() {
    const {
      store,
      context,
      modelList,
      silent
    } = this;


    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs),
        rhsIndex = context.get(rhs);

      return lhsIndex - rhsIndex;
    });
    modelList.forEach(m => {
      const index = context.get(m);

      store.insert(index, m, silent);
    });
  }

  redo() {
    const me = this;
    me.store.remove(me.modelList, me.silent);
  }

}

RemoveAction._$name = 'RemoveAction';


const STORE_PROP$3 = Symbol('STORE_PROP');
const ALL_RECORDS_PROP = Symbol('ALL_RECORDS_PROP');


class RemoveAllAction extends ActionBase {
  static get defaultConfig() {
    return {

      store: undefined,


      allRecords: undefined,


      silent: false
    };
  }

  get type() {
    return 'RemoveAllAction';
  }

  get store() {
    return this[STORE_PROP$3];
  }

  set store(store) {
    this[STORE_PROP$3] = store;
  }

  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }

  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }

  undo() {
    const {
      store,
      allRecords,
      silent
    } = this;
    store.add(allRecords, silent);
  }

  redo() {
    const me = this;
    me.store.removeAll(me.silent);
  }

}

RemoveAllAction._$name = 'RemoveAllAction';


const makeModelUpdateAction = (model, newData, oldData) => {
  return new UpdateAction({
    model,
    newData,
    oldData
  });
};
const makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    context
  });
};
const makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};
const makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};
const makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};
const makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};
const makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};

const stateTransition = (stm, event, ...args) => {
  const newState = event.call(stm[STATE_PROP], stm, ...args);

  if (typeof newState === 'string') {
    stm[STATE_PROP] = Registry.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;

    if (typeof state === 'string') {
      stm[STATE_PROP] = Registry.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === 'object') {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
    }

    if (typeof next === 'function') {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === 'object') {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
  }
};


class StateTrackingManager extends Events(Base) {
  static get defaultConfig() {
    return {

      disabled: true,


      autoRecord: false,


      autoRecordTransactionStopTimeout: 100,


      makeModelUpdateAction: makeModelUpdateAction,


      makeModelInsertChildAction: makeModelInsertChildAction,


      makeModelRemoveChildAction: makeModelRemoveChildAction,


      makeStoreModelAddAction: makeStoreModelAddAction,


      makeStoreModelInsertAction: makeStoreModelInsertAction,


      makeStoreModelRemoveAction: makeStoreModelRemoveAction,


      makeStoreRemoveAllAction: makeStoreRemoveAllAction,


      getTransactionTitle: null
    };
  }

  construct(...args) {
    const me = this;
    Object.assign(me, {
      [STATE_PROP]: ReadyState,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false
    });
    super.construct(...args);
  }

  doDestroy() {
    super.doDestroy();
    this.destroyProperties(STATE_PROP);
  }


  get state() {
    return this[STATE_PROP];
  }


  get position() {
    return this[POS_PROP];
  }


  get length() {
    return this[QUEUE_PROP].length;
  }


  get stores() {
    return Array.from(this[STORES_PROP]);
  }


  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }


  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);
      store.stm = this;
    }
  }


  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter(s => s !== store);
      store.stm = null;
    }
  }


  getStoreById(id) {
    return this[STORES_PROP].find(s => s.id === id);
  }


  forEachStore(fn) {
    this[STORES_PROP].forEach(s => fn(s, s.id));
  }


  get disabled() {
    return this.state === DisabledState;
  }

  set disabled(val) {
    const me = this;

    if (me.disabled != val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
        me.trigger('stmDisabled', {
          disabled: true
        });
      } else {
        stateTransition(me, me.state.onEnable, me);
        me.trigger('stmDisabled', {
          disabled: false
        });
      }
    }
  }


  enable() {
    this.disabled = false;
  }


  disable() {
    this.disabled = true;
  }


  get isReady() {
    return this.state === ReadyState || this.state === AutoReadyState;
  }


  get isRecording() {
    return this.state === RecordingState || this.state === AutoRecordingState;
  }


  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }

  set autoRecord(value) {
    const me = this;

    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }


  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }


  stopTransaction(title = null) {
    stateTransition(this, this.state.onStopTransaction, title);
  }


  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }


  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }


  get transaction() {
    return this[TRANSACTION_PROP];
  }


  get queue() {
    return this[QUEUE_PROP].map(t => t.title);
  }


  get isRestoring() {
    return this.state === RestoringState;
  }


  get canUndo() {
    return this.state.canUndo(this);
  }


  get canRedo() {
    return this.state.canRedo(this);
  }


  undo(steps = 1) {
    stateTransition(this, this.state.onUndo, steps);
  }


  undoAll() {
    this.undo(this.length);
  }


  redo(steps = 1) {
    stateTransition(this, this.state.onRedo, steps);
  }


  redoAll() {
    this.redo(this.length);
  }


  resetQueue(
    options = {
      undo: true,
      redo: true
    }) {
    stateTransition(this, this.state.onResetQueue, options);
  }


  resetUndoQueue() {
    this.resetQueue({
      undo: true
    });
  }


  resetRedoQueue() {
    this.resetQueue({
      redo: true
    });
  }

  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore(store => {
      store.onStmRecordingStart && store.onStmRecordingStart(this, transaction);
    });


    this.trigger('recordingStart', {
      stm: this,
      transaction
    });
  }

  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore(store => {
      store.onStmRecordingStop && store.onStmRecordingStop(this, transaction, reason);
    });


    this.trigger('recordingStop', {
      stm: this,
      transaction,
      reason
    });
  }

  notifyStoresAboutStateRestoringStart() {
    this.forEachStore(store => {
      store.onStmRestoringStart && store.onStmRestoringStart(this);
    });


    this.trigger('restoringStart', {
      stm: this
    });
  }

  notifyStoresAboutStateRestoringStop() {
    this.forEachStore(store => {
      store.onStmRestoringStop && store.onStmRestoringStop(this);
    });


    this.trigger('restoringStop', {
      stm: this
    });
  }

  notifyStoresAboutQueueReset(options) {
    this.forEachStore(store => {
      store.onStmQueueReset && store.onStmQueueReset(this, options);
    });


    this.trigger('queueReset', {
      stm: this,
      options
    });
  }


  onModelUpdate(model, newData, oldData) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData);
  }


  onModelInsertChild(parentModel, index, childModels, context) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
  }


  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }


  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }


  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }


  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }


  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }

}

StateTrackingManager._$name = 'StateTrackingManager';


class CSSHelper {

  static insertRule(cssText) {
    const {
        styleSheet
      } = this,
      oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);

    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }


  static findRule(selector) {
    let result,
      isFn = typeof selector === 'function';


    Array.prototype.find.call(document.head.querySelectorAll('link[rel=stylesheet],style[type*=css]'), element => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, r => {
        return isFn ? selector(r) : r.selectorText === selector;
      });

      if (result) {
        return true;
      }
    });
    return result;
  }

  static get styleSheet() {
    if (!this._stylesheet) {
      this._stylesheet = DomHelper.createElement({
        tag: 'style',
        id: 'bryntum-private-styles',
        type: 'text/css',
        parent: document.head
      }).sheet;
    }

    return this._stylesheet;
  }

}

CSSHelper._$name = 'CSSHelper';


const arraySlice$1 = Array.prototype.slice,

  syncEqualityEvaluator = {

    ignore: {
      '_element': 1,
      'parent': 1,
      'elementData': 1,
      'ns': 1
    },


    evaluate(property, a, b) {
      if (property === 'html' && typeof a.value !== 'string' && `compareHtml` in a.object) {

        return a.object.compareHtml === b.object.compareHtml;
      }
    }

  },

  syncIgnoreAttributes = {
    tag: 1,
    html: 1,
    children: 1,
    tooltip: 1,
    parent: 1,
    nextSibling: 1,
    ns: 1,
    reference: 1,
    _element: 1,
    elementData: 1,
    retainElement: 1,
    compareHtml: 1,
    syncOptions: 1,
    isReleased: 1
  },
  isClass = {
    'class': 1,
    className: 1,
    classname: 1
  },
  emptyArray$3 = Object.freeze([]);


class DomSync {

  static sync(options) {
    this.performSync(options, options.targetElement);
    return options.targetElement;
  }

  static performSync(options, targetElement) {
    const {
        domConfig,
        callback
      } = options,
      configIsEqual = options.configEquality ? options.configEquality(domConfig, targetElement.lastDomConfig, syncEqualityEvaluator) : ObjectHelper.isDeeplyEqual(domConfig, targetElement.lastDomConfig, syncEqualityEvaluator);

    if (!configIsEqual) {
      if (domConfig) {

        if (!domConfig.onlyChildren) {
          this.syncAttributes(domConfig, targetElement);
          this.syncContent(domConfig, targetElement);
        }

        this.syncChildren(options, targetElement);

        domConfig._element = targetElement;
      } else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }

      targetElement.lastDomConfig = domConfig;
      return true;
    } else {

      this.relinkElements(domConfig, targetElement);

      callback && callback({
        action: 'none',
        domConfig,
        targetElement
      });
    }

    return false;
  }


  static relinkElements(domConfig, targetElement) {
    domConfig._element = targetElement;


    domConfig.children && domConfig.children.forEach((childDomConfig, i) => {


      if (childDomConfig && typeof childDomConfig !== 'string') {
        this.relinkElements(childDomConfig, targetElement.lastDomConfig.children[i]._element);
      }
    });
  }

  static syncDataset(domConfig, targetElement) {
    const {
        lastDomConfig
      } = targetElement,
      sameConfig = domConfig === lastDomConfig,
      source = Object.keys(domConfig.dataset),
      target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset),
      delta = ArrayHelper.delta(source, target);

    for (let i = 0; i < delta.onlyInA.length; i++) {
      const attr = delta.onlyInA[i];
      targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, domConfig.dataset[attr]);
    }

    for (let i = 0; i < delta.inBoth.length; i++) {
      const attr = delta.inBoth[i];


      if (sameConfig || domConfig.dataset[attr] != lastDomConfig.dataset[attr]) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, domConfig.dataset[attr]);
      }
    }

    for (let i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }

  static syncClassList(domConfig, targetElement) {
    const attr = domConfig.className || domConfig.class,
      classNameString = typeof attr === 'object' ? ObjectHelper.getTruthyKeys(attr).join(' ') : attr;
    targetElement.setAttribute('class', classNameString);
  }

  static getSyncAttributes(domConfig) {
    const attributes = {},

      names = [];

    if (domConfig) {
      Object.keys(domConfig).forEach(attr => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }

    return {
      attributes,
      names
    };
  }

  static syncAttributes(domConfig, targetElement) {
    const {
        lastDomConfig
      } = targetElement,

      sameConfig = domConfig === lastDomConfig,
      sourceSyncAttrs = this.getSyncAttributes(domConfig),

      {
        attributes: sourceAttributes,
        names: sourceNames
      } = sourceSyncAttrs,
      {
        attributes: targetAttributes,
        names: targetNames
      } = sameConfig ? sourceSyncAttrs : this.getSyncAttributes(lastDomConfig),

      {
        onlyInA: toAdd,
        onlyInB: toRemove,
        inBoth: toSync
      } = sameConfig ? {
        onlyInA: emptyArray$3,
        onlyInB: emptyArray$3,
        inBoth: sourceNames
      } : ArrayHelper.delta(sourceNames, targetNames);

    for (let i = 0; i < toAdd.length; i++) {
      const attr = toAdd[i],
        sourceAttr = sourceAttributes[attr];

      if (attr === 'style') {

        DomHelper.applyStyle(targetElement, sourceAttr, true);
      } else if (attr === 'dataset') {
        this.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        this.syncClassList(domConfig, targetElement);
      } else {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }

    for (let i = 0; i < toRemove.length; i++) {
      targetElement.removeAttribute(toRemove[i]);
    }


    for (let i = 0; i < toSync.length; i++) {
      const attr = toSync[i],
        sourceAttr = sourceAttributes[attr],
        targetAttr = targetAttributes[attr];

      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      } else if (attr === 'style') {
        if (sameConfig || !ObjectHelper.isEqual(sourceAttr, targetAttr, true)) {

          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      } else if (attr === 'dataset') {
        this.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        this.syncClassList(domConfig, targetElement);
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
  }


  static syncContent(domConfig, targetElement) {
    const {
      html
    } = domConfig;

    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }

    if (html != null) {

      if (html instanceof DocumentFragment) {

        if (targetElement.childNodes.length === 1 && targetElement.childElementCount === 0 && html.childNodes.length === 1 && html.childElementCount === 0) {
          DomHelper.setInnerText(targetElement, html.firstChild.data);
        } else {
          targetElement.innerHTML = '';
          targetElement.appendChild(html);
        }
      } else if (String(html).includes('<')) {
        targetElement.innerHTML = html;
      } else {
        DomHelper.setInnerText(targetElement, html);
      }
    }
  }

  static appendTextNode(text, targetElement, callback) {
    const newNode = document.createTextNode(text);
    targetElement.appendChild(newNode);
    callback && callback({
      action: 'newNode',
      domConfig: text,
      targetElement: newNode
    });
  }

  static insertElement(domConfig, targetElement, targetNode, syncId, options) {

    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || 'svg') : document.createElement(domConfig.tag || 'div');

    targetElement.insertBefore(newElement, targetNode);

    this.performSync(options, newElement);

    if (syncId != null) {
      targetElement.syncIdMap[syncId] = newElement;
    }

    options.callback && options.callback({
      action: 'newElement',
      domConfig,
      targetElement: newElement,
      syncId
    });
  }


  static syncChildren(options, targetElement) {
    let {
      domConfig,
      syncIdField,
      callback,
      releaseThreshold,
      configEquality,
      ns
    } = options;

    if (domConfig.html) {
      return;
    }

    const me = this,
      sourceConfigs = arraySlice$1.call(domConfig.children || []),
      targetNodes = arraySlice$1.call(targetElement.childNodes),
      syncIdMap = targetElement.syncIdMap || {},
      syncOptions = domConfig.syncOptions || {};

    syncIdField = syncOptions.syncIdField || syncIdField;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;

    releaseThreshold = 'releaseThreshold' in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    let syncId;

    if (syncIdField) {
      targetElement.syncIdMap = {};
    }

    const syncChildOptions = {
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };

    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;

      if (!sourceConfig) {
        continue;
      }

      const isTextNode = typeof sourceConfig === 'string';

      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns;

      if (!isTextNode) {

        if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];

          if (syncId != null && !sourceConfig.unmatched) {

            const syncTargetElement = syncIdMap[syncId];

            if (syncTargetElement) {
              if (
                !sourceConfig.retainElement &&
                me.performSync(syncChildOptions, syncTargetElement)) {

                callback && callback({
                  action: 'reuseOwnElement',
                  domConfig: sourceConfig,
                  targetElement: syncTargetElement,
                  syncId
                });
              }

              if (sourceConfig.retainElement) {
                syncTargetElement.retainElement = true;

                sourceConfig._element = syncTargetElement;
              } else if (syncTargetElement.retainElement) {
                syncTargetElement.retainElement = false;
              }

              targetElement.syncIdMap[syncId] = syncTargetElement;

              ArrayHelper.remove(targetNodes, syncTargetElement);
              syncTargetElement.isReleased = false;
            } else {

              sourceConfigs.push(sourceConfig);

              sourceConfig.unmatched = true;
            }

            continue;
          }
        }

        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }

      let targetNode;

      for (let i = 0; i < targetNodes.length && !targetNode; i++) {
        if (!targetNodes[i].retainElement) {
          targetNode = targetNodes[i];

          if (i === 0) {
            targetNodes.shift();
          } else {
            targetNodes.splice(i, 1);
          }
        }
      }

      if (!targetNode) {
        if (isTextNode) {
          this.appendTextNode(sourceConfig, targetElement, callback);
        } else {

          this.insertElement(sourceConfig, targetElement, null, syncId, syncChildOptions);
        }
      } else {

        if (targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || 'div').toLowerCase() === targetNode.tagName.toLowerCase()) {
          const {
              lastDomConfig
            } = targetNode,
            result = me.performSync(syncChildOptions, targetNode);

          if (syncId != null) {
            targetElement.syncIdMap[syncId] = targetNode;
          }

          targetNode.isReleased = false;

          result && callback && callback({
            action: 'reuseElement',
            domConfig: sourceConfig,
            lastDomConfig,
            targetElement: targetNode,
            syncId
          });
        } else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
        } else {
          if (isTextNode) {
            this.appendTextNode(sourceConfig, targetElement, callback);
          } else {

            this.insertElement(sourceConfig, targetElement, targetNode, syncId, syncChildOptions);
          }

          targetNode.remove();
        }
      }
    }

    let releaseCount = 0;

    targetNodes.forEach(targetNode => {
      const {
        lastDomConfig
      } = targetNode;

      if (!targetNode.retainElement) {


        if (syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {

          if (!targetNode.isReleased) {
            targetNode.className = 'b-released';
            targetNode.isReleased = true;
            callback && callback({
              action: 'releaseElement',
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });

            if (lastDomConfig) {


              lastDomConfig.isReleased = true;

              if (lastDomConfig.className) {
                lastDomConfig.className = 'b-released';
              }
            }

            targetNode.elementData = targetNode.lastConfig = null;
          }

          releaseCount++;
        } else {
          targetNode.remove();
          callback && callback({
            action: 'removeElement',
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {

        if (targetNode.lastDomConfig) {
          targetElement.syncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    });
  }

}

DomSync._$name = 'DomSync';


var DragHelperContainer = (Target => class DragHelperContainer extends (Target || Base) {


  initContainerDrag() {
    const me = this;

    if (!me.mode) me.mode = 'container';
    if (me.mode === 'container' && !me.containers) throw new Error('Container drag mode must specify containers');
  }


  grabContainerDrag(event) {
    const me = this;

    if (!me.ignoreSelector || !DomHelper.up(event.target, me.ignoreSelector)) {

      const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);

      if (element) {
        const box = element.getBoundingClientRect();
        me.context = {
          element,
          valid: true,
          action: 'container',
          offsetX: event.pageX - box.left,
          offsetY: event.pageY - box.top,
          originalPosition: {
            parent: element.parentElement,
            prev: element.previousElementSibling,
            next: element.nextElementSibling
          }
        };
      }

      return true;
    }

    return false;
  }


  startContainerDrag(event) {
    const {
        context
      } = this,
      {
        element: dragElement
      } = context,
      div = dragElement.cloneNode(true),
      box = dragElement.getBoundingClientRect();

    div.classList.add(this.dragProxyCls);
    div.classList.add(this.draggingCls);
    document.body.appendChild(div);
    context.dragProxy = div;

    div.style.width = box.width + 'px';
    div.style.height = box.height + 'px';
    DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);

    context.dragging = dragElement;
    dragElement.classList.add(this.dropPlaceholderCls);
  }


  updateContainerDrag(event) {
    const me = this,
      context = me.context;
    if (!context.started || !context.targetElement) return;
    const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, 'b-grid'),
      willLoseFocus = context.dragging && context.dragging.contains(document.activeElement);

    if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {

      return;
    }


    if (willLoseFocus) {
      GlobalEvents.suspendFocusEvents();
    }

    if (containerElement && context.valid) {
      me.moveNextTo(containerElement, event);
    } else {

      me.revertPosition();
    }

    if (willLoseFocus) {
      GlobalEvents.resumeFocusEvents();
    }

    event.preventDefault();
  }


  finishContainerDrag(event) {
    const me = this,
      context = me.context,

      {
        dragging,
        dragProxy,
        valid,
        draggedTo,
        insertBefore,
        originalPosition
      } = context;

    if (dragging) {

      context.valid = valid && draggedTo && (
        dragging !== insertBefore || originalPosition.parent !== draggedTo);

      context.finalize = (valid = context.valid) => {

        if (!valid && this.context) {
          me.revertPosition();
        }

        dragging.classList.remove(me.dropPlaceholderCls);
        dragProxy.remove();
        me.reset();
      };


      context.async = false;
      me.trigger('drop', {
        context,
        event
      });

      if (!context.async) {

        context.finalize();
      } else {
        context.awaitingFinalization = true;
      }
    }
  }


  abortContainerDrag(invalid = false, event = null, silent = false) {
    const me = this,
      context = me.context;

    if (context.dragging) {
      context.dragging.classList.remove(me.dropPlaceholderCls);
      context.dragProxy.remove();
      me.context = {};
    }

    if (!silent) {
      me.trigger(invalid ? 'drop' : 'abort', {
        context,
        event
      });
    }
  }


  updateContainerProxy(event) {
    const me = this,
      context = me.context,
      proxy = context.dragProxy;
    let newX = event.pageX - context.offsetX,
      newY = event.pageY - context.offsetY;

    if (typeof me.minX === 'number') {
      newX = Math.max(me.minX, newX);
    }

    if (typeof me.maxX === 'number') {
      newX = Math.min(me.maxX - proxy.offsetWidth, newX);
    }

    if (typeof me.minY === 'number') {
      newY = Math.max(me.minY, newY);
    }

    if (typeof me.maxY === 'number') {
      newY = Math.min(me.maxY - proxy.offsetHeight, newY);
    }

    if (me.lockX) {
      DomHelper.setTranslateY(proxy, newY);
    } else if (me.lockY) {
      DomHelper.setTranslateX(proxy, newX);
    } else {
      DomHelper.setTranslateXY(proxy, newX, newY);
    }

    let targetElement;

    if (event.type === 'touchmove') {
      let touch = event.changedTouches[0];
      targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      targetElement = event.target;
    }

    context.targetElement = targetElement;
  }


  moveNextTo(targetElement, event) {
    const context = this.context,
      dragElement = context.dragging,
      parent = targetElement.parentElement;

    if (targetElement !== dragElement) {

      const centerX = targetElement.getBoundingClientRect().left + targetElement.offsetWidth / 2;

      if (event.pageX < centerX) {

        parent.insertBefore(dragElement, targetElement);
        context.insertBefore = targetElement;
      } else {

        if (targetElement.nextElementSibling) {

          if (targetElement.nextElementSibling !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
            parent.insertBefore(dragElement, targetElement.nextElementSibling);
          } else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {


            context.insertBefore = targetElement.nextElementSibling;
          }
        } else {
          parent.appendChild(dragElement);
          context.insertBefore = null;
        }
      }

      context.draggedTo = parent;
    }
  }


  revertPosition() {
    const context = this.context,
      original = context.originalPosition;

    if (original.next) {
      const isNoop = original.next && original.next.previousSibling === context.dragging || !original.next && context.dragging === original.parent.lastChild;

      if (!isNoop) {
        original.parent.insertBefore(context.dragging, original.next);
      }
    } else {
      original.parent.appendChild(context.dragging);
    }

    context.draggedTo = null;
  }

});


const noScroll = {
  pageXOffset: 0,
  pageYOffset: 0
};


var DragHelperTranslate = (Target => class DragHelperTranslate extends Delayable(Target || Base) {


  initTranslateDrag() {
    const me = this;
    me.mode = me.mode || 'translateXY';

    if (!me.isElementDraggable && me.targetSelector) {
      me.isElementDraggable = element => DomHelper.up(element, me.targetSelector);
    }
  }


  grabTranslateDrag(event) {
    const me = this,
      element = me.getTarget(event);

    if (element) {
      me.context = {
        valid: true,
        action: me.mode,

        element,
        startPageX: event.pageX,
        startPageY: event.pageY,
        startClientX: event.clientX,
        startClientY: event.clientY
      };
      return true;
    }

    return false;
  }

  getTarget(event) {
    return DomHelper.up(event.target, this.targetSelector);
  }


  startTranslateDrag(event) {
    const me = this,
      context = me.context,
      {
        relatedElements
      } = context;
    let element = context.dragProxy || context.element;

    if (element && !context.started) {
      const grabbed = element,
        grabbedParent = element.parentElement,

        dragWithin = me.dragWithin = me.dragWithin || me.cloneTarget && document.body,
        outerElement = me.outerElement;

      if (me.cloneTarget) {
        const offsetX = DomHelper.getOffsetX(element, dragWithin),
          offsetY = DomHelper.getOffsetY(element, dragWithin),
          offsetWidth = element.offsetWidth,
          offsetheight = element.offsetHeight;
        element = this.createProxy(element);

        DomHelper.setTranslateXY(element, offsetX, offsetY);
        element.style.width = `${offsetWidth}px`;
        element.style.height = `${offsetheight}px`;
        element.classList.add(me.dragProxyCls);
        dragWithin.appendChild(element);
        grabbed.classList.add('b-drag-original');

        if (me.hideOriginalElement) {
          grabbed.classList.add('b-hidden');
        }
      }

      Object.assign(me.context, {

        element,

        grabbed,

        grabbedParent,

        grabbedNextSibling: element.nextElementSibling,

        elementStartX: DomHelper.getTranslateX(element),
        elementStartY: DomHelper.getTranslateY(element),
        elementX: DomHelper.getOffsetX(element, dragWithin || outerElement),
        elementY: DomHelper.getOffsetY(element, dragWithin || outerElement),
        scrollX: 0,
        scrollY: 0,
        scrollManagerElementContainsDragProxy: !me.cloneTarget || dragWithin === outerElement
      });
      element.classList.add(me.draggingCls);

      if (dragWithin) {
        context.parentElement = element.parentElement;

        if (dragWithin !== element.parentElement) {
          dragWithin.appendChild(element);
        }

        me.updateTranslateProxy(event);
      }

      if (relatedElements) {
        relatedElements.forEach(r => {
          r.classList.add(me.draggingCls);
        });
      }
    }
  }


  applyConstraints(element, x, y) {
    const me = this,
      dragWithin = me.dragWithin,
      {
        pageXOffset,
        pageYOffset
      } = dragWithin === document.body ? window : noScroll;

    if (dragWithin && me.constrain) {
      if (x < 0) x = 0;
      if (x + element.offsetWidth > dragWithin.scrollWidth) x = dragWithin.scrollWidth - element.offsetWidth;
      if (y < 0) y = 0;
      if (y + element.offsetHeight > dragWithin.scrollHeight) y = dragWithin.scrollHeight - element.offsetHeight;
    }

    if (typeof me.minX === 'number') {
      x = Math.max(me.minX + pageXOffset, x);
    }

    if (typeof me.maxX === 'number') {
      x = Math.min(me.maxX + pageXOffset, x);
    }

    if (typeof me.minY === 'number') {
      y = Math.max(me.minY + pageYOffset, y);
    }

    if (typeof me.maxY === 'number') {
      y = Math.min(me.maxY + pageYOffset, y);
    }

    return {
      constrainedX: x,
      constrainedY: y
    };
  }


  updateTranslateProxy(event, scrollManagerConfig) {
    const me = this,
      {
        mode,
        lockX,
        lockY
      } = me,
      context = me.context,
      element = context.dragProxy || context.element,
      {
        relatedElements,
        relatedElDragFromPos
      } = context;


    if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
      context.scrollX = scrollManagerConfig.scrollRelativeLeft;
      context.scrollY = scrollManagerConfig.scrollRelativeTop;
    }

    context.pageX = event.pageX;
    context.pageY = event.pageY;
    context.clientX = event.clientX;
    context.clientY = event.clientY;
    const newX = context.elementStartX + event.pageX - context.startPageX + context.scrollX,
      newY = context.elementStartY + event.pageY - context.startPageY + context.scrollY,
      {
        constrainedX,
        constrainedY
      } = me.applyConstraints(element, newX, newY);

    if (mode === 'translateXY' && !(lockX || lockY)) {
      DomHelper.setTranslateXY(element, constrainedX, constrainedY);
    } else if (mode === 'translateX' || lockY) {
      DomHelper.setTranslateX(element, constrainedX);
    } else if (mode === 'translateY' || lockX) {
      DomHelper.setTranslateY(element, constrainedY);
    }

    if (relatedElements) {
      const deltaX = !lockX && mode !== 'translateY' ? constrainedX - context.elementStartX : 0,
        deltaY = !lockY && mode !== 'translateX' ? constrainedY - context.elementStartY : 0;
      relatedElements.forEach((r, i) => {
        const [x, y] = relatedElDragFromPos[i];
        DomHelper.setTranslateXY(r, x + deltaX, y + deltaY);
      });
    }

    context.newX = constrainedX;
    context.newY = constrainedY;
  }


  finishTranslateDrag(event) {
    const me = this,
      context = me.context,
      xChanged = context.newX !== context.elementStartX,
      yChanged = context.newY !== context.elementStartY,
      element = context.dragProxy || context.element,
      {
        relatedElements
      } = context;

    function cleanUp() {
      element.classList.remove(me.invalidCls);
      element.classList.remove(me.draggingCls);

      if (relatedElements) {
        relatedElements.forEach(r => {
          r.classList.remove(me.invalidCls);
          r.classList.remove(me.draggingCls);
        });
      }

      if (!element.classList.contains('b-aborting')) {
        if (me.hideOriginalElement) {
          context.grabbed.classList.remove('b-hidden');
        }

        context.grabbed.classList.remove('b-drag-original');
      }
    }

    if (!me.ignoreSamePositionDrop || me.mode !== 'translateY' && xChanged || me.mode !== 'translateX' && yChanged) {
      if (context.valid === false) {
        me.abortTranslateDrag(true, event);
      } else {
        const targetRect = Rectangle.from(me.dragWithin || me.outerElement);

        if (!me.minX && event.pageX < targetRect.left || !me.maxX && event.pageX > targetRect.right || !me.minY && event.pageY < targetRect.top || !me.maxY && event.pageY > targetRect.bottom) {

          context.valid = false;
          me.abortTranslateDrag(true, event);
        } else {
          context.finalize = (valid = context.valid) => {
            if (context.asyncCleanup) {
              cleanUp();
            }

            if (!valid && me.context) {

              me.abortTranslateDrag(true, null, true);
            } else if (me.cloneTarget || context.dragProxy) {
              element.remove();
            }

            me.reset();
          };


          context.async = false;
          me.trigger('drop', {
            context,
            event
          });

          if (!context.async) {

            context.finalize();
          } else {
            context.awaitingFinalization = true;
          }
        }
      }

      if (!context.asyncCleanup) {
        cleanUp();
      }
    } else {

      me.abortTranslateDrag(false, event);
    }
  }


  abortTranslateDrag(invalid = false, event = null, silent = false) {
    const me = this,
      context = me.context,
      {
        relatedElements,
        relatedElStartPos,
        grabbed
      } = context,
      element = context.dragProxy || context.element,
      resetEl = me.cloneTarget && me.hideOriginalElement ? grabbed : element;
    let {
      elementStartX,
      elementStartY
    } = context;

    if (element && context.started) {

      if (!me.cloneTarget && me.dragWithin && me.dragWithin !== context.grabbedParent) {
        context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
      }

      grabbed.classList.remove('b-hidden');


      if (me.cloneTarget) {
        if (me.hideOriginalElement) {
          [elementStartX, elementStartY] = DomHelper.getTranslateXY(grabbed);
          DomHelper.alignTo(grabbed, element);


          resetEl.getBoundingClientRect();
        }

        element.remove();
      }

      resetEl.classList.add('b-aborting');

      if (me.mode === 'translateXY' && !(me.lockX || me.lockY)) {
        DomHelper.setTranslateXY(resetEl, elementStartX, elementStartY);
        relatedElements && relatedElements.forEach((element, i) => {
          element.classList.add('b-aborting');
          DomHelper.setTranslateXY(element, relatedElStartPos[i][0], relatedElStartPos[i][1]);
        });
      }

      if (me.mode === 'translateX' || me.lockY) {
        DomHelper.setTranslateX(resetEl, elementStartX);
        relatedElements && relatedElements.forEach((element, i) => {
          element.classList.add('b-aborting');
          DomHelper.setTranslateX(element, relatedElStartPos[i][0]);
        });
      }

      if (me.mode === 'translateY' || me.lockX) {
        DomHelper.setTranslateY(resetEl, elementStartY);
        relatedElements && relatedElements.forEach((element, i) => {
          element.classList.add('b-aborting');
          DomHelper.setTranslateY(element, relatedElStartPos[i][1]);
        });
      }

      me.setTimeout(() => {
        resetEl.classList.remove('b-aborting');
        grabbed.classList.remove('b-dragging');
        grabbed.classList.remove('b-drag-original');

        if (!me.cloneTarget) {
          relatedElements && relatedElements.forEach((element, i) => {
            element.classList.remove('b-aborting');
          });
          element.classList.remove('b-aborting');
          element.classList.remove(me.draggingCls);
          element.classList.remove(me.invalidCls);
        }
      }, me.transitionDuration, undefined, true);

      if (!silent) {
        me.trigger(invalid ? 'drop' : 'abort', {
          context,
          event
        });
      }
    }

    me.reset();
  }

});


const documentListeners = {
  down: 'onMouseDown',
  move: 'onMouseMove',
  up: 'onMouseUp',
  docclick: 'onDocumentClick',
  touchstart: 'onTouchStart',
  touchmove: 'onTouchMove',
  touchend: 'onTouchEnd',
  keydown: 'onKeyDown'
};


class DragHelper extends base(Base).mixes(Events, DragHelperContainer, DragHelperTranslate) {

  static get defaultConfig() {
    return {

      dragProxyCls: 'b-drag-proxy',


      invalidCls: 'b-drag-invalid',


      draggingCls: 'b-dragging',


      dropPlaceholderCls: 'b-drop-placeholder',


      dragThreshold: 5,


      outerElement: document.body,


      dragWithin: null,


      constrain: true,


      minX: null,


      maxX: null,


      minY: null,


      maxY: null,


      mode: null,


      isElementDraggable: null,


      targetSelector: null,


      dropTargetSelector: null,


      cloneTarget: false,


      hideOriginalElement: false,


      containers: null,


      ignoreSelector: null,
      startEvent: null,


      lockX: false,


      lockY: false,


      touchStartDelay: 300,

      transitionDuration: 300,
      clickSwallowDuration: 50,
      ignoreSamePositionDrop: true,
      testConfig: {
        transitionDuration: 10,


        clickSwallowDuration: BrowserHelper.isEdge ? 300 : 50
      }
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);
    me.initListeners();

    if (me.mode === 'container') {
      me.initContainerDrag();
    } else if (me.mode.startsWith('translate')) {
      me.initTranslateDrag();
    }

    me.initialMode = me.mode;
  }

  doDestroy() {

    this.abort(true);
    super.doDestroy();
  }


  initListeners() {
    const dragStartListeners = {
      element: this.outerElement,
      mousedown: documentListeners.down,
      thisObj: this
    };

    if (BrowserHelper.isTouchDevice) {
      dragStartListeners.touchstart = documentListeners.touchstart;
    }

    EventHelper.on(dragStartListeners);
  }


  onPointerDown(event) {
    let me = this,
      handled = false,
      isTouch = ('touches' in event);


    if (me.context) {
      if (!me.context.awaitingFinalization) {
        me.onMouseUp(event);
        me.reset();
      }

      return;
    }

    me.startEvent = event;
    if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) return;

    if (me.mode) {
      if (!handled && me.mode === 'container') handled = me.grabContainerDrag(event);
      if (!handled && me.mode.startsWith('translate')) handled = me.grabTranslateDrag(event);
    }

    if (handled) {
      const dragListeners = {
        element: document,
        thisObj: me,
        keydown: documentListeners.keydown
      };

      if (isTouch) {
        dragListeners.touchmove = {
          handler: documentListeners.touchmove,
          passive: false

        };


        dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
      } else {
        dragListeners.mousemove = documentListeners.move;
        dragListeners.mouseup = documentListeners.up;
      }

      me.removeListeners = EventHelper.on(dragListeners);

      if (me.dragWithin && me.dragWithin !== me.outerElement) {
        const box = me.dragWithin.getBoundingClientRect();
        me.minY = box.top;
        me.maxY = box.bottom;
        me.minX = box.left;
        me.maxX = box.right;
      }
    }
  }


  onTouchStart(event) {
    const me = this;

    if (event.touches.length === 1) {
      me.touchStartTimer = me.setTimeout(() => {
        me.touchStartTimer = null;
      }, me.touchStartDelay, 'touchStartDelay');
      me.onPointerDown(event);
    }
  }


  onMouseDown(event) {

    if (event.button === 0) {
      this.onPointerDown(event);
    }
  }

  internalMove(event) {
    const me = this,
      context = me.context,
      distance = EventHelper.getDistanceBetween(me.startEvent, event),
      abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;

    if (abortTouchDrag) {
      me.abort(true);
      return;
    }

    if (!me.touchStartTimer && context && context.element &&
      event.target && event.target.nodeType === Node.ELEMENT_NODE && (context.started || distance >= me.dragThreshold)) {
      if (!context.started) {

        if (me.callPreventable('dragStart', {
          context,
          event
        }, () => {
          if (me.mode !== 'container') {
            if (me.lockY) {
              me.mode = 'translateX';
            } else if (me.lockX) {
              me.mode = 'translateY';
            } else {
              me.mode = me.initialMode;
            }
          }

          const direction = me.lockX ? 'vertical' : me.lockY ? 'horizontal' : 'both';

          if (context.action.startsWith('translate')) {
            me.startTranslateDrag(event);
          } else if (context.action === 'container') {
            me.startContainerDrag(event);
          }

          context.started = true;

          if (me.scrollManager) {
            me.scrollManager.startMonitoring({
              direction: direction,
              element: me.dragWithin || me.outerElement,
              callback: config => {
                if (me.context.element && me.lastMouseMoveEvent) {

                  me.lastMouseMoveEvent.isScroll = true;
                  me.update(me.lastMouseMoveEvent, config);
                }
              },
              thisObj: me
            });
          }

          document.body.classList.add('b-draghelper-active');
        }) === false) {
          return me.abort();
        }
      }

      if (event.type === 'touchmove') {
        event.preventDefault();
        event.stopImmediatePropagation();
      }

      me.update(event);
    }
  }

  onTouchMove(event) {
    this.internalMove(event);
  }


  onMouseMove(event) {
    this.internalMove(event);
  }


  update(event, scrollManagerConfig) {
    const me = this,
      context = me.context,
      draggingElement = context.dragProxy || context.element;

    let target = event.target,
      scrollingPageElement = document.scrollingElement || document.body;


    if (event.type === 'touchmove') {
      const touch = event.changedTouches[0];
      target = DomHelper.elementFromPoint(touch.clientX + scrollingPageElement.scrollLeft, touch.clientY + scrollingPageElement.scrollTop);
    }

    context.target = target;

    if (me.dropTargetSelector) {
      context.valid = Boolean(target.closest(me.dropTargetSelector));
    } else {

      context.valid = true;
    }

    if (context.action) {
      if (context.action === 'container') {
        me.updateContainerProxy(event, scrollManagerConfig);
      }

      if (context.action.startsWith('translate')) {
        me.updateTranslateProxy(event, scrollManagerConfig);
      }
    }

    me.trigger('drag', {
      context,
      event
    });


    if (context.action === 'container') {
      me.updateContainerDrag(event, scrollManagerConfig);
    }

    draggingElement.classList[context.valid ? 'remove' : 'add'](me.invalidCls);
    if (event) me.lastMouseMoveEvent = event;
  }


  abort(silent = false) {
    const me = this,
      context = me.context;
    me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

    if (context) {

      context.element.getBoundingClientRect();

      context.valid = false;

      if (context.action === 'container') {
        me.abortContainerDrag(undefined, undefined, silent);
      } else {
        me.abortTranslateDrag(undefined, undefined, silent);
      }
    }

    me.reset();
  }


  removeListeners() {
  }


  reset(silent) {
    document.body.classList.remove('b-draghelper-active');
    this.removeListeners();


    if (!silent) {
      this.trigger('reset');
    }

    this.context = this.lastMouseMoveEvent = null;
  }

  onTouchEnd(event) {
    this.onMouseUp(event);
  }


  onDocumentClick(event) {
    event.stopPropagation();
  }


  onMouseUp(event) {
    const me = this,
      context = me.context;
    me.removeListeners();

    if (context) {
      me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

      if (context.action === 'container') {
        me.finishContainerDrag(event);
      } else if (context.started && context.action.startsWith('translate')) {
        me.finishTranslateDrag(event);
      }

      if (context.started) {


        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners.docclick,
          capture: true,
          expires: me.clickSwallowDuration,

          once: true
        });
      } else {
        me.reset(true);
      }
    }
  }


  onKeyDown(event) {
    if (event.key === 'Escape') this.abort();
  }


  createProxy(element) {
    const clone = element.cloneNode(true);
    clone.removeAttribute('id');
    return clone;
  }

}

DragHelper._$name = 'DragHelper';

const documentListeners$1 = {
  down: 'onMouseDown',
  move: 'onMouseMove',
  up: 'onMouseUp',
  docclick: 'onDocumentClick',
  touchstart: 'onTouchStart',
  touchmove: 'onTouchMove',
  touchend: 'onTouchEnd',
  keydown: 'onKeyDown'
};


class ResizeHelper extends Events(Base) {

  static get defaultConfig() {
    return {

      resizingCls: 'b-resizing',


      dragThreshold: 5,


      handleSize: 10,


      dynamicHandleSize: null,


      reservedSpace: 10,


      touchHandleSize: 30,


      minWidth: 1,


      maxWidth: 0,


      minHeight: 1,


      maxHeight: 0,

      outerElement: document.body,


      scroller: null,


      allowResize: null,


      dragWithin: null,


      isElementResizable: null,


      targetSelector: null,


      leftHandle: true,


      rightHandle: true,


      topHandle: true,


      bottomHandle: true,


      handleSelector: null,


      handleContainerSelector: null,
      startEvent: null,


      grab: null,


      invalidCls: 'b-resize-invalid',


      handleVisibilityThreshold: null,


      skipTranslate: false,


      direction: 'horizontal'
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);

    if (!me.handleSelector && BrowserHelper.isTouchDevice) {
      me.handleSize = me.touchHandleSize;
    }

    me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;
    me.initListeners();
    me.initResize();
  }

  doDestroy() {
    this.abort(true);
    super.doDestroy();
  }


  initResize() {
    const me = this;

    if (!me.isElementResizable && me.targetSelector) {
      me.isElementResizable = element => DomHelper.up(element, me.targetSelector);
    }

    if (me.grab) {
      const {
        edge,
        element,
        event
      } = me.grab;
      me.startEvent = event;

      me.context = {
        element,
        edge,
        valid: true,
        async: false,
        elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,

        elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,

        newX: DomHelper.getTranslateX(element) || element.offsetLeft,

        newY: DomHelper.getTranslateY(element) || element.offsetTop,

        elementWidth: element.offsetWidth,
        elementHeight: element.offsetHeight,
        startX: event.clientX + me.scrollLeft,
        startY: event.clientY + me.scrollTop,
        started: true,
        finalize: () => me.reset && me.reset()
      };
      element.classList.add(me.resizingCls);
      me.internalStartResize(me.isTouch);
    }
  }


  initListeners() {
    const me = this,
      dragStartListeners = {
        element: me.outerElement,
        mousedown: documentListeners$1.down,
        thisObj: me
      };

    if (BrowserHelper.isTouchDevice) {
      dragStartListeners.touchstart = documentListeners$1.touchstart;
    } else if (!me.handleSelector) {
      dragStartListeners.mousemove = {
        handler: documentListeners$1.move,


        delegate: me.targetSelector
      };

      dragStartListeners.mouseleave = {
        handler: 'onMouseLeaveTarget',
        delegate: me.targetSelector,
        capture: true
      };
    }

    me.removeListeners = EventHelper.on(dragStartListeners);
  }

  removeListeners() {
  }


  get scrollLeft() {
    if (this.scroller) {
      return this.scroller.x;
    }

    return this.outerElement.scrollLeft;
  }

  get scrollTop() {
    if (this.scroller) {
      return this.scroller.y;
    }

    return this.outerElement.scrollTop;
  }


  internalStartResize(isTouch) {
    const me = this,
      dragListeners = {
        element: document,
        keydown: documentListeners$1.keydown,
        thisObj: me
      };

    if (isTouch) {
      dragListeners.touchmove = documentListeners$1.touchmove;


      dragListeners.touchend = dragListeners.pointerup = documentListeners$1.touchend;
    } else {
      dragListeners.mousemove = documentListeners$1.move;
      dragListeners.mouseup = documentListeners$1.up;
    }

    me.removeDragListeners = EventHelper.on(dragListeners);
    me.scrollManager && me.scrollManager.startMonitoring({
      direction: me.direction,

      element: me.dragWithin || me.outerElement,
      callback: config => me.context && me.context.element && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config),
      thisObj: me
    });
  }


  removeDragListeners() {
  }

  reset() {
    this.removeDragListeners();
    this.context = null;
  }

  onPointerDown(isTouch, event) {
    const me = this;
    me.startEvent = event;

    if (!me.isElementResizable || me.isElementResizable(event.target, event)) {
      if (me.grabResizeHandle(isTouch, event)) {

        event.stopImmediatePropagation();
        me.internalStartResize(isTouch);
      }
    }
  }

  onTouchStart(event) {

    if (event.touches.length > 1) {
      return;
    }

    this.onPointerDown(true, event);
  }


  onMouseDown(event) {

    if (event.button !== 0) {
      return;
    }

    this.onPointerDown(false, event);
  }

  internalMove(isTouch, event) {
    const me = this,
      context = me.context;

    if (context && context.element && (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)) {
      if (!context.started) {
        me.trigger('resizeStart', {
          context,
          event
        });
        context.started = true;
      }

      me.update(event);
    } else if (!isTouch && !me.handleSelector) {
      me.checkResizeHandles(event);
    }
  }

  onTouchMove(event) {
    this.internalMove(true, event);
  }


  onMouseMove(event) {
    this.internalMove(false, event);
  }

  internalEnd(isTouch, event) {
    const me = this,
      context = me.context;
    me.removeDragListeners();

    if (context) {
      me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);
      me.finishResize(event);

      if (me.context && !BrowserHelper.isFirefox && !BrowserHelper.isSafari) {


        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners$1.docclick,
          capture: true,
          once: true
        });
      }
    }
  }

  onTouchEnd(event) {
    this.internalEnd(true, event);
  }


  onMouseUp(event) {
    this.internalEnd(false, event);
  }


  onDocumentClick(event) {
    event.stopPropagation();
  }


  onKeyDown(event) {
    if (event.key === 'Escape') {
      this.abort();
    }
  }


  update(event) {
    const me = this,
      context = me.context,
      parentRectangle = Rectangle.from(me.outerElement.parentElement);

    context.currentX = Math.max(Math.min(event.clientX, parentRectangle.right - 1), parentRectangle.x) + me.scrollLeft;
    context.currentY = Math.max(Math.min(event.clientY, parentRectangle.bottom - 1), parentRectangle.y) + me.scrollTop;
    me.updateResize(event);
    me.trigger('resizing', {
      context,
      event
    });
    context.element.classList[context.valid === false ? 'add' : 'remove'](me.invalidCls);


    if (event) {
      me.lastMouseMoveEvent = event;
    }
  }


  abort(silent = false) {
    const me = this;
    me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

    if (me.context) {
      me.abortResize(null, silent);
    }
  }


  grabResizeHandle(isTouch, event) {
    const me = this;

    if (me.allowResize && !me.allowResize(event.target, event)) {
      return false;
    }

    const handleSelector = me.handleSelector,
      coordsFrom = event.type === 'touchstart' ? event.changedTouches[0] : event,
      clientX = coordsFrom.clientX,
      clientY = coordsFrom.clientY,

      element = me.targetSelector ? DomHelper.up(event.target, me.targetSelector) : event.target;

    if (element) {
      let edge;


      if (handleSelector) {
        if (event.target.matches(handleSelector)) {
          if (me.direction === 'horizontal') {
            if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
              edge = 'left';
            } else {
              edge = 'right';
            }
          } else {
            if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
              edge = 'top';
            } else {
              edge = 'bottom';
            }
          }
        } else {
          return false;
        }
      } else {
        if (me.direction === 'horizontal') {
          if (me.overLeftHandle(event, element)) {
            edge = 'left';
          } else if (me.overRightHandle(event, element)) {
            edge = 'right';
          }
        } else {
          if (me.overTopHandle(event, element)) {
            edge = 'top';
          } else if (me.overBottomHandle(event, element)) {
            edge = 'bottom';
          }
        }

        if (!edge) {
          me.context = null;

          return false;
        }
      }


      if (event.type === 'touchstart') {
        event.preventDefault();
      }

      if (me.trigger('beforeResizeStart', {
        element,
        event
      }) !== false) {

        me.context = {
          element,
          edge,
          valid: true,
          async: false,
          direction: me.direction,
          isTouch: isTouch,
          elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,

          elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,

          newX: DomHelper.getTranslateX(element) || element.offsetLeft,

          newY: DomHelper.getTranslateY(element) || element.offsetTop,

          elementWidth: element.offsetWidth,
          elementHeight: element.offsetHeight,
          startX: clientX + me.scrollLeft,
          startY: clientY + me.scrollTop,
          finalize: () => me.reset && me.reset()
        };
        element.classList.add(me.resizingCls);
        return true;
      }
    }

    return false;
  }


  checkResizeHandles(event) {
    const me = this,
      target = me.targetSelector ? DomHelper.up(event.target, me.targetSelector) : event.target;

    if (target && (!me.allowResize || me.allowResize(event.target, event))) {
      me.currentElement = me.handleContainerSelector ? DomHelper.up(event.target, me.handleContainerSelector) : event.target;

      if (me.currentElement) {
        let over = false;

        if (me.direction === 'horizontal') {
          over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
        } else {
          over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
        }

        if (over) {
          me.highlightHandle();
        } else {
          me.unHighlightHandle();
        }
      }
    } else if (me.currentElement) {
      me.unHighlightHandle();
    }
  }

  onMouseLeaveTarget(event) {
    const me = this;
    me.currentElement = me.handleContainerSelector ? DomHelper.up(event.target, me.handleContainerSelector) : event.target;

    if (me.currentElement) {
      me.unHighlightHandle();
    }
  }


  updateResize(event) {
    const me = this,
      context = me.context;

    if (me.allowEdgeSwitch) {
      if (me.direction === 'horizontal') {
        context.edge = context.currentX > context.startX ? 'right' : 'left';
      } else {
        context.edge = context.currentY > context.startY ? 'bottom' : 'top';
      }
    }

    let
      deltaX = context.currentX - context.startX,
      deltaY = context.currentY - context.startY,
      minWidth = DomHelper.getExtremalSizePX(context.element, 'minWidth') || me.minWidth,
      maxWidth = DomHelper.getExtremalSizePX(context.element, 'maxWidth') || me.maxWidth,
      minHeight = DomHelper.getExtremalSizePX(context.element, 'minHeight') || me.minHeight,
      maxHeight = DomHelper.getExtremalSizePX(context.element, 'maxHeight') || me.maxHeight,

      sign = context.edge === 'right' || context.edge === 'bottom' ? 1 : -1,

      newWidth = context.elementWidth + deltaX * sign,
      width = Math.max(minWidth, newWidth),
      newHeight = context.elementHeight + deltaY * sign,
      height = Math.max(minHeight, newHeight);

    if (maxWidth > 0) {
      width = Math.min(width, maxWidth);
    }

    if (maxHeight > 0) {
      height = Math.min(height, maxHeight);
    }

    if (context.element.style.flex) {
      context.element.style.flex = '';
    }

    if (me.direction === 'horizontal') {
      context.element.style.width = Math.abs(width) + 'px';
      context.newWidth = width;

      if (context.edge === 'left' || width < 0) {
        context.newX = Math.max(Math.min(context.elementStartX + context.elementWidth - me.minWidth, context.elementStartX + deltaX), 0);

        if (!me.skipTranslate) {
          DomHelper.setTranslateX(context.element, context.newX);
        }
      } else if (context.edge === 'right' && me.allowEdgeSwitch && !me.skipTranslate) {
        DomHelper.setTranslateX(context.element, context.elementStartX);
      }
    } else {
      context.element.style.height = Math.abs(height) + 'px';
      context.newHeight = height;

      if (context.edge === 'top' || height < 0) {
        context.newY = Math.max(Math.min(context.elementStartY + context.elementHeight - me.minHeight, context.elementStartY + deltaY), 0);

        if (!me.skipTranslate) {
          DomHelper.setTranslateY(context.element, context.newY);
        }
      } else if (context.edge === 'bottom' && me.allowEdgeSwitch && !me.skipTranslate) {
        DomHelper.setTranslateY(context.element, context.elementStartY);
      }
    }
  }


  finishResize(event) {
    const me = this,
      context = me.context,
      eventObject = {
        context,
        event
      };
    context.element.classList.remove(me.resizingCls);
    let changed = false;

    if (me.direction === 'horizontal') {
      changed = context.newWidth && context.newWidth !== context.elementWidth;
    } else {
      changed = context.newHeight && context.newHeight !== context.elementHeight;
    }

    me.trigger(changed ? 'resize' : 'cancel', eventObject);

    if (!context.async) {
      context.finalize();
    }
  }


  abortResize(event = null, silent = false) {
    const me = this,
      context = me.context;
    context.element.classList.remove(me.resizingCls);

    if (me.direction === 'horizontal') {
      DomHelper.setTranslateX(context.element, context.elementStartX);
      context.element.style.width = context.elementWidth + 'px';
    } else {
      DomHelper.setTranslateY(context.element, context.elementStartY);
      context.element.style.height = context.elementHeight + 'px';
    }

    !silent && me.trigger('cancel', {
      context,
      event
    });

    if (!me.isDestroyed) {
      me.reset();
    }
  }


  highlightHandle() {
    const me = this,
      target = me.targetSelector ? DomHelper.up(me.currentElement, me.targetSelector) : me.currentElement;

    me.currentElement.classList.add('b-resize-handle');
    target.classList.add('b-over-resize-handle');
  }


  unHighlightHandle() {
    const me = this,
      target = me.targetSelector ? DomHelper.up(me.currentElement, me.targetSelector) : me.currentElement;
    target && target.classList.remove('b-over-resize-handle');
    me.currentElement.classList.remove('b-resize-handle');
    me.currentElement = null;
  }

  overAnyHandle(event, target) {
    return this.overStartHandle(event, target) || this.overEndHandle(event, target);
  }

  overStartHandle(event, target) {
    return this.direction === 'horizontal' ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
  }

  overEndHandle(event, target) {
    return this.direction === 'horizontal' ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
  }

  getDynamicHandleSize(opposite, offsetWidth) {
    const handleCount = opposite ? 2 : 1,
      {
        handleSize
      } = this;

    if (this.dynamicHandleSize && handleSize * handleCount > offsetWidth - this.reservedSpace) {
      return Math.max((offsetWidth - this.reservedSpace) / handleCount, 1);
    }

    return handleSize;
  }


  overLeftHandle(event, target) {
    const me = this,
      {
        offsetWidth
      } = target;

    if (me.leftHandle && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const leftHandle = Rectangle.from(target);
      leftHandle.width = me.getDynamicHandleSize(me.rightHandle, offsetWidth);
      return leftHandle.contains(EventHelper.getPagePoint(event));
    }

    return false;
  }


  overRightHandle(event, target) {
    const me = this,
      {
        offsetWidth
      } = target;

    if (me.rightHandle && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const rightHandle = Rectangle.from(target);
      rightHandle.x = rightHandle.right - me.getDynamicHandleSize(me.leftHandle, offsetWidth);
      return rightHandle.contains(EventHelper.getPagePoint(event));
    }

    return false;
  }


  overTopHandle(event, target) {
    const me = this,
      {
        offsetHeight
      } = target;

    if (me.topHandle && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const topHandle = Rectangle.from(target);
      topHandle.height = me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return topHandle.contains(EventHelper.getPagePoint(event));
    }

    return false;
  }


  overBottomHandle(event, target) {
    const me = this,
      {
        offsetHeight
      } = target;

    if (me.bottomHandle && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const bottomHandle = Rectangle.from(target);
      bottomHandle.y = bottomHandle.bottom - me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return bottomHandle.contains(EventHelper.getPagePoint(event));
    }

    return false;
  }

}

ResizeHelper._$name = 'ResizeHelper';


class RandomGenerator {
  constructor() {
    this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86];
    this.randomCache = {};
    this.rndIndex = 0;
  }


  nextRandom(max) {
    let randomCache = this.randomCache,
      randomNumbers;

    if (randomCache[max]) {
      randomNumbers = randomCache[max];
    } else {
      randomNumbers = this.random100.filter(num => num < max);
      randomCache[max] = randomNumbers;
    }

    return randomNumbers[this.rndIndex++ % randomNumbers.length];
  }


  reset() {
    this.rndIndex = 0;
  }


  fromArray(array) {
    return array[this.nextRandom(array.length)];
  }

}

RandomGenerator._$name = 'RandomGenerator';

class DataGenerator {

  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
    this.rndRating.reset();
  }


  static* generate(count, randomHeight = false, initialId = 1) {
    const me = this,
      rnd = me.rnd,
      rndTime = me.rndTime,
      rndRating = me.rndRating,
      firstNames = me.firstNames,
      surNames = me.surNames,
      teams = me.teams,
      foods = me.foods,
      colors = me.colors,
      cities = me.cities;

    for (let i = 0; i < count; i++) {
      const firstName = rnd.fromArray(firstNames),
        surName = rnd.fromArray(surNames),
        name = `${firstName} ${String.fromCharCode(65 + i % 25)} ${surName}`,
        startDay = rnd.nextRandom(60) + 1,
        start = new Date(2019, 0, startDay),
        finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2),

        row = {
          id: i + initialId,
          title: 'Row ' + i,
          name: name,
          firstName: firstName,
          surName: surName,
          city: rnd.fromArray(cities),
          team: rnd.fromArray(cities) + ' ' + rnd.fromArray(teams),
          age: 10 + rnd.nextRandom(80),
          food: rnd.fromArray(foods),
          color: rnd.fromArray(colors),
          score: rnd.nextRandom(100) * 10,
          rank: rnd.nextRandom(100) + 1,
          start: start,
          finish: finish,
          time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
          percent: rnd.nextRandom(100),
          done: rnd.nextRandom(100) < 50,
          rating: rndRating.nextRandom(5),
          relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10))
        };

      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }

      yield row;
    }
  }


  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    if (reset) this.reset();
    const rows = [],
      number = DataGenerator.overrideRowCount ? DataGenerator.overrideRowCount : count,
      generator = this.generate(number, randomHeight, initialId);

    for (let i = 0; i < number; i++) {
      rows.push(generator.next().value);
    }

    return rows;
  }

}

Object.assign(DataGenerator, {
  rnd: new RandomGenerator(),
  rndTime: new RandomGenerator(),
  rndRating: new RandomGenerator(),
  cities: ['Stockholm', 'Barcelona', 'Paris', 'Dubai', 'New York', 'San Francisco', 'Washington', 'Moscow'],
  firstNames: ['Mike', 'Linda', 'Don', 'Karen', 'Doug', 'Jenny', 'Daniel', 'Melissa', 'John', 'Jane', 'Theo', 'Lisa', 'Adam', 'Mary', 'Barbara', 'James', 'David'],
  surNames: ['McGregor', 'Ewans', 'Scott', 'Smith', 'Johnson', 'Adams', 'Williams', 'Brown', 'Jones', 'Miller', 'Davis', 'More', 'Wilson', 'Taylor', 'Anderson', 'Thomas', 'Jackson'],
  teams: ['Lions', 'Eagles', 'Tigers', 'Horses', 'Dogs', 'Cats', 'Panthers', 'Rats', 'Ducks', 'Cougars', 'Hens', 'Roosters'],
  foods: ['Pancake', 'Burger', 'Fish n chips', 'Carbonara', 'Taco', 'Salad', 'Bolognese', 'Mac n cheese', 'Waffles'],
  colors: ['Blue', 'Green', 'Red', 'Yellow', 'Pink', 'Purple', 'Orange', 'Teal', 'Black']
});
DataGenerator._$name = 'DataGenerator';

const knownProps = ['action', 'target', 'to', 'deltaX', 'deltaY', 'x', 'y', 'text'];

class DemoBot extends Events(Delayable()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }

  construct(config) {
    super.construct(config);
    const me = this;

    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }

    EventHelper.playingDemo = true;
    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: 'div',
        className: 'simulated-mouse'
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });
    me.intervalId = me.setInterval(me.nextStep.bind(me), 1000);
    me.outerElement.classList.add('b-playing-demo');
    me.outerElement.addEventListener('click', event => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }

  doDestroy() {
    this.abort();
  }

  abort(atEnd = false) {
    const me = this;
    me.mouse.style.top = '-100px';
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);
    me.outerElement.classList.remove('b-playing-demo');

    if (me.widget) {
      me.widget.playingDemo = false;
    }

    EventHelper.playingDemo = false;
    me.trigger(atEnd ? 'done' : 'abort');
  }

  triggerEvent(element, type, data) {
    if (!element) return null;
    let event;

    if (type.startsWith('mouse')) {
      const box = this.mouse.getBoundingClientRect();
      event = new MouseEvent(type, Object.assign({
        view: window,
        bubbles: true,
        cancelable: true,
        clientX: box.left,
        clientY: box.top
      }, data || {}));
    } else {
      event = document.createEvent('Event');
      event.initEvent(type, true, false);
    }

    element.dispatchEvent(event);
    return event;
  }

  handleMouseMove(step, target) {
    const me = this,
      mouse = me.mouse;
    mouse.classList.add('quick');
    if (me.mouseDown) mouse.classList.add('drag');
    let mouseBox = Rectangle.from(mouse, me.outerElement),
      x = mouseBox.x,
      y = mouseBox.y,
      deltaX = 0,
      deltaY = 0;

    if (step.to) {
      if (typeof step.to === 'string') {
        const toElement = me.outerElement.querySelector(step.to);

        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement),
            toX = rect.x + rect.width / 2,
            toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }

    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }

    let i = 0;
    me.innerIntervalId = me.setInterval(() => {

      if (me.shouldPause) {
        return;
      }

      if (i++ === 9) {
        clearInterval(me.innerIntervalId);

        if (step.then) {
          step.then();
        }
      }

      const mouseX = x + deltaX * i,
        mouseY = y + deltaY * i;

      mouse.style.left = mouseX + 'px';
      mouse.style.top = mouseY + 'px';
      const mouseBounds = mouse.getBoundingClientRect(),
        clientX = mouseBounds.left,
        clientY = mouseBounds.top,
        eventTarget = document.elementFromPoint(clientX, clientY);

      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);

          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach(element => me.triggerEvent(element, 'mouseout'));
            me.mouseOutElements.length = 0;
          }
        }

        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, 'mouseover');
      }

      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }

  getTarget(step) {
    const me = this,
      target = step.target;

    if (!target) {
      return me.prevTarget || me.outerElement;
    }

    if (typeof target === 'function') {
      return target(step);
    }

    return document.querySelector(target);
  }

  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === 'function') {
        return step.action(step);
      }

      return step;
    }

    if (typeof step === 'function') {
      step();
      return step;
    }

    for (let prop in step) {
      if (step.hasOwnProperty(prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }

    if (!step.target && (typeof step.to === 'string' || typeof step.to === 'function')) step.target = step.to;
    return step;
  }

  get isScrolling() {
    const me = this,
      box = me.outerElement.getBoundingClientRect(),
      scrolled = me.lastTop && box.top !== me.lastTop;
    me.lastTop = box.top;
    return scrolled;
  }

  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < window.innerHeight && box.bottom > 0;
  }

  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }

  nextStep() {
    const me = this;

    if (me.shouldPause) {
      return;
    }

    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }

    if (me.currentStep === 0) {
      me.trigger('initialize');
    }

    const mouse = me.mouse,
      step = me.normalizeStep(me.steps[me.currentStep++]),
      target = me.getTarget(step),
      action = step.action;

    if (target && action) {
      mouse.className = 'simulated-mouse';

      if (action === 'mousemove') {
        me.handleMouseMove(step, target);
      } else {

        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + 'px';
          mouse.style.top = rect.y + rect.height / 2 + 'px';
        }

        if (action === 'mousedown') {
          me.mouseDown = true;
        }

        if (action === 'mouseup') {
          me.mouseDown = false;
        }

        me.timeoutId = me.setTimeout(() => {
          me.prevTarget = target;

          mouse.classList.add(action);

          if (action === 'type') {
            const field = IdHelper.fromElement(target),
              parts = step.text.split('|');
            field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
          } else {
            me.triggerEvent(target, action);
          }
        }, action === 'type' ? 100 : 550);
      }
    }
  }

}

DemoBot._$name = 'DemoBot';


class Fullscreen {
  static init() {
    const fnNames = ['fullscreenEnabled', 'requestFullscreen', 'exitFullscreen', 'fullscreenElement'],

      prefixFn = prefix => fnNames.map(fn => {
        let result = prefix + StringHelper.capitalizeFirstLetter(fn);

        if (prefix === 'moz') {
          result = result.replace('screen', 'Screen');


          if ('mozCancelFullScreen' in document && fn === 'exitFullscreen') {
            result = 'mozCancelFullScreen';
          }
        }

        return result;
      });

    this.functions = 'fullscreenEnabled' in document && fnNames || 'webkitFullscreenEnabled' in document && prefixFn('webkit') || 'mozFullScreenEnabled' in document && prefixFn('moz') || 'msFullscreenEnabled' in document && prefixFn('ms') || [];

    const eventNames = ['fullscreenchange', 'fullscreenerror'],
      msEventNames = ['MSFullscreenChange', 'MSFullscreenError'],
      prefixEvt = prefix => eventNames.map(eventName => prefix + StringHelper.capitalizeFirstLetter(eventName));

    this.events = 'fullscreenEnabled' in document && eventNames || 'webkitFullscreenEnabled' in document && prefixEvt('webkit') || 'mozFullscreenEnabled' in document && prefixEvt('moz') || 'msFullscreenEnabled' in document && msEventNames || [];
  }


  static get enabled() {
    return document[this.functions[0]];
  }


  static request(element) {
    return element[this.functions[1]]();
  }


  static exit() {
    return document[this.functions[2]]();
  }


  static get isFullscreen() {
    return !!document[this.functions[3]];
  }


  static onFullscreenChange(fn) {
    document.addEventListener(this.events[0], fn);
  }


  static unFullscreenChange(fn) {
    document.removeEventListener(this.events[0], fn);
  }

}

Fullscreen.init();
Fullscreen._$name = 'Fullscreen';


const excludedPropNames = {
  constructor: 1,
  prototype: 1,
  name: 1,
  length: 1,
  arguments: 1,
  caller: 1,
  callee: 1,
  __proto__: 1
};


class Override {

  static apply(override) {
    if (!override.target) throw new Error('Override must specify what it overrides, using static getter target');
    if (!override.target.class) throw new Error('Override must specify which class it overrides, using target.class');
    if (!this.shouldApplyOverride(override)) return false;
    const staticKeys = Object.getOwnPropertyNames(override),
      instanceKeys = Object.getOwnPropertyNames(override.prototype);
    staticKeys.splice(staticKeys.indexOf('target'), 1);
    this.internalOverrideAll(override.target.class, staticKeys, override);
    this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);
    return true;
  }

  static internalOverrideAll(targetClass, properties, overrideDefinition) {
    Reflect.ownKeys(overrideDefinition).forEach(key => {
      if (properties.includes(key) && !excludedPropNames[key]) {
        const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
        let currentTargetClass = targetClass;
        let targetProperty = null;


        while (!targetProperty && currentTargetClass) {
          targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);

          if (!targetProperty) {
            currentTargetClass = Object.getPrototypeOf(currentTargetClass);
          }
        }

        if (targetProperty) {
          this.internalOverride(currentTargetClass, key, desc, targetProperty);
        }
      }
    });
  }

  static internalOverride(target, key, desc, targetDesc) {
    const overrides = target._overridden = target._overridden || {};
    overrides[key] = target[key];

    if (targetDesc.get) {
      Object.defineProperty(target, key, {
        enumerable: false,
        configurable: true,
        get: desc.get
      });
    } else {
      target[key] = desc.value;
    }
  }


  static shouldApplyOverride(override) {
    const config = override.target;

    if (!config.maxVersion && !config.minVersion) return true;

    if (!config.product) throw new Error('Override must specify product when using versioning');

    if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
      return false;
    }

    if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
      return false;
    }

    return true;
  }

}

Override._$name = 'Override';


let nextObjectIdentity = 0;
const objectIdentityMap = new WeakMap();

const argsToCacheKey = (...args) => args.map(arg => {
  let result;

  if (arg && typeof arg == 'object' || typeof arg == 'function') {
    result = objectIdentityMap.get(arg);

    if (result === undefined) {
      result = ++nextObjectIdentity;
      objectIdentityMap.set(arg, result);
    }
  } else {
    result = String(arg);
  }

  return result;
}).join('-');


const memo = fn => {
  const mlist = new Map();
  return (...args) => {
    const mkey = argsToCacheKey(args);
    let result = mlist.get(mkey);

    if (result === undefined) {
      result = fn(...args);
      mlist.set(mkey, result);
    }

    return result;
  };
};


const memoCps = fn => {
  const table = new Map(),
    entryContinuations = entry => entry[0],
    entryResults = entry => entry[1],
    pushContinuation = (entry, cont) => entryContinuations(entry).push(cont),
    pushResult = (entry, result) => entryResults(entry).push(result),
    isResultSubsumed = (entry, result) => entryResults(entry).some(r => ObjectHelper.isEqual(r, result)),
    makeEntry = () => [[], []],
    isEmptyEntry = entry => !entryResults(entry).length && !entryContinuations(entry).length,
    tableRef = str => {
      let entry = table.get(str);

      if (entry === undefined) {
        entry = makeEntry();
        table.set(str, entry);
      }

      return entry;
    };

  return (str, cont) => {
    const entry = tableRef(str);

    if (isEmptyEntry(entry)) {
      pushContinuation(entry, cont);
      fn(str, result => {
        if (!isResultSubsumed(entry, result)) {
          pushResult(entry, result);
          entryContinuations(entry).forEach(cont => cont(result));
        }
      });
    } else {
      pushContinuation(entry, cont);
      entryResults(entry).forEach(result => cont(result));
    }
  };
};

const SUCCESS = Symbol('success');
const FAILURE = Symbol('failure');


const success = (val, rest) => [SUCCESS, val, rest];


const failure = rest => [FAILURE, rest];


const isSuccess = result => result.length && result[0] === SUCCESS;


const resolveParser = p => typeof p === 'function' && !p.length ? p() : p;


const succeed = memo(val => memoCps((str, cont) => cont(success(val, str))));


const string = memo(match => memoCps((str, cont) => {
  const len = Math.min(match.length, str.length),
    head = str.substr(0, len),
    tail = str.substr(len);
  cont(head === match ? success(head, tail) : failure(tail));
}));


const bind = (p, fn) => (str, cont) => resolveParser(p)(str, result => {
  if (isSuccess(result)) {
    const [, val, rest] = result;
    fn(val)(rest, cont);
  } else {
    cont(result);
  }
});


const seq = memo((...parsers) => {
  const seq2 = memo((a, b) => memoCps(bind(a, x => bind(b, y => succeed([].concat(x, y))))));
  return parsers.reduce(seq2, succeed([]));
});


const alt = memo((...parsers) => memoCps((str, cont) => parsers.forEach(p => resolveParser(p)(str, cont))));


const regexp = memo(pattern => (str, cont) => {
  const rexp = new RegExp(`^${pattern}`),
    match = rexp.exec(str);

  if (match) {
    const head = match[0],
      tail = str.substr(head.length);
    cont(success(head, tail));
  } else {
    cont(failure(str));
  }
});


const red = memo((p, fn) => bind(p, (...val) => succeed(fn(...[].concat.apply([], val)))));


const runParser = (body, str) => {
  let results = [];
  body(str, result => {
    if (isSuccess(result)) {
      const [, , left] = result;

      if (left === '') {
        results.push(result);
      }
    }
  });
  return results;
};


const defineParser = body => (str, cont) => cont ? resolveParser(body)(str, cont) : runParser(resolveParser(body), str);


var Parser = {
  memo,
  memoCps,
  success,
  failure,
  isSuccess,
  resolveParser,
  succeed,
  string,
  bind,
  seq,
  alt,
  regexp,
  red,
  runParser,
  defineParser
};


class BooleanCombo extends Localizable(Combo) {
  static get $name() {
    return 'BooleanCombo';
  }

  static get type() {
    return 'booleancombo';
  }

  static get defaultConfig() {
    return {

      positiveValue: true,


      positiveText: null,


      negativeValue: false,


      negativeText: null,


      value: false
    };
  }

  get store() {
    if (!this._store) {
      this.store = new Store({
        data: [{
          id: this.positiveValue,
          text: this.positiveText || this.L('Yes')
        }, {
          id: this.negativeValue,
          text: this.negativeText || this.L('No')
        }]
      });
    }

    return this._store;
  }

  set store(store) {
    super.store = store;
  }

}

BooleanCombo._$name = 'BooleanCombo';
BryntumWidgetAdapterRegister.register(BooleanCombo.type, BooleanCombo);


class DisplayField extends TextField {
  static get $name() {
    return 'DisplayField';
  }

  static get defaultConfig() {
    return {
      readOnly: true,
      editable: false,
      cls: 'b-display-field'
    };
  }

  get focusElement() {
  }

  set readOnly(value) {
  }

  get readOnly() {
    return true;
  }

}

DisplayField._$name = 'DisplayField';
BryntumWidgetAdapterRegister.register('display', DisplayField);
BryntumWidgetAdapterRegister.register('displayfield', DisplayField);


class DurationField extends TextField {
  static get $name() {
    return 'DurationField';
  }

  static get defaultConfig() {
    return {

      value: null,


      step: 1,


      unit: null,
      defaultUnit: 'day',


      magnitude: null,


      useAbbreviation: false,


      allowNegative: false,


      decimalPrecision: null,
      triggers: {
        spin: {
          type: 'spintrigger'
        }
      }
    };
  }

  get inputValue() {


    return this.value == null ? '' : this.value.toString(this.useAbbreviation);
  }


  set unit(unit) {
    this._unit = unit;
    super.value = this.calcValue();
  }

  get unit() {
    return this._unit;
  }


  set magnitude(magnitude) {
    this._magnitude = this.roundMagnitude(magnitude);
    super.value = this.calcValue();
  }

  get magnitude() {
    return this._magnitude;
  }

  roundMagnitude(value) {
    return value && this.decimalPrecision != null ? ObjectHelper.round(value, this.decimalPrecision) : value;
  }

  get allowDecimals() {
    return this.decimalPrecision !== 0;
  }

  get isValid() {
    const me = this,
      isEmpty = me.value == null || me.value && me.value.magnitude == null;
    return isEmpty && !me.required || !isEmpty && (me.allowNegative || me.value.magnitude >= 0);
  }

  internalOnChange(event) {
    const me = this,
      value = me.value,
      oldVal = me._lastValue;

    if (me.hasChanged(oldVal, value)) {
      me._lastValue = value;
      me.trigger('change', {
        value,
        event,
        userAction: true,
        valid: me.isValid
      });
    }
  }

  onFocusOut(e) {
    this.syncInputFieldValue(true);
    return super.onFocusOut(e);
  }


  set value(value) {
    const me = this;
    let newMagnitude, newUnit;

    if (typeof value === 'number') {

      newMagnitude = me.roundMagnitude(value);
      newUnit = me._unit;
    } else if (typeof value === 'string') {

      const parsedDuration = DateHelper.parseDuration(value, me.allowDecimals, me._unit || DurationField.defaultConfig.defaultUnit);

      if (parsedDuration) {
        newUnit = parsedDuration.unit;
        newMagnitude = me.roundMagnitude(parsedDuration.magnitude);
      }
    } else {

      if (value && 'unit' in value && 'magnitude' in value) {
        newUnit = value.unit;
        newMagnitude = me.roundMagnitude(value.magnitude);
      } else {
        newUnit = null;
        newMagnitude = null;
      }
    }

    if (me._magnitude !== newMagnitude || me._unit !== newUnit) {
      me._magnitude = newMagnitude;
      me._unit = newUnit;
      super.value = me.calcValue();
    }
  }

  get value() {
    return super.value;
  }

  calcValue() {
    const me = this;

    if ((!me._unit || !me._magnitude) && me.clearable) {
      return null;
    } else {
      return new Duration(me._magnitude, me._unit || DurationField.defaultConfig.defaultUnit);
    }
  }

  hasChanged(oldValue, newValue) {
    return newValue && !oldValue || !newValue && oldValue || newValue && oldValue && !oldValue.isEqual(newValue);
  }


  get milliseconds() {
    return this.value ? this.value.milliseconds : 0;
  }

  onInternalKeyDown(keyEvent) {
    if (keyEvent.key === 'ArrowUp') {
      this.doSpinUp();
    } else if (keyEvent.key === 'ArrowDown') {
      this.doSpinDown();
    }
  }

  doSpinUp() {
    const me = this;
    me._isUserAction = true;
    me.magnitude = (me.magnitude || 0) + me.step;
    me._isUserAction = false;
  }

  doSpinDown() {
    const me = this;

    if (me.allowNegative || (me.magnitude || 0) > 0) {
      me._isUserAction = true;
      me.magnitude = (me.magnitude || 0) - me.step;
      me._isUserAction = false;
    }
  }

}

DurationField._$name = 'DurationField';
BryntumWidgetAdapterRegister.register('durationfield', DurationField);
BryntumWidgetAdapterRegister.register('duration', DurationField);


class FileField extends Field {
  static get $name() {
    return 'FileField';
  }

  internalOnChange(event) {


    super.internalOnInput(event);
    super.internalOnChange(event);
  }

  internalOnInput() {
  }

  static get defaultConfig() {
    return {

      multiple: false,


      accept: null
    };
  }

  inputTemplate() {
    const me = this;


    return TemplateHelper.tpl`
            <input
             type="file"
             reference="input"
             id="${me.id}_input"
             class="${me.inputCls || ''}"
             ${me.multiple ? 'multiple' : ''}
             ${me.accept ? 'accept="' + me.accept + '"' : ''}
            />
        `;
  }


  get files() {
    return this.input.files;
  }


  pickFile() {
    this.input.click();
  }


  clear() {
    this.input.value = null;
  }

  triggerChange(event) {
    this.trigger('change', {
      event,
      value: this.input.value,
      oldValue: this._lastValue,
      userAction: true,
      valid: true
    });
  }

}

FileField._$name = 'FileField';
BryntumWidgetAdapterRegister.register('filefield', FileField);


class FilePicker extends Container {
  static get $name() {
    return 'FilePicker';
  }

  static get defaultConfig() {
    return {

      defaultBindProperty: 'value',


      buttonConfig: null,


      fileFieldConfig: null
    };
  }

  construct(config = {}) {
    const me = this;
    config.items = [Object.assign({
      type: 'button',
      ref: 'fileButton',
      text: 'File'
    }, config.buttonConfig), Object.assign({
      type: 'filefield',
      ref: 'fileField',
      style: 'display: none'
    }, config.fileFieldConfig)].concat(config.items || []);
    super.construct(config);
    me.button.on({
      click: me.onButtonClick,
      thisObj: me
    });
    me.fileField.on({
      change: me.onFileFieldChange,
      thisObj: me
    });

    me._thisIsAUsedExpression(me.fileTip);
  }

  get button() {
    return this.widgetMap.fileButton;
  }

  get fileField() {
    return this.widgetMap.fileField;
  }


  get files() {
    return this.fileField.files;
  }

  get fileTip() {
    const me = this;
    return me._fileTip || (me._fileTip = new Tooltip({
      cls: 'b-file-tip',
      forElement: me.button.element,
      showOnHover: true,
      align: 'b-t',
      scrollAction: 'realign',
      listeners: {
        beforeshow() {
          const tip = this,
            files = me.files;

          if (files && files.length) {
            tip.html = `${Array.from(files).map(file => file.name).join('<br>')}`;
            return true;
          }

          return false;
        }

      }
    }));
  }


  clear() {
    const me = this;
    me.fileField.clear();
    me.button.badge = '';
    me.trigger('clear');
  }

  onButtonClick({
                  event
                }) {
    const me = this;


    me.fileField.pickFile();
    event.preventDefault();
  }

  onFileFieldChange() {
    const me = this;
    me.button.badge = me.files.length || '';
    me.trigger('change', {
      files: me.files
    });
  }

}

FilePicker._$name = 'FilePicker';
BryntumWidgetAdapterRegister.register('filepicker', FilePicker);


class FlagField extends Checkbox {
  static get $name() {
    return 'FlagField';
  }

  static get type() {
    return 'flagfield';
  }

  static get defaultConfig() {
    return {
      value: ''
    };
  }

  get value() {
    return this.checked;
  }

  set value(v) {
    v = Boolean(v);
    super.value = v;

    if (!this.inputting) {
      this.checked = v;
    }
  }

}

FlagField._$name = 'FlagField';
BryntumWidgetAdapterRegister.register(FlagField.type, FlagField);


class MessageDialog extends Popup {
  static get $name() {
    return 'MessageDialog';
  }

  static get defaultConfig() {
    return {
      id: 'bryntum-msgdialog',
      centered: true,
      modal: true,
      hidden: true,
      autoShow: false,
      closeAction: 'hide',
      title: '\xa0',
      items: [{
        type: 'widget',
        id: 'bryntum-msgdialog-message',
        cls: 'b-msgdialog-message',
        ref: 'message'
      }, {
        type: 'textfield',
        id: 'bryntum-msgdialog-input',
        cls: 'b-msgdialog-input',
        ref: 'input'
      }],
      bbar: {
        id: 'bryntum-msgdialog-bbar',
        items: [{
          ref: 'yesButton',
          id: 'bryntum-msgdialog-yesbutton',
          cls: 'b-msgdialog-yesbutton',
          text: 'Yes',
          onClick: 'up.onYesClick'
        }, {
          ref: 'noButton',
          id: 'bryntum-msgdialog-nobutton',
          cls: 'b-msgdialog-nobutton',
          text: 'No',
          onClick: 'up.onNoClick'
        }, {
          ref: 'cancelButton',
          id: 'bryntum-msgdialog-cancelbutton',
          cls: 'b-msgdialog-cancelbutton',
          text: 'Cancel',
          onClick: 'up.onCancelClick'
        }]
      }
    };
  }


  async confirm({
                  message,
                  title = '\xa0'
                }) {
    const me = this;
    me.title = title;
    me.element.classList.remove(me.showClass);

    if (message) {
      me.showClass = 'b-show-message-yes-no';
      me.widgetMap.message.html = message;
    } else {
      me.showClass = 'b-show-yes-no';
    }

    me.element.classList.add(me.showClass);
    me.show();
    return me.promise = new Promise(resolve => {
      me.resolve = resolve;
    });
  }

  doResolve(value) {
    const me = this,
      {
        resolve
      } = me;

    if (resolve) {
      me.resolve = me.reject = me.promise = null;
      resolve(value);
      me.hide();
    }
  }

  onInternalKeyDown(event) {

    if (event.key === 'Escape') {
      event.stopImmediatePropagation();

      if (this.widgetMap.cancelButton.isVisible) {
        this.onCancelClick();
      } else {
        this.onNoClick();
      }
    }

    super.onInternalKeyDown(event);
  }

  onYesClick() {
    this.doResolve(md.yesButton);
  }

  onNoClick() {
    this.doResolve(md.noButton);
  }

  onCancelClick() {
    this.doResolve(md.cancelButton);
  }

}

const md = new MessageDialog();
md.noButton = 0;
md.yesButton = 1;
md.cancelButton = 3;


class PagingToolbar extends Toolbar {
  static get $name() {
    return 'PagingToolbar';
  }

  static get defaultConfig() {
    return {

      store: null,
      localeClass: this,
      namedItems: {
        firstPageButton: {
          onClick: 'up.onFirstPageClick',
          icon: 'b-fa-angle-double-left'
        },
        previousPageButton: {
          onClick: 'up.onPreviousPageClick',
          icon: 'b-fa-angle-left'
        },
        pageNumber: {
          type: 'numberfield',
          label: 'L{page}',
          min: 1,
          max: 1,
          triggers: null,
          onChange: 'up.onPageNumberChange'
        },
        pageCount: {
          type: 'widget',
          cls: 'b-pagecount b-toolbar-text'
        },
        nextPageButton: {
          onClick: 'up.onNextPageClick',
          icon: 'b-fa-angle-right'
        },
        lastPageButton: {
          onClick: 'up.onLastPageClick',
          icon: 'b-fa-angle-double-right'
        },
        reloadButton: {
          onClick: 'up.onReloadClick',
          icon: 'b-fa-redo'
        },
        dataSummary: {
          type: 'widget',
          cls: 'b-toolbar-text'
        }
      },
      items: {
        firstPageButton: true,
        previousPageButton: true,
        pageNumber: true,
        pageCount: true,
        nextPageButton: true,
        lastPageButton: true,
        sep: '|',
        reloadButton: true,
        spacer: '->',
        dataSummary: true
      }
    };
  }

  set store(store) {
    const me = this,
      listener = {
        beforerequest: 'onStoreBeforeRequest',
        afterrequest: 'onStoreChange',
        change: 'onStoreChange',
        thisObj: me
      };

    if (me.store) {
      me.store.un(listener);
    }

    me._store = store;

    if (store) {
      store.on(listener);

      if (store.isLoading) {
        me.onStoreBeforeRequest();
      }
    }
  }

  get store() {
    return this._store;
  }

  onStoreBeforeRequest() {
    this.eachWidget(w => w.disable());
  }

  updateLocalization() {
    const me = this,
      {
        reloadButton,
        firstPageButton,
        previousPageButton,
        nextPageButton,
        lastPageButton
      } = me.widgetMap;
    firstPageButton.tooltip = me.L('firstPage');
    previousPageButton.tooltip = me.L('prevPage');
    nextPageButton.tooltip = me.L('nextPage');
    lastPageButton.tooltip = me.L('lastPage');
    reloadButton.tooltip = me.L('reload');
    me.updateSummary();
    super.updateLocalization();
  }

  updateSummary() {
    const me = this,
      {
        pageCount,
        dataSummary
      } = me.widgetMap;
    let count, lastPage, start, end, allCount;
    count = lastPage = start = end = allCount = 0;

    if (me.store) {
      const {
          store
        } = me,
        {
          pageSize,
          currentPage
        } = store;
      count = store.count;
      lastPage = store.lastPage;
      allCount = store.allCount;
      start = Math.max(0, (currentPage - 1) * pageSize + 1);
      end = Math.min(allCount, start + pageSize - 1);
    }

    pageCount.html = me.L('pageCountTemplate')({
      lastPage
    });
    dataSummary.html = count ? me.L('summaryTemplate')({
      start,
      end,
      allCount
    }) : me.L('noRecords');
  }

  onStoreChange() {
    const me = this,
      {
        widgetMap,
        store
      } = me,
      {
        count,
        lastPage,
        currentPage
      } = store,
      {
        pageNumber,
        pageCount,
        firstPageButton,
        previousPageButton,
        nextPageButton,
        lastPageButton,
        dataSummary
      } = widgetMap;
    me.eachWidget(w => w.enable());
    pageNumber.value = currentPage;
    pageNumber.max = lastPage;
    dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
    firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
    nextPageButton.disabled = lastPageButton.disabled = currentPage >= lastPage || !count;
    me.updateSummary();
  }

  onPageNumberChange({
                       value
                     }) {
    if (this.store.currentPage !== value) {
      this.store.loadPage(value);
    }
  }

  onFirstPageClick() {
    this.store.loadPage(1);
  }

  onPreviousPageClick() {
    this.store.previousPage();
  }

  onNextPageClick() {
    this.store.nextPage();
  }

  onLastPageClick() {
    this.store.loadPage(this.store.lastPage);
  }

  onReloadClick() {
    this.store.loadPage(this.store.currentPage);
  }

}

PagingToolbar._$name = 'PagingToolbar';
BryntumWidgetAdapterRegister.register('pagingtoolbar', PagingToolbar);


const hasFlex = el => parseInt(DomHelper.getStyleValue(el, 'flex-basis'), 10) || parseInt(DomHelper.getStyleValue(el, 'flex-grow'), 10);


class Splitter extends Widget {

  static get defaultConfig() {
    return {

      orientation: 'auto'
    };
  }


  doDestroy() {
    this.mouseDetacher && this.mouseDetacher();
    super.doDestroy();
  }


  template() {
    return TemplateHelper.tpl`
            <div class="b-splitter"></div>
        `;
  }

  get element() {
    return super.element;
  }

  set element(element) {
    super.element = element;
    EventHelper.on({
      element: this.element,
      mousedown: 'onMouseDown',
      thisObj: this
    });
  }


  get currentOrientation() {
    return this._currentOrientation;
  }


  get orientation() {
    return this._orientation;
  }

  set orientation(orientation) {
    this._orientation = orientation;

    if (orientation === 'auto') {
      this._currentOrientation = null;
    } else {
      this._currentOrientation = orientation;
    }

    this.updateOrientation();
  }

  updateOrientation() {
    const me = this,
      {
        element
      } = this;

    if (me._prevOrientation) {
      element.classList.remove(me._prevOrientation);
    }

    if (!me._currentOrientation && me.rendered && element.offsetParent) {
      const flexDirection = DomHelper.getStyleValue(element.parentElement, 'flex-direction');

      if (flexDirection) {
        me._currentOrientation = flexDirection.startsWith('column') ? 'horizontal' : 'vertical';
      } else {
        const previous = element.previousElementSibling,
          next = element.nextElementSibling;

        if (!previous || !next) {

          return;
        }

        const prevRect = previous.getBoundingClientRect(),
          nextRect = next.getBoundingClientRect(),
          topMost = prevRect.top < nextRect.top ? prevRect : nextRect,
          bottomMost = topMost === nextRect ? prevRect : nextRect;
        me._currentOrientation = topMost.top !== bottomMost.top ? 'horizontal' : 'vertical';
      }
    }

    if (me._currentOrientation) {
      element.classList.add(`b-${me._currentOrientation}`);
    }

    me._prevOrientation = me._currentOrientation;
  }


  onMouseDown(event) {
    const me = this,
      {
        element
      } = me,
      prev = element.previousElementSibling,
      next = element.nextElementSibling,
      prevHasFlex = hasFlex(prev),
      nextHasFlex = hasFlex(next),
      flexed = [];

    for (const child of element.parentElement.children) {
      if (hasFlex(child) && child !== element) {
        flexed.push({
          element: child,
          width: child.offsetWidth,
          height: child.offsetHeight
        });
      }
    }

    me.context = {
      startX: event.pageX,
      startY: event.pageY,
      prevWidth: prev.offsetWidth,
      prevHeight: prev.offsetHeight,
      nextWidth: next.offsetWidth,
      nextHeight: next.offsetHeight,
      prevHasFlex,
      nextHasFlex,
      flexed,
      prev,
      next
    };
    me.mouseDetacher = EventHelper.on({
      element: document,
      mousemove: 'onMouseMove',
      mouseup: 'onMouseUp',
      thisObj: me
    });
  }

  onMouseMove(event) {
    const me = this,
      {
        context
      } = me,
      deltaX = event.pageX - context.startX,
      deltaY = event.pageY - context.startY;
    event.preventDefault();
    Object.assign(context, {
      deltaX,
      deltaY
    });

    if (!context.started) {
      context.started = true;
      me.trigger('start', {
        context,
        event
      });


      context.flexed.forEach(flexed => {
        if (me.currentOrientation === 'vertical') {
          flexed.element.style.flexGrow = flexed.width;
        } else {
          flexed.element.style.flexGrow = flexed.height;
        }

        flexed.element.style.flexBasis = '0';
      });
    }

    if (me.currentOrientation === 'vertical') {
      const newPrevWidth = context.prevWidth + deltaX,
        newNextWidth = context.nextWidth - deltaX;

      if (context.prevHasFlex) {
        context.prev.style.flexGrow = newPrevWidth;
      } else {
        context.prev.style.width = `${newPrevWidth}px`;
      }

      if (context.nextHasFlex) {
        context.next.style.flexGrow = newNextWidth;
      } else {
        context.next.style.width = `${newNextWidth}px`;
      }
    } else {
      const newPrevHeight = context.prevHeight + deltaY,
        newNextHeight = context.nextHeight - deltaY;

      if (context.prevHasFlex) {
        context.prev.style.flexGrow = newPrevHeight;
      } else {
        context.prev.style.height = `${newPrevHeight}px`;
      }

      if (context.nextHasFlex) {
        context.next.style.flexGrow = newNextHeight;
      } else {
        context.next.style.height = `${newNextHeight}px`;
      }
    }

    me.trigger('move', {
      context,
      event
    });
  }

  onMouseUp(event) {
    const me = this;
    me.mouseDetacher && me.mouseDetacher();
    me.mouseDetacher = null;

    if (me.context.started) {
      me.trigger('end', {
        context: me.context,
        event
      });
    }

    me.context = null;
  }

  render() {
    super.render(...arguments);
    const me = this;

    if (!me._currentOrientation) {

      me.updateOrientation();

      if (!me._currentOrientation) {


        me.requestAnimationFrame(() => me.updateOrientation());
      }
    }
  }

}

Splitter._$name = 'Splitter';
BryntumWidgetAdapterRegister.register('splitter', Splitter);


class Column extends Events(Localizable(Model)) {

  static get fields() {
    return [


      'text',

      'field',

      'renderer',

      'width',


      'flex',


      {
        name: 'editor',
        defaultValue: {}
      },

      'finalizeCellEdit',

      {
        name: 'revertOnEscape',
        defaultValue: true
      },

      {
        name: 'invalidAction',
        defaultValue: 'block'
      },

      {
        name: 'sortable',
        defaultValue: true
      },

      {
        name: 'searchable',
        defaultValue: true
      },

      {
        name: 'filterable',
        defaultValue: true
      },

      {
        name: 'hideable',
        defaultValue: true
      },

      {
        name: 'draggable',
        defaultValue: true
      },

      {
        name: 'groupable',
        defaultValue: true
      },

      {
        name: 'resizable',
        defaultValue: true
      },


      'groupRenderer',

      'headerRenderer',

      'tooltipRenderer',

      'cellCls',

      'cls',


      'icon',


      'align',

      {
        name: 'minWidth',
        defaultValue: 60
      },


      {
        name: 'hidden',
        defaultValue: false
      },

      {
        name: 'locked'
      },

      {
        name: 'region'
      },


      {
        name: 'showColumnPicker',
        defaultValue: true
      },

      {
        name: 'enableHeaderContextMenu',
        defaultValue: true
      },

      {
        name: 'enableCellContextMenu',
        defaultValue: true
      },

      'headerMenuItems',

      'cellMenuItems',


      'sum',

      'summaries',

      'summaryRenderer',


      'responsiveLevels',

      'tags',

      'touchConfig',

      'tree',

      'filterType',

      {
        name: 'htmlEncode',
        defaultValue: true
      },

      {
        name: 'autoSyncHtml',
        defaultValue: false
      }, 'type',

      {
        name: 'instantUpdate',
        defaultValue: false
      }, {
        name: 'repaintOnResize',
        defaultValue: false
      },

      'editTargetSelector',

      {
        name: 'exportable',
        defaultValue: true
      },

      {
        name: 'exportedType'
      }
    ];
  }

  static get autoExposeFields() {
    return false;
  }


  construct(data, store) {
    const me = this;
    me.masterStore = store;

    if (store) {
      me._grid = Array.isArray(store) ? store[0].grid : store.grid;
    }

    me.localizableProperties = data.localizableProperties || ['text'];

    if (data.localeClass) {
      me.localeClass = data.localeClass;
    }

    super.construct(data, store, null, false);
    me.processConfiguredListeners(data.listeners);


    if (!('field' in me.data)) {
      me.field = '_' + (me.type || '') + ++Column.emptyCount;
      me.noFieldSpecified = true;
    }

    me.hasComplexMapping = me.field && me.field.includes('.');

    if (!me.width && !me.flex && !me.children) {

      me.set({
        width: Column.defaultWidth,
        flex: null
      }, null, true);
    }
  }

  remove() {
    const {
        subGrid,
        grid
      } = this,
      focusedCell = subGrid && grid && grid.focusedCell;

    if (focusedCell && focusedCell.columnId === this.id) {

      if (document.activeElement === grid) {
        grid.navigateRight();
      } else {
        focusedCell.columnId = subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true).id;
      }
    }

    super.remove();
  }


  getRawValue(record) {
    const me = this;

    if (me.hasComplexMapping) {
      return ObjectHelper.getPath(record, me.field);
    }

    return record[me.field] || record.get(me.field);
  }

  get owner() {
    return this._owner || this.subGrid;
  }

  set owner(owner) {
    this._owner = owner;
  }

  get nextVisibleSibling() {


    const region = this.region;
    let next = this.nextSibling;

    while (next && (next.hidden || next.region !== region)) {
      next = next.nextSibling;
    }

    return next;
  }

  get isLastInSubGrid() {
    return !this.nextVisibleSibling && (!this.parent || this.parent.isLastInSubGrid);
  }


  get element() {
    return this.grid.getHeaderElement(this);
  }


  get textWrapper() {
    return DomHelper.getChild(this.element, '.b-grid-header-text');
  }


  get textElement() {
    return DomHelper.down(this.element, '.b-grid-header-text-content');
  }


  get contentElement() {
    return DomHelper.down(this.element, '.b-grid-header-children');
  }


  get editor() {
    let editor = this.data.editor;

    if (editor && !(editor instanceof Widget)) {

      const result = this.grid.processCellEditor({
        editor,
        field: this.field
      });

      if (result) {

        editor = this.data.editor = result.editor;
      } else {
        if (typeof editor === 'string') {
          editor = {
            type: editor
          };
        }

        editor = this.data.editor = WidgetHelper.createWidget(Object.assign(this.defaultEditor, editor, {
          owner: this.grid
        }));
      }
    }

    return editor;
  }

  set editor(editor) {
    this.data.editor = editor;
  }


  get defaultEditor() {
    return {
      type: 'textfield',
      name: this.field
    };
  }


  static get type() {
    return 'column';
  }

  static get text() {
    return this.defaultValues.text;
  }

  get grid() {
    return this._grid || this.parent && this.parent.grid;
  }

  get locked() {
    return this.data.region === 'locked';
  }

  set locked(locked) {
    this.region = locked ? 'locked' : 'normal';
  }

  get sortable() {
    return this.isLeaf && this.data.sortable;
  }

  set sortable(sortable) {
    this.set('sortable', sortable);
  }

  get groupable() {
    return this.isLeaf && this.data.groupable;
  }

  set groupable(groupable) {
    this.set('groupable', groupable);
  }


  hide(silent = false) {
    const me = this,
      parent = me.parent;

    if (!me.hidden) {
      me.hidden = true;

      if (parent && !parent.isRoot) {

        const anyVisible = parent.children.some(child => child.hidden !== true);

        if (!anyVisible && !parent.hidden) {
          silent = true;

          parent.hide();
        }
      }

      if (me.children) {
        me.children.forEach(child => child.hide(true));
      }

      if (!silent) {
        me.stores.forEach(store => store.trigger('hideColumn'));
      }
    }
  }


  show(silent = false) {
    const me = this,
      parent = me.parent;

    if (me.hidden) {
      me.hidden = false;

      if (parent && parent.hidden) {
        parent.show();
      }

      if (me.children) {
        me.children.forEach(child => child.show(true));
      }

      if (!silent) {
        me.stores.forEach(store => store.trigger('showColumn'));
      }
    }
  }


  toggle(force = null) {
    if (this.hidden && force === undefined || force === true) return this.show();
    if (!this.hidden && force === undefined || force === false) return this.hide();
  }


  generateId() {
    if (!Column.generatedIdIndex) Column.generatedIdIndex = 0;
    return (this.field ? this.field.replace(/\./g, '-') : 'col') + ++Column.generatedIdIndex;
  }


  get allIndex() {
    return this.masterStore.indexOf(this);
  }


  get width() {
    return this.data.width;
  }

  set width(width) {
    const data = {
      width
    };

    if (width && 'flex' in this.data) {
      data.flex = null;
    }

    this.set(data);
  }


  set subGrid(subGrid) {
    this._subGrid = subGrid;
  }


  get subGrid() {
    return this._subGrid || (this.grid ? this.grid.getSubGridFromColumn(this) : undefined);
  }


  get subGridElement() {
    return this.subGrid.element;
  }

  measureSize(value) {
    return DomHelper.measureSize(value, this.subGrid ? this.subGrid.element : undefined);
  }


  calculateMinWidth() {
    const me = this,
      width = me.measureSize(me.width),
      minWidth = me.measureSize(me.minWidth);
    let minChildWidth = 0;

    if (me.children) {
      minChildWidth = me.children.reduce((result, column) => {
        return result + column.calculateMinWidth();
      }, 0);
    }

    return Math.max(width, minWidth, minChildWidth);
  }


  resizeToFitContent() {
    const me = this,
      {
        grid,
        renderer,
        defaultRenderer,
        element
      } = me,
      rowManager = grid.rowManager,
      store = grid.store,
      count = store.count,
      useRenderer = renderer || defaultRenderer;
    if (count <= 0) return;
    const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id=${me.id}]`),
      originalStyle = cellElement.cssText,

      originalClassName = cellElement.className;

    let maxWidth = 0,
      start,
      end,
      i,
      record,
      value;

    if (grid.resizeToFitIncludesHeader) {
      const style = window.getComputedStyle(element);

      maxWidth = DomHelper.measureText(element.innerText, element, false, element.parentElement) + parseInt(style.paddingLeft);


      element.parentElement.offScreenDiv.parentElement.remove();
    }


    if (count > 1000) {
      start = Math.max(Math.min(rowManager.topIndex + rowManager.rowCount / 2 - 500, count - 1000), 0);
      end = start + 1000;
    } else {
      start = 0;
      end = count;
    }

    for (i = start; i < end; i++) {
      record = store.getAt(i);
      value = me.getRawValue(record);

      if (useRenderer) {
        value = useRenderer.call(me, {
          cellElement,
          rowElement: cellElement.parentNode,
          value,
          record,
          column: me,
          size: {
            height: record.rowHeight || 0
          },
          grid,
          row: {},
          updatingSingleRow: false
        });

        value = value == null ? cellElement.innerHTML : String(value);
      }

      if (value) {

        maxWidth = Math.max(maxWidth, DomHelper.measureText(value, cellElement, !(me.htmlEncode && !me.disableHtmlEncode), me.subGrid.element));
      }
    }

    cellElement.className = originalClassName;
    cellElement.cssText = originalStyle;
    return me.width = maxWidth;
  }


  getState() {

    const me = this,
      state = {
        [me.flex ? 'flex' : 'width']: me.flex ? me.flex : me.width,
        id: me.id,
        hidden: me.hidden,
        index: me.allIndex,
        region: me.region,
        filterable: me.filterable,
        text: me.text,
        locked: me.locked
      };
    if (me.children) state.children = me.children.map(child => child.getState());
    return state;
  }


  applyState(state) {
    const me = this;
    me.beginBatch();

    if ('locked' in state) {
      me.locked = state.locked;
    }

    if ('minWidth' in state) {
      me.minWidth = state.minWidth;
    }

    if ('width' in state) {
      me.width = state.width;
    }

    if ('flex' in state) {
      me.flex = state.flex;
    }

    if ('width' in state && me.flex) {
      me.flex = undefined;
    } else if ('flex' in state && me.width) {
      me.width = undefined;
    }

    if ('text' in state) {
      me.text = state.text;
    }

    if ('region' in state) {
      me.region = state.region;
    }

    if ('renderer' in state) {
      me.renderer = state.renderer;
    }

    if ('filterable' in state) {
      me.filterable = state.filterable;
    }

    me.endBatch();

    if ('hidden' in state) {
      me.toggle(state.hidden !== true);
    }
  }


  clearCell(cellElement) {
    cellElement.innerHTML = '';
  }


  canEdit(record) {
    return true;
  }

}


Column.emptyCount = 0;
Column.defaultWidth = 100;
Column.exposeProperties();
Column._$name = 'Column';


class ColumnStore extends Localizable(Store) {
  static get defaultConfig() {
    return {
      modelClass: Column,
      tree: true,


      autoAddField: false
    };
  }

  construct(config) {
    const me = this;


    if (config.grid) {
      config.grid._columnStore = me;
      me.id = `${config.grid.id}-columns`;

      config.grid.on({
        subGridCollapse: 'clearSubGridCaches',
        subGridExpand: 'clearSubGridCaches',
        thisObj: me
      });
    }

    super.construct(config);


    me.on({
      change: me.clearCaches,
      thisObj: me,
      prio: 1
    });
  }

  get modelClass() {
    return this._modelClass;
  }

  set modelClass(ClassDef) {
    this._modelClass = ClassDef;
  }

  doDestroy() {
    const allColumns = [];
    this.traverse(column => allColumns.push(column));
    super.doDestroy();

    allColumns.forEach(column => column.destroy());
  }


  getById(id) {
    return super.getById(id) || this.idRegister[id];
  }

  forEach(fn, thisObj = this) {

    this.traverseWhile((n, i) => fn.call(thisObj, n, i), true);
  }

  get totalFixedWidth() {
    let result = 0;

    for (let col of this) {
      if (!col.hidden) {
        if (col.flex) {
          result += col.measureSize(Column.defaultWidth);
        } else {
          result += Math.max(col.measureSize(col.width), col.measureSize(col.minWidth));
        }
      }
    }

    return result;
  }


  get topColumns() {
    return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;
  }


  get visibleColumns() {
    const me = this;

    if (!me._visibleColumns) {
      me._visibleColumns = me.leaves.filter(column => !column.hidden && (!column.subGrid || !column.subGrid.collapsed));
    }

    return me._visibleColumns;
  }

  clearSubGridCaches(subGrid) {
    subGrid.columns.clearCaches();
    this.clearCaches();
  }

  clearCaches() {
    this._visibleColumns = null;
  }

  onMasterDataChanged(event) {
    super.onMasterDataChanged(event);

    this.clearCaches();
  }

  getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {
    let columns = this.visibleColumns,
      column = columnOrId instanceof Column ? columnOrId : this.getById(columnOrId),
      idx = columns.indexOf(column) + (next ? 1 : -1);


    if (!columns[idx]) {
      if (wrap) {
        idx = next ? 0 : columns.length - 1;
      } else {
        return null;
      }
    }

    return columns[idx];
  }


  get bottomColumns() {
    return this.leaves;
  }


  get(field) {
    return this.findRecord('field', field, true);
  }


  createRecord(data) {
    const {
        grid = {}
      } = this,

      {
        store
      } = grid;
    let columnClass = this.modelClass;

    if (data.type) {
      columnClass = ColumnStore.getColumnClass(data.type);

      if (!columnClass) {
        throw new Error(this.L('columnTypeNotFound', data));
      }
    }

    if (data.locked) {
      data.region = 'locked';
      delete data.locked;
    }

    const column = new columnClass(data, this);


    if (!column.data.region) {
      column.data.region = grid.defaultRegion || 'normal';
    }

    if (this.autoAddField && !column.noFieldSpecified && store && !store.modelClass.getFieldDefinition(column.field)) {
      let fieldDefinition = column.field;

      if (column.constructor.fieldType) {
        fieldDefinition = {
          name: column.field,
          type: column.constructor.fieldType
        };
      }

      store.modelClass.addField(fieldDefinition);
    }

    return column;
  }


  indexOf(recordOrId) {

    let index = super.indexOf(recordOrId);
    if (index > -1) return index;


    return this.records.findIndex(r => r.field === recordOrId);
  }


  static registerColumnType(columnClass, simpleRenderer = false) {
    if (!ColumnStore.columnTypes) ColumnStore.columnTypes = {};
    columnClass.simpleRenderer = simpleRenderer;
    ColumnStore.columnTypes[columnClass.type] = columnClass;
  }


  static getColumnClass(type) {
    return ColumnStore.columnTypes && ColumnStore.columnTypes[type];
  }

}


const columnResizeEvent = (handler, thisObj) => ({
  'update': ({
               store,
               record,
               changes
             }) => {
    let result = true;

    if ('width' in changes || 'minWidth' in changes || 'flex' in changes) {
      result = handler.call(thisObj, {
        store,
        record,
        changes
      });
    }

    return result;
  }
});

ColumnStore.registerColumnType(Column, true);
ColumnStore._$name = 'ColumnStore';


class ActionColumn extends Column {
  static get type() {
    return 'action';
  }

  static get fields() {
    return [

      'actions'];
  }

  static get defaults() {
    return {
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      htmlEncode: false,
      resizable: false,
      minWidth: 30
    };
  }

  construct(config, store) {
    this.internalCellCls = 'b-action-cell';
    super.construct(...arguments);

    if (!config.width && !config.flex) {
      this.grid.on('paint', this.updateAutoWidth, this);
    }
  }


  renderer({
             column,
             record
           }) {
    return {
      className: {
        'b-actions-ct': 1
      },
      children: column.actions.map((actionConfig, index) => {
        if ('visible' in actionConfig) {
          if (typeof actionConfig.visible === 'function' && actionConfig.visible({
            record
          }) === false) {
            return '';
          }

          if (actionConfig.visible === false) {
            return '';
          }
        }

        return {
          tag: 'i',
          dataset: {
            index,
            btip: actionConfig.tooltip || ''
          },
          className: {
            'b-action-item': 1,
            [actionConfig.cls]: 1
          }
        };
      })
    };
  }

  onCellClick({
                grid,
                column,
                record,
                target
              }) {
    if (!target.classList.contains('b-action-item') || grid.readOnly) {
      return;
    }

    const actionIndex = target.dataset.index,
      action = column.actions[actionIndex],
      actionHandler = action.onClick;

    if (actionHandler) {
      this.callback(actionHandler, column, [{
        record,
        action
      }]);
    }
  }


  updateAutoWidth() {

    const actions = this.actions.map(actionOriginal => {
      const action = {
        ...actionOriginal
      };

      delete action.visible;
      return action;
    });
    const actionsDomConfig = this.renderer({
        column: {
          actions
        }
      }),
      actionsHtml = DomHelper.createElement(actionsDomConfig).outerHTML,
      cellElement = this.grid.element.querySelector(`.b-grid-cell[data-column-id=${this.id}]`);
    this.width = DomHelper.measureText(actionsHtml, cellElement, true, cellElement.parentElement);
  }

}

ColumnStore.registerColumnType(ActionColumn);
ActionColumn.exposeProperties();
ActionColumn._$name = 'ActionColumn';


class AggregateColumn extends Column {

  static get type() {
    return 'aggregate';
  }

  static get fields() {
    return ['function'];
  }

  static get defaults() {
    return {

      function: 'sum'
    };
  }

  construct(data, columnStore) {
    this.configuredAlign = 'align' in data;
    this.configuredEditor = 'editor' in data;
    super.construct(...arguments);
    const {
      grid
    } = columnStore;

    if (grid) {
      this.owner = grid;
      grid.on({
        paint: 'onGridPaint',
        thisObj: this,
        prio: 1000
      });
    }
  }

  onGridPaint({
                source: grid
              }) {
    this.store = grid.store;
  }

  set store(store) {
    const me = this,
      storeListeners = {
        update: 'onRecordUpdate',
        thisObj: me,
        prio: 1000
      },
      oldStore = me._store;

    if (store !== oldStore) {
      if (oldStore) {
        oldStore.un(storeListeners);
      }

      me._store = store;
      const {
          modelClass
        } = store,
        field = modelClass.fieldMap[me.field];


      if (field && field.type === 'number') {
        if (!me.configuredAlign) {
          me.align = 'end';
        }

        if (!me.configuredEditor) {
          me.editor = 'number';
        }
      }

      store.on(storeListeners);
    }
  }

  canEdit(record) {
    return record.isLeaf;
  }

  get store() {
    return this._store;
  }

  sum(...args) {
    let result = 0;

    for (let i = 0, {
      length
    } = args; i < length; i++) {
      result += parseInt(args[i] || 0, 10);
    }

    return result;
  }

  avg(...args) {
    let result = 0;
    const {
      length
    } = args;

    for (let i = 0; i < length; i++) {
      result += parseInt(args[i] || 0, 10);
    }

    return result / length;
  }

  onRecordUpdate({
                   record,
                   changes
                 }) {
    const me = this,
      {
        rowManager
      } = me.grid;

    if (me.field in changes) {
      if (record.isLeaf) {
        record.bubble(rec => {
          const row = rowManager.getRowFor(rec);

          if (row) {
            const cell = row.getCell(me.field);

            if (cell) {
              row.renderCell(cell, rec);
            }
          }
        }, true);
      }
    }
  }

  getRawValue(record) {
    let value = 0;

    if (record.children) {
      const me = this,
        fn = me.function,
        isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',
        {
          handler,
          thisObj
        } = isMathFn ? {
          handler: Math[fn],
          thisObj: Math
        } : me.resolveCallback(fn);

      for (let i = 0, {
        length
      } = record.children; i < length; i++) {
        value = handler.call(thisObj, value, me.getRawValue(record.children[i]));
      }

      record.setData(me.field, value);
    } else {
      value = record[this.field];
    }

    return value;
  }

}

ColumnStore.registerColumnType(AggregateColumn, true);
AggregateColumn.exposeProperties();
AggregateColumn._$name = 'AggregateColumn';


class WidgetColumn extends Column {

  static get type() {
    return 'widget';
  }

  static get fields() {
    return [

      'widgets'];
  }

  static get defaults() {
    return {
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false
    };
  }


  construct(config, store) {
    this.widgetMap = {};
    this.internalCellCls = 'b-widget-cell';
    super.construct(...arguments);
  }

  doDestroy() {

    for (const widget of Object.values(this.widgetMap)) {
      widget.destroy && widget.destroy();
    }

    super.doDestroy();
  }


  renderer(event) {
    const me = this,
      {
        cellElement,
        column,
        value,
        record,
        isExport
      } = event,
      widgets = column.widgets;


    if (!isExport && widgets) {


      if (!cellElement.widgets) {

        me.clearCell(cellElement);
      }

      cellElement.widgets = widgets.map((widgetCfg, i) => {
        let widget, widgetNextSibling;

        if (cellElement.widgets) {

          widget = cellElement.widgets[i];

          widgetNextSibling = widget.element.nextElementSibling;

          if (widgetCfg.recreate && widget) {

            delete me.widgetMap[widget.id];
            widget.destroy();
            cellElement.widgets[i] = null;
          }
        }

        if (!widget) {
          me.onBeforeWidgetCreate(widgetCfg, event);
          widget = WidgetHelper.append(widgetCfg, widgetNextSibling ? {
            insertBefore: widgetNextSibling
          } : cellElement)[0];
          me.widgetMap[widget.id] = widget;
          me.onAfterWidgetCreate(widget, event);
        }

        widget.cellInfo = {
          cellElement,
          value,
          record,
          column
        };

        if (me.grid) {
          widget.readOnly = me.grid.readOnly;
        }

        if (me.onBeforeWidgetSetValue(widget, event) !== false) {
          if (!widgetCfg.noValueOnRender) {
            if (widgetCfg.valueProperty) {
              widget[widgetCfg.valueProperty] = value;
            } else if (widget.defaultBindProperty) {
              widget[widget.defaultBindProperty] = value;
            } else {
              widget.text = widget.value = value;
            }
          }
        }

        me.onAfterWidgetSetValue(widget, event);
        return widget;
      });
    }

    if (isExport) {
      return null;
    }
  }


  onBeforeWidgetCreate(widgetCfg, event) {
  }


  onAfterWidgetCreate(widget, event) {
  }


  onBeforeWidgetSetValue(widget, renderEvent) {
  }


  onAfterWidgetSetValue(widget, renderEvent) {
  }

  clearCell(cellElement) {
    if (cellElement.widgets) {
      cellElement.widgets.forEach(widget => {

        delete this.widgetMap[widget.id];
        widget.destroy();
      });
      cellElement.widgets = null;
    }

    super.clearCell(cellElement);
  }


  resizeToFitContent() {
  }

}

ColumnStore.registerColumnType(WidgetColumn);
WidgetColumn.exposeProperties();
WidgetColumn._$name = 'WidgetColumn';


class CheckColumn extends WidgetColumn {

  static get type() {
    return 'check';
  }

  static get fields() {
    return ['checkCls', 'showCheckAll'];
  }

  static get defaults() {
    return {
      align: 'center',


      checkCls: null,


      showCheckAll: false,
      widgets: [{
        type: 'checkbox',
        valueProperty: 'checked'
      }]
    };
  }

  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-check-cell';

    if (this.grid) {
      this.grid.on('destroy', () => this.headerCheckbox && this.headerCheckbox.destroy());
    }
  }

  headerRenderer({
                   headerElement,
                   column
                 }) {
    const me = this;
    headerElement.classList.add('b-check-header');

    if (column.showCheckAll) {
      headerElement.classList.add('b-check-header-with-checkbox');

      if (column.headerCheckbox) {
        column.headerCheckbox.destroy();
      }

      column.headerCheckbox = new Checkbox({
        appendTo: headerElement,
        owner: me.grid,
        listeners: {
          change: ({
                     checked
                   }) => {

            column.trigger('toggleAll', {
              checked
            });
          }
        }
      });
    } else {
      return column.text;
    }
  }

  renderer({
             value,
             isExport
           }) {
    if (isExport) {
      return value == null ? '' : value;
    } else {
      super.renderer(...arguments);
    }
  }

  onBeforeWidgetCreate(widgetCfg, event) {
    widgetCfg.cls = this.checkCls;
  }

  onAfterWidgetCreate(widget, event) {
    event.cellElement.widget = widget;
    widget.on({
      beforeChange: 'onBeforeCheckboxChange',
      change: 'onCheckboxChange',
      thisObj: this
    });
  }

  onBeforeWidgetSetValue(widget) {
    widget.record = widget.cellInfo.record;
    this.isInitialSet = true;
  }

  onAfterWidgetSetValue(widget) {
    this.isInitialSet = false;
  }


  onBeforeCheckboxChange({
                           source,
                           checked
                         }) {
    if (!this.isInitialSet) {

      return this.trigger('beforeToggle', {
        record: source.cellInfo.record,
        checked
      });
    }
  }

  onCheckboxChange({
                     source,
                     checked
                   }) {
    if (!this.isInitialSet) {
      const record = source.cellInfo.record,
        field = this.field;

      if (field) {
        const setterName = `set${StringHelper.capitalizeFirstLetter(field)}`;

        if (record[setterName]) {
          record[setterName](checked);
        } else {
          record.set(field, checked);
        }
      }


      this.trigger('toggle', {
        record,
        checked
      });
    }
  }

}

ColumnStore.registerColumnType(CheckColumn, true);
CheckColumn._$name = 'CheckColumn';


class DateColumn extends Column {

  static get type() {
    return 'date';
  }

  static get fieldType() {
    return 'date';
  }

  static get fields() {
    return ['format', 'pickerFormat', 'step'];
  }

  static get defaults() {
    return {

      format: 'L',


      step: 1,
      minWidth: 85,
      filterType: 'date'
    };
  }


  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-date-cell';
  }


  defaultRenderer({
                    value
                  }) {
    return value ? this.formatValue(value) : '';
  }


  groupRenderer({
                  cellElement,
                  groupRowFor
                }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }


  formatValue(value) {

    if (typeof value === 'string') {
      value = DateHelper.parse(value, this.format || undefined);
    }

    return DateHelper.format(value, this.format || undefined);
  }


  set format(value) {
    const me = this,
      editor = me.editor;
    me.set('format', value);

    if (editor) {
      editor.format = me.format;
    }
  }

  get format() {
    return this.get('format');
  }

  get defaultEditor() {
    const me = this;
    return {
      name: me.field,
      type: 'date',
      calendarContainerCls: 'b-grid-cell-editor-related',
      format: me.format,
      step: me.step
    };
  }

}

ColumnStore.registerColumnType(DateColumn, true);
DateColumn.exposeProperties();
DateColumn._$name = 'DateColumn';


class PercentColumn extends Column {
  static get type() {
    return 'percent';
  }

  static get fieldType() {
    return 'number';
  }

  static get fields() {
    return ['lowThreshold'];
  }

  static get defaults() {
    return {

      editor: {
        type: 'number',
        min: 0,
        max: 100
      },


      lowThreshold: 20,
      filterType: 'number',
      htmlEncode: false,
      searchable: false,
      summaryRenderer: sum => `${sum}%`
    };
  }

  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-percent-bar-cell';
  }


  renderer({
             value
           }) {
    value = value || 0;
    return {
      className: 'b-percent-bar-outer',
      children: [{
        tag: 'div',
        className: {
          'b-percent-bar': 1,
          'b-zero': value === 0,
          'b-low': value < this.lowThreshold
        },
        style: {
          width: value + '%'
        },
        html: value + '%'
      }]
    };
  }

  clearCell(cellElement) {
    if (cellElement.percentBarElement) {
      cellElement.percentBarElement = null;
    }

    super.clearCell(cellElement);
  }


  resizeToFitContent() {
  }

}

PercentColumn.sum = 'average';
ColumnStore.registerColumnType(PercentColumn, true);
PercentColumn._$name = 'PercentColumn';


class NumberColumn extends Column {

  static get type() {
    return 'number';
  }

  static get fieldType() {
    return 'number';
  }

  static get fields() {
    return [

      'min',

      'max',

      'step',

      'unit'];
  }

  static get defaults() {
    return {
      filterType: 'number'
    };
  }

  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-number-cell';
  }


  get defaultEditor() {
    return {
      name: this.field,
      type: 'numberfield',
      max: this.max,
      min: this.min,
      step: this.step
    };
  }


  defaultRenderer({
                    value = 0
                  }) {
    if (this.unit) {
      return `${value}${this.unit}`;
    }

    return value;
  }

}

ColumnStore.registerColumnType(NumberColumn, true);
NumberColumn.exposeProperties();
NumberColumn._$name = 'NumberColumn';


class RatingColumn extends NumberColumn {
  static get type() {
    return 'rating';
  }

  static get fieldType() {
    return 'number';
  }

  static get fields() {
    return ['emptyIcon', 'filledIcon', 'editable'];
  }

  static get defaults() {
    return {
      min: 0,
      max: 5,


      emptyIcon: 'b-icon b-icon-star',


      filledIcon: 'b-icon b-icon-star',


      editable: true,
      filterType: 'number',
      searchable: false,
      width: '11.2em',
      htmlEncode: false,
      autoSyncHtml: true,
      minWidth: '11.2em',
      editor: false
    };
  }

  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-rating-cell';
  }


  renderer({
             value
           }) {
    let html = `<div class="b-rating-cell-inner ${!this.editable ? 'b-not-editable' : ''}">`;

    for (let i = 0; i < this.max; i++) {
      let filled = i < value;
      html += `<i class="b-rating-icon ${filled ? 'b-filled ' + this.filledIcon : 'b-empty ' + this.emptyIcon}"></i>`;
    }

    html += '</div>';
    return html;
  }

  onCellClick({
                grid,
                column,
                record,
                cellSelector,
                target,
                event
              }) {
    if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {
      let starIndex = [].indexOf.call(target.parentNode.childNodes, target);

      if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {
        starIndex = starIndex - 1;
      }

      if (record.get(column.field) === 1 && starIndex === 0) {
        starIndex = -1;
      }

      record.set(column.field, starIndex + 1);
    }
  }

}

ColumnStore.registerColumnType(RatingColumn, true);
RatingColumn.exposeProperties();
RatingColumn._$name = 'RatingColumn';


class RowNumberColumn extends Column {
  static get defaults() {
    return {
      groupable: false,
      sortable: false,
      filterable: false,
      searchable: false,
      resizable: false,
      minWidth: 50,
      width: 50,
      align: 'right',
      text: '#',
      editor: false
    };
  }

  construct(config, store) {
    const me = this;
    super.construct(...arguments);

    if (me.grid) {
      me.grid.store.on({
        change: me.resizeToFitContent,
        thisObj: me
      });

      if (me.grid.store.count) {
        me.grid.on({
          render: me.resizeToFitContent,
          thisObj: me,
          once: true
        });
      }
    }

    me.internalCellCls = 'b-row-number-cell';
  }

  static get type() {
    return 'rownumber';
  }


  renderer({
             record,
             grid
           }) {
    return record.meta.specialRow ? '' : grid.store.indexOf(record, true) + 1;
  }


  resizeToFitContent() {
    const grid = this.grid,
      store = grid.store,
      count = store.count;

    if (count && !this.hidden) {
      const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id=${this.id}]`);

      if (cellElement) {
        const cellStyle = window.getComputedStyle(cellElement),
          cellPadding = parseInt(cellStyle['padding-left']),
          maxWidth = DomHelper.measureText(count, cellElement);
        this.width = maxWidth + 2 * cellPadding;
      }
    }
  }

  set flex(f) {
  }

}

ColumnStore.registerColumnType(RowNumberColumn, true);
RowNumberColumn._$name = 'RowNumberColumn';


class TemplateColumn extends Column {
  static get fields() {
    return [

      'template'];
  }

  static get defaults() {
    return {
      htmlEncode: false
    };
  }

  constructor(config, store) {
    super(...arguments);
    const me = this;
    if (!me.template) throw new Error(me.L('noTemplate'));
    if (typeof me.template !== 'function') throw new Error(me.L('noFunction'));
  }

  static get type() {
    return 'template';
  }


  renderer(renderData) {

    if (!renderData.record.meta.specialRow) {
      return this.template({
        value: renderData.value,
        record: renderData.record,
        field: renderData.column.field
      });
    }
  }

}

ColumnStore.registerColumnType(TemplateColumn, true);
TemplateColumn.exposeProperties();
TemplateColumn._$name = 'TemplateColumn';


class TimeColumn extends Column {

  static get type() {
    return 'time';
  }

  static get fieldType() {
    return 'date';
  }

  static get fields() {
    return ['format'];
  }

  static get defaults() {
    return {

      format: 'LT',
      minWidth: 140,
      filterType: 'time'
    };
  }


  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-time-cell';
  }


  defaultRenderer({
                    value
                  }) {
    return value ? this.formatValue(value) : '';
  }


  groupRenderer({
                  cellElement,
                  groupRowFor
                }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }


  formatValue(value) {
    const me = this;

    if (typeof value === 'string') {
      value = DateHelper.parse(value, me.format);
    }

    return DateHelper.format(value, me.format);
  }


  set format(value) {
    const me = this,
      editor = me.editor;
    me.set('format', value);

    if (editor) {
      editor.format = me.format;
    }
  }

  get format() {
    return this.get('format');
  }

  get defaultEditor() {
    return {
      name: this.field,
      type: 'time',
      format: this.format
    };
  }

}

ColumnStore.registerColumnType(TimeColumn, true);
TimeColumn.exposeProperties();
TimeColumn._$name = 'TimeColumn';


let currentParentHasIcon = false;


class TreeColumn extends Column {
  static get defaults() {
    return {
      tree: true,
      hideable: false,
      minWidth: 150
    };
  }

  static get fields() {
    return [

      {
        name: 'expandIconCls',
        defaultValue: 'b-icon b-icon-tree-expand'
      },

      {
        name: 'collapseIconCls',
        defaultValue: 'b-icon b-icon-tree-collapse'
      },

      {
        name: 'collapsedFolderIconCls'
      },

      {
        name: 'expandedFolderIconCls'
      },

      {
        name: 'leafIconCls',
        defaultValue: 'b-icon b-icon-tree-leaf'
      }, {
        name: 'editTargetSelector',
        defaultValue: '.b-tree-cell-value'
      }];
  }

  static get type() {
    return 'tree';
  }

  constructor(config, store) {
    super(...arguments);
    const me = this;
    me.internalCellCls = 'b-tree-cell';


    me.shouldHtmlEncode = me.htmlEncode;
    me.tempDiv = document.createElement('div');
    me.setData('htmlEncode', false);

    if (me.renderer) {
      me.originalRenderer = me.renderer;
    }

    me.renderer = me.treeRenderer.bind(me);
  }


  treeRenderer(renderData) {
    const me = this,
      {
        cellElement,
        row,
        record,
        isExport
      } = renderData,
      gridMeta = record.instanceMeta(renderData.grid.store),
      tag = record.href ? 'a' : 'div';
    let {
        value
      } = renderData,
      result;

    if (me.originalRenderer) {
      const rendererHtml = me.originalRenderer(renderData);
      value = rendererHtml === false ? cellElement.innerHTML : rendererHtml;
    }

    if (!isExport) {
      let html = '',
        iconCls;

      if (!record.isLeaf) {
        const isCollapsed = gridMeta.collapsed,
          expanderIconCls = isCollapsed ? me.expandIconCls : me.collapseIconCls,
          folderIconCls = isCollapsed ? me.collapsedFolderIconCls : me.expandedFolderIconCls;

        if (row.$name === 'Row') {
          const loadingCls = 'b-loading-children',
            collapsedCls = 'b-tree-collapsed',
            expandedCls = 'b-tree-expanded',
            rowClsToAdd = ['b-tree-parent-row'],
            rowClsToRemove = [];

          if (gridMeta.isLoadingChildren) {
            rowClsToAdd.push(loadingCls);
          } else {
            rowClsToRemove.push(loadingCls);
          }

          if (isCollapsed) {
            rowClsToAdd.push(collapsedCls);
            rowClsToRemove.push(expandedCls);
          } else {
            rowClsToAdd.push(expandedCls);
            rowClsToRemove.push(collapsedCls);
          }

          row.removeCls(...rowClsToRemove);
          row.addCls(...rowClsToAdd);
        }

        cellElement.classList.add('b-tree-parent-cell');
        html += `<div class="b-tree-expander">${expanderIconCls ? `<i class="${expanderIconCls}"></i>` : ''}</div>`;

        currentParentHasIcon = iconCls = renderData.iconCls || record.iconCls || folderIconCls;
      } else {

        cellElement.classList.add('b-tree-leaf-cell');

        iconCls = renderData.iconCls || record.iconCls || me.leafIconCls;
      }

      value = value != null ? value : '';

      if (me.shouldHtmlEncode) {
        me.tempDiv.innerText = value;
        value = me.tempDiv.innerHTML;
      }

      html += `<div class="b-tree-cell-value">${iconCls ? `<i class="b-tree-icon ${iconCls}"></i>` : ''}${value}</div>`;

      const padding = record.childLevel * 1.7 + (record.isLeaf ? currentParentHasIcon ? 1.8 : iconCls ? 0.4 : 0.3 : 0);

      result = `<${tag} ${record.href ? `href="${record.href}"` : ''} ${tag === 'a' && record.target ? `target="${record.target}"` : ''} class="b-tree-cell-inner" style="padding-left:${padding}em;">${html}</${tag}>`;
    } else {
      result = value != null ? value : '';
    }

    return result;
  }

}

ColumnStore.registerColumnType(TreeColumn, true);
TreeColumn.exposeProperties();
TreeColumn._$name = 'TreeColumn';


class GridRowModel extends Model {
  static get fields() {
    return [

      'iconCls',

      'expanded',

      'cls',

      'rowHeight',

      'href',

      'target'];
  }

}

GridRowModel.exposeProperties();
GridRowModel._$name = 'GridRowModel';


const consumerToFeatureMap = new Map(),
  consumerToDefaultFeatureMap = new Map(),
  DEFAULT_FOR_TYPE = 'Grid',
  remapToBase = {
    'Grid': 'GridBase',
    'Scheduler': 'SchedulerBase',
    'Gantt': 'GanttBase'
  },
  classNameFix = /\$\d+$/;


class GridFeatureManager {

  static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {

    as = StringHelper.lowercaseFirstLetter(as || featureClass.hasOwnProperty('$name') && featureClass.$name || featureClass.name);


    as = as.replace(classNameFix, '');

    if (!Array.isArray(forType)) {
      forType = [forType || DEFAULT_FOR_TYPE];
    }

    forType.forEach(forType => {
      const type = remapToBase[forType] || forType,
        consumerFeaturesMap = consumerToFeatureMap.get(type) || new Map(),
        consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || new Map();
      consumerFeaturesMap.set(as, featureClass);
      consumerDefaultFeaturesMap.set(featureClass, onByDefault);
      consumerToFeatureMap.set(type, consumerFeaturesMap);
      consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);
    });
  }


  static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType,
      consumerFeaturesMap = consumerToFeatureMap.get(type),
      features = {};

    if (consumerFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);
    }

    return features;
  }


  static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType,
      consumerFeaturesMap = consumerToFeatureMap.get(type),
      consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    let features = {};

    if (consumerFeaturesMap && consumerDefaultFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => {
        if (consumerDefaultFeaturesMap.get(featureClass)) {
          features[as] = featureClass;
        }
      });
    }

    return features;
  }


  static getInstanceFeatures(instance) {
    return instance.classNameHierarchy().reduce((features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)), {});
  }


  static getInstanceDefaultFeatures(instance) {
    return instance.classNameHierarchy().reduce((features, typeName) => Object.entries(this.getTypeNameFeatures(typeName)).reduce((features, [as, featureClass]) => {
      if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {
        features[as] = featureClass;
      } else {
        delete features[as];
      }

      return features;
    }, features), {});
  }


  static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType,
      consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;
  }


  static isDefaultFeatureForInstance(featureClass, instance) {

    const typeChain = instance.classNameHierarchy().reverse();
    let result = null;

    for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {
      const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);

      if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {
        result = consumerDefaultFeaturesMap.get(featureClass);
      }
    }

    return result || false;
  }


  static reset() {
    consumerToFeatureMap.clear();
    consumerToDefaultFeatureMap.clear();
  }

}

GridFeatureManager._$name = 'GridFeatureManager';


class CellTooltip extends InstancePlugin {

  static get $name() {
    return 'CellTooltip';
  }

  static get defaultConfig() {
    return {

      tooltipRenderer: null
    };
  }


  construct(grid, config) {
    const me = this;
    super.construct(grid, me.processConfig(config));
  }

  initTip() {
    const me = this;
    me.tip = new Tooltip(Object.assign({
      forElement: me.client.element,
      forSelector: '.b-grid-cell',
      hoverDelay: 1000,
      trackMouse: false,
      cls: 'b-celltooltip-tip',
      getHtml: me.getTooltipContent.bind(me),
      listeners: {
        pointerOver: 'onPointerOver',
        thisObj: me
      }
    }, me.initialConfig));
    me.relayEvents(me.tip, ['beforeshow', 'show']);
  }

  onPointerOver({
                  target
                }) {
    const column = this.client.getColumnFromElement(target);

    return column.tooltipRenderer !== false;
  }


  processConfig(config) {
    if (typeof config === 'function') {
      return {
        tooltipRenderer: config
      };
    }

    return config;
  }

  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }

  doDestroy() {
    this.tip && this.tip.destroy();
    super.doDestroy();
  }

  doDisable(disable) {
    if (!disable) {
      this.initTip();
    } else if (this.tip) {
      this.tip.destroy();
      this.tip = null;
    }

    super.doDisable(disable);
  }


  getTooltipContent({
                      tip,
                      activeTarget: cellElement,
                      event
                    }) {
    const me = this,
      record = me.client.getRecordFromElement(cellElement),
      column = me.client.getColumnFromElement(cellElement);
    let result;

    if (!me.forSelector && record === me.lastRecord && column === me.lastColumn) {
      return me.tip._html;
    }

    me.lastRecord = record;
    me.lastColumn = column;

    if (column.tooltipRenderer) {
      result = column.tooltipRenderer({
        cellElement,
        record,
        column,
        event,
        tip,
        cellTooltip: me
      });

      if (result === false) {
        VersionHelper.deprecate('Grid', '5.0.0', 'Returning false to indicate loading is deprecated. Please see https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
      }
    } else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
      result = me.tooltipRenderer({
        cellElement,
        record,
        column,
        event,
        tip,
        cellTooltip: me
      });

      if (result === false) {
        VersionHelper.deprecate('Grid', '5.0.0', 'Returning false to indicate loading is deprecated. Please see https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
      }
    }

    return result;
  }

}

CellTooltip._$name = 'CellTooltip';
GridFeatureManager.registerFeature(CellTooltip);


class ColumnDragToolbar extends Delayable(InstancePlugin) {

  static get $name() {
    return 'ColumnDragToolbar';
  }

  static get pluginConfig() {
    return {
      after: ['render']
    };
  }


  construct(grid, config) {
    if (grid.features.columnReorder) {
      grid.features.columnReorder.on('beforedestroy', this.onColumnReorderBeforeDestroy, this);
    }

    this.grid = grid;
    super.construct(grid, config);
  }

  doDestroy() {
    const me = this;

    if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {
      me.detachFromColumnReorder();
    }

    me.element && me.element.remove();
    me.element = null;
    super.doDestroy();
  }

  doDisable(disable) {
    if (this.initialized) {
      if (disable) {
        this.detachFromColumnReorder();
      } else {
        this.init();
      }
    }

    super.doDisable(disable);
  }

  init() {
    const me = this,
      grid = me.grid;

    if (!grid.features.columnReorder) {
      return;
    }

    me.reorderDetacher = grid.features.columnReorder.on({
      gridheaderdragstart({
                            context
                          }) {
        const column = grid.columns.getById(context.element.dataset.columnId);
        me.showToolbar(column);
      },

      gridheaderdrag: ({
                         context
                       }) => me.onDrag(context),
      gridheaderabort: () => {
        me.hideToolbar();
      },
      gridheaderdrop: ({
                         context
                       }) => {
        if (context.valid) {
          me.hideToolbar();
        } else {
          me.onDrop(context);
        }
      },
      thisObj: me
    });
    me.initialized = true;
  }

  onColumnReorderBeforeDestroy() {
    this.detachFromColumnReorder();
  }

  detachFromColumnReorder() {
    const me = this;
    me.grid.features.columnReorder.un('beforedestroy', me.onColumnReorderBeforeDestroy, me);
    me.reorderDetacher && me.reorderDetacher();
    me.reorderDetacher = null;
  }


  render() {
    if (!this.initialized) {
      this.init();
    }
  }


  showToolbar(column) {
    const me = this,
      buttons = me.grid.getColumnDragToolbarItems(column, []),
      groups = [];
    me.clearTimeout(me.buttonHideTimer);
    me.clearTimeout(me.toolbarHideTimer);
    buttons.forEach(button => {
      let group = groups.find(group => group.text === button.group);

      if (!group) {
        group = {
          text: button.group,
          buttons: []
        };
        groups.push(group);
      }

      group.buttons.push(button);
    });
    me.element = DomHelper.append(me.grid.element, me.template(groups));
    me.groups = groups;
    me.buttons = buttons;
    me.column = column;
  }

  hideToolbar() {
    const me = this;
    return new Promise(resolve => {
      if (me.element && !me.toolbarHideTimer) {
        me.element.classList.add('b-remove');

        me.toolbarHideTimer = me.setTimeout(() => {
          me.toolbarHideTimer = null;
          me.element && me.element.remove();
          me.element = null;
          resolve();
        }, 200);
      }
    });
  }


  onDrag(info) {
    const me = this;

    if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {
      me.element.classList.add('b-closer');
    } else {
      me.element.classList.remove('b-closer');
    }

    if (me.hoveringButton) {
      me.hoveringButton.classList.remove('b-hover');
      me.hoveringButton = null;
    }

    if (info.targetElement && info.targetElement.closest('.b-columndragtoolbar')) {
      me.element.classList.add('b-hover');
      let button = info.targetElement.closest('.b-columndragtoolbar  .b-target-button:not([data-disabled=true])');

      if (button) {
        button.classList.add('b-hover');
        me.hoveringButton = button;
      }
    } else {
      me.element.classList.remove('b-hover');
    }
  }

  onDrop(info) {
    const me = this;

    if (info.targetElement && info.targetElement.matches('.b-columndragtoolbar .b-target-button:not([data-disabled=true])')) {
      const buttonEl = info.targetElement,
        button = me.buttons.find(button => button.name === buttonEl.dataset.name);

      if (button) {
        buttonEl.classList.add('b-activate');
        me.buttonHideTimer = me.setTimeout(() => {
          me.hideToolbar();
          button.onDrop({
            column: me.column
          });
        }, 100);
      }
    } else {
      me.hideToolbar();
    }
  }

  template(groups) {
    return TemplateHelper.tpl`
            <div class="b-columndragtoolbar">
            <div class="b-title"></div>
            ${groups.map(group => TemplateHelper.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${group.buttons.map(btn => TemplateHelper.tpl`
                        <div class="b-target-button" data-name="${btn.name}" data-disabled="${btn.disabled}">
                            <i class="${btn.icon}"></i>
                            ${btn.text}
                        </div>
                    `)}
                    </div>
                    <div class="b-title">${group.text}</div>
                </div>
            `)}
            </div>`;
  }

}

ColumnDragToolbar.featureClass = 'b-hascolumndragtoolbar';

ColumnDragToolbar._$name = 'ColumnDragToolbar';
GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);


class ColumnPicker extends InstancePlugin {

  static get $name() {
    return 'ColumnPicker';
  }

  static get defaultConfig() {
    return {

      groupByRegion: false,


      groupByTag: false
    };
  }

  static get pluginConfig() {
    return {
      chain: ['getHeaderMenuItems', 'getColumnDragToolbarItems']
    };
  }


  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
  }


  getColumnPickerItems(columnStore) {
    const me = this;

    if (me.groupByRegion) {

      return me.grid.regions.map(region => {
        const columns = me.grid.getSubGrid(region).columns.topColumns;
        return {
          text: StringHelper.capitalizeFirstLetter(region),
          menu: me.buildColumnMenu(columns),
          disabled: columns.length === 0,
          region: region
        };
      });
    } else if (me.groupByTag) {

      const tags = {};
      columnStore.topColumns.forEach(column => {
        column.tags && column.hideable && column.tags.forEach(tag => {
          if (!tags[tag]) {
            tags[tag] = 1;
          }
        });
      });

      return Object.keys(tags).sort().map(tag => ({
        text: StringHelper.capitalizeFirstLetter(tag),
        menu: me.buildColumnMenu(me.getColumnsForTag(tag)),
        tag: tag,
        onBeforeSubMenu: ({
                            item,
                            itemEl
                          }) => {
          me.refreshTagMenu(item, itemEl);
        }
      }));
    } else {

      return me.buildColumnMenu(columnStore.topColumns);
    }
  }


  getColumnsForTag(tag) {

    return this.grid.columns.records.filter(column => column.tags && column.tags.includes(tag) && column.hideable !== false);
  }


  refreshTagMenu(item, itemEl) {
    const columns = this.getColumnsForTag(item.tag);
    columns.forEach(column => {
      const subItem = item.items.find(subItem => subItem.column === column);
      if (subItem) subItem.checked = column.hidden !== true;
    });
  }


  buildColumnMenu(columns) {
    let currentRegion = columns.length > 0 && columns[0].region,
      {
        grid
      } = this;
    return columns.reduce((items, column) => {
      const visibleInRegion = this.grid.columns.visibleColumns.filter(col => col.region === column.region);

      if (column.hideable !== false) {
        const itemConfig = {
          grid,
          text: column.text,
          column: column,
          name: column.id,
          checked: column.hidden !== true,
          disabled: column.hidden !== true && visibleInRegion.length === 1,
          cls: column.region !== currentRegion ? 'b-separator' : ''
        };
        currentRegion = column.region;

        if (column.children) {
          itemConfig.menu = this.buildColumnMenu(column.children);
        }

        items.push(itemConfig);
      }

      return items;
    }, []);
  }


  getHeaderMenuItems(column, items) {
    const me = this,
      {
        grid,
        disabled
      } = me,
      {
        columns
      } = grid;

    if (column.showColumnPicker !== false && columns.some(col => col.hideable)) {

      items.push({
        text: me.L('columnsMenu'),
        name: 'columnPicker',
        icon: 'b-fw-icon b-icon-columns',
        cls: 'b-separator',
        weight: 100,
        menu: me.getColumnPickerItems(columns),
        onToggle: me.onColumnToggle,
        disabled
      });
    }

    if (column.hideable !== false) {
      const visibleInRegion = columns.visibleColumns.filter(col => col.region === column.region);
      items.push({
        text: me.L('hideColumn'),
        icon: 'b-fw-icon b-icon-hide-column',
        weight: 101,
        name: 'hideColumn',
        disabled: visibleInRegion.length === 1 || disabled,
        onItem: () => column.hide()
      });
    }
  }


  onColumnToggle({
                   menu,
                   item,
                   checked
                 }) {
    if (!!item.column.hidden !== !checked) {
      item.column[checked ? 'show' : 'hide']();
      const {
          grid,
          column
        } = item,
        {
          columns
        } = grid,

        siblingItems = menu.items,

        visibleInRegion = columns.visibleColumns.filter(col => col.region === item.column.region),

        {
          currentMenu
        } = grid.features.contextMenu,

        hideItem = currentMenu.items.find(item => item.name === 'hideColumn');

      if (visibleInRegion.length === 1) {
        const lastVisibleItem = siblingItems.find(i => i.name === visibleInRegion[0].id);

        if (lastVisibleItem) {
          lastVisibleItem.disabled = true;
        }

        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = true;
        }
      } else {
        visibleInRegion.forEach(col => {
          const siblingItem = siblingItems.find(sibling => sibling.column === col);

          if (siblingItem) {
            siblingItem.disabled = false;
          }
        });

        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = false;
        }
      }

      if (item.menu) {


        item.menu.eachWidget(subItem => {
          subItem.checked = checked;
        });
      }

      const parentItem = menu.owner;

      if (parentItem && parentItem.column === column.parent) {
        const anyChecked = siblingItems.some(subItem => subItem.checked === true);
        parentItem.checked = anyChecked;
      }
    }
  }


  getColumnDragToolbarItems(column, items) {
    const visibleInRegion = this.grid.columns.visibleColumns.filter(col => col.region === column.region);

    if (column.hideable !== false && visibleInRegion.length > 1) {
      items.push({
        text: this.L('hideColumnShort'),
        group: this.L('Column'),
        icon: 'b-fw-icon b-icon-hide-column',
        weight: 101,
        name: 'hideColumn',
        onDrop: ({
                   column
                 }) => column.hide()
      });
    }

    return items;
  }

}

ColumnPicker._$name = 'ColumnPicker';
GridFeatureManager.registerFeature(ColumnPicker, true);


class ColumnReorder extends Delayable(InstancePlugin) {

  static get $name() {
    return 'ColumnReorder';
  }

  construct(grid, config) {
    this.ignoreSelectors = ['.b-grid-header-resize-handle', '.b-field'];
    this.grid = grid;
    super.construct(grid, config);
  }

  doDestroy() {
    this.dragHelper && this.dragHelper.destroy();
    super.doDestroy();
  }


  init() {
    const me = this,
      {
        grid
      } = me,
      gridEl = grid.element,
      containers = DomHelper.children(gridEl, '.b-grid-headers');
    containers.push(...DomHelper.children(gridEl, '.b-grid-header-children'));

    if (me.dragHelper) {

      me.dragHelper.containers = containers;
    } else {
      me.dragHelper = new DragHelper({
        name: 'columnReorder',
        mode: 'container',
        dragThreshold: 10,
        targetSelector: '.b-grid-header',
        outerElement: gridEl.querySelector('header.b-grid-header-container'),
        containers,

        isElementDraggable(element) {
          const abort = Boolean(DomHelper.up(element, me.ignoreSelectors.join(',')));

          if (abort || me.disabled) {
            return false;
          }

          const columnEl = DomHelper.up(element, this.targetSelector),
            column = columnEl && grid.columns.getById(columnEl.dataset.columnId),
            isLast = column && column.childLevel === 0 && grid.subGrids[column.region].columns.count === 1;


          return Boolean(column) && column.draggable !== false && !isLast;
        },

        ignoreSelector: '.b-filter-icon,.b-grid-header-resize-handle',
        listeners: {
          dragstart: me.onDragStart,
          drag: me.onDrag,
          drop: me.onDrop,
          thisObj: me
        }
      });
      me.relayEvents(me.dragHelper, ['dragStart', 'drag', 'drop', 'abort'], 'gridHeader');
    }
  }


  static get pluginConfig() {
    return {
      after: ['render', 'renderContents']
    };
  }


  onDrag({
           context,
           event
         }) {
    const me = this,
      targetHeader = IdHelper.fromElement(event.target, 'header');

    if (targetHeader && targetHeader.subGrid.sealedColumns) {
      context.valid = false;
      return;
    }

    if (!me.grid.features.columnDragToolbar) {
      context.valid = Boolean(event.target.closest('.b-grid-headers'));
    }
  }

  onDragStart() {
    const me = this;

    if (!me.grid.features.columnDragToolbar) {
      const headerContainerBox = me.grid.element.querySelector('.b-grid-header-container').getBoundingClientRect();
      me.dragHelper.minY = headerContainerBox.top;
      me.dragHelper.maxY = headerContainerBox.bottom;
    }

    this.grid.headerContainer.classList.add('b-dragging-header');
  }


  onDrop({
           context
         }) {
    if (!context.valid) {
      return this.onInvalidDrop({
        context
      });
    }

    const me = this,
      grid = me.grid,
      element = context.dragging,
      onHeader = DomHelper.up(context.target, '.b-grid-header'),
      onColumn = grid.columns.get(onHeader.dataset.column),
      toRegion = context.draggedTo.dataset.region || onColumn.region,
      sibling = context.insertBefore,
      column = grid.columns.getById(element.dataset.columnId),
      insertBefore = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling,
      newParent = insertBefore ? insertBefore.parent : grid.columns.rootNode;
    grid.headerContainer.classList.remove('b-dragging-header');

    if (toRegion === column.region && (onColumn === column.previousSibling || insertBefore === column.nextSibling)) {
      me.dragHelper.abort();
      return;
    }

    const emptyParent = column.parent && column.parent.children.length === 1 && column.parent;

    if (emptyParent) {
      emptyParent.parent.removeChild(emptyParent);
    }

    element.remove();
    column.region = toRegion;

    newParent.insertChild(column, insertBefore);
  }


  onInvalidDrop() {
    this.grid.headerContainer.classList.remove('b-dragging-header');
  }


  renderContents() {

    this.init();
  }


  render() {

    this.init();
  }

}

ColumnReorder.featureClass = 'b-column-reorder';
ColumnReorder._$name = 'ColumnReorder';
GridFeatureManager.registerFeature(ColumnReorder, true);


class ColumnResize extends InstancePlugin {
  static get $name() {
    return 'ColumnResize';
  }

  static get defaultConfig() {
    return {

      liveResize: 'auto'
    };
  }

  construct(grid, config) {
    const me = this;
    me.grid = grid;
    super.construct(grid, config);
    me.resizer = new ResizeHelper({
      name: 'columnResize',
      targetSelector: '.b-grid-header',
      handleSelector: '.b-grid-header-resize-handle',
      outerElement: grid.element,
      listeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onResize,
        thisObj: me
      }
    });
  }


  static get pluginConfig() {
    return [];
  }

  set liveResize(liveResize) {
    if (liveResize === 'auto') {
      liveResize = !BrowserHelper.isMobileSafari;
    }

    this._liveResize = liveResize;
  }

  get liveResize() {
    return this._liveResize;
  }

  doDestroy() {
    this.resizer && this.resizer.destroy();
    super.doDestroy();
  }

  onBeforeResizeStart() {
    return !this.disabled;
  }

  onResizeStart({
                  context
                }) {
    const {
        grid,
        resizer
      } = this,
      column = context.column = grid.columns.getById(context.element.dataset.columnId);
    resizer.minWidth = column.minWidth;

    context.element.style.minWidth = '';
    grid.element.classList.add('b-column-resizing');
  }


  onResizing({
               context
             }) {
    if (context.valid && this.liveResize) {
      this.grid.dragResizing = true;
      context.column.width = context.newWidth;
    }
  }


  onResize({
             context
           }) {
    const {
        grid
      } = this,
      {
        column
      } = context;
    grid.element.classList.remove('b-column-resizing');

    if (context.valid) {
      if (this.liveResize) {
        grid.dragResizing = false;
        grid.afterColumnsResized();
      } else {
        column.width = context.newWidth;
      }


      if (BrowserHelper.isIE11 && column.parent && column.parent.flex) {
        const parent = column.parent,
          headerEl = grid.getHeaderElement(parent.id);
        headerEl.style.flexBasis = parent.children.reduce((result, column) => {
          return result + grid.getHeaderElement(column.id).offsetWidth;
        }, 0) + 'px';
      }
    }
  }

}

ColumnResize._$name = 'ColumnResize';
GridFeatureManager.registerFeature(ColumnResize, true);


class ContextMenu extends InstancePlugin {

  static get $name() {
    return 'ContextMenu';
  }

  static get defaultConfig() {
    return {

      headerItems: [],


      processHeaderItems: null,


      cellItems: [],


      processCellItems: null,


      triggerEvent: null,


      disableCellContextMenu: null
    };
  }


  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
  }

  doDestroy() {
    if (this.currentMenu) {
      this.currentMenu.destroy();
    }

    super.doDestroy();
  }


  static get pluginConfig() {
    return {
      assign: ['showContextMenu'],
      chain: ['onElementContextMenu', 'onElementClick', 'onElementDblClick', 'onElementKeyDown']
    };
  }


  onElementContextMenu(event) {
    this.triggerEvent === 'contextmenu' && this.showContextMenu(event);
  }

  onElementClick(event) {
    this.triggerEvent === 'click' && this.showContextMenu(event);
  }

  onElementDblClick(event) {
    this.triggerEvent === 'dblclick' && this.showContextMenu(event);
  }

  onElementKeyDown(event) {
    if (!event.handled && event.target.matches('.b-grid-header.b-depth-0')) {
      switch (event.key) {
        case ' ':
        case 'ArrowDown':
          this.showContextMenu(event);
          break;
      }
    }
  }


  showContextMenu(event) {
    if (!this.disabled) {
      const header = DomHelper.up(event.target, '.b-grid-header'),
        cellData = this.grid.getEventData(event);

      if (header) {
        this.handleHeaderContextMenu(header, event);
      } else if (cellData && !this.disableCellContextMenu) {
        this.handleCellContextMenu(cellData, event);
      }
    }
  }

  handleHeaderContextMenu(header, event) {
    if (header.dataset.column) {
      const me = this,
        grid = me.grid,
        column = grid.columns.getById(header.dataset.columnId),
        setColumn = item => {
          if (!item.column) {
            item.column = column;
          }

          let menu = item.menu;

          if (menu) {
            if (!Array.isArray(menu)) {
              menu = menu.items || menu.widgets;
            }

            menu.forEach(setColumn);
          }
        };

      if (column.enableHeaderContextMenu !== false) {

        const items = [...me.headerItems, ...(column.headerMenuItems || [])],
          {
            processHeaderItems
          } = me,
          eventParams = {
            items,
            column,
            event,
            element: header
          };

        grid.getHeaderMenuItems(column, items);

        if ((!processHeaderItems || processHeaderItems(eventParams) !== false) && items.length > 0) {
          event.preventDefault();
          items.sort((a, b) => (a.weight || 150) - (b.weight || 150));


          items.forEach(setColumn);

          if (grid.trigger('headerContextMenuBeforeShow', eventParams) !== false) {

            me.currentMenu = WidgetHelper.showContextMenu(event.type === 'keydown' ? header : [event.clientX + 1, event.clientY + 1], {
              owner: me.client,
              constrainTo: document,
              cls: 'b-context-menu',
              items: items,

              scrollAction: 'hide',

              onItem({
                       source,
                       item,
                       element
                     }) {
                grid.trigger('contextMenuItem', {
                  source: grid,
                  item,
                  column,
                  element
                });
              },

              onToggle({
                         source,
                         item,
                         checked,
                         element
                       }) {
                grid.trigger('contextMenuToggleItem', {
                  source: grid,
                  item,
                  column,
                  checked,
                  element
                });
              },

              onDestroy() {

                me.currentMenu = null;
              },

              listeners: {
                show({
                       source: menu
                     }) {
                  eventParams.menu = menu;
                  grid.trigger('headerContextMenuShow', eventParams);
                }

              }
            });
          }
        }
      }
    }
  }

  handleCellContextMenu(cellData, event) {
    const me = this,
      grid = me.grid,
      cell = cellData.cellElement,
      column = grid.columns.getById(cellData.columnId);

    if (column.enableCellContextMenu !== false) {


      grid.focusCell(cellData.cellSelector, {
        doSelect: !grid.isSelected(cellData.id),
        event
      });
      const record = cellData.record,
        items = [...(me.cellItems || []), ...(column.cellMenuItems || [])],
        {
          processCellItems
        } = me,
        eventParams = {
          items,
          column,
          event,
          record,
          element: cell
        };

      grid.getCellMenuItems(column, record, items);

      if ((!processCellItems || processCellItems(eventParams) !== false) && items.length > 0) {
        items.forEach(item => {
          item.column = column;
          item.record = record;
        });
        event.preventDefault();
        items.sort((a, b) => (a.weight || 150) - (b.weight || 150));

        if (grid.trigger('cellContextMenuBeforeShow', eventParams) !== false) {
          me.currentMenu = WidgetHelper.showContextMenu([event.clientX + 1, event.clientY + 1], {
            owner: me.client,
            items: items,

            onBeforeItem: itemEvent => {
              Object.assign(itemEvent, eventParams);
            },

            onItem({
                     item
                   }) {
              grid.trigger('contextMenuItem', {
                source: grid,
                item,
                column,
                record,
                cell
              });
            },

            onClose({
                      reason
                    }) {

              if (reason !== 'outside') {
                grid.focus();
              }
            },

            onDestroy() {

              me.currentMenu = null;
            },

            listeners: {
              show({
                     source: menu
                   }) {
                eventParams.menu = menu;
                grid.trigger('cellContextMenuShow', eventParams);
              }

            }
          });
        }
      }
    }
  }


  hideContextMenu(animate) {
    this.currentMenu && this.currentMenu.hide(animate);
  }


  get triggerEvent() {
    return this._triggerEvent || this.client.contextMenuTriggerEvent;
  }

  set triggerEvent(value) {
    this._triggerEvent = value;
  }

}

ContextMenu.featureClass = '';
ContextMenu._$name = 'ContextMenu';
GridFeatureManager.registerFeature(ContextMenu, true);


class Filter extends InstancePlugin {

  static get $name() {
    return 'Filter';
  }

  static get pluginConfig() {
    return {
      chain: ['renderHeader', 'getCellMenuItems', 'getHeaderMenuItems', 'onElementClick']
    };
  }

  construct(grid, config) {
    const me = this;
    me.grid = grid;
    me.store = grid.store;
    me.closeFilterEditor = me.closeFilterEditor.bind(me);
    super.construct(grid, config);
    me.store.on({
      filter: me.onStoreFilter
    }, me);

    if (config && typeof config === 'object') {
      me.store.filter(config, null, me.client.isConfiguring);
    }
  }


  doDestroy() {
    const me = this;
    me.filterTip && me.filterTip.destroy();
    me.filterEditorPopup && me.filterEditorPopup.destroy();
    me.store.un({
      sort: me.onStoreFilter
    }, me);
    super.doDestroy();
  }


  refreshHeaders(reRenderRows) {
    const me = this,
      grid = me.grid,
      element = grid.headerContainer;

    if (element) {

      DomHelper.children(element, '.b-filter-icon.b-latest').forEach(iconElement => iconElement.classList.remove('b-latest'));

      if (!me.filterTip) {
        me.filterTip = new Tooltip({
          forElement: element,
          forSelector: '.b-filter-icon',

          getHtml({
                    activeTarget
                  }) {
            return activeTarget.dataset.filterText;
          }

        });
      }

      for (const column of grid.columns) {
        if (column.filterable !== false) {
          const filter = me.store.filters.getBy('property', column.field),
            headerEl = column.element;

          if (headerEl) {
            const textEl = column.textWrapper;
            let filterIconEl = textEl && textEl.querySelector('.b-filter-icon'),
              filterText;

            if (filter) {
              filterText = me.L('filter') + ': ' + (typeof filter === 'string' ? filter : `${filter.operator} ${filter.displayValue || filter.value || ''}`);
            } else {
              filterText = me.L('applyFilter');
            }

            if (!filterIconEl) {

              filterIconEl = DomHelper.createElement({
                parent: textEl,
                tag: 'div',
                className: 'b-filter-icon',
                dataset: {
                  filterText: filterText
                }
              });
              headerEl.classList.add('b-filterable');
            } else {
              filterIconEl.dataset.filterText = filterText;
            }

            if (column.field === me.store.latestFilterField) filterIconEl.classList.add('b-latest');
            headerEl.classList[filter ? 'add' : 'remove']('b-filter');

          }

          column.meta.isFiltered = !!filter;
        }
      }

      if (reRenderRows) {
        grid.refreshRows();
      }
    }
  }


  applyFilter(config) {
    const {
        store
      } = this,
      column = this.grid.columns.get(config.property);

    if (typeof column.filterable === 'function') {
      store.filter({
        filterBy: record => column.filterable(Object.assign({}, config, {
          record
        })),

        value: config.value,
        property: config.property,
        operator: config.operator,
        displayValue: config.displayValue
      });
    } else {
      store.filter(config);
    }
  }

  getPopupDateItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    const me = this,
      onClose = changeCallback,
      onClear = closeCallback;

    function onChange({
                        source,
                        value
                      }) {
      if (value == null) {
        closeCallback();
      } else {
        me.applyFilter({
          property: field,
          operator: source.operator,
          value,
          displayValue: source._value
        });
        changeCallback();
      }
    }

    return [{
      type: 'date',
      ref: 'on',
      placeholder: me.L('on'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: filter && filter.operator === '=' ? filter.value : initialValue,
      operator: '=',
      onChange,
      onClose,
      onClear
    }, {
      type: 'date',
      ref: 'before',
      placeholder: me.L('before'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-before"></i>',
      value: filter && filter.operator === '<' ? filter.value : null,
      operator: '<',
      onChange,
      onClose,
      onClear
    }, {
      type: 'date',
      ref: 'after',
      cls: 'b-last-row',
      placeholder: me.L('after'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-after"></i>',
      value: filter && filter.operator === '>' ? filter.value : null,
      operator: '>',
      onChange,
      onClose,
      onClear
    }];
  }

  getPopupNumberItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    const me = this,
      onEsc = changeCallback,
      onClear = closeCallback;

    function onChange({
                        source,
                        value
                      }) {
      if (value == null) {
        closeCallback();
      } else {
        me.applyFilter({
          property: field,
          operator: source.operator,
          value
        });
        changeCallback();
      }
    }

    return [{
      type: 'number',
      placeholder: me.L('equals'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: filter && filter.operator === '=' ? filter.value : initialValue,
      operator: '=',
      onChange,
      onEsc,
      onClear
    }, {
      type: 'number',
      placeholder: me.L('lessThan'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-less"></i>',
      value: filter && filter.operator === '<' ? filter.value : null,
      operator: '<',
      onChange,
      onEsc,
      onClear
    }, {
      type: 'number',
      cls: 'b-last-row',
      placeholder: me.L('moreThan'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-more"></i>',
      value: filter && filter.operator === '>' ? filter.value : null,
      operator: '>',
      onChange,
      onEsc,
      onClear
    }];
  }

  getPopupStringItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    const me = this;
    return [{
      type: fieldType,
      cls: 'b-last-row',
      placeholder: me.L('filter'),
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: filter ? filter.value || filter : initialValue,
      onChange: ({
                   value
                 }) => {
        if (value === '') {
          closeCallback();
        } else {
          me.applyFilter({
            property: field,
            value
          });
          changeCallback();
        }
      },
      onClose: changeCallback,
      onClear: closeCallback
    }];
  }


  getPopupItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    switch (fieldType) {
      case 'date':
        return this.getPopupDateItems(...arguments);

      case 'number':
        return this.getPopupNumberItems(...arguments);

      default:
        return this.getPopupStringItems(...arguments);
    }
  }


  showFilterEditor(column, value) {
    const me = this,
      {
        store
      } = me,
      col = typeof column === 'string' ? me.grid.columns.getById(column) : column,
      headerEl = col.element,
      field = store.modelClass.fieldMap[col.field],
      filter = store.filters.getBy('property', col.field),
      type = field && field.type || col.filterType || col.type || 'string',
      fieldType = {
        string: 'text',
        number: 'number',
        date: 'date'
      }[type] || 'text';

    if (col.filterable === false) {
      return;
    }

    me.closeFilterEditor();
    me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {
      owner: this.grid,
      width: '16em',
      cls: 'b-filter-popup',
      scrollAction: 'realign',
      items: me.getPopupItems(fieldType, filter, value, col.field, me.store, me.closeFilterEditor, () => {
        me.store.removeFilter(col.field);
        me.closeFilterEditor();
      })
    });
  }


  closeFilterEditor() {
    const me = this;


    me.filterEditorPopup && me.filterEditorPopup.setTimeout(me.filterEditorPopup.destroy);
    me.filterEditorPopup = null;
  }


  getMenuDateItems(column, record) {
    const me = this,
      value = record[column.field],
      filter = operator => {
        me.applyFilter({
          property: column.field,
          operator,
          value,
          displayValue: column.formatValue ? column.formatValue(value) : value
        });
      };

    return [{
      text: me.L('on'),
      icon: 'b-fw-icon b-icon-filter-equal',
      cls: 'b-separator',
      name: 'filterDateEquals',
      disabled: me.disabled,
      onItem: () => filter('=')
    }, {
      text: me.L('before'),
      icon: 'b-fw-icon b-icon-filter-before',
      name: 'filterDateBefore',
      disabled: me.disabled,
      onItem: () => filter('<')
    }, {
      text: me.L('after'),
      icon: 'b-fw-icon b-icon-filter-after',
      name: 'filterDateAfter',
      disabled: me.disabled,
      onItem: () => filter('>')
    }];
  }

  getMenuNumberItems(column, record) {
    const me = this,
      filter = operator => {
        me.applyFilter({
          property: column.field,
          operator: operator,
          value: record[column.field]
        });
      };

    return [{
      text: me.L('equals'),
      icon: 'b-fw-icon b-icon-filter-equal',
      cls: 'b-separator',
      name: 'filterNumberEquals',
      disabled: me.disabled,
      onItem: () => filter('=')
    }, {
      text: me.L('lessThan'),
      icon: 'b-fw-icon b-icon-filter-less',
      name: 'filterNumberLess',
      disabled: me.disabled,
      onItem: () => filter('<')
    }, {
      text: me.L('moreThan'),
      icon: 'b-fw-icon b-icon-filter-more',
      name: 'filterNumberMore',
      disabled: me.disabled,
      onItem: () => filter('>')
    }];
  }

  getMenuStringItems(column, record) {
    return [{
      text: this.L('equals'),
      icon: 'b-fw-icon b-icon-filter-equal',
      cls: 'b-separator',
      name: 'filterStringEquals',
      disabled: this.disabled,
      onItem: () => {
        this.applyFilter({
          property: column.field,
          value: record[column.field]
        });
      }
    }];
  }


  getCellMenuItems(column, record, items) {
    const me = this,
      field = record.getFieldDefinition(column.field);

    if (column.filterable !== false) {
      const filterItems = [];

      if (column.meta.isFiltered) {
        filterItems.push({
          text: me.L('removeFilter'),
          icon: 'b-fw-icon b-icon-clear',
          cls: 'b-separator',
          name: 'filterRemove',
          disabled: me.disabled,

          onItem() {
            me.store.removeFilter(column.field);
          }

        });
      }

      switch (column.filterType || column.type || field && field.type) {
        case 'date':
          filterItems.push(...me.getMenuDateItems(...arguments));
          break;

        case 'number':
          filterItems.push(...me.getMenuNumberItems(...arguments));
          break;

        default:
          filterItems.push(...me.getMenuStringItems(...arguments));
          break;
      }

      if (column.meta.isFiltered && filterItems.length > 1) {
        filterItems[1].cls = '';
      }

      items.push(...filterItems);
    }
  }


  getHeaderMenuItems(column, items) {
    const me = this;

    if (column.meta.isFiltered) {
      items.push({
        text: me.L('editFilter'),
        name: 'editFilter',
        icon: 'b-fw-icon b-icon-filter',
        cls: 'b-separator',
        disabled: me.disabled,

        onItem() {
          me.showFilterEditor(column);
        }

      });
      items.push({
        text: me.L('removeFilter'),
        name: 'removeFilter',
        icon: 'b-fw-icon b-icon-remove',
        disabled: me.disabled,

        onItem() {
          me.store.removeFilter(column.field);
        }

      });
    } else if (column.filterable !== false) {
      items.push({
        text: me.L('filter'),
        name: 'filter',
        icon: 'b-fw-icon b-icon-filter',
        cls: 'b-separator',
        disabled: me.disabled,

        onItem() {
          me.showFilterEditor(column);
        }

      });
    }
  }


  onStoreFilter() {


    this.refreshHeaders(false);
  }


  renderHeader() {
    this.refreshHeaders(false);
  }


  onElementClick(event) {
    const target = event.target;
    if (this.filterEditorPopup) this.closeFilterEditor();

    if (target.classList.contains('b-filter-icon')) {
      const headerEl = DomHelper.up(target, '.b-grid-header');
      this.showFilterEditor(headerEl.dataset.columnId);
      return false;
    }
  }

}

Filter._$name = 'Filter';
GridFeatureManager.registerFeature(Filter);


class FilterBar extends InstancePlugin {

  static get $name() {
    return 'FilterBar';
  }

  static get defaultConfig() {
    return {

      keyStrokeFilterDelay: 300,

      clearStoreFiltersOnHide: true
    };
  }


  construct(grid, config) {
    const me = this;
    Object.assign(me, {
      filterFieldCls: 'b-filter-bar-field',
      filterFieldInputCls: 'b-filter-bar-field-input',
      filterableColumnCls: 'b-filter-bar-enabled',
      filterFieldInputSelector: '.b-filter-bar-field-input',
      filterableColumnSelector: '.b-filter-bar-enabled',
      filterParseRegExp: /^\s*([<>=*])?(.*)$/,
      storeTrackingSupended: 0,
      store: grid.store,
      grid: grid
    });
    me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);
    super.construct(grid, Array.isArray(config) ? {
      filter: config
    } : config);
    me.store.on({
      filter: me.onStoreFilter,
      thisObj: me
    });

    if (me.filter) {
      me.store.filter(me.filter);
    }

    me.gridDetacher = grid.on('beforeelementclick', me.onBeforeElementClick, me);
  }

  doDestroy() {
    const me = this;
    me.destroyFilterBar();
    me.gridDetacher && me.gridDetacher();
    super.doDestroy();
  }

  doDisable(disable) {
    const {
      columns
    } = this.grid;

    columns && columns.forEach(column => {
      const widget = this.getColumnFilterField(column);

      if (widget) {
        widget.disabled = disable;
      }
    });
    super.doDisable(disable);
  }

  static get pluginConfig() {
    return {
      before: ['onElementKeyDown'],
      chain: ['renderHeader', 'getHeaderMenuItems']
    };
  }


  destroyFilterBar() {
    this.grid.columns && this.grid.columns.forEach(this.destroyColumnFilterField, this);
  }


  hideFilterBar() {
    const me = this,
      columns = me.grid.columns;

    me.clearStoreFiltersOnHide && me.suspendStoreTracking();

    columns && columns.forEach(col => me.hideColumnFilterField(col, true));

    me.grid.store.filter();
    me.clearStoreFiltersOnHide && me.resumeStoreTracking();
    me.hidden = true;
  }


  showFilterBar() {
    this.renderFilterBar();
    this.hidden = false;
  }


  toggleFilterBar() {
    const me = this;

    if (me.hidden) {
      me.showFilterBar();
    } else {
      me.hideFilterBar();
    }
  }


  renderFilterBar() {
    this.grid.columns.visibleColumns.forEach(column => this.renderColumnFilterField(column));
    this.rendered = true;
  }


  renderColumnFilterField(column) {
    const me = this,
      grid = me.grid,
      filterable = me.getColumnFilterable(column);

    if (filterable && !column.hidden) {
      const headerEl = column.element;
      let widget = me.getColumnFilterField(column);


      if (!widget) {
        const filter = grid.store.filters.getBy('property', column.field),
          type = `${column.filterType || 'text'}field`;
        widget = WidgetHelper.append(Object.assign({
          type,
          owner: me.grid,
          clearable: true,
          column: column,
          name: column.field,
          value: filter && me.buildFilterString(filter),
          cls: me.filterFieldCls,
          inputCls: me.filterFieldInputCls,
          keyStrokeChangeDelay: me.keyStrokeFilterDelay,
          onChange: me.onColumnFilterFieldChange,
          onClear: me.onColumnFilterFieldChange,
          disabled: me.disabled
        }, filterable.filterField), headerEl)[0];
        me.setColumnFilterField(column, widget);
      } else {

        me.onColumnFilterFieldChange({
          source: widget,
          value: widget.value
        });

        widget.render(headerEl);

        widget.show();
      }

      headerEl.classList.add(me.filterableColumnCls);
    }
  }


  updateColumnFilterFields() {
    const me = this,
      grid = me.grid;
    let field, filter;

    for (const column of grid.columns) {
      field = me.getColumnFilterField(column);

      if (field) {
        filter = grid.store.filters.getBy('property', column.field);
        field.value = filter && me.buildFilterString(filter) || '';
      }
    }
  }

  getColumnFilterable(column) {
    if (!column.isRoot && column.filterable !== false && column.field) {
      if (typeof column.filterable === 'function') {
        column.filterable = {
          filterFn: column.filterable
        };
      }

      return column.filterable;
    }
  }

  destroyColumnFilterField(column) {
    const me = this,
      widget = me.getColumnFilterField(column);

    if (widget) {
      me.hideColumnFilterField(column);

      widget.destroy();

      me.setColumnFilterField(column, undefined);
    }
  }

  hideColumnFilterField(column, silent) {
    const me = this,
      store = me.grid.store,
      columnEl = column.element,
      widget = me.getColumnFilterField(column);

    if (widget) {

      widget.hide();

      if (me.clearStoreFiltersOnHide && column.field) {
        store.removeFilter(column.field, silent);
      }

      columnEl === null || columnEl === void 0 ? void 0 : columnEl.classList.remove(me.filterableColumnCls);
    }
  }

  getColumnFilterField(column) {
    return this._columnFilters && this._columnFilters[column.data.id];
  }

  setColumnFilterField(column, widget) {
    this._columnFilters = this._columnFilters || {};
    this._columnFilters[column.data.id] = widget;
  }


  parseFilterValue(value) {
    const match = String(value).match(this.filterParseRegExp);
    return {
      operator: match[1] || '*',
      value: match[2]
    };
  }

  buildFilterString(filter) {
    let result;

    if (filter && !filter.initialConfig.filterBy) {
      result = (filter.operator === '*' ? '' : filter.operator) + filter.value;
    }

    return result;
  }


  onStoreFilter() {
    if (!this.storeTrackingSupended && this.rendered) {
      this.updateColumnFilterFields();
    }
  }

  suspendStoreTracking() {
    this.storeTrackingSupended++;
  }

  resumeStoreTracking() {
    this.storeTrackingSupended--;
  }


  renderHeader() {
    if (!this.hidden) {
      this.renderFilterBar();
    }
  }

  onElementKeyDown(event) {
    const me = this;

    if (event.handled) return;


    if (event.target.matches(me.filterFieldInputSelector)) {
      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowRight':
          event.handled = true;
      }
    }
  }

  onBeforeElementClick({
                         event
                       }) {
    const me = this;

    if (event.target.closest('.' + me.filterFieldCls)) {
      return false;
    }
  }


  onColumnFilterFieldChange({
                              source: field,
                              value
                            }) {
    const me = this,
      store = me.grid.store,
      filterable = me.getColumnFilterable(field.column);


    me.suspendStoreTracking();

    if (value == null || value === '' || Array.isArray(value) && value.length === 0) {

      store.removeFilter(field.name);
    } else if (filterable.filterFn) {
      store.filter({
        filterBy: record => filterable.filterFn({
          property: field.name,
          value,
          record
        }),

        property: field.name
      });
    } else {
      store.filter(Object.assign({
        property: field.name
      }, me.parseFilterValue(value)));
    }

    me.resumeStoreTracking();
  }


  getHeaderMenuItems(column, items) {
    const me = this;
    items.push({
      text: me.L(me.hidden ? 'enableFilterBar' : 'disableFilterBar'),
      name: 'toggleFilterBar',
      icon: 'b-fw-icon b-icon-filter',
      cls: 'b-separator',
      onItem: () => me.toggleFilterBar()
    });
  }

}

FilterBar.featureClass = 'b-filter-bar';
FilterBar._$name = 'FilterBar';
GridFeatureManager.registerFeature(FilterBar);


class Group extends InstancePlugin {
  static get $name() {
    return 'Group';
  }

  static get defaultConfig() {
    return {

      field: null,


      renderer: null
    };
  }

  construct(grid, config) {
    const me = this;

    if (grid.features.tree) {
      return;
    }

    me._thisIsAUsedExpression(grid.features.groupSummary);

    config = me.processConfig(config);
    Object.assign(me, {
      grid: grid,
      rowManager: grid.rowManager,
      store: grid.store
    });
    super.construct(grid, config);
    me.store.on({
      group: me.onStoreGroup,
      thisObj: me
    });
    me.rowManager.on({
      rendercell: me.renderCell,
      thisObj: me
    });
  }


  processConfig(config) {
    if (typeof config === 'string') {
      return {
        field: config,
        ascending: null
      };
    }

    return config;
  }

  setConfig(config) {
    if (config === null) {
      this.store.clearGroupers();
    } else {
      super.setConfig(this.processConfig(config));
    }
  }

  set renderer(renderer) {
    this.groupRenderer = renderer;
  }

  set field(field) {
    this._field = field;
    this.store.group(field, this.ascending);
  }

  get field() {
    return this._field;
  }

  doDestroy() {
    super.doDestroy();
  }

  doDisable(disable) {
    const {
      store
    } = this;


    if (disable && store.isGrouped) {
      const {
        sorters
      } = store;
      sorters.unshift(...store.groupers);
      store.clearGroupers();
      store.sort(sorters);
    }

    super.doDisable(disable);
  }


  static get pluginConfig() {
    return {
      assign: ['collapseAll', 'expandAll'],
      chain: ['renderHeader', 'getHeaderMenuItems', 'getColumnDragToolbarItems', 'onElementTouchStart', 'onElementClick', 'onElementKeyDown'],
      override: ['onStoreDataChange']
    };
  }


  toggleCollapse(recordOrId, collapse) {
    this.internalToggleCollapse(recordOrId, collapse);
  }


  internalToggleCollapse(recordOrId, collapse, skipRender = false) {
    const me = this,
      store = me.store,
      groupRecord = store.getById(recordOrId),
      meta = groupRecord.meta;
    if (meta.groupRowFor === undefined) return;
    collapse = collapse === undefined ? !meta.collapsed : collapse;

    if (collapse) {
      store.excludeGroupRecords(groupRecord);
    } else {
      store.includeGroupRecords(groupRecord);
    }

    meta.collapsed = collapse;


    me.grid.trigger('toggleGroup', {
      groupRecord,
      collapse
    });

    if (!skipRender) {

      me.rowManager.renderFromRecord(groupRecord);
    }
  }


  collapseAll() {
    const me = this;

    if (me.store.isGrouped && !me.disabled) {
      me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, true, true));
      me.grid.refreshRows(true);
    }
  }


  expandAll() {
    const me = this;

    if (me.store.isGrouped && !me.disabled) {
      me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, false, true));
      me.grid.refreshRows();
    }
  }


  renderCell(renderData) {
    const me = this;

    if (!me.store.isGrouped || me.disabled) {
      return;
    }

    const {
        cellElement,
        rowElement,
        column
      } = renderData,
      grid = me.grid,
      meta = renderData.record.meta,
      firstColumn = grid.columns.visibleColumns[0],
      firstSubGridColumns = grid.subGrids[grid.regions[0]].columns.visibleColumns;

    if (Object.prototype.hasOwnProperty.call(meta, 'groupRowFor')) {

      column.clearCell(cellElement);


      rowElement.classList[meta.collapsed ? 'add' : 'remove']('b-grid-group-collapsed');
      rowElement.classList.add('b-group-row');

      if (firstColumn.type === 'rownumber' && column === firstSubGridColumns[1] || firstColumn.type !== 'rownumber' && column === firstSubGridColumns[0]) {
        cellElement.classList.add('b-group-title');
      }

      me.buildGroupHeader(renderData);
    } else {


      if (cellElement === rowElement.firstElementChild) {


        rowElement.classList.remove('b-group-row');
        rowElement.classList.remove('b-grid-group-collapsed');
        cellElement.classList.remove('b-group-title');
      }
    }
  }

  buildGroupHeader(renderData) {
    const me = this,
      {
        record,
        cellElement,
        column,
        persist
      } = renderData,
      grid = me.grid,
      meta = record.meta,


      count = meta.childCount - (grid.features.groupSummary ? 1 : 0),
      firstVisibleColumn = grid.columns.visibleColumns[0],
      firstSubGridColumns = column && grid.subGrids[grid.regions[0]].columns.visibleColumns,
      isFirstColumn = firstVisibleColumn.type === 'rownumber' && column === firstSubGridColumns[1] || firstVisibleColumn.type !== 'rownumber' && column === firstSubGridColumns[0];
    let html = null,
      applyDefault = true;

    if (persist || column) {
      const groupColumn = grid.columns.get(meta.groupField);

      if (groupColumn && groupColumn.groupRenderer) {
        if (isFirstColumn) {

          html = groupColumn.groupRenderer(Object.assign({}, renderData, {
            groupRowFor: meta.groupRowFor,
            groupRecords: record.groupChildren,
            groupColumn,
            count
          }));
          applyDefault = false;
        }
      } else if (me.groupRenderer) {

        html = me.groupRenderer(Object.assign({}, renderData, {
          groupRowFor: meta.groupRowFor,
          groupRecords: record.groupChildren,
          groupColumn,
          count,
          isFirstColumn
        }));
      }


      if (isFirstColumn && html == null && applyDefault) {
        html = `${meta.groupRowFor === '__novalue__' ? '' : meta.groupRowFor} (${count})`;
      }
    } else if (me.groupRenderer) {

      html = me.groupRenderer(renderData);
    }

    if (typeof html === 'string') {
      cellElement.innerHTML = html;
    }

    if (cellElement.childElementCount > 0) {
      cellElement._hasHtml = true;
    }

    return cellElement.innerHTML;
  }


  renderHeader(headerContainerElement) {
    const {
      store,
      grid
    } = this;

    if (store.isGrouped) {

      for (const groupInfo of store.groupers) {

        const column = grid.columns.get(groupInfo.field),
          header = column && grid.getHeaderElement(column.id);


        if (header) {
          header.classList.add('b-group');
          header.classList.add(groupInfo.ascending ? 'b-asc' : 'b-desc');
        }
      }
    }
  }


  getHeaderMenuItems(column, items) {
    const me = this,
      store = me.store;

    if (column.groupable !== false) {
      items.push({
        text: me.L('groupAscending'),
        icon: 'b-fw-icon b-icon-group-asc',
        name: 'groupAsc',
        cls: 'b-separator',
        weight: 110,
        disabled: me.disabled,
        onItem: ({
                   item: {
                     column
                   }
                 }) => store.group(column.field, true)
      }, {
        text: me.L('groupDescending'),
        icon: 'b-fw-icon b-icon-group-desc',
        name: 'groupDesc',
        weight: 110,
        disabled: me.disabled,
        onItem: ({
                   item: {
                     column
                   }
                 }) => store.group(column.field, false)
      });
    }

    if (store.isGrouped) {
      items.push({
        text: me.L('stopGrouping'),
        icon: 'b-fw-icon b-icon-clear',
        name: 'groupRemove',
        cls: column.groupable ? '' : 'b-separator',
        weight: 110,
        disabled: me.disabled,
        onItem: ({
                   item: {
                     column
                   }
                 }) => store.clearGroupers()
      });
    }
  }


  getColumnDragToolbarItems(column, items) {
    const me = this,
      store = me.store;
    items.push({
      text: me.L('groupAscendingShort'),
      group: me.L('Group'),
      icon: 'b-icon b-icon-group-asc',
      name: 'groupAsc',
      cls: 'b-separator',
      weight: 110,
      disabled: me.disabled,
      onDrop: ({
                 column
               }) => store.group(column.field, true)
    });
    items.push({
      text: me.L('groupDescendingShort'),
      group: me.L('Group'),
      icon: 'b-icon b-icon-group-desc',
      name: 'groupDesc',
      weight: 110,
      disabled: me.disabled,
      onDrop: ({
                 column
               }) => store.group(column.field, false)
    });
    const grouped = store.groupers && store.groupers.some(col => col.field === column.field) && !me.disabled;
    items.push({
      text: me.L('stopGroupingShort'),
      group: me.L('Group'),
      icon: 'b-icon b-icon-clear',
      name: 'groupRemove',
      disabled: !grouped,
      weight: 110,
      onDrop: ({
                 column
               }) => store.removeGrouper(column.field)
    });
    return items;
  }


  onStoreGroup({
                 groupers
               }) {
    const {
        grid
      } = this,
      {
        element
      } = grid,
      curGroupHeaders = element && DomHelper.children(element, '.b-grid-header.b-group');

    if (element) {
      for (const header of curGroupHeaders) {
        DomHelper.removeClasses(header, ['b-group', 'b-asc', 'b-desc']);
      }

      if (groupers) {
        for (const groupInfo of groupers) {
          const header = grid.getHeaderElementByField(groupInfo.field);

          if (header) {
            DomHelper.addClasses(header, ['b-group', groupInfo.ascending ? 'b-asc' : 'b-desc']);
          }
        }
      }
    }
  }


  onElementTouchStart(event) {
    const me = this,
      target = event.target,
      header = DomHelper.up(target, '.b-grid-header'),
      column = header && me.grid.getColumnFromElement(header);

    if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {
      me.store.group(column.field);
    }
  }


  onElementClick(event) {
    const me = this,
      store = me.store,
      target = event.target,
      row = DomHelper.up(target, '.b-group-row'),
      header = DomHelper.up(target, '.b-grid-header'),
      field = header && header.dataset.column;

    if (target.classList.contains('b-resizer') || me.disabled) {
      return;
    }

    if (header && field) {
      const columnGrouper = store.groupers && store.groupers.find(g => g.field === field);

      if (columnGrouper && !event.shiftKey) {
        store.group(field, !columnGrouper.ascending);
        return false;
      } else if (event.shiftKey) {
        const column = me.grid.columns.get(field);

        if (column.groupable !== false) {
          if (event.altKey) {
            store.removeGrouper(field);
          } else {
            store.group(field);
          }
        }
      }

      event.preventDefault();
    }

    if (row) {
      me.internalToggleCollapse(DomDataStore.get(row).id);
      return false;
    }
  }


  onElementKeyDown(event) {
    const me = this;

    if (!me.disabled && me.store.isGrouped && event.target === me.client.focusElement && event.key === ' ' && me.grid.focusedCell) {
      event.preventDefault();
      me.internalToggleCollapse(me.grid.focusedCell.id);
    }
  }


  onStoreDataChange(data) {
    const store = data.source;

    if (store.isGrouped && store.count > 0) {
      return;
    }

    this.overridden.onStoreDataChange(data);
  }

}

Group._$name = 'Group';
GridFeatureManager.registerFeature(Group, true, ['Grid', 'Scheduler']);


var SummaryFormatter = (Target => class SummaryFormatter extends (Target || Base) {

  generateHtml(column, records, cls) {
    const store = this.store,
      summaries = column.summaries || (column.sum ? [{
        sum: column.sum,
        renderer: column.summaryRenderer
      }] : []);
    let html = `<table class="${cls}">`;
    summaries.forEach(config => {
      let type = config.sum,
        sum = null;
      if (type === true) type = 'sum';

      switch (type) {
        case 'sum':
        case 'add':
          sum = store.sum(column.field, records);
          break;

        case 'max':
          sum = store.max(column.field, records);
          break;

        case 'min':
          sum = store.min(column.field, records);
          break;

        case 'average':
        case 'avg':
          sum = store.average(column.field, records);
          break;

        case 'count':
          sum = records.length;
          break;

        case 'countNotEmpty':
          sum = records.reduce((sum, record) => {
            const value = record[column.field];
            return sum + (value !== null && value !== undefined ? 1 : 0);
          }, 0);
          break;
      }

      if (typeof type === 'function') {
        sum = records.reduce(type, 'seed' in config ? config.seed : 0);
      }

      if (sum !== null) {
        const valueCls = 'b-grid-summary-value',

          labelHtml = config.label ? `<td class="b-grid-summary-label">${config.label}</td>` : '';

        let valueHtml = config.renderer ? config.renderer({
            config,
            sum
          }) : sum,
          summaryHtml;

        if (valueHtml == null) {
          valueHtml = '';
        }

        if (!String(valueHtml).includes('<td>')) {
          summaryHtml = labelHtml
            ? `${labelHtml}<td class="${valueCls}">${valueHtml}</td>`
            : `<td colspan="2" class="${valueCls}">${valueHtml}</td>`;
        } else {
          summaryHtml = valueHtml;
        }

        html += `<tr>${summaryHtml}</tr>`;
      }
    });
    return html + '</table>';
  }

});


class GroupSummary extends SummaryFormatter(InstancePlugin) {

  static get $name() {
    return 'GroupSummary';
  }

  construct(grid, config) {
    const me = this;
    Object.assign(me, {
      grid: grid,
      store: grid.store
    });
    super.construct(grid, config);

    if (!grid.features.group) {
      throw new Error('Requires Group feature to work, please enable');
    }

    me.store.on({
      update: me.onStoreUpdate,

      prio: 1,
      thisObj: me
    });
    me.grid.rowManager.on({
      beforerenderrow: me.onBeforeRenderRow,
      rendercell: me.renderCell,
      thisObj: me
    });
  }

  doDisable(disable) {

    this.store.useGroupFooters = !disable;

    if (!this.isConfiguring) {
      this.store.group();
    }

    super.doDisable(disable);
  }


  onBeforeRenderRow({
                      row,
                      record
                    }) {
    if (row.isGroupFooter && !record.meta.hasOwnProperty('groupFooterFor')) {

      row.isGroupFooter = false;
      row.removeCls('b-group-footer');

      row.forceInnerHTML = true;
    }
  }


  renderCell({
               column,
               cellElement,
               rowElement,
               row,
               record,
               size
             }) {
    const me = this;

    if (!me.store.isGrouped) return;

    if (record.meta.hasOwnProperty('groupFooterFor')) {

      rowElement.classList.add('b-group-footer');
      row.isGroupFooter = true;


      const heightSetting = me.updateSummaryHtml(cellElement, column, record.meta.groupRecord.groupChildren);
      const count = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;

      if (count > 1) {
        size.height = me.grid.rowHeight + count * me.grid.rowHeight * 0.1;
      }

      if (heightSetting.height) {
        size.height += heightSetting.height;
      }
    }
  }

  updateSummaryHtml(cellElement, column, records) {
    records = records.slice();
    records.pop();

    const html = this.generateHtml(column, records, 'b-grid-group-summary');

    if (!cellElement.children.length) {
      cellElement.innerHTML = html;
    } else {
      DomHelper.sync(html, cellElement.firstElementChild);
    }

    return column.summaries ? column.summaries.length : column.sum ? 1 : 0;
  }


  onStoreUpdate({
                  source: store,
                  changes
                }) {
    if (!this.disabled && store.isGrouped) {


      if (changes && store.groupers.find(grouper => grouper.field in changes)) {
        return;
      }


      const shouldUpdate = Object.keys(changes).some(field => {
        const colField = this.grid.columns.get(field);

        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });

      if (shouldUpdate) {
        this.grid.forceFullRefresh = true;
      }
    }
  }

}

GroupSummary.featureClass = 'b-group-summary';
GroupSummary._$name = 'GroupSummary';
GridFeatureManager.registerFeature(GroupSummary);


class QuickFind extends InstancePlugin {

  static get $name() {
    return 'QuickFind';
  }

  static get defaultConfig() {
    return {
      mode: 'header',
      find: ''
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onElementKeyDown', 'onElementKeyPress', 'onCellNavigate']
    };
  }


  construct(grid, config) {
    const me = this;
    me.grid = grid;
    me.store = grid.store;
    super.construct(grid, config);
  }

  doDisable(disable) {
    if (disable) {
      this.clear();
    }

    super.doDisable(disable);
  }


  showQuickFind() {
    const me = this,
      header = me.grid.getHeaderElement(me.columnId);

    if (header) {
      if (!me.headerField) {
        const [element, field, badge] = DomHelper.createElement({
          tag: 'div',
          className: 'b-quick-hit-header',
          children: [{
            tag: 'div',
            className: 'b-quick-hit-field'
          }, {
            tag: 'div',
            className: 'b-quick-hit-badge'
          }]
        }, true);

        if (me.mode === 'header') {
          header.appendChild(element);
        } else {
          element.className += ' b-quick-hit-mode-grid';
          me.grid.element.appendChild(element);
        }

        me.headerField = {
          header: element,
          field: field,
          badge: badge,
          colHeader: header
        };
      }

      me.headerField.field.innerHTML = me.find;
      me.headerField.badge.innerHTML = me.found.length;
      header.classList.add('b-quick-find-header');

      if (!me.renderListenerInitialized) {
        me.grid.rowManager.on({
          rendercell: me.renderCell,
          thisObj: me
        });
        me.renderListenerInitialized = true;
      }
    }
  }


  hideQuickFind() {
    const me = this;

    for (let hit of me.prevFound || me.found) {
      let row = me.grid.getRowById(hit.id);
      if (row) row.renderCell(row.getCell(me.columnId), hit.data);
    }

    if (me.headerField) {
      me.headerField.header.parentNode.removeChild(me.headerField.header);
      me.headerField.colHeader.classList.remove('b-quick-find-header');
      me.headerField = null;
    }

    if (me.renderListenerInitialized) {
      me.grid.rowManager.un({
        rendercell: me.renderCell
      }, me);
      me.renderListenerInitialized = false;
    }

    me.grid.trigger('hideQuickFind');
  }


  search(find, columnFieldOrId = this.columnId) {
    let me = this,
      column = me.grid.columns.getById(columnFieldOrId) || me.grid.columns.get(columnFieldOrId),
      found = me.store.findByField(column.field, find),
      i = 1,
      grid = me.grid;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found: found,
      find: find,
      columnId: column.id
    });

    if (find) {
      me.showQuickFind();
    } else {
      me.hideQuickFind();
    }

    if (me.currentColumn && me.currentColumn !== column) me.currentColumn.disableHtmlEncode = false;

    for (let cell of DomHelper.children(grid.element, '.b-quick-hit')) {


      cell.classList.remove('b-quick-hit');
      cell.classList.remove('b-quick-hit-cell');

      let row = DomDataStore.get(cell).row;
      row.renderCell(cell);
    }

    column.disableHtmlEncode = true;
    me.currentColumn = column;
    if (!found) return;

    if (found.length > 0) {
      me.gotoClosestHit(grid.focusedCell, found);
    }

    for (let hit of found) {
      me.foundMap[hit.id] = i++;
      let row = grid.getRowById(hit.data.id);

      if (row) {
        row.renderCell(row.getCell(column.id));
      }

      if (i > 1000) break;
    }

    me.grid.trigger('quickFind', {
      find,
      found
    });
  }


  clear() {
    if (this.found && this.found.length) {
      this.search('');
    }
  }


  get foundCount() {
    return this.found ? this.found.length : 0;
  }


  gotoHit(index) {
    let me = this,
      grid = me.grid,
      nextHit = me.found[index];

    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      });
    }

    return !!nextHit;
  }

  gotoClosestHit(focusedCell, found) {
    let focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,
      foundSorted = found.slice().sort((a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex));
    this.gotoHit(found.indexOf(foundSorted[0]));
  }


  gotoFirstHit() {
    this.gotoHit(0);
  }


  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }


  gotoNextHit() {
    let me = this,
      grid = me.grid,

      currentId = grid._focusedCell ? grid._focusedCell.id : grid.lastFocusedCell.id,
      currentIndex = grid.store.indexOf(currentId) || 0,
      nextHit = me.found.find(hit => hit.index > currentIndex);

    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      });
    } else {
      me.gotoFirstHit();
    }
  }


  gotoPrevHit() {
    let me = this,
      grid = me.grid,
      currentId = grid._focusedCell ? grid._focusedCell.id : grid.lastFocusedCell.id,
      currentIndex = grid.store.indexOf(currentId) || 0,
      found = me.found,
      prevHit;
    if (!found.length) return;

    for (let i = found.length - 1; i--; i >= 0) {
      if (found[i].index < currentIndex) {
        prevHit = found[i];
        break;
      }
    }

    if (prevHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: prevHit.id
      });
    } else {
      me.gotoLastHit();
    }
  }


  renderCell(renderData) {
    const me = this,
      cellElement = renderData.cellElement,
      foundMap = me.foundMap && me.columnId === renderData.column.id && me.foundMap[renderData.record.id];

    if (foundMap) {

      const htmlEncoded = renderData.column.htmlEncode || renderData.column.shouldHtmlEncode;

      cellElement.classList.add('b-quick-hit');

      if (!htmlEncoded) {
        cellElement.classList.add('b-quick-hit-cell');
      } else {


        let inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement,
          html = inner.innerText,
          where = html && html.toLowerCase().indexOf(me.find.toLowerCase());

        if (where > -1) {
          let end = where + me.find.length,
            casedFind = html.slice(where, end),
            spaceChar = '';

          if (html[where - 1] === ' ') {
            spaceChar = '&nbsp;';
          }

          html = html.slice(0, where) + `<span class="b-quick-hit-text">${spaceChar}${casedFind}</span>` + html.slice(end);
          inner.innerHTML = html + `<div class="b-quick-hit-cell-badge">${foundMap}</div>`;
        } else {
          cellElement.classList.add('b-quick-hit-cell');
        }
      }
    }
  }


  onElementKeyDown(event) {
    const me = this,
      filterFeature = this.grid.features.filter;

    if (me.disabled || DomHelper.up(event.target, BrowserHelper.isIE11 ? '.b-widget:not(.b-grid-subgrid):not(.b-grid)' : '.b-widget:not(.b-grid)')) {
      return;
    }

    if (me.find.length > 0) {

      if (event.key === 'Backspace') {
        event.preventDefault();
        me.find = me.find.substr(0, me.find.length - 1);

        me.search(me.find);
      } else if (event.key === 'Escape') {
        event.preventDefault();
        me.find = '';
        me.search(me.find);
      } else if (event.key === 'F3' || event.key.toLowerCase() === 'g' && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();

        if (event.shiftKey) {
          me.gotoPrevHit();
        } else {
          me.gotoNextHit();
        }
      } else if (filterFeature && me.columnId && me.foundCount && event.ctrlKey && event.shiftKey && event.key === 'F') {
        filterFeature.showFilterEditor(me.grid.columns.getById(me.columnId), me.find);
      }
    }
  }


  onElementKeyPress(event) {
    const me = this;

    if (me.disabled || DomHelper.up(event.target, BrowserHelper.isIE11 ? '.b-widget:not(.b-grid-subgrid):not(.b-grid)' : '.b-widget:not(.b-grid)') || event.key === 'Enter') {
      return;
    }

    if (me.grid._focusedCell) {
      const column = me.grid.columns.getById(me.grid._focusedCell.columnId);

      if (column && column.searchable !== false) {
        me.columnId = me.grid._focusedCell.columnId;

        if (event.key && event.key.length === 1) {
          me.find += event.key;
          me.search(me.find);
        }
      }
    }
  }

  onCellNavigate(grid, fromCellSelector, toCellSelector, event) {
    const me = this,
      found = me.prevFound || me.found;

    if (found && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
      me.clear();
    }
  }

}

QuickFind._$name = 'QuickFind';
GridFeatureManager.registerFeature(QuickFind);


class RegionResize extends InstancePlugin {

  static get $name() {
    return 'RegionResize';
  }

  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
  }

  doDestroy() {

    super.doDestroy();
  }


  static get pluginConfig() {
    return {
      chain: ['onElementTouchStart', 'onElementTouchMove', 'onElementTouchEnd', 'onElementMouseDown', 'onElementMouseMove', 'onElementDblClick', 'onElementMouseUp', 'onSubGridCollapse', 'onSubGridExpand', 'render']
    };
  }

  onElementDblClick(event) {
    const me = this,
      grid = me.grid,
      splitterEl = DomHelper.up(event.target, '.b-grid-splitter-collapsed');


    if (splitterEl && !me.expanding) {
      me.expanding = true;
      let region = splitterEl.dataset.region,
        subGrid = grid.getSubGrid(region);


      if (!subGrid.collapsed) {
        region = grid.getLastRegions()[1];
        subGrid = grid.getSubGrid(region);
      }

      subGrid.expand().then(() => me.expanding = false);
    }
  }


  startMove(splitterElement, clientX) {
    const me = this,
      {
        grid
      } = me,
      region = splitterElement.dataset.region,
      gridEl = grid.element,
      nextRegion = grid.regions[grid.regions.indexOf(region) + 1],
      nextSubGrid = grid.getSubGrid(nextRegion),
      splitterSubGrid = grid.getSubGrid(region);
    let subGrid = splitterSubGrid,
      flip = 1;

    if (subGrid.flex != null) {

      if (nextSubGrid.flex == null) {
        subGrid = nextSubGrid;
        flip = -1;
      }
    }

    if (splitterElement.classList.contains('b-grid-splitter-collapsed')) {
      return;
    }

    const availableWidth = subGrid.element.offsetWidth + nextSubGrid.element.offsetWidth;
    me.dragContext = {
      element: splitterElement,
      headerEl: subGrid.header.element,
      subGridEl: subGrid.element,
      subGrid,
      splitterSubGrid,
      originalWidth: subGrid.element.offsetWidth,
      originalX: clientX,
      minWidth: subGrid.minWidth || 0,
      maxWidth: Math.min(availableWidth, subGrid.maxWidth || availableWidth),
      flip
    };
    gridEl.classList.add('b-moving-splitter');
    splitterSubGrid.toggleSplitterCls('b-moving');
  }


  endMove() {
    const dragContext = this.dragContext;

    if (dragContext) {
      this.grid.element.classList.remove('b-moving-splitter');
      dragContext.splitterSubGrid.toggleSplitterCls('b-moving', false);
      this.dragContext = null;
    }
  }

  onCollapseClick(subGrid, splitterEl) {
    const me = this,
      grid = me.grid,
      region = splitterEl.dataset.region,
      regions = grid.getLastRegions();


    if (regions[0] === region) {
      const lastSubGrid = grid.getSubGrid(regions[1]);

      if (lastSubGrid.collapsed) {
        lastSubGrid.expand();
        return;
      }
    }

    subGrid.collapse();
  }

  onExpandClick(subGrid, splitterEl) {
    const me = this,
      grid = me.grid,
      region = splitterEl.dataset.region,
      regions = grid.getLastRegions();


    if (regions[0] === region) {
      if (!subGrid.collapsed) {
        const lastSubGrid = grid.getSubGrid(regions[1]);
        lastSubGrid.collapse();
        return;
      }
    }

    subGrid.expand();
  }


  updateMove(newClientX) {
    const {
      dragContext
    } = this;

    if (dragContext) {
      const difX = newClientX - dragContext.originalX,
        newWidth = Math.min(dragContext.maxWidth, dragContext.originalWidth + difX * dragContext.flip);

      dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);
    }
  }


  onElementTouchStart(event) {
    const target = event.target.closest('.b-grid-splitter');

    if (target) {
      this.startMove(target, event.touches[0].clientX);
    }
  }


  onElementTouchMove(event) {
    if (this.dragContext) {
      this.updateMove(event.touches[0].clientX);
      event.preventDefault();
    }
  }


  onElementTouchEnd(event) {
    if (this.dragContext) {
      this.endMove();
      event.preventDefault();
    }
  }


  onElementMouseDown(event) {
    const me = this,
      target = event.target,
      splitter = target.closest(':not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter'),
      subGrid = splitter && me.grid.getSubGrid(splitter.dataset.region);

    if (event.button === 0) {


      if (target.classList.contains('b-grid-splitter') || target.classList.contains('b-grid-splitter-inner')) {
        me.startMove(splitter, event.clientX);
      } else if (target.classList.contains('b-icon-collapse-gridregion')) {
        me.onCollapseClick(subGrid, splitter);
      } else if (target.classList.contains('b-icon-expand-gridregion')) {
        me.onExpandClick(subGrid, splitter);
      }
    }
  }


  onElementMouseMove(event) {
    if (this.dragContext) {
      this.updateMove(event.clientX);
      event.preventDefault();
    }
  }


  onElementMouseUp(event) {
    if (this.dragContext) {
      this.endMove();
      event.preventDefault();
    }
  }

  onSubGridCollapse(subGrid) {
    const splitterEl = this.grid.resolveSplitter(subGrid),
      regions = this.grid.getLastRegions();

    if (regions[1] === subGrid.region) {
      splitterEl.classList.add('b-grid-splitter-allow-collapse');
    }
  }

  onSubGridExpand(subGrid) {
    const splitterEl = this.grid.resolveSplitter(subGrid);
    splitterEl.classList.remove('b-grid-splitter-allow-collapse');
  }

  render() {
    const {
      regions,
      subGrids
    } = this.grid;

    if (regions.length > 2) {


      subGrids[regions[0]].splitterElement.classList.add('b-left-only');
      subGrids[regions[1]].splitterElement.classList.add('b-right-only');
    }
  }

}

RegionResize.featureClass = 'b-split';
RegionResize._$name = 'RegionResize';
GridFeatureManager.registerFeature(RegionResize);


class RowReorder extends Delayable(InstancePlugin) {


  static get $name() {
    return 'RowReorder';
  }

  static get defaultConfig() {
    return {

      hoverExpandTimeout: 1000,
      finalizeDelay: 300
    };
  }

  construct(grid, config) {
    this.grid = grid;
    super.construct(...arguments);
  }

  doDestroy() {
    this.dragHelper && this.dragHelper.destroy();
    super.doDestroy();
  }


  init() {
    const me = this,
      {
        grid
      } = me;
    me.dragHelper = new DragHelper({
      name: 'rowReorder',
      mode: 'translateXY',
      cloneTarget: true,
      dragThreshold: 10,
      targetSelector: '.b-grid-row',
      lockX: true,
      transitionDuration: grid.transitionDuration,
      scrollManager: grid.scrollManager,
      dragWithin: grid.verticalScroller,
      outerElement: grid.verticalScroller,

      ignoreSamePositionDrop: false,

      createProxy(element) {
        const clone = element.cloneNode(true),
          container = document.createElement('div');
        clone.removeAttribute('id');

        clone.style.transform = '';
        container.appendChild(clone);
        return container;
      },

      listeners: {
        beforedragstart: me.onBeforeDragStart,
        dragstart: me.onDragStart,
        drag: me.onDrag,
        drop: me.onDrop,
        reset: me.onReset,
        prio: 10000,

        thisObj: me
      }
    });
    me.dropIndicator = DomHelper.createElement({
      parent: grid.bodyContainer,
      className: 'b-row-drop-indicator'
    });
    me.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');
  }


  static get pluginConfig() {
    return {
      after: ['render']
    };
  }


  onBeforeDragStart({
                      context
                    }) {
    const grid = this.grid,
      targetSubGrid = grid.regions[0],
      subGridEl = grid.subGrids[targetSubGrid].element;

    if (this.disabled || grid.readOnly || !subGridEl.contains(context.element)) {
      return false;
    }

    const record = context.record = this.grid.getRecordFromElement(context.element);
    return !record.meta.specialRow;
  }

  onDragStart({
                context
              }) {
    const me = this,
      cellEdit = me.grid.features.cellEdit,
      record = me.grid.getRecordFromElement(context.grabbed);

    if (!record) {
      throw new Error('Failed to find record for dragged element');
    }

    if (cellEdit) {
      me.cellEditDisabledState = cellEdit.disabled;
      cellEdit.disabled = true;
    }

    if (me.grid.features.contextMenu) {
      me.grid.features.contextMenu.hideContextMenu(false);
    }

    me.grid.element.classList.add('b-row-reordering');
    const focusedCell = context.element.querySelector('.b-focused');
    focusedCell && focusedCell.classList.remove('b-focused');
    DomHelper.removeClasses(context.element.firstElementChild, ['b-selected', 'b-hover']);
    me.record = record;
  }

  onDrag({
           context,
           event
         }) {
    const me = this,
      {
        store,
        rowManager
      } = me.grid;

    if (!me.dragHelper.outerElement.contains(event.target) || !event.target.closest('.b-grid-subgrid')) {
      context.valid = false;
      return;
    }

    let valid = context.valid,
      row = me.grid.rowManager.getRowAt(event.clientY),
      overRecord,
      dataIndex,
      after,
      insertBefore;

    if (row) {
      const rowTop = row.top + me.grid._bodyRectangle.y - me.grid.scrollable.y,
        middleY = rowTop + row.height / 2;
      dataIndex = row.dataIndex;
      overRecord = row && store.getAt(dataIndex);

      after = event.clientY > middleY;
    } else {
      dataIndex = store.count - 1;
      overRecord = store.last;
      row = me.grid.rowManager.getRow(dataIndex);
      after = true;
    }


    if (overRecord === me.record) {
      valid = false;
    }

    if (store.tree) {
      DomHelper.removeClsGlobally(me.grid.element, 'b-row-reordering-target-parent');
      insertBefore = after ? overRecord.nextSibling : overRecord;

      if (me.record.contains(overRecord)) {
        valid = false;
      }

      context.parent = overRecord.parent;

      if (!context.parent.isRoot) {
        const parentRow = rowManager.getRowById(context.parent);

        if (parentRow) {
          parentRow.addCls('b-row-reordering-target-parent');
        }
      }

      me.clearTimeout(me.hoverTimer);

      if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {
        me.hoverTimer = me.setTimeout(() => me.grid.expand(overRecord), me.hoverExpandTimeout);
      }
    } else {

      insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;
    }

    DomHelper.setTranslateY(me.dropIndicator, row.top + (after ? row.height : 0));
    context.insertBefore = insertBefore;
    context.valid = valid;
  }


  async onDrop(event) {
    const me = this,
      context = event.context;

    if (context.valid) {
      context.asyncCleanup = context.async = true;
      context.element.classList.add('b-dropping');
      me.setTimeout(() => me.finalizeReorder(context).then(() => me.trigger('gridRowDrop', event)), me.finalizeDelay);
    } else {
      me.trigger('gridRowDrop', event);
    }
  }

  async finalizeReorder(context) {
    const me = this,
      grid = me.grid,
      store = grid.store;
    context.valid = context.valid && store.includes(me.record);

    if (context.valid) {
      let result;

      if (store.tree) {
        context.valid = store.includes(me.record);

        if (context.valid) {
          result = await context.parent.tryInsertChild(me.record, context.insertBefore);
          context.valid = result !== false;
        }
      } else {
        store.insert(context.insertBefore ? store.indexOf(context.insertBefore) : store.count, me.record);
      }

      store.clearSorters();
    }

    context.finalize(context.valid);
    grid.element.classList.remove('b-row-reordering');
  }


  onReset() {
    const me = this,
      cellEdit = me.grid.features.cellEdit;
    me.grid.element.classList.remove('b-row-reordering');

    if (cellEdit) {
      cellEdit.disabled = me.cellEditDisabledState;
    }

    DomHelper.removeClsGlobally(me.grid.element, 'b-row-reordering-target-parent');
  }


  render() {

    this.init();
  }

}

RowReorder.featureClass = '';
RowReorder._$name = 'RowReorder';
GridFeatureManager.registerFeature(RowReorder, false);
GridFeatureManager.registerFeature(RowReorder, true, 'Gantt');


class Search extends InstancePlugin {

  static get $name() {
    return 'Search';
  }

  construct(grid, config) {
    const me = this;
    super.construct(grid, config);
    Object.assign(me, {
      store: grid.store,
      grid: grid,
      find: '',
      hitEls: []
    });
  }

  doDestroy() {
    this.clear(true);
    super.doDestroy();
  }

  doDisable(disable) {
    if (disable) {
      this.clear();
    }

    super.doDisable(disable);
  }


  static get pluginConfig() {
    return {
      chain: ['getCellMenuItems', 'onElementKeyDown']
    };
  }


  search(find, gotoHit = true, reapply = false) {
    const me = this;

    if (!find) {
      return me.clear();
    }

    if (!reapply && find === me.find || me.disabled) {
      return;
    }

    const grid = me.grid,

      columns = grid.columns.visibleColumns.filter(col => col.searchable !== false),
      fields = columns.map(col => col.field),
      found = me.store.search(find, fields);
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      find
    });

    for (let cell of DomHelper.children(grid.element, '.b-search-hit')) {


      cell.classList.remove('b-search-hit');
      cell.classList.remove('b-search-hit-cell');

      let row = DomDataStore.get(cell).row;
      row.renderCell(cell);
    }

    if (!found) return;

    if (me.hitColumns) {
      me.hitColumns.forEach(col => col.disableHtmlEncode = false);
    }

    me.hitColumns = [];

    for (let hit of found) {
      me.foundMap[hit.field + '-' + hit.id] = i++;

      const column = me.grid.columns.get(hit.field);

      if (column) {
        column.disableHtmlEncode = true;
        me.hitColumns.push(column);
      }

      if (i > 1000) break;
    }

    if (!me.listenersInitialized) {
      me.grid.rowManager.on({
        rendercell: me.renderCell
      }, me);
      me.store.on({
        refresh: me.onStoreRefresh
      }, me);
      me.listenersInitialized = true;
    }

    grid.refreshRows();
    me.grid.trigger('search', {
      grid,
      find,
      found
    });

    if (gotoHit && !me.isHitFocused) {
      me.gotoNextHit(true);
    }

    return found;
  }


  clear(silent = false) {
    const me = this,
      grid = me.grid;

    if (me.foundMap) {
      delete me.foundMap;
    }

    delete me.find;
    DomHelper.forEachSelector(grid.element, '.b-search-hit', cell => DomHelper.removeClasses(cell, ['b-search-hit', 'b-search-hit-cell']));
    DomHelper.removeEachSelector(grid.element, '.b-search-hit-cell-badge,.b-search-hit-text');

    if (me.listenersInitialized) {
      grid.rowManager.un({
        rendercell: me.renderCell
      }, me);
      me.store.un({
        refresh: me.onStoreRefresh
      }, me);
      me.listenersInitialized = false;
    }

    if (!silent) {
      grid.refreshRows();
      me.grid.trigger('clearSearch', {
        grid
      });
    }
  }


  get foundCount() {
    return this.found && this.found.length || 0;
  }


  get isHitFocused() {
    const me = this,
      grid = me.grid,
      currentIndex = grid.focusedCell ? grid.store.indexOf(grid.focusedCell.id) : -1,
      currentColumn = grid.focusedCell ? grid.columns.getById(grid.focusedCell.columnId) : null;
    return currentIndex !== -1 && me.found.some(hit => hit.index === currentIndex && currentColumn && hit.field === currentColumn.field);
  }


  gotoNextHit(fromStart = false) {
    const me = this;
    if (!me.found || !me.found.length) return;
    const grid = me.grid,
      fromCell = grid.focusedCell || grid.lastFocusedCell,
      currentIndex = fromCell && !fromStart ? grid.store.indexOf(fromCell.id) : -1,
      nextHit = me.found.findIndex(hit => hit.index > currentIndex);

    if (nextHit !== -1) {
      me.gotoHit(nextHit);
    }
  }


  gotoPrevHit() {
    const me = this;
    if (!me.found || !me.found.length) return;
    const grid = me.grid,
      fromCell = grid.focusedCell || grid.lastFocusedCell,
      currentIndex = fromCell ? grid.store.indexOf(fromCell.id) : 0,
      found = me.found;

    for (let i = found.length - 1; i--; i >= 0) {
      let hit = found[i];

      if (hit.index < currentIndex) {
        me.gotoHit(i);
        break;
      }
    }
  }


  gotoHit(index) {
    let me = this,
      grid = me.grid,
      nextHit = me.found[index];

    if (nextHit) {
      grid.focusCell({
        field: nextHit.field,
        id: nextHit.id
      });
    }

    return !!nextHit;
  }


  gotoFirstHit() {
    this.gotoHit(0);
  }


  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }


  renderCell({
               cellElement,
               column,
               record,
               value,
               cellContent
             }) {
    const me = this,
      hitIndex = me.foundMap && me.foundMap[column.field + '-' + record.id];


    if (hitIndex) {

      cellElement.classList.add('b-search-hit');

      const inner = DomHelper.down(cellElement, '.b-grid-cell-value') || cellElement,
        find = String(me.find).toLowerCase();

      if (String(value).toLowerCase() === find) {
        inner.innerHTML = `<span class="b-search-hit-text">${cellContent}</span><div class="b-search-hit-cell-badge">${hitIndex}</div>`;
      } else {
        const find = String(me.find).toLowerCase(),
          where = cellContent && cellContent.toLowerCase().indexOf(find);

        if (where > -1) {
          let end = where + find.length,
            casedFind = cellContent.slice(where, end);
          inner.innerHTML = `${cellContent.slice(0, where)}<span class="b-search-hit-text">${casedFind}</span>${cellContent.slice(end)}<div class="b-search-hit-cell-badge">${hitIndex}</div>`;
        } else {
          cellElement.classList.add('b-search-hit-cell');
        }
      }

      me.hitEls.push(cellElement);
    }
  }


  getCellMenuItems(column, record, items) {
    const me = this;

    if (column.searchable) {
      items.push({
        text: me.L('searchForValue'),
        icon: 'b-fw-icon b-icon-search',
        cls: 'b-separator',
        name: 'search',
        disabled: me.disabled,
        onItem: ({
                   item
                 }) => {
          const {
            column,
            record
          } = item;

          let sel = window.getSelection().toString();
          if (!sel) sel = record[column.field];
          me.search(sel);
        }
      });
    }

    return items;
  }


  onElementKeyDown(event) {
    const me = this;

    if (me.find && me.find !== '') {
      if (event.key === 'F3' || event.key.toLowerCase() === 'g' && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();

        if (event.shiftKey) {
          me.gotoPrevHit();
        } else {
          me.gotoNextHit();
        }
      }
    }
  }

  onStoreRefresh() {
    this.search(this.find, false, true);
  }

}

Search.featureClass = 'b-search';
Search._$name = 'Search';
GridFeatureManager.registerFeature(Search);


class Sort extends InstancePlugin {

  static get $name() {
    return 'Sort';
  }

  static get defaultConfig() {
    return {

      multiSort: true,
      ignoreRe: new RegExp([
        'b-grid-header-resize-handle', 'b-filter-icon'].join('|')),
      sortableCls: 'b-sortable',
      sortedCls: 'b-sort',
      sortedAscCls: 'b-asc',
      sortedDescCls: 'b-desc'
    };
  }


  construct(grid, config) {
    const me = this;

    config = me.processConfig(config);
    me.store = grid.store;
    me.grid = grid;
    me.store.on({
      sort: me.syncHeaderSortState,
      thisObj: me
    });
    super.construct(grid, config);
  }


  processConfig(config) {
    if (typeof config === 'string' || Array.isArray(config)) {
      return {
        field: config,
        ascending: null
      };
    }

    return config;
  }

  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }

  set field(field) {

    const column = this.grid.columns.get(field);

    if (column && typeof column.sortable === 'object') {

      column.sortable.field = column.sortable.property || field;
      field = column.sortable;
    }

    this.store.sort(field, this.ascending);
  }

  doDestroy() {
    super.doDestroy();
  }


  static get pluginConfig() {
    return {
      chain: ['onElementClick', 'getHeaderMenuItems', 'getColumnDragToolbarItems', 'renderHeader']
    };
  }


  syncHeaderSortState() {
    const me = this,
      sorterMap = {};

    if (!me.grid.isConfiguring) {
      let storeSorters = me.store.sorters,
        sorterCount = storeSorters.length,
        classList = new DomClassList(),
        sorter;

      for (let sortIndex = 0; sortIndex < sorterCount; sortIndex++) {
        const sorter = storeSorters[sortIndex];

        if (sorter.field) {
          sorterMap[sorter.field] = {
            ascending: sorter.ascending,
            sortIndex: sortIndex + 1
          };
        }
      }

      for (const leafColumn of me.grid.columns.bottomColumns) {
        const leafHeader = leafColumn.element;

        if (leafHeader) {


          const dataset = leafColumn.textWrapper && leafColumn.textWrapper.dataset;


          dataset && dataset.sortIndex && delete dataset.sortIndex;
          classList.value = leafHeader.classList;

          if (leafColumn.sortable !== false) {
            classList.add(me.sortableCls);
            sorter = sorterMap[leafColumn.field];

            if (sorter) {
              if (sorterCount > 1 && dataset) {
                dataset.sortIndex = sorter.sortIndex;
              }

              classList.add(me.sortedCls);

              if (sorter.ascending) {
                classList.add(me.sortedAscCls);
                classList.remove(me.sortedDescCls);
              } else {
                classList.add(me.sortedDescCls);
                classList.remove(me.sortedAscCls);
              }
            } else {
              classList.remove(me.sortedCls);


              if (!classList['b-group']) {
                classList.remove(me.sortedAscCls);
                classList.remove(me.sortedDescCls);
              }
            }
          } else {
            classList.remove(me.sortableCls);
          }

          DomHelper.syncClassList(leafHeader, classList);
        }
      }
    }
  }


  getHeaderMenuItems(column, items) {
    const me = this,
      {
        disabled
      } = me;

    if (column.sortable !== false) {
      items.push({
        text: me.L('sortAscending'),
        icon: 'b-fw-icon b-icon-sort-asc',
        name: 'sortAsc',
        cls: 'b-separator',
        weight: 105,
        disabled,
        onItem: ({
                   item: {
                     column
                   }
                 }) => me.store.sort(column.field, true)
      });
      items.push({
        text: me.L('sortDescending'),
        icon: 'b-fw-icon b-icon-sort-desc',
        name: 'sortDesc',
        weight: 105,
        disabled,
        onItem: ({
                   item: {
                     column
                   }
                 }) => me.store.sort(column.field, false)
      });

      if (me.multiSort && me.grid.columns.records.filter(col => col.sortable).length > 1) {
        const sorter = this.grid.store.sorters.find(s => s.field === column.field);
        items.push({
          text: me.L('multiSort'),
          icon: 'b-fw-icon b-icon-sort',
          name: 'multiSort',
          weight: 105,
          disabled,
          menu: [{
            text: sorter ? me.L('toggleSortAscending') : me.L('addSortAscending'),
            icon: 'b-fw-icon b-icon-sort-asc',
            name: 'addSortAsc',
            disabled: sorter && sorter.ascending,
            weight: 105,
            onItem: ({
                       item: {
                         column
                       }
                     }) => me.store.addSorter(column.field, true)
          }, {
            text: sorter ? me.L('toggleSortDescending') : me.L('addSortDescending'),
            icon: 'b-fw-icon b-icon-sort-desc',
            name: 'addSortDesc',
            disabled: sorter && !sorter.ascending,
            weight: 105,
            onItem: ({
                       item: {
                         column
                       }
                     }) => me.store.addSorter(column.field, false)
          }, {
            text: me.L('removeSorter'),
            icon: 'b-fw-icon b-icon-remove',
            name: 'remove-sorter',
            weight: 105,
            disabled: !sorter,
            onItem: ({
                       item: {
                         column
                       }
                     }) => me.store.removeSorter(column.field)
          }]
        });
      }
    }

    return items;
  }


  getColumnDragToolbarItems(column, items) {
    const me = this,
      {
        store,
        disabled
      } = me;

    if (column.sortable !== false) {
      items.push({
        text: me.L('sortAscendingShort'),
        group: me.L('Sort'),
        icon: 'b-icon b-icon-sort-asc',
        name: 'sortAsc',
        cls: 'b-separator',
        weight: 105,
        disabled,
        onDrop: ({
                   column
                 }) => store.sort(column.field, true)
      });
      items.push({
        text: me.L('sortDescendingShort'),
        group: me.L('Sort'),
        icon: 'b-icon b-icon-sort-desc',
        name: 'sortDesc',
        weight: 105,
        disabled,
        onDrop: ({
                   column
                 }) => store.sort(column.field, false)
      });
      const sorter = store.sorters.find(s => s.field === column.field);
      Array.prototype.push.apply(items, [{
        text: me.L('addSortAscendingShort'),
        group: me.L('Multisort'),
        icon: 'b-icon b-icon-sort-asc',
        name: 'multisortAddAsc',
        disabled: disabled || sorter && sorter.ascending,
        weight: 105,
        onDrop: ({
                   column
                 }) => store.addSorter(column.field, true)
      }, {
        text: me.L('addSortDescendingShort'),
        group: me.L('Multisort'),
        icon: 'b-icon b-icon-sort-desc',
        name: 'multisortAddDesc',
        disabled: disabled || sorter && !sorter.ascending,
        weight: 105,
        onDrop: ({
                   column
                 }) => store.addSorter(column.field, false)
      }, {
        text: me.L('removeSorterShort'),
        group: me.L('Multisort'),
        icon: 'b-icon b-icon-remove',
        name: 'multisortRemove',
        weight: 105,
        disabled: disabled || !sorter,
        onDrop: ({
                   column
                 }) => store.removeSorter(column.field)
      }]);
    }

    return items;
  }


  onElementClick(event) {
    const me = this,
      store = me.store,
      target = event.target,
      header = DomHelper.up(target, '.b-grid-header.b-sortable'),
      field = header && header.dataset.column;
    if (me.ignoreRe.test(target.className) || me.disabled) return;

    if (header && field) {
      const column = me.grid.columns.getById(header.dataset.columnId),
        columnGrouper = store.isGrouped && store.groupers.find(g => g.field === field);

      if (columnGrouper && !event.shiftKey) {
        return;
      }

      if (column.sortable && !event.shiftKey) {
        if (event.ctrlKey && event.altKey) {
          store.removeSorter(column.field);
        } else {
          let sortBy = column.field;

          if (typeof column.sortable === 'function') {
            sortBy = {
              field: column.field,
              fn: column.sortable
            };
          } else if (typeof column.sortable === 'object') {
            sortBy = column.sortable;

            if (!sortBy.field) {
              sortBy.field = sortBy.property || column.field;
            }
          }

          store.sort(sortBy, null, event.ctrlKey);
        }
      }
    }
  }


  renderHeader() {
    this.syncHeaderSortState();
  }

}

Sort.featureClass = 'b-sort';
Sort._$name = 'Sort';
GridFeatureManager.registerFeature(Sort, true);


class Stripe extends InstancePlugin {
  static get $name() {
    return 'Stripe';
  }

  construct(grid, config) {
    super.construct(grid, config);
    grid.rowManager.on({
      renderrow: 'onRenderRow',
      thisObj: this
    });
  }

  doDisable(disable) {

    this.client.refreshRows();
    super.doDisable(disable);
  }


  onRenderRow({
                row
              }) {
    if (!this.disabled) {
      row.addCls(row.dataIndex % 2 === 0 ? 'b-even' : 'b-odd');
    }
  }

}

Stripe._$name = 'Stripe';
GridFeatureManager.registerFeature(Stripe);


class Bar extends Widget {
  static get $name() {
    return 'Bar';
  }

  static get defaultConfig() {
    return {
      scrollable: {}

    };
  }

  get columns() {
    return this._columns || this.subGrid.columns;
  }

  set columns(columns) {
    this._columns = columns;
  }


  fixCellWidths() {
    const me = this;
    let hasFlex = false,
      flexBasis;

    me.columns.traverse(column => {
      const cellEl = me.getBarCellElement(column.id),
        domWidth = DomHelper.setLength(column.width),
        domMinWidth = DomHelper.setLength(column.minWidth);

      if (cellEl) {


        if (BrowserHelper.isIE11) {
          flexBasis = `calc(${domWidth} - ${me.getLrPadding(cellEl)}px)`;
        } else {
          flexBasis = domWidth;
        }

        hasFlex = hasFlex || Boolean(column.flex);

        if (column.isParent && column.width == null && column.flex == null) {
          const flex = column.children.reduce((result, child) => result += !child.hidden && child.flex || 0, 0);

          cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : '';

          if (flex > 0) {


            column.traverse(col => col.data.minWidth = null);
          }
        } else {
          if (parseInt(column.minWidth) >= 0) {
            cellEl.style.minWidth = domMinWidth;
          }

          cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = '';

          if (column.flex) {


            if (!isNaN(parseInt(column.flex)) && column.children) {
              cellEl.style.flex = `${column.flex} 0 auto`;
            } else {
              cellEl.style.flex = column.flex;
            }
          } else if (parseInt(column.width) >= 0) {
            const parent = column.parent;


            if (me.isHeader && !parent.isRoot && !parent.width) {
              cellEl.style.width = domWidth;
            } else {


              cellEl.style.flexBasis = flexBasis;
            }
          }
        }

        if (column.height >= 0) {
          cellEl.style.height = DomHelper.setLength(column.height);
        }
      }
    });
    me.element.classList[hasFlex ? 'add' : 'remove']('b-has-flex');
  }

  getLrPadding(cellEl) {
    if (!this.cellLrPadding) {
      const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);
      this.cellLrPadding = parseInt(s.getPropertyValue('padding-left')) + parseInt(s.getPropertyValue('padding-right')) + parseInt(s.getPropertyValue('border-left-width')) + parseInt(s.getPropertyValue('border-right-width'));
    }

    return this.cellLrPadding;
  }


  getBarCellElement(columnId) {
    return this.element.querySelector(`[data-column-id="${columnId}"]`);
  }

}

Bar._$name = 'Bar';


class Footer extends Bar {
  static get $name() {
    return 'Footer';
  }

  static get defaultConfig() {
    return {
      isFooter: true
    };
  }

  startConfigure(config) {
    config.scrollable.overflowX = 'hidden-scroll';
    super.startConfigure(config);
  }

  get subGrid() {
    return this._subGrid;
  }

  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }

  refreshContent() {
    this.element.firstElementChild.innerHTML = this.contentTemplate();
    this.fixFooterWidths();
  }

  onPaint({
            firstPaint
          }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }

  template() {
    const region = this.subGrid.region;
    return TemplateHelper.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${region}">
                <div reference="footersElement" class="b-grid-footers b-grid-footers-${region}" data-region="${region}"></div>
            </div>
        `;
  }

  get overflowElement() {
    return this.footersElement;
  }


  getFooter(columnId) {
    return this.getBarCellElement(columnId);
  }


  contentTemplate() {
    const me = this;
    return me.columns.visibleColumns.map(column => {
      return column.hidden ? '' : TemplateHelper.tpl`
                <div
                    class="b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ''} ${column.cls || ''}"
                    data-column="${column.field || ''}" data-column-id="${column.id}" data-all-index="${column.allIndex}"
                    >
                    ${column.footerText || ''}
                </div>`;
    }).join('');
  }


  fixFooterWidths() {
    this.fixCellWidths();
  }

}

Footer._$name = 'Footer';


class Summary extends SummaryFormatter(InstancePlugin) {

  static get $name() {
    return 'Summary';
  }

  construct(grid, config) {
    const me = this;
    Object.assign(me, {
      grid: grid,
      store: grid.store
    });
    super.construct(grid, config);
    me.store.on({
      change: me.onStoreChanged,
      thisObj: me
    });

    me.grid.eachSubGrid(subGrid => {
      if (!subGrid.footer) {
        subGrid.footer = new Footer({
          subGrid,
          parent: subGrid

        });
      }
    });
  }

  doDestroy() {
    super.doDestroy();
  }

  doDisable(disable) {
    super.doDisable(disable);

    if (disable) {
      this.grid.element.classList.add('b-summary-disabled');
    } else {
      this.updateSummaries();
      this.grid.element.classList.remove('b-summary-disabled');
    }
  }


  static get pluginConfig() {
    return {
      chain: ['renderRows']
    };
  }


  renderRows() {
    this.updateSummaries();
  }


  updateSummaries() {
    const me = this,
      {
        grid,
        store
      } = me,
      cells = DomHelper.children(grid.element, '.b-grid-footer'),
      records = store.storage.values.filter(r => !r.meta.specialRow);

    grid.columns.forEach(column => {
      column.summaries && column.summaries.forEach(config => {
        if ('seed' in config) {
          if (!('initialSeed' in config)) {
            config.initialSeed = config.seed;
          }

          if (['number', 'string', 'date'].includes(typeof config.initialSeed)) {
            config.seed = config.initialSeed;
          } else {

            config.seed = Object.assign({}, config.initialSeed);
          }
        }
      });
    });
    cells.forEach(cellElement => {
      const column = grid.columns.get(cellElement.dataset.column),
        html = me.generateHtml(column, records, 'b-grid-footer-summary');

      if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {

        if (!cellElement.children.length) {
          cellElement.innerHTML = html;
        } else {
          DomHelper.sync(html, cellElement.firstElementChild);
        }
      }
    });
  }


  onStoreChanged({
                   action,
                   changes
                 }) {
    let shouldUpdate = true;

    if (this.disabled) {
      return;
    }

    if (action === 'update') {


      shouldUpdate = Object.keys(changes).some(field => {
        const colField = this.grid.columns.get(field);

        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
    }

    if (shouldUpdate) {
      this.updateSummaries();
    }
  }

}

Summary.featureClass = 'b-summary';
Summary._$name = 'Summary';
GridFeatureManager.registerFeature(Summary);


const immediatePromise$3 = new Promise(resolve => resolve());


class Tree extends Delayable(InstancePlugin) {

  static get $name() {
    return 'Tree';
  }

  static get defaultConfig() {
    return {

      expandOnCellClick: false
    };
  }

  static get pluginConfig() {
    return {
      assign: ['collapseAll', 'expandAll', 'collapse', 'expand', 'expandTo', 'toggleCollapse'],
      before: ['navigateRight', 'navigateLeft'],
      chain: ['onElementClick', 'onElementKeyDown']
    };
  }


  construct(grid, config) {
    const me = this;
    super.construct(grid, config);

    const treeColumn = grid.columns.find(col => col instanceof TreeColumn);
    Object.assign(me, {
      grid: grid,
      store: grid.store,
      rowManager: grid.rowManager,
      treeColumn: treeColumn
    });
    me.store.on({
      beforeLoadChildren: 'onBeforeLoadChildren',
      loadChildren: 'onLoadChildren',
      loadChildrenException: 'onLoadChildrenException',
      beforeToggleNode: 'onBeforeToggleNode',
      thisObj: me
    });
  }

  doDisable(disable) {
  }


  async toggleCollapse(idOrRecord, collapse, skipRefresh = false) {
    const me = this,
      {
        store,
        grid
      } = me,
      {
        rowManager
      } = grid,
      record = store.getById(idOrRecord),
      meta = record.instanceMeta(store);

    if (await store.toggleCollapse(record, collapse)) {
      const row = rowManager.getRowFor(record);

      if (row) {
        const cell = row.getCell(me.treeColumn.id);

        cell && row.renderCell(cell, record);
      }


      if (!me.isTogglingNode) {
        grid.element.classList.add('b-toggling-node');
        me.isTogglingNode = true;
        me.requestAnimationFrame(() => {
          grid.element.classList.remove('b-toggling-node');
          me.isTogglingNode = false;
        });
      }

      grid.trigger(meta.collapsed ? 'collapseNode' : 'expandNode', {
        source: grid,
        record
      });
      grid.trigger('toggleNode', {
        source: grid,
        record,
        collapse
      });
    }
  }


  async collapse(idOrRecord) {
    return this.toggleCollapse(idOrRecord, true);
  }


  async expand(idOrRecord) {
    return this.toggleCollapse(idOrRecord, false);
  }

  onBeforeToggleNode({
                       record,
                       collapse
                     }) {
    this.grid.trigger('beforeToggleNode', {
      record,
      collapse
    });
  }

  onBeforeLoadChildren({
                         source: store,
                         params
                       }) {
    const parent = store.getById(params[store.modelClass.idField]),
      row = this.grid.rowManager.getRowFor(parent);

    if (row) {
      row.addCls('b-loading-children');
    }
  }

  onLoadChildren({
                   source: store,
                   params
                 }) {
    const parent = store.getById(params[store.modelClass.idField]),
      row = this.grid.rowManager.getRowFor(parent);

    if (row) {
      row.removeCls('b-loading-children');
    }
  }

  onLoadChildrenException({
                            record
                          }) {
    const row = this.grid.rowManager.getRowFor(record);

    if (row) {
      row.removeCls('b-loading-children');
    }
  }


  expandOrCollapseAll(collapse = true, topNode = this.store.rootNode) {

    const {
        grid,
        store
      } = this,
      promises = [],
      childRecords = [];
    grid.trigger('beforeToggleAllNodes', {
      source: grid,
      collapse
    });

    store.suspendEvents();
    store.traverse(record => {
      const gridMeta = record.instanceMeta(store);

      if (!record.isLeaf) {
        if (collapse && !gridMeta.collapsed) {
          this.toggleCollapse(record, true, true);
          childRecords.push(...record.children);
        } else if (!collapse && gridMeta.collapsed) {
          if (Array.isArray(record.children)) {
            childRecords.push(...record.children);
          }

          promises.push(this.toggleCollapse(record, false, true));
        }
      }
    }, topNode, topNode === store.rootNode);
    store.resumeEvents();
    return (collapse ? immediatePromise$3 : Promise.all(promises)).then(() => {

      grid.refreshRows(collapse);

      if (childRecords.length) {
        if (collapse) {
          store.trigger('remove', {
            records: childRecords,
            isCollapse: true,
            isCollapseAll: true
          });
        } else {
          store.trigger('add', {
            records: childRecords,
            isExpand: true,
            isExpandAll: true
          });
        }
      }

      grid.trigger('toggleAllNodes', {
        source: grid,
        collapse
      });
    });
  }


  async collapseAll() {
    return this.expandOrCollapseAll(true);
  }


  async expandAll() {
    return this.expandOrCollapseAll(false);
  }


  async expandTo(idOrRecord) {
    const me = this,
      record = me.store.getById(idOrRecord),
      recordMeta = record.instanceMeta(me.store);

    if (recordMeta.hiddenByCollapse === false) return;

    let refreshNeeded = false,
      parent = record.parent,
      parents = [];


    while (parent && !parent.isRoot) {
      parents.push(parent);
      parent = parent.parent;
    }

    await parents.reverse().forEach(async parent => {
      if (parent.instanceMeta(me.store).collapsed) {
        refreshNeeded = true;
      }

      await me.toggleCollapse(parent, false, true);
    });

    if (refreshNeeded) {
      me.grid.refreshRows();
    }

    await me.grid.scrollRowIntoView(record);
  }


  onElementClick(event) {
    const me = this,
      target = event.target,
      cellData = me.grid.getEventData(event);

    if (target.closest('.b-tree-expander') || me.expandOnCellClick && cellData && cellData.record.isParent) {
      me.toggleCollapse(cellData.record);
    }
  }


  onElementKeyDown(event) {

    if (event.target === this.client.focusElement && event.key === ' ') {
      event.preventDefault();
      this.toggleCollapse(this.grid.focusedCell.id);
    }
  }

  navigateRight(event) {
    const me = this,
      grid = me.grid,
      cellSelector = grid.focusedCell;

    if (cellSelector) {
      const record = grid.store.getById(cellSelector.id);

      if (grid.columns.getById(cellSelector.columnId).tree && (event.shiftKey || grid.columns.count === 1)) {

        if (record.isParent && record.instanceMeta(grid.store).collapsed) {
          me.expand(record);
        } else {
          grid.navigateDown(event);
        }

        return false;
      }
    }
  }

  navigateLeft(event) {
    const me = this,
      grid = me.grid,
      cellSelector = grid.focusedCell;

    if (cellSelector) {
      const record = grid.store.getById(cellSelector.id);

      if (grid.columns.getById(cellSelector.columnId).tree && (event.shiftKey || grid.columns.count === 1)) {

        if (record.isParent && !record.instanceMeta(grid.store).collapsed) {
          me.collapse(record);
        } else if (record.parent) {
          grid.focusCell({
            id: record.parent.id,
            columnId: cellSelector.columnId
          });
        }

        return false;
      }
    }
  }

}

Tree.featureClass = 'b-tree';
Tree._$name = 'Tree';
GridFeatureManager.registerFeature(Tree, false, 'Grid');
GridFeatureManager.registerFeature(Tree, true, 'TreeGrid');

const RowsRange = {
  all: 'all',
  visible: 'visible'
};
const PaperFormat = {
  A6: {
    width: 4.13,
    height: 5.81
  },
  A5: {
    width: 5.81,
    height: 8.25
  },
  A4: {
    width: 8.25,
    height: 11.69
  },
  A3: {
    width: 11.69,
    height: 16.49
  },
  Legal: {
    width: 8.5,
    height: 14
  },
  Letter: {
    width: 8.5,
    height: 11
  }
};
const Orientation = {
  portrait: 'portrait',
  landscape: 'landscape'
};
const FileFormat = {
  pdf: 'pdf',
  png: 'png'
};


var LocalizableComboItems = (Target => class LocalizableComboItems extends (Target || Combo) {
  static get $name() {
    return 'LocalizableComboItems';
  }

  static get defaultConfig() {
    return {
      items: true
    };
  }

  set items(items) {
    if (items === true) {
      items = this.buildLocalizedItems();
    }

    super.items = items;
  }

  get items() {
    return super.items;
  }

  construct(...args) {

    this.inConstruct = true;
    super.construct(...args);
    this.inConstruct = false;
  }

  buildLocalizedItems() {
    return [];
  }

  updateLocalizedItems() {
    const me = this;

    if (me.store && !me.inConstruct) {
      const {
        value
      } = me;


      me.store.data = me.buildLocalizedItems();
      me.value = null;
      me.value = value;
      me.syncInputFieldValue(true);
    }
  }

  updateLocalization() {
    this.updateLocalizedItems();
    super.updateLocalization();
  }

});

class LocalizableCombo extends LocalizableComboItems(Combo) {
}

LocalizableCombo._$name = 'LocalizableCombo';
BryntumWidgetAdapterRegister.register('localizablecombo', LocalizableCombo);

class ExportRowsCombo extends LocalizableCombo {
  static get $name() {
    return 'ExportRowsCombo';
  }

  static get defaultConfig() {
    return {
      editable: false
    };
  }

  buildLocalizedItems() {
    const me = this;
    return [{
      id: RowsRange.all,
      text: me.L(RowsRange.all)
    }, {
      id: RowsRange.visible,
      text: me.L(RowsRange.visible)
    }];
  }

}

ExportRowsCombo._$name = 'ExportRowsCombo';
BryntumWidgetAdapterRegister.register(ExportRowsCombo.$name, ExportRowsCombo);

class ExportOrientationCombo extends LocalizableCombo {
  static get $name() {
    return 'ExportOrientationCombo';
  }

  static get defaultConfig() {
    return {
      editable: false
    };
  }

  buildLocalizedItems() {
    const me = this;
    return [{
      id: Orientation.portrait,
      text: me.L(Orientation.portrait)
    }, {
      id: Orientation.landscape,
      text: me.L(Orientation.landscape)
    }];
  }

}

ExportOrientationCombo._$name = 'ExportOrientationCombo';
BryntumWidgetAdapterRegister.register(ExportOrientationCombo.$name, ExportOrientationCombo);


class ExportDialog extends Popup {
  static get $name() {
    return 'ExportDialog';
  }

  static get defaultConfig() {
    return {
      autoShow: false,
      autoClose: false,
      closable: true,
      centered: true,


      client: null,


      hidePNGMultipageOption: true,
      title: 'L{exportSettings}',
      bbar: [{
        type: 'button',
        ref: 'exportButton',
        color: 'b-green',
        localeClass: this,
        text: 'L{export}'
      }, {
        type: 'button',
        ref: 'cancelButton',
        color: 'b-gray',
        localeClass: this,
        text: 'L{cancel}'
      }]
    };
  }

  buildDialogItems(config) {
    const me = this,
      {
        exporters,
        client
      } = config,
      labelWidth = me.L('labelWidth');
    me.columnsStore = client.columns.chain(record => record.isLeaf);

    function buildComboItems(obj, fn = x => x) {
      return Object.keys(obj).map(key => ({
        id: key,
        text: fn(key)
      }));
    }

    return [{
      labelWidth,
      type: 'combo',
      ref: 'columnsField',
      label: 'L{columns}',
      localeClass: this,
      store: me.columnsStore,
      value: me.columnsStore.allRecords,
      valueField: 'id',
      displayField: 'text',
      multiSelect: true
    }, {
      labelWidth,
      type: 'exportrowscombo',
      ref: 'rowsRangeField',
      label: 'L{rows}',
      localeClass: this,
      value: RowsRange.all
    }, {
      labelWidth,
      type: 'localizablecombo',
      ref: 'exporterTypeField',
      label: 'L{exporterType}',
      localeClass: this,
      editable: false,
      value: exporters[0].type,
      buildLocalizedItems: () => exporters.map(exporter => ({
        id: exporter.type,
        text: exporter.title
      })),

      onChange({
                 value
               }) {
        this.owner.widgetMap.alignRowsField.hidden = value !== 'multipage';
      }

    }, {
      labelWidth,
      type: 'checkbox',
      ref: 'alignRowsField',
      label: 'L{alignRows}',
      localeClass: this,
      checked: true,
      hidden: exporters[0].type !== 'multipage'
    }, {
      labelWidth,
      type: 'combo',
      ref: 'fileFormatField',
      label: 'L{fileFormat}',
      localeClass: this,
      editable: false,
      value: FileFormat.pdf,
      items: buildComboItems(FileFormat, value => value.toUpperCase()),

      onChange({
                 value,
                 oldValue
               }) {
        if (me.hidePNGMultipageOption) {
          const exporterField = me.widgetMap.exporterTypeField,
            exporter = exporterField.store.find(r => r.id === 'singlepage');

          if (value === FileFormat.png && exporter) {
            this._previousDisabled = exporterField.disabled;
            exporterField.disabled = true;
            this._previousValue = exporterField.value;
            exporterField.value = 'singlepage';
          } else if (oldValue === FileFormat.png && this._previousValue) {
            exporterField.disabled = this._previousDisabled;
            exporterField.value = this._previousValue;
          }
        }
      }

    }, {
      labelWidth,
      type: 'combo',
      ref: 'paperFormatField',
      label: 'L{paperFormat}',
      localeClass: this,
      editable: false,
      value: 'A4',
      items: buildComboItems(PaperFormat)
    }, {
      labelWidth,
      type: 'exportorientationcombo',
      ref: 'orientationField',
      label: 'L{orientation}',
      localeClass: this,
      value: Orientation.portrait
    }];
  }

  construct(config = {}) {
    const me = this,
      {
        client
      } = config;

    if (!client) {
      throw new Error('`client` config is required');
    }

    const items = me.buildDialogItems(config);

    if (config.items) {
      if (Array.isArray(config.items)) {
        config.items.push(...items);
      } else {
        items.forEach(item => {
          config.items[item.ref] = item;
          delete item.ref;
        });
      }
    } else {
      config.items = items;
    }

    config.width = config.width || me.L('width');
    super.construct(config);
    me.widgetMap.exportButton.on('click', me.onExportClick, me);
    me.widgetMap.cancelButton.on('click', me.onCancelClick, me);
    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      prio: -1,
      thisObj: me
    });
  }

  onLocaleChange() {
    const labelWidth = this.L('labelWidth');
    this.width = this.L('width');
    this.eachWidget(widget => {
      if (widget instanceof Field) {
        widget.labelWidth = labelWidth;
      }
    });
  }

  onExportClick() {
    const values = this.values;


    this.trigger('export', {
      values
    });
  }

  onCancelClick() {

    this.trigger('cancel');
    this.hide();
  }

  get values() {
    const fieldRe = /field/i,
      result = {};
    this.eachWidget(widget => {
      if (fieldRe.test(widget.ref)) {
        result[widget.ref.replace(fieldRe, '')] = widget instanceof Checkbox ? widget.checked : widget.value;
      }
    });
    return result;
  }

}

ExportDialog._$name = 'ExportDialog';

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}

function _awaitAsyncGenerator(value) {
  return new _AwaitValue(value);
}


class Exporter extends Delayable(Events(Localizable(Base))) {
  static get defaultConfig() {
    return {

      translateURLsToAbsolute: true,


      keepPathName: true
    };
  }


  pageTpl(data) {
    const {
      title,
      header,
      footer,
      styles,
      htmlClasses,
      bodyStyle,
      bodyClasses = [],
      paperHeight,
      paperWidth,
      html
    } = data;
    bodyClasses.push(`b-${this.constructor.type}`);
    return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses}" style="width: ${paperWidth}in; height: ${paperHeight}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join('')}
                </head>
                <body class="b-export ${bodyClasses.join(' ')}" style="width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}">
                    <div class="b-export-content">
                        ${header && `<div class="b-export-header" style="width: 100%">${header}</div>`}
                        <div class="b-export-body"><div class="b-export-viewport">${html}</div></div>
                        ${footer && `<div class="b-export-footer" style="width: 100%">${footer}</div>`}
                    </div>
                </body>
            </html>`;
  }


  get stylesheets() {
    const me = this;

    if (me._stylesheets) {
      return me._stylesheets;
    }

    const translate = me.translateURLsToAbsolute,
      origin = window.origin,
      styleSheetNodes = Array.from(document.querySelectorAll('link[rel="stylesheet"], style')),
      styles = [];
    styleSheetNodes.forEach(node => {
      node = node.cloneNode(true);

      if (translate && node.href) {
        let result;

        if (translate === true) {
          result = node.href;
        } else {
          if (this.keepPathName) {
            result = node.href.replace(origin, translate);
          } else {
            result = new URL(node.getAttribute('href'), translate);
          }
        }

        node.setAttribute('href', result);
      }

      let styleText;


      if (BrowserHelper.isIE11 && node.styleSheet && /style/i.test(node.tagName)) {
        styleText = `<style type="text/css">${node.styleSheet.cssText}</style>`;
      } else {
        styleText = node.outerHTML;
      }

      if (translate && /style/i.test(node.tagName)) {
        const converter = me.getStyleTagURLConverter(translate);
        styleText = styleText.replace(/url\(['"]?(.+?)['"]?\)/g, converter);
      }

      styles.push(styleText);
    });
    styles.push(`<style>
                body, html {
                    overflow: auto;
                }

                body {
                    position: relative;
                    margin: 0;
                }
            </style>`);
    return me._stylesheets = styles;
  }

  set stylesheets(value) {
    this._stylesheets = value;
  }

  getStyleTagURLConverter(translate) {
    return function (match, url) {
      let result;

      try {
        let base;

        if (/^#/.test(url)) {
          result = match;
        } else {
          if (translate === true) {
            base = window.location.href;
          } else {
            if (this.keepPathName) {
              base = window.location.href.replace(window.location.origin, translate);
            } else {
              base = translate;
            }
          }

          result = `url('${new URL(url, base).href}')`;
        }
      } catch (e) {
        result = match;
      }

      return result;
    }.bind(this);
  }

  saveState({
              client
            }) {
    this.state = client.state;
  }

  async restoreState({
                       client
                     }) {
    let waitForScrollEnd = false;

    if (client.scrollable.y !== this.state.scroll.scrollTop) {
      waitForScrollEnd = true;
    }

    client.state = this.state;

    if (waitForScrollEnd) {
      await new Promise(resolve => {
        client.scrollable.on({
          scrollEnd() {
            resolve();
          },

          once: true
        });
      });
    }
  }

  beforeExport() {

    this.element = document.createElement('div');
  }

  cloneElement(element, target = this.element, clear = true) {
    if (clear) {
      target.innerHTML = '';
    }

    if (BrowserHelper.isChrome) {
      target.appendChild(element.cloneNode(true));
    } else {
      target.innerHTML = element.outerHTML;
    }

    DomHelper.removeEachSelector(target, '.b-grid-row');
    target.querySelector('.b-gridbase > .b-mask').remove();
  }


  measureElement(html = '') {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }

    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: 'hidden',
        position: 'absolute'
      },

      html: `<div style="height: 1px"></div>${html}<div style="height: 1px"></div>`
    });
    const result = target.offsetHeight - 2;
    target.remove();
    return result;
  }

  prepareHTML(html) {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }

    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: 'hidden',
        position: 'absolute'
      },
      html
    });
    const elements = target.querySelectorAll('img');

    for (let i = 0, l = elements.length; i < l; i++) {
      elements[i].setAttribute('src', elements[i].src);
    }

    const result = target.innerHTML;
    target.remove();
    return result;
  }

  createPlaceholder(el, clear = true) {
    if (clear) {
      el.innerHTML = '';
    }

    return DomHelper.createElement({
      parent: el,
      id: IdHelper.generateId('export')
    });
  }

  getVirtualScrollerHeight(client) {
    let result = 0;


    client.eachSubGrid(subGrid => {
      if (subGrid.overflowingHorizontally) {
        result = DomHelper.scrollBarWidth;
      }
    });

    return result === 0 ? result : result + 1;
  }

  inchToPx(value) {


    return value * 96;
  }

  getScaleValue(base, value) {
    return Math.floor(base * 10000 / value) / 10000;
  }

  async export(config) {
    const me = this;
    let pages;
    me.beforeExport();
    me.saveState(config);
    await me.prepareComponent(config);

    try {
      pages = await me.getPages(config);
    } finally {
      await me.restoreComponent(config);
      me.stylesheets = null;


      await new Promise(resolve => me.requestAnimationFrame(resolve));
      await me.restoreState(config);
    }

    return pages;
  }

  async getPages(config) {
    const generator = this.pagesExtractor(config),
      pages = [];
    let step;

    while ((step = await generator.next()) && !step.done) {
      pages.push(step.value);
    }

    return pages;
  }

  async prepareComponent(config) {
    const me = this,
      {
        client,
        columns,
        rowsRange
      } = config,
      exportMeta = me.exportMeta = {
        totalWidth: 0,
        totalHeight: 0 - me.getVirtualScrollerHeight(client),
        subGrids: {}
      };
    client.columns.forEach(column => {
      if (columns.includes(column.id)) {
        column.show();
      } else {
        column.hide();
      }
    });

    if (client.rowManager.rowCount > 0) {
      if (rowsRange === RowsRange.all) {
        exportMeta.firstVisibleDataIndex = client.rowManager.rows[0].dataIndex;
        await client.scrollable.scrollTo(0, 0);
      } else {
        const firstVisibleDataIndex = exportMeta.firstVisibleDataIndex = client.rowManager.rows.find(row => row.bottom > client.scrollable.y).dataIndex;
        await client.scrollRowIntoView(client.store.getAt(firstVisibleDataIndex), {
          block: 'start'
        });
        config.alignRows = true;
      }
    }

    this.cloneElement(client.element);
    const {
      element
    } = me;
    client.eachSubGrid(subGrid => {
      const placeHolder = me.createPlaceholder(element.querySelector(`[id="${subGrid.id}"]`), false),
        width = subGrid.columns.visibleColumns.reduce((result, column) => {
          if (typeof column.width === 'number') {
            result += column.width;
          } else {
            result += client.getHeaderElement(column.id).offsetWidth;
          }

          return result;
        }, 0);
      exportMeta.totalWidth += width;
      const splitterEl = subGrid.splitterElement;

      if (splitterEl) {
        exportMeta.totalWidth += splitterEl.offsetWidth;
      }

      exportMeta.subGrids[subGrid.region] = {
        id: subGrid.id,
        headerId: subGrid.header && subGrid.header.id || null,
        footerId: subGrid.footer && subGrid.footer.id || null,
        rows: [],
        placeHolder,
        width
      };
    });
  }

  prepareExportElement() {
    const me = this,
      {
        element,
        exportMeta
      } = me;

    Object.values(exportMeta.subGrids).forEach(({
                                                  width,
                                                  id,
                                                  headerId,
                                                  footerId
                                                }) => {
      [id, headerId, footerId].forEach(id => {
        if (id) {
          element.querySelector(`[id="${id}"]`).style.width = `${width}px`;
        }
      });
    });
    return element.innerHTML;
  }

  async restoreComponent() {
  }

  async scrollRowIntoView(client, index) {
    await client.scrollRowIntoView(client.store.getAt(index), {
      block: 'start'
    });

    await new Promise(resolve => this.requestAnimationFrame(resolve));
  }

}


Exporter.prototype.pagesExtractor = function () {
  var _pagesExtractor = _wrapAsyncGenerator(function* () {
    yield '';
  });

  function pagesExtractor() {
    return _pagesExtractor.apply(this, arguments);
  }

  return pagesExtractor;
}();

Exporter._$name = 'Exporter';

class MultiPageExporter extends Exporter {
  static get type() {
    return 'multipage';
  }

  static get title() {

    return this.L('multipage');
  }

  async stateNextPage({
                        client
                      }) {
    const {
      exportMeta
    } = this;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    delete exportMeta.lastExportedRowBottom;

    if (exportMeta.verticalPosition >= exportMeta.verticalPages) {
      exportMeta.verticalPosition = exportMeta.currentPageTopMargin = 0;
      ++exportMeta.horizontalPosition;
      await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, {
        block: 'start'
      });
    }
  }


  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this,
      {
        exportMeta
      } = me,
      {
        client,
        headerTpl,
        footerTpl,
        alignRows
      } = config,
      paperFormat = PaperFormat[config.paperFormat],
      isPortrait = config.orientation === Orientation.portrait,
      paperWidth = isPortrait ? paperFormat.width : paperFormat.height,
      paperHeight = isPortrait ? paperFormat.height : paperFormat.width,
      pageWidth = me.inchToPx(paperWidth),
      pageHeight = me.inchToPx(paperHeight),
      horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);

    let totalHeight = exportMeta.totalHeight + client.height - client.bodyHeight + client.scrollable.scrollHeight,
      contentHeight = pageHeight;

    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }

    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }

    let verticalPages,
      totalRows = client.store.count;

    if (config.rowsRange === RowsRange.visible) {


      totalRows = Math.min(client.store.count, client.rowManager.visibleRowCount);
      const lastRowBottom = client.rowManager.rows[totalRows - 1].bottom;
      totalHeight = totalHeight - client.scrollable.scrollHeight + lastRowBottom;
    }


    if (alignRows) {


      const rowHeight = client.rowManager.rowOffsetHeight,
        rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight),
        rowsPerPage = Math.floor(contentHeight / rowHeight),
        remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(totalHeight / contentHeight);
    }

    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      pageWidth,
      pageHeight,
      horizontalPages,
      verticalPages,
      totalHeight,
      contentHeight,
      totalRows,
      totalPages: horizontalPages * verticalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0
    });
    this.adjustRowBuffer(client);
  }

  async restoreComponent(config) {
    await super.restoreComponent(config);
    this.restoreRowBuffer(config.client);
  }


  adjustRowBuffer(client) {
    const {
        contentHeight
      } = this.exportMeta,
      {
        rowManager
      } = client;
    this.oldRowManagerConfig = {
      prependRowBuffer: rowManager.prependRowBuffer,
      appendRowBuffer: rowManager.appendRowBuffer
    };

    const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);
    rowManager.prependRowBuffer = adjustedRowBuffer;
    rowManager.appendRowBuffer = adjustedRowBuffer;
    client.renderRows();
  }

  restoreRowBuffer(client) {
    client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;
    client.rowManager.appendRowBuffer = this.oldRowManagerConfig.appendRowBuffer;

  }

  async buildPage(config) {
    const me = this,
      {
        exportMeta
      } = me,
      {
        client,
        headerTpl,
        footerTpl,
        alignRows
      } = config,
      {
        totalWidth,
        totalPages,
        currentPage,
        subGrids,
        currentPageTopMargin,
        verticalPosition,
        totalRows
      } = exportMeta,
      {
        rowManager
      } = client,
      {
        rows
      } = rowManager;

    Object.values(subGrids).forEach(subGrid => subGrid.rows = []);


    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);
    }

    let headerHeight = 0,
      footerHeight = 0,
      index = config.rowsRange === RowsRange.visible ? rows.findIndex(r => r.bottom > client.scrollable.y) : rows.findIndex(r => r.bottom + currentPageTopMargin + client.headerHeight > 0),
      remainingHeight,
      header,
      footer;
    const firstRowIndex = index,


      overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;

    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
      headerHeight = me.measureElement(header);
    }

    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
      footerHeight = me.measureElement(footer);
    }


    remainingHeight = exportMeta.pageHeight - headerHeight - footerHeight - overflowingHeight;

    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }

    let lastDataIndex,
      offset = 0;

    while (remainingHeight > 0) {
      const row = rows[index];

      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;


        me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        lastDataIndex = row.dataIndex;

        if (++index === rows.length && remainingHeight > 0) {
          if (lastDataIndex + 1 === client.store.count) {
            remainingHeight = 0;
          }
        } else if (config.rowsRange === RowsRange.visible && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }

    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);

    if (config.rowsRange === RowsRange.visible) {
      exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {

      const detacher = rowManager.on('offsetrows', ({
                                                      offset: value
                                                    }) => offset += value);
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher();
    }

    const html = me.buildPageHtml();
    return {
      html,
      header,
      footer,
      offset
    };
  }

  async onRowsCollected() {
  }

  collectRow(row) {
    const subGrids = this.exportMeta.subGrids;
    Object.entries(row.elements).forEach(([key, value]) => {
      subGrids[key].rows.push(value.outerHTML);
    });
  }

  buildPageHtml() {
    const me = this,
      {
        subGrids
      } = me.exportMeta;

    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
                                       placeHolder,
                                       rows
                                     }) => {
      const placeHolderText = placeHolder.outerHTML;
      html = html.replace(placeHolderText, rows.join(''));
    });
    return html;
  }

  prepareExportElement() {
    const me = this,
      {
        element,
        exportMeta
      } = me;

    if (exportMeta.scrollableTopMargin) {
      element.querySelector('.b-grid-vertical-scroller').style.marginTop = `-${exportMeta.scrollableTopMargin}px`;
    }

    return super.prepareExportElement();
  }

}


MultiPageExporter.prototype.pagesExtractor = function () {
  var _pagesExtractor = _wrapAsyncGenerator(function* (config) {
    const me = this,
      {
        exportMeta,
        stylesheets
      } = me,
      {
        totalWidth,
        totalPages,
        paperWidth,
        paperHeight,
        contentHeight
      } = exportMeta;
    let currentPage;

    while ((currentPage = exportMeta.currentPage) < totalPages) {
      me.trigger('exportStep', {
        text: me.L('exportingPage', {
          currentPage,
          totalPages
        }),
        progress: Math.round((currentPage + 1) / totalPages * 90)
      });
      const {
        html,
        header,
        footer,
        offset
      } = yield _awaitAsyncGenerator(me.buildPage(config));


      const styles = [...stylesheets, `
                <style>
                    #${config.client.id} {
                        height: ${exportMeta.totalHeight}px !important;
                        width: ${totalWidth}px !important;
                    }

                    .b-export-body .b-export-viewport {
                        margin-left : ${-paperWidth * exportMeta.horizontalPosition}in;
                        margin-top  : ${exportMeta.currentPageTopMargin}px;
                    }
                </style>
            `];

      exportMeta.currentPageTopMargin -= contentHeight + offset;
      yield _awaitAsyncGenerator(me.stateNextPage(config));
      yield {
        html: me.pageTpl({
          html,
          header,
          footer,
          styles,
          paperWidth,
          paperHeight
        })
      };
    }
  });

  function pagesExtractor(_x) {
    return _pagesExtractor.apply(this, arguments);
  }

  return pagesExtractor;
}();

MultiPageExporter._$name = 'MultiPageExporter';

class SinglePageExporter extends Exporter {
  static get type() {
    return 'singlepage';
  }

  static get title() {

    return this.L('singlepage');
  }

  static get defaultConfig() {
    return {

      centerContentHorizontally: false
    };
  }

  async prepareComponent(config) {
    await super.prepareComponent(config);
    Object.assign(this.exportMeta, {
      verticalPages: 1,
      horizontalPages: 1,
      totalPages: 1,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0
    });
  }

  async onRowsCollected() {
  }

  positionRows(rows) {
    let currentTop = 0;


    return rows.map(([html, height]) => {
      const result = html.replace(/translate\(\d+px, \d+px\)/, `translate(0px, ${currentTop}px)`);
      currentTop += height;
      return result;
    });
  }

  collectRow(row) {
    const subGrids = this.exportMeta.subGrids;
    Object.entries(row.elements).forEach(([key, value]) => {
      subGrids[key].rows.push([value.outerHTML, row.offsetHeight]);
    });
  }

  buildPageHtml() {
    const me = this,
      {
        subGrids
      } = me.exportMeta;

    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
                                       placeHolder,
                                       rows
                                     }) => {
      const placeHolderText = placeHolder.outerHTML;
      html = html.replace(placeHolderText, me.positionRows(rows).join(''));
    });
    return html;
  }

}


SinglePageExporter.prototype.pagesExtractor = function () {
  var _pagesExtractor = _wrapAsyncGenerator(function* (config) {


    const me = this,
      {
        client
      } = config,
      {
        rowManager,
        store
      } = client,
      styles = me.stylesheets,
      portrait = config.orientation === Orientation.portrait,
      paperFormat = PaperFormat[config.paperFormat],
      paperWidth = portrait ? paperFormat.width : paperFormat.height,
      paperHeight = portrait ? paperFormat.height : paperFormat.width,
      totalRows = config.rowsRange === RowsRange.visible && store.count

        ? Math.min(store.count, rowManager.visibleRowCount) : store.count;
    let {
        totalHeight,
        totalWidth
      } = me.exportMeta,
      processedRows = 0,
      lastDataIndex = -1,
      header,
      footer;

    if (rowManager.rows.length > 0) {
      if (config.rowsRange === RowsRange.visible) {
        lastDataIndex = rowManager.rows.find(row => row.bottom > client.scrollable.y).dataIndex - 1;
      }

      while (processedRows < totalRows) {
        const rows = rowManager.rows,
          lastRow = rows[rows.length - 1],
          lastProcessedRowIndex = processedRows;
        rows.forEach(row => {


          if (row.dataIndex > lastDataIndex && processedRows < totalRows) {
            ++processedRows;
            totalHeight += row.offsetHeight;
            me.collectRow(row);
          }
        });

        const firstNewRowIndex = rows.findIndex(r => r.dataIndex === lastDataIndex + 1),
          lastNewRowIndex = firstNewRowIndex + (processedRows - lastProcessedRowIndex);
        yield _awaitAsyncGenerator(me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config));

        if (processedRows < totalRows) {
          lastDataIndex = lastRow.dataIndex;
          yield _awaitAsyncGenerator(me.scrollRowIntoView(client, lastDataIndex + 1));
        }
      }
    }

    const html = me.buildPageHtml();

    totalHeight += client.height - client.bodyHeight;
    const totalClientHeight = totalHeight;

    if (config.headerTpl) {
      header = me.prepareHTML(config.headerTpl({
        totalWidth
      }));
      const height = me.measureElement(header);
      totalHeight += height;
    }

    if (config.footerTpl) {
      footer = me.prepareHTML(config.footerTpl({
        totalWidth
      }));
      const height = me.measureElement(footer);
      totalHeight += height;
    }

    const widthScale = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)),
      heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)),
      scale = Math.min(widthScale, heightScale);

    styles.push(`<style>
                #${client.id} {
                    height: ${totalClientHeight}px !important;
                    width: ${totalWidth}px !important;
                }

                .b-export-content {
                    ${me.centerContentHorizontally ? 'left: 50%;' : ''}
                    transform: scale(${scale}) ${me.centerContentHorizontally ? 'translateX(-50%)' : ''};
                    transform-origin: top left;
                    height: ${scale === 1 ? 'inherit' : 'auto !important'};
                }
            </style>`);

    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight
      })
    };
  });

  function pagesExtractor(_x) {
    return _pagesExtractor.apply(this, arguments);
  }

  return pagesExtractor;
}();

SinglePageExporter._$name = 'SinglePageExporter';


class PdfExport extends Localizable(InstancePlugin) {
  static get $name() {
    return 'PdfExport';
  }

  static get defaultConfig() {
    return {

      exportServer: undefined,


      fileName: null,


      fileFormat: 'pdf',


      clientURL: null,


      paperFormat: 'A4',


      orientation: 'portrait',


      rowsRange: 'all',


      alignRows: false,


      pagesPerRequest: 0,


      exporterConfig: null,


      exporterType: 'singlepage',


      exporters: [SinglePageExporter, MultiPageExporter],


      translateURLsToAbsolute: true,


      keepPathName: true,


      openAfterExport: true,


      openInNewTab: false,


      headerTpl: null,


      footerTpl: null,


      fetchOptions: null
    };
  }


  get currentExportPromise() {
    return this._currentExportPromise;
  }

  set currentExportPromise(value) {
    this._currentExportPromise = value;
  }

  get exportersMap() {
    return this._exportersMap || (this._exportersMap = new Map());
  }

  getExporter(config = {}) {
    const me = this,
      {
        exportersMap
      } = me,
      {
        type
      } = config;
    let exporter;

    if (exportersMap.has(type)) {
      exporter = exportersMap.get(type);
    } else {
      const exporterClass = this.exporters.find(cls => cls.type === type);

      if (!exporterClass) {
        throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);
      }

      config = ObjectHelper.clone(config);
      delete config.type;
      exporter = new exporterClass(config);
      exporter.relayAll(me);
      exportersMap.set(type, exporter);
    }

    return exporter;
  }

  buildRequest(pages, config) {
    return {
      html: JSON.stringify(pages),
      fileFormat: config.fileFormat,
      format: config.paperFormat,
      orientation: config.orientation
    };
  }

  buildExportConfig(config) {
    const me = this,
      {
        client,
        exportServer,
        clientURL,
        fileFormat,
        fileName,
        paperFormat,
        rowsRange,
        alignRows,
        orientation,
        exporters,
        translateURLsToAbsolute,
        keepPathName,
        headerTpl,
        footerTpl
      } = me;
    return ObjectHelper.assign({
      client,
      exportServer,
      clientURL,
      fileFormat,
      paperFormat,
      rowsRange,
      alignRows,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      headerTpl,
      footerTpl,
      exporterType: exporters[0].type,
      fileName: fileName || client.$name
    }, config);
  }


  async export(config = {}) {
    const me = this,
      {
        client,
        pagesPerRequest
      } = me;
    config = me.buildExportConfig(config);
    let result;
    config.exporterConfig = ObjectHelper.assign({
      type: config.exporterType,
      translateURLsToAbsolute: config.translateURLsToAbsolute,
      keepPathName: config.keepPathName
    }, config.exporterConfig || {});


    if (client.trigger('beforeExport', config) !== false) {

      client.ignoreViewBox = true;
      client.mask(client.loadMask);

      try {
        const exporter = me.getExporter(config.exporterConfig);

        if (pagesPerRequest === 0) {
          const pages = await exporter.export(config);


          me.trigger('exportStep', {
            progress: 90,
            text: me.L('Waiting for response from server...')
          });
          const response = await AjaxHelper.post(config.exportServer, {
            html: pages,
            orientation: config.orientation,
            format: config.paperFormat,
            fileFormat: config.fileFormat,
            fileName: config.fileName,
            clientURL: config.clientURL
          }, Object.assign({
            credentials: 'omit',
            parseJson: true
          }, me.fetchOptions));
          result = {
            response
          };

          if (response.ok) {
            const responseJSON = response.parsedJson;

            if (me.openAfterExport) {
              if (responseJSON.success) {
                if (BrowserHelper.isIE11) {
                  window.open(responseJSON.url, 'ExportedPanel');
                } else {
                  const link = document.createElement('a');
                  link.download = config.fileName;
                  link.href = responseJSON.url;

                  if (me.openInNewTab) {
                    link.target = '_blank';
                  }

                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                }
              } else {
                WidgetHelper.toast(responseJSON.msg);
              }
            }
          }
        }
      } catch (error) {
        if (error instanceof Response) {
          result = {
            response: error
          };
        } else {
          result = {
            error
          };
        }

        throw error;
      } finally {
        if (me.exportDialog) {
          me.exportDialog.close();
        }

        client.unmask();
        client.ignoreViewBox = false;


        me.trigger('export', result);

        if (result.error) {
          WidgetHelper.toast(me.L('Export failed'));
        } else if (!result.response.ok) {
          WidgetHelper.toast(me.L('Server error'));
        }

        client.trigger('export', result);
      }
    }

    return result;
  }


  showExportDialog() {
    const me = this;

    if (!me.exportDialog) {
      me.exportDialog = new ExportDialog({
        client: me.client,
        exporters: me.exporters,
        listeners: {
          export: me.onExportDialogExport,
          thisObj: me
        }
      });
    }

    me.exportDialog.show();
  }

  onExportDialogExport({
                         values
                       }) {
    const me = this;
    me.mask = new Mask({
      progress: 0,
      maxProgress: 100,
      text: 'Generating pages...',
      element: me.exportDialog.element
    });
    const detacher = me.on({
      export() {
        me.mask.close();
        detacher();
      },

      exportstep({
                   progress,
                   text
                 }) {
        me.mask.progress = progress;
        me.mask.text = text;
      }

    });
    me.currentExportPromise = me.export(values);

    me.currentExportPromise.then(() => me.currentExportPromise = null);
  }

}

PdfExport._$name = 'PdfExport';
GridFeatureManager.registerFeature(PdfExport, false, 'Grid');


class TableExporter extends Base {
  static get defaultConfig() {
    return {

      target: null,


      defaultColumnWidth: 100,


      exportDateAsInstance: true,


      showGroupHeader: true,


      columns: null,


      indent: true,


      indentationSymbol: '\u00A0\u00A0\u00A0\u00A0'
    };
  }


  export(config = {}) {
    const me = this;
    config = ObjectHelper.assign({}, me.config, config);
    me.normalizeColumns(config);
    return me.generateExportData(config);
  }

  generateExportData(config) {
    const me = this,
      columns = me.generateColumns(config),
      rows = me.generateRows(config);
    return {
      rows,
      columns
    };
  }

  normalizeColumns(config) {


    const columns = config.columns || this.target.columns.visibleColumns.filter(rec => rec.exportable !== false);
    config.columns = columns.map(col => {
      if (typeof col === 'string') {
        return this.target.columns.find(column => column.field === col) || {
          field: col
        };
      } else {
        return col;
      }
    });
  }

  generateColumns(config) {
    return config.columns.map(col => this.processColumn(col, config));
  }

  generateRows(config) {
    const {
      columns
    } = config;

    if (!columns.length) {
      return [];
    }

    const me = this,
      {
        target
      } = me;
    return target.store

      .map(record => me.processRecord(record, columns, config))
      .filter(cells => cells.length);
  }

  getColumnType(column, store = this.target.store) {
    let result = column.exportedType || 'object';

    if (column.exportedType === undefined) {
      if (column.field) {
        const fieldDefinition = store.modelClass.getFieldDefinition(column.field);

        if (fieldDefinition && fieldDefinition.type) {
          result = fieldDefinition.type;
        }
      }
    }

    return result;
  }


  processColumn(column, config) {
    const me = this,
      {
        target
      } = me,
      {
        defaultColumnWidth
      } = config;
    let {
      field,
      text: value,
      width,
      minWidth
    } = column;


    if (!(field in target.store.modelClass.fieldMap)) {
      field = '';
    }

    if (!value || !width) {
      const gridColumn = target.columns.find(col => col.field === field);

      if (!value) {
        value = gridColumn && gridColumn.text || field;
      }

      if (width == null) {
        width = gridColumn && gridColumn.width || defaultColumnWidth;
      }
    }

    width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);
    return {
      field,
      value,
      width,
      type: me.getColumnType(column)
    };
  }


  processRecord(record, columns, config) {
    const {
        target
      } = this,
      {
        showGroupHeader,
        indent,
        indentationSymbol
      } = config;
    let cells;

    if (!record) {
      cells = columns.map(() => '');
    } else if (record.meta.specialRow) {
      if (showGroupHeader && record.meta.groupRowFor) {
        cells = columns.map(column => {
          return target.features.group.buildGroupHeader({

            cellElement: DomHelper.createElement(),
            grid: target,
            record,
            column
          });
        });
      }
    } else {
      cells = columns.map(column => {
        let value = record[column.field],
          useRenderer = column.renderer || column.defaultRenderer;

        if (useRenderer && !(value && column instanceof DateColumn && config.exportDateAsInstance)) {
          value = useRenderer.call(column, {
            value,
            record,
            column,
            grid: target,
            isExport: true
          });
        }

        if (indent && column.tree) {
          value = `${indentationSymbol.repeat(record.childLevel)}${value}`;
        }

        return value;
      });
    }

    return cells;
  }

}

TableExporter._$name = 'TableExporter';

class BooleanUnicodeSymbol {
  constructor(value) {
    this._value = value;
  }

  get value() {
    return this._value;
  }

  toString() {
    return Boolean(this.value) ? '' : '';
  }

}

BooleanUnicodeSymbol._$name = 'BooleanUnicodeSymbol';


class ExcelExporter extends InstancePlugin {
  static get $name() {
    return 'ExcelExporter';
  }

  static get defaultConfig() {
    return {

      filename: null,


      dateFormat: 'YYYY-MM-DD',


      exporterClass: TableExporter,


      exporterConfig: null,


      zipcelx: null,


      convertEmptyValueToEmptyString: true
    };
  }

  processValue(value) {
    if (value === undefined || value === null || Number.isNaN(value) || typeof value === 'function' || typeof value === 'object' && String(value) === '[object Object]') {
      return '';
    } else {
      return value;
    }
  }

  generateExportData(config) {
    const me = this,
      {
        rows,
        columns
      } = me.exporter.export(config.exporterConfig);
    return {
      rows: rows.map(row => {
        return row.map((value, index) => {
          if (value instanceof Date) {
            value = DateHelper.format(value, config.dateFormat);
          } else if (typeof value === 'boolean') {
            value = new BooleanUnicodeSymbol(value);
          }

          if (me.convertEmptyValueToEmptyString) {
            value = me.processValue(value);
          }


          const type = 'string';
          return {
            value,
            type
          };
        });
      }),
      columns: columns.map(col => {
        let {
          field,
          value,
          width,
          type
        } = col;


        type = 'string';
        return {
          field,
          value,
          width,
          type
        };
      })
    };
  }


  export(config = {}) {
    const me = this;

    if (!me.zipcelx) {
      throw new Error('ExcelExporter: "zipcelx" library is required');
    }

    if (me.disabled) {
      return;
    }

    config = ObjectHelper.assign({}, me.config, config);

    if (!config.filename) {
      config.filename = me.client.$name;
    }

    const {
        filename
      } = config,
      {
        rows,
        columns
      } = me.generateExportData(config);
    me.zipcelx({
      filename,
      sheet: {
        data: [columns].concat(rows),
        cols: columns
      }
    });
  }

  construct(grid, config) {
    super.construct(grid, config);

    if (!this.zipcelx) {
      if (typeof zipcelx !== 'undefined') {
        this.zipcelx = zipcelx;
      }
    }
  }

  get exporter() {
    return this._exporter || (this._exporter = new this.exporterClass(Object.assign({
      target: this.client
    }, this.exporterConfig)));
  }

}

ExcelExporter._$name = 'ExcelExporter';
GridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');


class ScrollManager extends Delayable(Base) {

  static get defaultConfig() {
    return {

      zoneWidth: 50,


      scrollSpeed: 5,


      verticalElement: null,


      direction: 'both',
      monitoring: [],


      startScrollDelay: 500,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 0
      }
    };
  }


  startMonitoring(elementOrConfig) {
    const me = this,
      config = elementOrConfig instanceof HTMLElement ? {
        element: elementOrConfig
      } : elementOrConfig,
      element = config.element,
      verticalElement = config.verticalElement || me.verticalElement || element;

    if (element && (element.scrollWidth > element.offsetWidth || verticalElement.scrollHeight > verticalElement.offsetHeight)) {

      if (me.monitoring.find(m => m.element === element)) return;
      config.direction = config.direction || me.direction;

      Object.assign(config, {
        verticalElement,
        scrollManager: me,
        startScrollLeft: element.scrollLeft,
        startScrollTop: verticalElement.scrollTop,
        scrollLeft: element.scrollLeft,
        scrollTop: verticalElement.scrollTop,
        scrollRelativeLeft: 0,
        scrollRelativeTop: 0
      });
      const handler = me.onMouseMove.bind(config);

      me.mouseMoveDetacher = EventHelper.on({
        mousemove: handler,
        touchmove: handler,
        mouseleave: () => me.clearTimeout(me.scrollTimeout),
        element
      });


      config.scrollWidth = element.scrollWidth;
      me.monitoring.push(config);
    }
  }


  stopMonitoring(element) {
    const me = this,
      config = me.monitoring.find(m => m.element === element);

    if (!config) return;
    me.stopScroll(config);
    me.mouseMoveDetacher && me.mouseMoveDetacher();
    me.monitoring.splice(me.monitoring.indexOf(config), 1);
  }


  startScroll(config) {
    config.scrolling = true;
    this.performScroll(config);
  }


  stopScroll(config) {
    const me = this;
    config.scrolling = false;

    if (config.scrollRequested) {
      me.cancelAnimationFrame(config.frameId);
      config.scrollRequested = false;
    }

    me.clearTimeout(me.scrollTimeout);
    me.scrollTimeout = null;
  }


  performScroll(config) {


    if (config.scrolling && !config.scrollRequested) {
      let element = config.element,
        vertical = config.verticalElement;

      if (config.scrollDeltaX !== 0) {
        config.scrollLeft += config.scrollDeltaX;

        config.scrollLeft = Math.max(Math.min(config.scrollLeft, config.scrollWidth - element.clientWidth), 0);
        config.scrollRelativeLeft = config.scrollLeft - config.startScrollLeft;
        element.scrollLeft = config.scrollLeft;
      }

      if (config.scrollDeltaY !== 0) {
        config.scrollTop += config.scrollDeltaY;

        config.scrollTop = Math.max(Math.min(config.scrollTop, vertical.scrollHeight - vertical.clientHeight), 0);
        config.scrollRelativeTop = config.scrollTop - config.startScrollTop;
        vertical.scrollTop = config.scrollTop;
      }

      if ((config.scrollRelativeLeft !== 0 || config.scrollRelativeTop !== 0) && config.callback) {
        config.callback.call(config.thisObj || this, config);
      }

      config.scrollRequested = true;
      config.frameId = this.requestAnimationFrame(() => {
        config.scrollRequested = false;
        this.performScroll(config);
      });
    }
  }


  onMouseMove(event) {
    const config = this,
      me = config.scrollManager,
      element = config.element,
      vertical = config.verticalElement,
      box = element.getBoundingClientRect(),
      vbox = vertical.getBoundingClientRect(),
      width = me.zoneWidth,
      speed = me.scrollSpeed;

    config.scrollDeltaX = 0;

    if (config.direction !== 'vertical') {
      if (event.clientX > box.right - width) {
        config.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
      } else if (event.clientX < box.left + width) {
        config.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
      }
    }

    config.scrollDeltaY = 0;

    if (config.direction !== 'horizontal') {
      if (event.clientY > vbox.bottom - width) {
        config.scrollDeltaY = Math.round((width - (vbox.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < vbox.top + width) {
        config.scrollDeltaY = -Math.round((width + (vbox.top - event.clientY)) / speed) - 1;
      }
    }

    if (config.scrollDeltaX === 0 && config.scrollDeltaY === 0) {
      me.stopScroll(config);
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = me.setTimeout(() => me.startScroll(config), me.startScrollDelay);
    }
  }

}

ScrollManager._$name = 'ScrollManager';


class Row extends Delayable(Base) {
  static get defaultConfig() {
    return {
      cls: 'b-grid-row'
    };
  }


  construct(config) {

    Object.assign(this, {
      _elements: {},
      _elementsArray: [],
      _cells: {},
      _allCells: [],
      _regions: [],
      lastHeight: 0,
      lastTop: -1,
      _dataIndex: 0,
      _top: 0,
      _height: 0,
      _id: null,
      forceInnerHTML: false,
      isGroupFooter: false
    }, config);
    super.construct();
  }

  doDestroy() {
    const me = this;

    if (!me.rowManager.isDestroying) {
      me.removeElements();

      if (me.rowManager.idMap[me.id] === me) {
        delete me.rowManager.idMap[me.id];
      }
    }

    super.doDestroy();
  }


  get index() {
    return this._index;
  }

  set index(index) {
    this._index = index;
  }


  get dataIndex() {
    return this._dataIndex;
  }

  set dataIndex(dataIndex) {
    if (this._dataIndex !== dataIndex) {
      const elements = this._elementsArray;
      this._dataIndex = dataIndex;

      for (let i = 0; i < elements.length; i++) {
        elements[i].dataset.index = dataIndex;
      }
    }
  }


  get id() {
    return this._id;
  }

  set id(id) {
    const me = this,
      idObj = {
        id
      },
      idMap = me.rowManager.idMap,
      elements = me._elementsArray,
      cells = me._allCells;

    if (me._id != id || idMap[id] !== me) {
      if (idMap[me._id] === me) delete idMap[me._id];
      idMap[id] = me;
      me._id = id;

      for (let i = 0; i < elements.length; i++) {
        DomDataStore.assign(elements[i], idObj);
      }

      for (let i = 0; i < cells.length; i++) {
        DomDataStore.assign(cells[i], idObj);
      }

      for (let i = 0; i < elements.length; i++) {
        elements[i].dataset.id = id;
      }
    }
  }


  addElement(region, element) {
    const me = this;
    let cellElement = element.firstElementChild;
    me._elements[region] = element;

    me._elementsArray.push(element);

    me._regions.push(region);

    DomDataStore.assign(element, {
      index: me.index
    });
    me._cells[region] = [];

    while (cellElement) {
      me._cells[region].push(cellElement);

      me._allCells.push(cellElement);

      DomDataStore.set(cellElement, {
        column: cellElement.dataset.column,

        columnId: cellElement.dataset.columnId,
        rowElement: cellElement.parentNode,
        row: me
      });
      cellElement = cellElement.nextElementSibling;
    }

    element.dataset.index = me.index;
  }


  getElement(region) {
    return this._elements[region];
  }


  eachElement(fn) {
    for (let i = 0; i < this._elementsArray.length; i++) {
      fn(this._elementsArray[i], i);
    }

  }


  eachCell(fn) {
    this._allCells.forEach(fn);
  }


  get elements() {
    return this._elements;
  }


  get cells() {
    return this._allCells;
  }


  getCells(region) {
    return this._cells[region];
  }


  getCell(columnId) {
    return this._allCells.find(cell => {
      const cellData = DomDataStore.get(cell);
      return cellData.columnId === columnId || cellData.column === columnId;
    });
  }

  removeElements(onlyRelease = false) {
    const me = this;

    me.rowManager.trigger('removeRow', {
      row: me
    });

    if (!onlyRelease) {
      me._elementsArray.forEach(element => element.remove());
    }

    me._elements = {};
    me._cells = {};
    me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;
    me.lastTop = -1;
  }


  get height() {
    return this._height;
  }

  set height(height) {
    this._height = height;
  }


  get offsetHeight() {


    return this.height + this.grid._rowBorderHeight;
  }


  setHeightIfBigger(height) {
    if (height > this.height) {
      this.height = height;
    }
  }


  updateElementsHeight() {
    const me = this;
    me.rowManager.storeKnownHeight(me.id, me.height);

    if (me.lastHeight !== me.height) {
      const elements = me._elementsArray;

      for (let i = 0; i < elements.length; i++) {
        elements[i].style.height = `${me.offsetHeight}px`;
      }

      me.lastHeight = me.height;
    }
  }


  addCls(...classes) {
    this.eachElement(element => DomHelper.addClasses(element, classes));
  }


  removeCls(...classes) {
    this.eachElement(element => DomHelper.removeClasses(element, classes));
  }


  get isFirst() {
    return this.dataIndex === 0;
  }


  get top() {
    return this._top;
  }


  get bottom() {
    return this._top + this._height + this.grid._rowBorderHeight;
  }


  setTop(top) {
    if (this._top !== top) {
      this._top = top;
      this.translateElements();
    }
  }


  setBottom(bottom) {
    this.setTop(bottom - this.offsetHeight);
  }


  translateElements() {
    const me = this,
      positionMode = me.grid.positionMode;

    if (me.lastTop !== me.top) {
      const elements = me._elementsArray;

      for (let i = 0; i < elements.length; i++) {
        const style = elements[i].style;

        if (positionMode === 'translate') {
          style.transform = `translate(0,${me.top}px)`;
        } else if (positionMode === 'translate3d') {
          style.transform = `translate3d(0,${me.top}px,0)`;
        } else if (positionMode === 'position') {
          style.top = `${me.top}px`;
        }
      }

      me.rowManager.trigger('translateRow', {
        row: me
      });
      me.lastTop = me.top;
    }
  }


  offset(offsetTop) {
    let newTop = this._top + offsetTop;

    if (newTop < 0) {
      offsetTop -= newTop;
      newTop = 0;
    }

    this.setTop(newTop);
    return offsetTop;
  }


  render(recordIndex, record, updatingSingleRow = true, batch = false) {
    const me = this,
      {
        cells,
        grid,
        rowManager,
        height: oldHeight
      } = me,
      oldId = me._id,
      elements = me._elementsArray,
      rowElData = DomDataStore.get(elements[0]),
      rowHeight = rowManager._rowHeight,
      defaultRowCls = updatingSingleRow && grid.transitionDuration ? `${me.cls} b-grid-row-updating` : me.cls;
    let i = 0,
      rowElement,
      cell,
      size;

    if (!record && record !== false) {
      record = grid.store.getById(rowElData.id);
      recordIndex = grid.store.indexOf(record);
    }

    const selected = record && grid.isSelected(record.id);

    rowManager.trigger('beforeRenderRow', {
      row: me,
      record,
      recordIndex,
      oldId
    });

    for (i; i < elements.length; i++) {
      rowElement = elements[i];

      rowElement.className = defaultRowCls;


      if (selected) {
        rowElement.classList.add('b-selected');
      }

      if (record.cls) {
        record.cls.split(' ').forEach(cls => rowElement.classList.add(cls));
      }
    }

    if (updatingSingleRow && grid.transitionDuration) {
      me.setTimeout(() => {

        elements.forEach(element => {
          element.classList.remove('b-grid-row-updating');
        });
      }, grid.transitionDuration);
    }

    const height = me.height = !grid.fixedRowHeight && grid.getRowHeight(record) || rowHeight;
    me.id = record.id;
    me.dataIndex = recordIndex;

    for (i = 0; i < cells.length; i++) {
      cell = cells[i];
      size = me.renderCell(cell, record, i, updatingSingleRow, height);

      if (!rowManager.fixedRowHeight) {

        me.setHeightIfBigger(size && size.height);
      }
    }

    me.updateElementsHeight();

    if (updatingSingleRow) {
      if (oldHeight !== me.height) {
        rowManager.translateFromRow(me, batch);
      }

      rowManager.trigger('updateRow', {
        row: me,
        record,
        recordIndex,
        oldId
      });
      rowManager.trigger('renderDone');
    }

    rowManager.trigger('renderRow', {
      row: me,
      record,
      recordIndex,
      oldId
    });
    me.forceInnerHTML = false;
  }


  renderCell(cellElement, record, index, updatingSingleRow = true, height) {
    const me = this,
      {
        grid
      } = me,
      cellElementData = DomDataStore.get(cellElement),
      column = grid.columns.getById(cellElementData.columnId),
      rowElement = cellElementData.rowElement,
      rowElementData = DomDataStore.get(rowElement),
      {

        internalCellCls,
        cellCls,
        align,
        renderer,
        defaultRenderer,
        id: columnId
      } = column,
      cellContext = {
        columnId,
        id: rowElementData.id
      },
      useRenderer = renderer || defaultRenderer;

    if (!record) {


      if (rowElementData.id === null) {


        cellElement.className = 'b-grid-cell';
        return;
      }

      record = grid.store.getById(rowElementData.id);
      if (!record) return;
    }

    let cellContent = column.getRawValue(record),
      shouldSetContent = true;
    const size = {
        height
      },
      rendererData = {
        cellElement,
        rowElement,
        value: cellContent,
        record,
        column,
        size,
        grid,
        row: cellElementData.row,
        updatingSingleRow
      },
      newCellClass = {
        'b-grid-cell': 1,
        [internalCellCls]: internalCellCls,

        [cellCls]: record.meta.specialRow && column.internalCellCls === 'b-check-cell' ? undefined : cellCls,
        'b-cell-dirty': record.isFieldModified(column.field),
        [`b-grid-cell-align-${align}`]: align,
        'b-selected': grid.isSelected(cellContext),
        'b-focused': grid.isFocused(cellContext)
      };
    DomHelper.syncClassList(cellElement, newCellClass);


    if (useRenderer) {
      cellContent = useRenderer.call(column, rendererData);

      if (cellContent === undefined) {
        shouldSetContent = false;
      }
    }

    if (grid.processCellContent) {
      shouldSetContent = grid.processCellContent({
        cellContent,
        cellElement,
        record,
        cellElementData,
        rendererData
      });
    }


    const text = rendererData.cellContent = cellContent == null ? '' : String(cellContent);

    if (shouldSetContent) {

      if (me.forceInnerHTML) {

        cellElement.innerHTML = '';
        cellElement.lastDomConfig = null;
      }


      if (column.htmlEncode && !column.disableHtmlEncode) {


        if (BrowserHelper.isLinux || cellElement._hasHtml) {
          cellElement.innerText = text;
          cellElement._hasHtml = false;
        } else {
          DomHelper.setInnerText(cellElement, text);
        }
      } else {
        const hasStringContent = typeof cellContent === 'string',
          hasObjectContent = typeof cellContent === 'object';

        if (column.autoSyncHtml && (!hasStringContent || cellElement.childElementCount)) {

          if (hasStringContent) {

            DomHelper.sync(text, cellElement.firstElementChild);
          } else {
            DomSync.sync({
              domConfig: cellContent,
              targetElement: cellElement
            });
          }
        } else if (hasObjectContent) {
          DomSync.sync({
            targetElement: cellElement,
            domConfig: {
              onlyChildren: true,
              children: [cellContent]
            }
          });
        } else {
          cellElement.innerHTML = text;
        }
      }
    }

    me.rowManager.trigger('renderCell', rendererData);
    return size;
  }

}

Row._$name = 'Row';


class RowManager extends InstancePlugin {


  static get pluginConfig() {
    return {
      chain: ['getRowById', 'topRow', 'bottomRow', 'getRecordCoords', 'getRow', 'getRowFor', 'getRowFromElement', 'destroy'],
      assign: ['rowHeight']
    };
  }

  static get defaultConfig() {
    return {

      prependRowBuffer: 5,


      appendRowBuffer: 5,


      rowHeight: null,


      fixedRowHeight: null,
      autoHeight: false
    };
  }

  static get properties() {
    return {
      idMap: {},

      topIndex: 0,
      lastScrollTop: 0,
      _rows: [],

      heightMap: new Map(),

      totalKnownHeight: 0,

      _totalHeight: 0,

      averageRowHeight: 0,
      scrollTargetRecordId: null,
      refreshDetails: {
        topRowIndex: 0,
        topRowTop: 0
      }
    };
  }


  construct(config) {
    config.grid._rowManager = this;
    super.construct(config.grid, config);
  }

  doDestroy() {

    this._rows.forEach(row => row.destroy());

    super.doDestroy();
  }


  initWithHeight(height, isRendering = false) {
    const me = this;

    if (me.autoHeight) {
      height = me.store.allCount * me.preciseRowOffsetHeight;
    }

    me.viewHeight = height;
    me.calculateRowCount(isRendering);
    return height;
  }


  reinitialize(returnToTop = false) {
    const me = this;


    me.calculateRowCount(false, true, true);

    if (me.topIndex + me.rowCount - 1 > me.store.count) {
      returnToTop = true;
    }

    const top = me.topRow && !returnToTop ? me.topRow.top : 0;
    me.scrollTargetRecordId = null;

    if (returnToTop) {
      me.topIndex = me.lastScrollTop = 0;
    }

    const {
      topRow
    } = me;

    if (topRow) {

      topRow.dataIndex = me.topIndex;
      topRow.setTop(top);
    }

    me.estimateTotalHeight();
    me.renderFromRow(topRow);
  }


  matchRowCount(skipRender = false) {
    const me = this,
      {
        rows,
        grid
      } = me,
      numRows = rows.length,
      delta = numRows - me.rowCount;

    if (delta) {
      if (delta < 0) {
        const newRows = [];

        for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {
          newRows.push(new Row({
            rowManager: me,
            grid,
            index,
            dataIndex
          }));
        }

        rows.push.apply(rows, newRows);

        me.trigger('addRows', {
          rows: newRows
        });

        if (!skipRender) {

          me.renderFromRow(rows[Math.max(0, numRows - 1)]);
        }
      } else {

        const removedRows = rows.splice(numRows - delta, delta);

        me.trigger('removeRows', {
          rows: removedRows
        });
        removedRows.forEach(row => row.destroy());
      }
    }
  }


  calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {

    const me = this,
      {
        store
      } = me,
      visibleRowCount = Math.ceil(me.viewHeight / me.rowOffsetHeight),

      maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;

    if (!me.grid.columns.count || isNaN(visibleRowCount)) {
      me.rowCount = 0;
      return 0;
    }


    if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) {
      return me.rowCount;
    }

    me.visibleRowCount = visibleRowCount;
    me.rowCount = Math.min(store.count, maxRenderRowCount);


    if (!skipMatchRowCount) {
      if (me.rows && me.rowCount !== me.rows.length) {
        me.matchRowCount(skipRender);
      } else if (!me.rowCount) {
        me.trigger('changeTotalHeight', {
          totalHeight: me.totalHeight
        });
      }

      me.grid.toggleEmptyText();
    }

    return me.rowCount;
  }

  removeAllRows() {

    const me = this,
      {
        topRow
      } = me,
      result = topRow ? me.refreshDetails = {
        topRowIndex: topRow.dataIndex,
        topRowTop: topRow.top
      } : me.refreshDetails,
      removedRows = me.rows.slice();

    me.trigger('removeRows', {
      rows: removedRows
    });
    me.rows.forEach(row => row.destroy());
    me.rows.length = 0;
    me.idMap = {};


    return result;
  }

  setPosition(refreshDetails) {

    const {
        topRow
      } = this,
      {
        topRowIndex,
        topRowTop
      } = refreshDetails;
    topRow.setTop(topRowTop);
    topRow.dataIndex = topRowIndex;
  }


  get store() {
    return this.client.store;
  }


  get rows() {
    return this._rows;
  }


  getRow(index) {
    return this.rowCount && this.rows[index - this.topIndex];
  }


  getRowById(recordOrId) {
    if (recordOrId.isModel) {
      recordOrId = recordOrId.id;
    }

    return this.idMap[recordOrId];
  }


  getRowFromElement(element) {
    element = element.closest('.b-grid-row');
    return element && this.getRow(element.dataset.index);
  }


  getRowAt(y, local = false) {

    if (!local) {


      y -= Rectangle.from(this.grid.bodyContainer, null, true).roundPx(1).top;

      y += this.grid.scrollable.y;
    }

    y = DomHelper.roundPx(y);
    return this.rows.find(r => y >= r.top && y < r.bottom);
  }


  getRowFor(recordOrId) {
    if (recordOrId instanceof HTMLElement) {
      return this.getRowFromElement(recordOrId);
    }

    return this.getRowById(recordOrId);
  }


  getNextRow(indexOrRow) {
    const index = typeof indexOrRow === 'number' ? indexOrRow : indexOrRow.index;
    return this.getRow((index + 1) % this.rowCount);
  }


  get topRow() {
    return this.rows[0];
  }


  get bottomRow() {

    const rowCount = Math.min(this.rowCount, this.store.count);
    return this.rows[rowCount - 1];
  }


  offsetRows(offset) {
    if (offset !== 0) {
      const {
          rows
        } = this,
        {
          length
        } = rows;

      for (let i = 0; i < length; i++) {
        rows[i].offset(offset);
      }
    }

    this.trigger('offsetRows', {
      offset
    });
  }


  get rowHeight() {
    return this._rowHeight;
  }

  set rowHeight(height) {
    const me = this,
      {
        grid,
        fixedRowHeight
      } = me,
      oldRowHeight = me.rowHeight;
    ObjectHelper.assertNumber(height, 'rowHeight');

    if (height < 10) {

      console.warn(`The rowHeight of ${height} was increased to 10 which is the minimum.`);

      height = 10;
    }

    me.trigger('beforeRowHeight', {
      height
    });
    me._rowHeight = height;
    me.prependBufferHeight = me.prependRowBuffer * me.rowOffsetHeight;
    me.appendBufferHeight = me.appendRowBuffer * me.rowOffsetHeight;

    if (fixedRowHeight) {
      me.averageRowHeight = height;
    }

    if (me.rows.length) {
      const oldY = grid.scrollable.y,
        topRow = me.getRowAt(oldY, true),
        edgeOffset = topRow.top - oldY;
      let average, oldAverage;

      if (fixedRowHeight) {
        average = height;
        oldAverage = oldRowHeight;
      } else {
        oldAverage = average = me.averageRowHeight;
        me.clearKnownHeights();

        average *= height / oldRowHeight;
      }

      me.calculateRowCount(false, true, true);

      me.topRow.setTop(me.topRow.dataIndex * (average + grid._rowBorderHeight));
      me.refresh();
      const newY = oldY * (average / oldAverage);

      if (newY !== oldY) {
        grid.scrollRowIntoView(topRow.id, {
          block: 'start',
          edgeOffset
        });
      }
    }

    me.trigger('rowHeight', {
      height
    });
  }


  get rowOffsetHeight() {
    return Math.floor(this.preciseRowOffsetHeight);
  }

  get preciseRowOffsetHeight() {
    return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }


  get allHeightsKnown() {
    return this.fixedRowHeight || this.heightMap.size >= this.store.count;
  }


  storeKnownHeight(id, height) {
    const me = this,
      {
        heightMap
      } = me;

    if (!me.fixedRowHeight) {

      if (heightMap.has(id)) {
        me.totalKnownHeight -= heightMap.get(id);
      }

      heightMap.set(id, height);

      me.totalKnownHeight += height;
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }


  invalidateKnownHeight(records) {
    const me = this;

    if (!me.fixedRowHeight) {
      const {
        heightMap
      } = me;

      if (!Array.isArray(records)) {
        records = [records];
      }

      records.forEach(record => {
        if (record) {
          if (heightMap.has(record.id)) {

            me.totalKnownHeight -= heightMap.get(record.id);
            heightMap.delete(record.id);
          }
        }
      });
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }


  clearKnownHeights() {
    this.heightMap.clear();
    this.averageRowHeight = this.totalKnownHeight = 0;
  }


  calculateTop(index) {

    if (this.fixedRowHeight) {
      return index * this.rowOffsetHeight;
    }

    const {
      heightMap,
      averageRowHeight,
      store,
      grid
    } = this;
    let top = 0;


    for (let i = 0; i < index; i++) {
      const record = store.getAt(i);

      if (heightMap.has(record.id)) {
        top += heightMap.get(record.id);
      } else {
        top += grid.getRowHeight(record) || averageRowHeight;
      }

      top += grid._rowBorderHeight;
    }

    return Math.floor(top);
  }


  getRecordCoords(recordOrId, local = false) {
    const me = this,
      id = typeof recordOrId === 'string' || typeof recordOrId === 'number' ? recordOrId : recordOrId.id,
      row = me.getRowById(recordOrId);
    let scrollingViewport = me.client._bodyRectangle;


    if (!local) {
      scrollingViewport = me.client._bodyRectangle = Rectangle.client(me.client.bodyContainer);
    }

    if (row) {
      return new Rectangle(scrollingViewport.x, local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y), scrollingViewport.width, row.offsetHeight);
    }

    return me.getRecordCoordsByIndex(me.store.indexOf(id), local);
  }


  getRecordCoordsByIndex(recordIndex, local = false) {
    const me = this,
      {
        topRow,
        bottomRow
      } = me,
      scrollingViewport = me.client._bodyRectangle,
      {
        id
      } = me.store.getAt(recordIndex),

      height = me.preciseRowOffsetHeight,
      currentTopIndex = topRow.dataIndex,
      currentBottomIndex = bottomRow.dataIndex,


      calculateFrom =
        recordIndex > currentBottomIndex ? {
            index: recordIndex - currentBottomIndex - 1,
            y: bottomRow.bottom,
            from: 'bottomRow'
          }
          : recordIndex > currentTopIndex / 2 ? {
            index: recordIndex - currentTopIndex,
            y: topRow.top,
            from: 'topRow'
          }
          : {
            index: recordIndex,
            y: 0,
            from: 'top'
          },
      top = me.allHeightsKnown
        ? me.calculateTop(recordIndex)
        : Math.floor(calculateFrom.y + calculateFrom.index * height),
      result = new Rectangle(scrollingViewport.x, local ? top : top + scrollingViewport.y - me.client.scrollable.y, scrollingViewport.width,
        Math.floor(me.heightMap.get(id) || height));


    result.virtual = true;


    result.block = result.bottom < scrollingViewport.y ? 'start' : result.y > scrollingViewport.bottom ? 'end' : 'nearest';
    return result;
  }


  get totalHeight() {
    return this._totalHeight;
  }


  forEach(fn) {
    this.rows.forEach(fn);
  }


  [Symbol.iterator]() {
    return this.rows[Symbol.iterator]();
  }


  returnToTop() {
    const me = this;
    me.topIndex = 0;
    me.lastScrollTop = 0;

    if (me.topRow) {
      me.topRow.dataIndex = 0;

      me.topRow.setTop(0);
    }

    me.refresh();

    me.grid.scrollable.y = 0;
  }


  renderFromRecord(record) {
    const row = this.getRowById(record.id);

    if (row) {
      this.renderFromRow(row);
    }
  }


  renderFromRow(fromRow = null) {
    const me = this,
      {
        rows,
        store
      } = me,
      storeCount = store.count;


    if (me.calculateRowCount(false, storeCount < rows.length, true) === 0) {
      return;
    }

    let
      fromRowIndex = fromRow ? rows.indexOf(fromRow) : 0,

      dataIndex = fromRow ? fromRow.dataIndex : rows[0].dataIndex,

      recordsAfter = storeCount - dataIndex - 1,

      toRowIndex = Math.min(rows.length - 1, fromRowIndex + recordsAfter),

      leftOverCount = rows.length - toRowIndex - 1,

      top = fromRowIndex > 0 ? rows[fromRowIndex - 1].bottom : rows[fromRowIndex].top,
      row;

    for (let i = fromRowIndex; i <= toRowIndex; i++) {
      row = rows[i];

      row.dataIndex = dataIndex;
      row.setTop(top);
      row.render(dataIndex, store.getAt(dataIndex++), false);
      top += row.offsetHeight;
    }


    while (leftOverCount-- > 0) {
      me.displayRecordAtTop();
    }

    me.estimateTotalHeight();
    me.trigger('renderDone');
  }


  renderRows(rows) {
    let oldHeight,
      heightChanged = false;
    rows = Array.from(rows);

    for (const row of rows) {
      oldHeight = row.height;


      row.render(null, null, false);
      heightChanged |= row.height !== oldHeight;
    }

    if (heightChanged) {
      this.translateFromRow(rows[0], true);

      this.estimateTotalHeight();
    }

    this.trigger('renderDone');
  }


  translateFromRow(fromRow, batch = false) {
    const me = this;
    let top = fromRow.bottom,

      row,
      index;

    for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {
      row.setTop(top);
      top += row.offsetHeight;
    }

    if (!batch) {
      me.estimateTotalHeight();
    }
  }


  refresh() {
    const me = this,
      {
        topRow
      } = me;

    if (!topRow) {
      return;
    }

    me.idMap = {};
    me.renderFromRow(topRow);
    me.trigger('refresh');
  }


  jumpToPosition(newScrollTop, forceRecordIndex) {


    const me = this,
      {
        store,
        heightMap
      } = me,
      storeCount = store.count;

    if (me.allHeightsKnown && !me.fixedRowHeight) {
      const top = newScrollTop - me.prependBufferHeight,
        border = me.grid._rowBorderHeight;
      let accumulated = 0,
        targetIndex = 0;

      while (accumulated < top) {
        const record = store.getAt(targetIndex);
        accumulated += heightMap.get(record.id) + border;
        targetIndex++;
      }

      const startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(me.calculateTop(startIndex), false);

      me.refresh();
    } else {
      const rowHeight = me.preciseRowOffsetHeight,


        targetIndex = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2),
        startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0),
        viewportTop = me.client.scrollable.y,
        viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(Math.floor(startIndex * rowHeight), false);

      me.refresh();


      if (me.bottomRow.bottom < viewportBottom) {

        while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {
          me.displayRecordAtBottom();
        }


      }

      me.estimateTotalHeight();
    }

    if (forceRecordIndex != null) {
      const {
          scrollable
        } = me.grid,
        targetRow = me.getRow(forceRecordIndex),


        rowCenter = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y,
        viewportCenter = scrollable.viewport.center.y;

      if (targetRow) {
        scrollable.y = newScrollTop = Math.floor(scrollable.y + (rowCenter - viewportCenter));
      }
    }

    return newScrollTop;
  }


  warpIfNeeded(newScrollTop) {
    const me = this,
      result = {
        newScrollTop,
        deltaTop: newScrollTop - me.lastScrollTop
      };

    if (Math.abs(result.deltaTop) > me.rowCount * me.rowOffsetHeight * 3) {

      let index;

      if (me.scrollTargetRecordId) {
        index = me.store.indexOf(me.scrollTargetRecordId);

      }

      result.newScrollTop = me.jumpToPosition(newScrollTop, index);
      result.deltaTop = 0;
    }

    return result;
  }


  updateRenderedRows(newScrollTop, force, ignoreError = false) {
    const me = this,
      clientRect = me.client._bodyRectangle;

    if (me.rowCount === 0) {
      return 0;
    }

    let result = me.totalHeight;

    if (force ||
      Math.abs(newScrollTop - me.lastScrollTop) > me.rowOffsetHeight ||
      me.topRow.top > newScrollTop || me.bottomRow.bottom < newScrollTop + clientRect.height) {

      const posInfo = me.warpIfNeeded(newScrollTop);
      me.scrollTargetRecordId = null;


      me.lastScrollTop = posInfo.newScrollTop;

      if (posInfo.deltaTop > 0) {

        me.fillBelow(posInfo.newScrollTop);
      } else if (posInfo.deltaTop < 0) {

        me.fillAbove(posInfo.newScrollTop);
      }

      if (!me.fixedRowHeight && !ignoreError) {
        me.correctError(posInfo, clientRect, newScrollTop);
      }

      result = me.estimateTotalHeight();
    }

    return result;
  }

  correctError(posInfo, clientRect, newScrollTop) {
    const me = this;
    let error = 0;


    if (me.allHeightsKnown) {
      error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
    } else {


      if (
        posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2 ||
        posInfo.deltaTop > 0 && newScrollTop > me.totalHeight - clientRect.height * 2 - 3) {

        error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
      }
    }

    if (error) {


      me.offsetRows(-error);
      me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;
    }
  }


  fillAbove(newTop) {
    const me = this,
      fillHeight = newTop - me.topRow.top - me.prependBufferHeight;
    let accumulatedHeight = 0;

    while (accumulatedHeight > fillHeight && me.topIndex > 0) {

      accumulatedHeight -= me.displayRecordAtTop();
    }

    me.trigger('renderDone');
  }


  fillBelow(newTop) {
    const me = this,
      fillHeight = newTop - me.topRow.top - me.prependBufferHeight,
      recordCount = me.store.count,
      rowCount = me.rowCount;
    let accumulatedHeight = 0;

    while (accumulatedHeight < fillHeight &&
      me.topIndex + rowCount < recordCount &&
      me.topRow.top + me.topRow.offsetHeight < newTop
      ) {

      accumulatedHeight += me.displayRecordAtBottom();
    }

    me.trigger('renderDone');
  }


  estimateTotalHeight(immediate = false) {
    const me = this;

    if (me.grid.renderingRows) {
      return;
    }

    const recordCount = me.store.count,
      unknownCount = recordCount - me.heightMap.size,
      {
        bottomRow
      } = me;
    let estimate;

    if (me.fixedRowHeight) {
      estimate = recordCount * me.rowOffsetHeight;
    } else {
      estimate =
        me.totalKnownHeight +
        me.heightMap.size * me.grid._rowBorderHeight +
        unknownCount * me.preciseRowOffsetHeight;

      if (bottomRow && unknownCount) {
        const bottom = bottomRow.bottom;

        if (bottom > estimate || me.topIndex + me.rowCount >= recordCount && estimate > bottom) {
          estimate = bottom;

          if (bottomRow.dataIndex < recordCount - 1) {
            estimate += (recordCount - 1 - bottomRow.dataIndex) * me.preciseRowOffsetHeight;
          }
        }
      }

      estimate = Math.floor(estimate);
    }

    if (estimate !== me.totalHeight) {
      if (me.trigger('changeTotalHeight', {
        totalHeight: estimate,
        immediate
      }) !== false) {
        me._totalHeight = estimate;
      }
    }

    return estimate;
  }


  displayRecordAtTop() {
    const me = this,
      recordIndex = me.topIndex - 1,
      record = me.store.getAt(recordIndex),

      bottomRow = me.bottomRow,
      bottomRowTop = bottomRow.top;
    me.trigger('beforeTranslateRow', {
      row: bottomRow,
      newRecord: record
    });

    bottomRow._top = me.topRow.top - me.rowOffsetHeight;

    bottomRow.estimatedTop = !me.fixedRowHeight;

    bottomRow.render(recordIndex, record, false);


    bottomRow._top = bottomRowTop;
    bottomRow.setBottom(me.topRow.top);
    bottomRow.estimatedTop = false;

    me.topIndex--;

    me._rows.unshift(me._rows.pop());

    return bottomRow.offsetHeight;
  }


  displayRecordAtBottom() {
    const me = this,
      recordIndex = me.topIndex + me.rowCount,
      record = me.store.getAt(recordIndex),

      topRow = me.topRow;
    me.trigger('beforeTranslateRow', {
      row: topRow,
      newRecord: record
    });
    topRow.dataIndex = recordIndex;

    topRow.setTop(me.bottomRow.bottom);

    topRow.render(recordIndex, record, false);

    me.topIndex++;

    me._rows.push(me._rows.shift());

    return topRow.offsetHeight;
  }

}

RowManager._$name = 'RowManager';


const xAxis$1 = {
  x: 1
};


class GridScroller extends Scroller {
  addScroller(scroller) {
    (this.xScrollers || (this.xScrollers = [])).push(scroller);
  }

  addPartner(otherScroller, axes = xAxis$1) {
    if (typeof axes === 'string') {
      axes = {
        [axes]: 1
      };
    }

    if (axes.x) {
      for (let i = 0; i < this.xScrollers.length; i++) {
        this.xScrollers[i].addPartner(otherScroller.xScrollers[i], 'x');
      }
    }

    if (axes.y) {
      super.addPartner(otherScroller, 'y');
    }
  }

  updateOverflowX(overflowX) {
    this.xScrollers && this.xScrollers.forEach(s => s.overflowX = overflowX);
    this.widget.virtualScrollers.classList[overflowX === false ? 'add' : 'remove']('b-hide-display');
  }

  scrollIntoView(element, options) {


    if (element.nodeType === 1) {
      for (const subGridScroller of this.xScrollers) {
        if (subGridScroller.element.contains(element)) {
          return subGridScroller.scrollIntoView(element, options);
        }
      }
    } else {
      return super.scrollIntoView(element, options);
    }
  }

  set x(x) {
    if (this.xScrollers) {
      this.xScrollers[0].x = x;
    }
  }

  get x() {

    return this.xScrollers ? this.xScrollers[0].x : 0;
  }

}

GridScroller._$name = 'GridScroller';


class Header extends Bar {
  static get $name() {
    return 'Header';
  }

  static get defaultConfig() {
    return {
      isHeader: true
    };
  }

  startConfigure(config) {
    config.scrollable.overflowX = 'hidden-scroll';
    super.startConfigure(config);
  }

  get subGrid() {
    return this._subGrid;
  }

  set subGrid(subGrid) {
    this._subGrid = subGrid;
    this.id = subGrid.id + '-header';
  }

  get region() {
    return this.subGrid && this.subGrid.region;
  }

  template() {
    const me = this,
      region = me.region;
    return TemplateHelper.tpl`
            <div class="b-grid-header-scroller b-grid-header-scroller-${region}">
                <div reference="headersElement" class="b-grid-headers b-grid-headers-${region}" data-region="${region}" data-max-depth="${me.maxDepth}" reference="headersElement"></div>
            </div>
        `;
  }

  get overflowElement() {
    return this.headersElement;
  }


  contentTemplate(column) {
    const me = this;

    if (column.hidden) {
      return '';
    } else {

      return TemplateHelper.tpl`
                <div class="b-grid-header" data-column="${column.field || ''}" data-column-id="${column.id}" ${column.isLeaf ? 'tabindex="0"' : ''}>
                    <div class="b-grid-header-text">
                        <div class="b-grid-header-text-content"></div>
                    </div>
                    ${column.children ? `
                    <div class="b-grid-header-children">
                            ${column.children.map(child => me.contentTemplate(child)).join('')}
                    </div>
                    ` : ''}
                    <div class="b-grid-header-resize-handle"></div>
                </div>
            `;

    }
  }

  calculateMinWidthForSafari() {
    let minWidth = 0,
      columns = this.columns.visibleColumns;
    columns.forEach(column => {
      minWidth += column.calculateMinWidth();
    });
    return minWidth;
  }


  fixHeaderWidths() {
    this.fixCellWidths();
  }

  refreshHeaders() {
    const me = this;

    me.columns.traverse(column => {
      const headerElement = me.getBarCellElement(column.id);

      if (headerElement) {
        const classList = new DomClassList({
          'b-grid-header': 1,
          'b-grid-header-parent': column.isParent,
          [`b-level-${column.childLevel}`]: 1,
          [`b-depth-${column.meta.depth}`]: 1,
          [`b-grid-header-align-${column.align}`]: column.align,
          'b-grid-header-resizable': column.resizable && column.isLeaf,
          [column.cls]: column.cls,
          'b-last-parent': column.isParent && column.isLastInSubGrid,
          'b-last-leaf': column.isLeaf && column.isLastInSubGrid
        });
        let html = column.text;
        headerElement.className = classList;

        if (column.headerRenderer) {
          html = column.headerRenderer.call(column.thisObj || me, {
            column,
            headerElement
          });
        }

        if (column.icon) {
          html = `<i class="${column.icon}"></i>` + (html || '');
        }

        const innerEl = headerElement.querySelector('.b-grid-header-text-content');

        if (innerEl) {
          innerEl.innerHTML = html || '';
        }
      }
    });
    me.fixHeaderWidths();
  }

  get columns() {
    const me = this,
      result = super.columns;

    if (!me.columnsDetacher) {


      me.columnsDetacher = result.on({
        change() {
          me.initDepths();
        },

        thisObj: me
      });
      me.initDepths();
    }

    return result;
  }

  set columns(columns) {
    super.columns = columns;
  }


  initDepths(columns = this.columns.topColumns, parent = null) {
    let me = this,
      maxDepth = 0;
    if (parent && parent.meta) parent.meta.depth++;

    for (let column of columns) {

      column.meta.depth = 0;

      if (column.children) {
        me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);
        if (column.meta.depth && parent) parent.meta.depth += column.meta.depth;
      }

      if (column.meta.depth > maxDepth) maxDepth = column.meta.depth;
    }

    if (!parent) {
      me.maxDepth = maxDepth;
    }

    return maxDepth;
  }


  getHeader(columnId) {
    return this.getBarCellElement(columnId);
  }

  get contentElement() {
    return this.element.firstElementChild;
  }

  refreshContent() {
    const me = this;
    me.content = me.columns.topColumns.map(col => me.contentTemplate(col)).join('');
    me.refreshHeaders();
  }

  onPaint({
            firstPaint
          }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }

}

Header._$name = 'Header';


const domEventHandlers = {
  touchstart: 'onElementTouchStart',
  touchmove: 'onElementTouchMove',
  touchend: 'onElementTouchEnd',
  mouseover: 'onElementMouseOver',
  mouseout: 'onElementMouseOut',
  mousedown: 'onElementMouseDown',
  mousemove: 'onElementMouseMove',
  mouseup: 'onElementMouseUp',
  click: 'onHandleElementClick',
  dblclick: 'onElementDblClick',
  keydown: 'onElementKeyDown',
  keyup: 'onElementKeyUp',
  keypress: 'onElementKeyPress',
  contextmenu: 'onElementContextMenu',
  focus: 'onGridElementFocus'
};


var GridElementEvents = (Target => class GridElementEvents extends (Target || Base) {

  static get defaultConfig() {
    return {

      longPressTime: 400
    };
  }


  initInternalEvents() {
    const handledEvents = Object.keys(domEventHandlers),
      len = handledEvents.length,
      listeners = {
        element: this.element,
        thisObj: this
      };


    for (let i = 0; i < len; i++) {
      listeners[handledEvents[i]] = 'handleEvent';
    }

    EventHelper.on(listeners);
  }


  getEventData(event) {
    const me = this,
      cellElement = DomHelper.up(event.target, '.b-grid-cell');

    if (cellElement) {
      const cellData = DomDataStore.get(cellElement),
        {
          id,
          columnId
        } = cellData,
        record = me.store.getById(id);


      return record ? {
        cellElement,
        cellData,
        columnId,
        id,
        record,
        cellSelector: {
          id,
          columnId
        }
      } : null;
    }
  }


  handleEvent(event) {
    if (!this.disabled) {
      this.event = event;

      if (domEventHandlers[event.type]) {
        this[domEventHandlers[event.type]](event);
      }
    }
  }


  onElementTouchStart(event) {
    const me = this;
    DomHelper.isTouchEvent = true;

    if (event.touches.length === 1) {
      me.longPressTimeout = setTimeout(() => {
        me.onElementLongPress(event);
        event.preventDefault();
        me.longPressPerformed = true;
      }, me.longPressTime);
    }
  }


  onElementTouchMove(event) {
    if (this.longPressTimeout) {
      clearTimeout(this.longPressTimeout);
      this.longPressTimeout = null;
    }
  }


  onElementTouchEnd(event) {
    const me = this;

    if (me.longPressPerformed) {
      if (event.cancelable) {
        event.preventDefault();
      }

      me.longPressPerformed = false;
    }

    if (me.longPressTimeout) {
      clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
  }

  onElementLongPress(event) {
  }


  triggerCellMouseEvent(name, event) {
    const me = this,
      cellData = me.getEventData(event);

    if (cellData) {
      const column = me.columns.getById(cellData.columnId);
      me.trigger('cell' + StringHelper.capitalizeFirstLetter(name), {
        grid: this,
        record: cellData.record,
        column,
        cellSelector: cellData.cellSelector,
        cellElement: cellData.cellElement,
        target: event.target,
        event
      });
    }
  }


  onElementMouseDown(event) {
    const me = this,
      cellData = me.getEventData(event);
    me.skipFocusSelection = true;
    me.triggerCellMouseEvent('mousedown', event);

    if (cellData && !event.defaultPrevented) {
      me.onFocusGesture(cellData, event);
    }
  }


  onElementMouseMove(event) {


    this.mouseMoveEvent = event;
  }


  onElementMouseUp(event) {
  }


  onHandleElementClick(event) {
    if (this.trigger('beforeElementClick', {
      event
    }) !== false) {
      this.onElementClick(event);
    }
  }


  onElementClick(event) {
    const me = this,
      cellData = me.getEventData(event);

    if (cellData) {
      me.triggerCellMouseEvent('click', event);


      DomDataStore.get(cellData.cellElement).row.removeCls('b-hover');
    }
  }

  onFocusGesture(cellData, event) {

    if (cellData) {
      this.focusCell(cellData.cellSelector, {
        scroll: false,
        doSelect: true,
        event
      });
    }
  }


  onElementDblClick(event) {
    const me = this,
      target = event.target;
    me.triggerCellMouseEvent('dblClick', event);

    if (target.classList.contains('b-grid-header-resize-handle')) {
      const header = DomHelper.up(target, '.b-grid-header'),
        column = me.columns.getById(header.dataset.columnId);
      column.resizeToFitContent();
    }
  }


  onElementMouseOver(event) {

    if (!this.scrolling) {
      const cellElement = DomHelper.up(event.target, '.b-grid-cell');

      if (cellElement) {
        const row = DomDataStore.get(cellElement).row;


        if (row && (typeof event.buttons !== 'number' || event.buttons === 0)) {
          this.hoveredRow = row;
        }

        this.triggerCellMouseEvent('mouseOver', event);
      }


      this.trigger('mouseOver', {
        event
      });
    }
  }


  onElementMouseOut(event) {
    this.hoveredRow = null;

    if (!this.scrolling) {
      const cellElement = DomHelper.up(event.target, '.b-grid-cell');

      if (cellElement) {
        this.triggerCellMouseEvent('mouseOut', event);
      }


      this.trigger('mouseOut', {
        event
      });
    }
  }

  set hoveredRow(row) {
    const me = this;

    if (me._hoveredRow && !me._hoveredRow.isDestroyed) {
      me._hoveredRow.removeCls('b-hover');

      me._hoveredRow = null;
    }

    if (row && !me.scrolling) {
      me._hoveredRow = row;
      row.addCls('b-hover');
    }
  }


  onElementKeyDown(event) {
    const me = this;


    if (event.handled) return;

    if (event.target.matches('.b-grid-header.b-depth-0')) {
      me.handleHeaderKeyDown(event);
    } else if (event.target === me.focusElement || BrowserHelper.isIE11 && event.currentTarget === me.focusElement) {

      me.handleViewKeyDown(event);
    } else if (event.key === 'Escape' && me.isActionableLocation) {
      const focusedCell = ObjectHelper.clone(me.focusedCell);
      focusedCell.element = null;
      me.focusCell(focusedCell);
      DomHelper.focusWithoutScrolling(me.element);
    }
  }

  handleViewKeyDown(event) {
    const me = this;

    switch (event.key) {
      case 'ArrowLeft':
        event.preventDefault();
        return me.navigateLeft(event);

      case 'ArrowRight':
        event.preventDefault();
        return me.navigateRight(event);

      case 'ArrowUp':
        event.preventDefault();
        return me.navigateUp(event);

      case 'ArrowDown':
        event.preventDefault();
        return me.navigateDown(event);
    }
  }

  handleHeaderKeyDown(event) {
    const me = this,
      column = me.columns.getById(event.target.dataset.columnId);
    column.onKeyDown && column.onKeyDown(event);

    switch (event.key) {
      case 'ArrowLeft':
        const prev = me.columns.getAdjacentVisibleLeafColumn(column, false);

        if (prev) {
          const element = me.getHeaderElement(prev.id);
          element.focus();
        }

        break;

      case 'ArrowRight':
        const next = me.columns.getAdjacentVisibleLeafColumn(column, true);

        if (next) {
          const element = me.getHeaderElement(next.id);
          element.focus();
        }

        break;

      case 'Enter':
        const element = me.getHeaderElement(column.id);
        element.click();
        break;
    }
  }


  onElementKeyPress(event) {
  }


  onElementKeyUp(event) {
  }


  onElementContextMenu(event) {
    const me = this,
      cellData = me.getEventData(event);

    if (cellData) {
      me.triggerCellMouseEvent('contextMenu', event);


      if (DomHelper.isTouchEvent) {
        me.onFocusGesture(cellData, event);
      }
    }
  }


  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const me = this;

    if (me._devicePixelRatio && me._devicePixelRatio !== window.devicePixelRatio) {

      DomHelper.resetScrollBarWidth();
    }

    me._devicePixelRatio = window.devicePixelRatio;

    me._bodyRectangle = Rectangle.client(me.bodyContainer);
    super.onInternalResize(...arguments);

    if (height !== oldHeight) {
      me._bodyHeight = me.bodyContainer.offsetHeight;

      if (me.isPainted) {


        me.rowManager.initWithHeight(me._bodyHeight);
      }
    }

    me.refreshVirtualScrollbars();

    if (width !== oldWidth) {

      me.setTimeout(() => {
        if (!me.isDestroyed) {
          me.updateResponsive(width, oldWidth);
        }
      }, 0);
    }
  }


  get widgetClass() {
  }

});


let validConfigTypes = {
  string: 1,
  object: 1,
  function: 1

};


var GridFeatures = (Target => class GridFeatures extends (Target || Base) {


  set features(features) {
    const me = this,
      defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);
    features = me._features = ObjectHelper.assign({}, features);

    if (defaultFeatures) {
      Object.entries(defaultFeatures).forEach(([as, featureClass]) => {
        if (!(as in features)) {
          features[as] = true;
        }
      });
    }


    let featureName, config, featureClass;
    const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);

    for (featureName of Object.keys(features)) {
      config = features[featureName];


      if (config) {

        if (StringHelper.lowercaseFirstLetter(featureName) !== featureName) {
          throw new Error(me.L('invalidFeatureNameFormat', featureName));
        }

        featureClass = registeredInstanceFeatures[featureName];

        if (!featureClass) {
          throw new Error(me.L('featureNotFound', featureName));
        }


        Reflect.defineProperty(features, featureName, me.createFeatureInitializer(features, featureName, featureClass, config));
      }
    }
  }

  get features() {
    return this._features;
  }

  createFeatureInitializer(features, featureName, featureClass, config) {
    const constructorArgs = [this],
      construct = featureClass.prototype.construct;


    if (validConfigTypes[typeof config]) {
      constructorArgs[1] = config;
    }

    return {
      configurable: true,

      get() {

        delete features[featureName];


        featureClass.prototype.construct = function (...args) {
          features[featureName] = this;
          construct.apply(this, args);
          featureClass.prototype.construct = construct;
        };

        return new featureClass(...constructorArgs);
      }

    };
  }


  hasFeature(name) {
    return !!(this.features && this.features[name]);
  }


  get widgetClass() {
  }

});


const defaultFocusOptions = Object.freeze({
    doSelect: true
  }),
  disableScrolling = Object.freeze({
    x: false,
    y: false
  });


var GridNavigation = (Target => class GridNavigation extends (Target || Base) {


  get focusedCell() {
    const result = this._focusedCell;

    if (result && this.getCell(result)) {
      return result;
    }

    this.clearFocus();
  }


  get isActionableLocation() {
    const focusedCell = this._focusedCell;
    return Boolean(focusedCell && focusedCell.element && this.getCell(focusedCell).contains(focusedCell.element));
  }

  set focusedCell(cellSelector) {
    this.focusCell(cellSelector, {
      doSelect: false
    });
  }

  get focusedRecord() {
    if (this._focusedCell) {
      return this.store.getById(this._focusedCell.id);
    }
  }


  get cellCSSSelector() {
    const me = this,
      cell = me._focusedCell,
      row = cell && me.getRowById(cell.id);
    if (!cell || !row) return '';
    return `[data-index=${row.index}] [data-column-id=${cell.columnId}]`;
  }


  onGridElementFocus(event) {

    const me = this,
      focusOptions = {
        doSelect: false,
        event
      };

    if (me._focusedCell) {
      me.focusCell(me._focusedCell, focusOptions);
    } else {


      const targetContext = me.element.contains(event.relatedTarget) ? null : me.lastFocusedCell;

      if (targetContext) {
        const cell = me.getCell(targetContext);


        if (!cell || !DomHelper.isVisible(cell) || !me.store.getById(targetContext.id)) {
          me.revertFocus();
          return;
        }

        me.returningFocus = true;
        me.focusCell(targetContext, focusOptions);
        me.returningFocus = false;
      } else if (!me.scrolling && !me.skipFocusSelection && me.store.first) {
        const {
            mouseMoveEvent: evt,
            rowManager: rm,
            _bodyRectangle: r
          } = me,
          focusY = evt ? Math.min(Math.max(evt.clientY, r.y), r.bottom) : r.center.y,
          defaultRow = rm.getRowAt(focusY) || rm.rows[Math.floor(rm.rowCount / 2)],
          focusContext = evt && me.getEventData(evt) || {
            id: defaultRow.id,
            columnId: me.columns.visibleColumns[0].id
          };

        if (me.getCell(focusContext)) {
          me.focusCell(focusContext, focusOptions);
        }
      }
    }

    me.skipFocusSelection = false;
  }

  onFocusOut(event) {
    super.onFocusOut(event);
    this.clearFocus();
  }


  isFocused(cellSelector) {
    return Boolean(this._focusedCell) && this.isLocationEqual(cellSelector, this._focusedCell);
  }


  focusCell(cellSelector, options = defaultFocusOptions) {


    cellSelector = this.normalizeCellContext(cellSelector === Object ? Object.assign({}, cellSelector) : cellSelector);
    const me = this,
      doSelect = options.doSelect !== false,
      {
        event,
        scroll
      } = options,
      lastFocusedCell = me.lastFocusedCell = me._focusedCell,
      isNotMove = me.isLocationEqual(cellSelector, lastFocusedCell),
      lastCell = lastFocusedCell && me.getCell(lastFocusedCell),
      subGrid = me.getSubGridFromColumn(cellSelector.columnId);
    let cell = me.getCell(cellSelector);


    if (event && event.type === 'mousedown') {
      for (let target = event.target; target !== cell; target = target.parentElement) {
        if (DomHelper.isFocusable(target)) {
          cellSelector.element = target;
          return;
        }
      }
    }

    if (isNotMove) {
      if (event) {
        me.onCellNavigate && me.onCellNavigate(me, null, me._focusedCell, event, doSelect);
      }

      return cellSelector;
    }

    if (lastCell) {
      lastCell.classList.remove('b-focused');
    }

    const testCell = cell || me.getCell({
        row: me.rowManager.topIndex,
        columnId: cellSelector.columnId
      }),
      subGridRect = Rectangle.from(subGrid.element),
      bodyRect = Rectangle.from(me.bodyContainer),
      cellRect = Rectangle.from(testCell).moveTo(null, subGridRect.y);

    if (scroll === false) {
      options = Object.assign({}, options, disableScrolling);
    } else {
      options = Object.assign({}, options, scroll);

      if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {
        options.x = options.y = false;
      } else {
        options.column = cellSelector.columnId;
      }

      me.scrollRowIntoView(cellSelector.id, options);
    }


    cell = me.getCell(cellSelector);

    if (cell) {
      cellSelector.element = cell;
      cell.classList.add('b-focused');
    }

    me._focusedCell = cellSelector;
    me.onCellNavigate && me.onCellNavigate(me, lastFocusedCell, me._focusedCell, event, doSelect);
    me.trigger('navigate', {
      lastFocusedCell,
      focusedCell: me._focusedCell,
      event
    });

    return cellSelector;
  }

  isLocationEqual(cellSelector, otherCellSelector) {
    return cellSelector && otherCellSelector && cellSelector.id === otherCellSelector.id && cellSelector.columnId === otherCellSelector.columnId && (

      !cellSelector.element || !otherCellSelector.element || cellSelector.element === otherCellSelector.element);
  }

  blurCell(cellSelector) {
    const me = this,
      cell = me.getCell(cellSelector);

    if (cell) {
      cell.classList.remove('b-focused');
    }
  }

  clearFocus() {
    const me = this;

    if (me._focusedCell) {

      me.lastFocusedCell = me._focusedCell;
      me.blurCell(me._focusedCell);
      me._focusedCell = null;
    }
  }


  internalNextPrevCell(next = true, event) {
    const me = this,
      cellSelector = me._focusedCell;

    if (cellSelector) {
      return me.focusCell({
        id: cellSelector.id,
        columnId: me.columns.getAdjacentVisibleLeafColumn(cellSelector.columnId, next, true).id
      }, {
        doSelect: true,
        event
      });
    }

    return null;
  }


  navigateRight(event) {
    return this.internalNextPrevCell(true, event);
  }


  navigateLeft(event) {
    return this.internalNextPrevCell(false, event);
  }


  internalNextPrevRow(next, skipSpecialRows = true, event) {
    const me = this,
      cell = me._focusedCell;
    if (!cell) return false;
    const record = me.store[`get${next ? 'Next' : 'Prev'}`](cell.id, false, skipSpecialRows);
    if (!record) return false;
    return me.focusCell({
      id: record.id,
      columnId: cell.columnId,
      scroll: {
        x: false
      }
    }, {
      doSelect: true,
      event
    });
  }


  navigateDown(event) {
    return this.internalNextPrevRow(true, false, event);
  }


  navigateUp(event) {
    return this.internalNextPrevRow(false, false, event);
  }


  get widgetClass() {
  }

});


var GridResponsive = (Target => class GridResponsive extends (Target || Base) {
  static get defaultConfig() {
    return {

      responsiveLevels: Object.freeze({
        small: 400,
        medium: 600,
        large: '*'
      })
    };
  }


  getClosestBiggerLevel(width) {
    let me = this,
      levels = Object.keys(me.responsiveLevels),
      useLevel = null,
      minDelta = 99995,
      biggestLevel = null;
    levels.forEach(level => {
      let levelSize = me.responsiveLevels[level];

      if (!['number', 'string'].includes(typeof levelSize)) {
        levelSize = levelSize.levelWidth;
      }

      if (levelSize === '*') {
        biggestLevel = level;
      } else if (width < levelSize) {
        const delta = levelSize - width;

        if (delta < minDelta) {
          minDelta = delta;
          useLevel = level;
        }
      }
    });
    return useLevel || biggestLevel;
  }


  get responsiveLevel() {
    return this.getClosestBiggerLevel(this.width);
  }


  updateResponsive(width, oldWidth) {
    const me = this,
      oldLevel = me.getClosestBiggerLevel(oldWidth),
      level = me.getClosestBiggerLevel(width);

    if (oldLevel !== level) {

      const levelConfig = me.responsiveLevels[level];

      if (!['number', 'string'].includes(typeof levelConfig)) {
        me.applyState(levelConfig);
      }

      me.columns.forEach(column => {
        const levels = column.responsiveLevels;

        if (levels) {
          if (levels[level]) {

            column.applyState(levels[level]);
          } else if (levels['*']) {
            column.applyState(levels['*']);
          }
        }
      });
      me.element.classList.remove('b-responsive-' + oldLevel);
      me.element.classList.add('b-responsive-' + level);


      me.trigger('responsive', {
        level,
        width,
        oldLevel,
        oldWidth
      });
    }
  }


  get widgetClass() {
  }

});

const validIdTypes = {
    string: 1,
    number: 1
  },
  isSelectAction = {
    dataset: 1,
    batch: 1
  };


var GridSelection = (Target => class GridSelection extends (Target || Base) {
  static get defaultConfig() {
    return {

      selectionMode: {
        row: true,
        cell: true,
        rowCheckboxSelection: false,
        multiSelect: true,
        checkbox: false,
        showCheckAll: false
      },
      selectedRecordCollection: {}
    };
  }

  afterConfigure() {
    const me = this;

    if (me.selectionMode.checkbox) {
      const checkColumnClass = ColumnStore.getColumnClass('check');

      if (!checkColumnClass) {
        throw new Error('CheckColumn must be imported for checkbox selection mode to work');
      }

      const col = me.checkboxColumn = new checkColumnClass({
        id: `${me.id}-selection-column`,
        width: '4em',
        minWidth: '4em',

        field: null,
        cellCls: 'b-checkbox-selection',

        region: Object.keys(me.subGridConfigs).sort()[0],
        showCheckAll: me.selectionMode.showCheckAll
      }, me.columns);
      col.meta.depth = 0;

      col._grid = me;

      const checkboxRenderer = col.renderer;

      col.renderer = renderData => {
        renderData.value = me.isSelected(renderData.record);
        checkboxRenderer.call(col, renderData);
      };

      col.on({
        toggle: 'onCheckChange',
        toggleAll: 'onCheckAllChange',
        thisObj: me
      });

      const insertIndex = me.columns.indexOf(me.columns.findRecord('type', 'rownumber')) + 1;
      me.columns.insert(insertIndex, col);
    }

    super.afterConfigure();
    me.store.on('idChange', me.onRecordIdChange, me);
  }


  onRecordIdChange({
                     record,
                     oldValue,
                     value
                   }) {
    const {
        selectedRecordCollection
      } = this,
      item = selectedRecordCollection.get(oldValue);

    if (item === record) {
      selectedRecordCollection.rebuildIndices();
    }
  }


  onSelectedRecordCollectionChange({
                                     source: selectedRecordCollection,
                                     action,
                                     added = [],
                                     removed
                                   }) {
    const me = this;

    if (me._selectedCell && !me.isSelectable(me._selectedCell)) {
      me.deselectCell(me._selectedCell);
    }

    added = added.filter(row => me.isSelectable(row));
    me.triggerChangeEvent({
      mode: 'row',
      action: added.length ? 'select' : 'deselect',
      selection: me.selectedRecords,
      selected: added,
      deselected: removed
    }, me.silent);
  }

  onCheckChange({
                  source: column,
                  checked,
                  record
                }) {
    if (checked) {
      this.selectRow({
        record,
        column,
        addToSelection: this.selectionMode.multiSelect !== false,
        scrollIntoView: false
      });

      if (column.headerCheckbox && this.selectedRecords.length === this.store.count - (this.store.groupRecords ? this.store.groupRecords.length : 0)) {
        column.suspendEvents();
        column.headerCheckbox.checked = true;
        column.resumeEvents();
      }
    } else {
      this.deselectRow(record);

      if (column.headerCheckbox) {
        column.suspendEvents();
        column.headerCheckbox.checked = false;
        column.resumeEvents();
      }
    }
  }

  onCheckAllChange({
                     checked
                   }) {
    this[checked ? 'selectAll' : 'deselectAll']();
  }

  onElementKeyDown(event) {
    const me = this,
      {
        focusedCell,
        checkboxColumn
      } = me;
    super.onElementKeyDown(event);

    if (focusedCell && event.key === ' ' && checkboxColumn && me.columns.getById(focusedCell.columnId) === checkboxColumn) {
      const checkbox = me.getCell(focusedCell).widget;

      if (checkbox) {
        checkbox.toggle();
      }
    }
  }


  set selectedRecordCollection(selectedRecordCollection) {
    if (!(selectedRecordCollection instanceof Collection)) {
      selectedRecordCollection = new Collection(selectedRecordCollection);
    }

    this._selectedRecordCollection = selectedRecordCollection;

    selectedRecordCollection.on({
      change: 'onSelectedRecordCollectionChange',
      thisObj: this
    });
  }

  get selectedRecordCollection() {
    return this._selectedRecordCollection;
  }


  spliceSelectedRecords(index, toRemove, toAdd) {
    this._selectedRecordCollection.splice(index, toRemove, toAdd);
  }


  isSelected(cellSelectorOrId) {
    const me = this;

    if (cellSelectorOrId instanceof Model) {
      cellSelectorOrId = cellSelectorOrId.id;
    }

    if (validIdTypes[typeof cellSelectorOrId]) {
      return me.selectedRecordCollection.includes(cellSelectorOrId);
    } else {
      return me._selectedCell && me._selectedCell.id == cellSelectorOrId.id && me._selectedCell.columnId === cellSelectorOrId.columnId;
    }
  }


  isSelectable(recordCellOrId) {


    if (!recordCellOrId) {
      return false;
    }

    const row = this.store.getById(recordCellOrId.id || recordCellOrId);
    return row && !(row.meta && row.meta.specialRow);
  }


  get selectedCell() {
    return this._selectedCell;
  }

  set selectedCell(cellSelector) {
    this.selectCell(cellSelector);
  }

  set selectionMode(mode) {
    if (mode && mode.rowCheckboxSelection) {
      mode.row = mode.checkbox = true;
      mode.cell = false;
    }

    this._selectionMode = mode;
  }

  get selectionMode() {
    return this._selectionMode;
  }


  get selectedRecord() {
    return this.selectedRecordCollection.last || null;
  }

  set selectedRecord(record) {
    this.selectRow({
      record
    });
  }


  get selectedRecords() {
    return this.selectedRecordCollection.values;
  }

  set selectedRecords(selectedRecords) {
    const {
        selectedRecordCollection,
        store
      } = this,
      toSelect = [];

    if (selectedRecords) {
      for (let record of selectedRecords) {
        record = store.getById(record);

        if (record) {
          toSelect.push(record);
        }
      }
    }

    selectedRecordCollection.splice(0, selectedRecordCollection.count, toSelect);
  }


  get selectedCellCSSSelector() {
    const me = this,
      cell = me._selectedCell,
      row = cell && me.getRowById(cell.id);
    if (!cell || !row) return '';
    return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;
  }


  selectRow({
              record,
              column = this.columns.bottomColumns[0],
              scrollIntoView = true,
              addToSelection = false
            }) {

    if (typeof arguments[0] !== 'object') {
      const args = arguments;
      record = args[0];
      scrollIntoView = args.length > 1 ? args[1] : true;
      addToSelection = args[2] || false;
    }

    const me = this,
      targetRecord = me.store.getById(record);

    if (record) {
      me.selectCell({
        id: targetRecord.id,
        column
      }, scrollIntoView, addToSelection);
    } else {
      me.deselectAll();
    }
  }


  selectCell(cellSelector, scrollIntoView = false, addToSelection = false, silent = false) {
    const me = this,
      {
        selectedRecordCollection,
        selectionMode
      } = me,
      selector = me.normalizeCellContext(cellSelector),
      record = selector.record || me.store.getById(selector.id);

    if (!me.isSelectable(record)) {
      this.deselectAll();
      return;
    }

    if (scrollIntoView) {
      me.scrollRowIntoView(selector.id, {
        column: selector.columnId
      });
    }

    if (selectionMode.row) {
      if (silent) {
        me.silent = (me.silent || 0) + 1;
      }

      if (addToSelection) {
        selectedRecordCollection.add(record);
      } else {
        selectedRecordCollection.splice(0, selectedRecordCollection.count, record);
      }

      if (silent) {
        me.silent--;
      }

      if (me.selectedRecordCollection.count === 1) {
        me.startCell = selector;
        me.lastRange = null;
      }
    }

    if (selectionMode.cell && (selector.columnId || selector.column) && !me.isSelected(selector)) {
      const deselected = me._selectedCell ? [me._selectedCell] : [];

      me._selectedCell = selector;
      me.triggerChangeEvent({
        mode: 'cell',
        action: 'select',
        selected: [selector],
        deselected,
        selection: [selector]
      }, silent);
    }

    return selector;
  }


  selectAll() {
    const me = this;

    if (me.store.isFiltered) {
      me.selectedRecordCollection.add(...me.store.records.filter(r => !r.meta.specialRow));
    } else {
      me.selectedRecords = me.store.records.filter(r => !r.meta.specialRow);
    }
  }


  deselectAll() {
    const me = this;

    if (me.store.isFiltered) {
      me.selectedRecordCollection.remove(...me.store.records.filter(r => !r.meta.specialRow));
    } else {
      me.selectedRecordCollection.clear();
    }

    if (me._selectedCell) {
      me.deselectCell(me._selectedCell);
    }
  }


  deselectRow(recordOrId) {
    const record = recordOrId instanceof Model ? recordOrId : this.store.getById(recordOrId);
    record && this.selectedRecordCollection.remove(record);
  }


  deselectCell(cellSelector) {
    const me = this,
      selector = me.normalizeCellContext(cellSelector),
      selMode = me.selectionMode,
      record = selector.record || me.store.getById(selector.id),
      selectedCell = me._selectedCell;

    if (selMode.row) {
      me.selectedRecordCollection.remove(record);
    }

    if (selMode.cell && selector.columnId && selectedCell) {
      if (selectedCell.id === selector.id && selectedCell.columnId === selector.columnId) {
        me._selectedCell = null;
        me.triggerChangeEvent({
          mode: 'cell',
          action: 'deselect',
          selected: [],
          deselected: [selector],
          selection: []
        });
      }
    }

    return selector;
  }


  selectRange(fromId, toId) {
    const {
        store,
        selectedRecordCollection
      } = this,
      fromIndex = store.indexOf(fromId),
      toIndex = store.indexOf(toId),
      startIndex = Math.min(fromIndex, toIndex),
      endIndex = Math.max(fromIndex, toIndex);

    if (startIndex === -1 || endIndex === -1) {
      throw new Error('Record not found in selectRange');
    }

    selectedRecordCollection.splice(0, selectedRecordCollection.count, store.getRange(startIndex, endIndex + 1, false));
  }


  onStoreRemove(event) {

    super.onStoreRemove && super.onStoreRemove(event);
    this.selectedRecordCollection.remove(event.records);
  }


  onStoreDataChange({
                      action,
                      source: store
                    }) {

    super.onStoreDataChange && super.onStoreDataChange(...arguments);

    if (isSelectAction[action]) {
      const selectedRecords = this.selectedRecordCollection,
        toRemove = [];
      selectedRecords.forEach(record => {

        if (store.includes(record)) {
          selectedRecords.splice(selectedRecords.indexOf(record), 1, store.getById(record.id));
        } else {
          toRemove.push(record);
        }
      });

      selectedRecords.remove(toRemove);
    }
  }


  onStoreRemoveAll() {

    super.onStoreRemoveAll && super.onStoreRemoveAll();
    this.deselectAll();
  }


  handleMouseMultiSelect(cellData, event) {
    const me = this,
      id = cellData.id;

    function mergeRange(fromId, toId) {
      const {
          store,
          selectedRecordCollection
        } = me,
        fromIndex = store.indexOf(fromId),
        toIndex = store.indexOf(toId),
        startIndex = Math.min(fromIndex, toIndex),
        endIndex = Math.max(fromIndex, toIndex);

      if (startIndex === -1 || endIndex === -1) {
        throw new Error('Record not found in selectRange');
      }

      const newRange = store.getRange(startIndex, endIndex + 1, false).filter(row => me.isSelectable(row));
      selectedRecordCollection.splice(0, me.lastRange || 0, newRange);
      me.lastRange = newRange;
    }

    if ((event.metaKey || event.ctrlKey) && me.isSelected(id)) {

      me.deselectRow(id);
    } else if (me.selectionMode.multiSelect) {
      if (event.shiftKey && me.startCell) {

        mergeRange(me.startCell.id, id);
      } else if (event.ctrlKey || event.metaKey) {

        me.selectRow({
          record: id,
          scrollIntoView: false,
          addToSelection: true
        });
      }
    }
  }


  onCellNavigate(me, fromCellSelector, toCellSelector, event, doSelect = true) {

    if (me.columns.getById(toCellSelector.columnId) === me.checkboxColumn || me.selectionMode.rowCheckboxSelection) {
      return;
    }


    if (!doSelect || me.returningFocus || event && event.target.closest('.b-tree-expander')) {
      return;
    }

    const isSameRecord = fromCellSelector && toCellSelector.id === fromCellSelector.id,
      isMouse = event && event.type === 'mousedown',
      isMouseCtrl = isMouse && event.ctrlKey;

    if (event && (!event.button || event.button === 2) && (event.shiftKey || isMouseCtrl)) {
      me.handleMouseMultiSelect(toCellSelector, event);
    } else {
      me.selectCell(toCellSelector, false, isSameRecord && (!event || event.shiftKey || event.ctrlKey) || event && (isMouseCtrl || event.button === 2 && me.isSelected(toCellSelector.id)));
    }

    if (!me.startCell || isMouseCtrl) {
      me.startCell = toCellSelector;
      me.lastRange = null;
    }
  }


  triggerChangeEvent(selectionChangeEvent, silent) {
    const me = this,
      {
        mode,
        selected,
        deselected
      } = selectionChangeEvent;
    let i, len, row, cell;


    if (mode === 'row') {
      for (i = 0, len = selected.length; i < len; i++) {
        row = me.getRowFor(selected[i]);

        if (row) {
          row.addCls('b-selected');

          if (me.checkboxColumn && !me.checkboxColumn.hidden && !selected[i].meta.specialRow) {
            row.getCell(me.checkboxColumn.id).widget.checked = true;
          }
        }
      }

      for (i = 0, len = deselected.length; i < len; i++) {
        row = me.getRowFor(deselected[i]);

        if (row) {
          row.removeCls('b-selected');

          if (me.checkboxColumn && !me.checkboxColumn.hidden && !deselected[i].meta.specialRow) {
            row.getCell(me.checkboxColumn.id).widget.checked = false;
          }
        }
      }
    } else if (mode === 'cell') {
      for (i = 0, len = selected.length; i < len; i++) {
        cell = me.getCell(selected[i]);

        if (cell) {
          cell.classList.add('b-selected');
        }
      }

      for (i = 0, len = deselected.length; i < len; i++) {
        cell = me.getCell(deselected[i]);

        if (cell) {
          cell.classList.remove('b-selected');
        }
      }
    }

    if (!silent) {
      me.trigger('selectionChange', selectionChangeEvent);
    }
  }


  get widgetClass() {
  }

});


const suspendStoreEvents = subGrid => subGrid.columns.suspendEvents(),
  resumeStoreEvents = subGrid => subGrid.columns.resumeEvents(),
  fillSubGridColumns = subGrid => {
    subGrid.columns.clearCaches();
    subGrid.columns.fillFromMaster();
  },
  compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;


var GridState = (Target => class GridState extends (Target || Base) {

  getState() {
    const me = this,
      style = me.element.style.cssText,
      state = {
        rowHeight: me.rowHeight,
        readOnly: me.readOnly
      };

    if (style) {
      state.style = style;
    }

    if (me.selectedCell) {

      const {
        id,
        columnId
      } = me.selectedCell;
      state.selectedCell = {
        id,
        columnId
      };
    }

    state.selectedRecords = me.selectedRecords.map(entry => entry.id);
    state.columns = me.columns.map(column => column.getState());
    state.store = me.store.state;
    state.scroll = me.storeScroll();
    state.width = {};
    state.collapsed = {};
    me.eachSubGrid(subGrid => {
      if (subGrid.flex == null) {
        state.width[subGrid.region] = subGrid.width;
      }

      state.collapsed[subGrid.region] = subGrid.collapsed;
    });
    return state;
  }


  applyState(state) {
    const me = this;

    if ('readOnly' in state) {
      me.readOnly = state.readOnly;
    }

    if ('rowHeight' in state) {
      me.rowHeight = state.rowHeight;
    }

    if ('style' in state) {
      me.style = state.style;
    }

    if ('selectedCell' in state) {
      me.selectedCell = state.selectedCell;
    }

    if ('store' in state) {
      me.store.state = state.store;
    }

    if ('selectedRecords' in state) {
      me.selectedRecords = state.selectedRecords;
    }

    if ('columns' in state) {
      let columnsChanged = false,
        needSort = false;

      me.columns.suspendEvents();
      me.eachSubGrid(suspendStoreEvents);

      state.columns.forEach((columnState, index) => {
        const column = me.columns.getById(columnState.id);

        if (column) {
          const columnGeneration = column.generation;
          column.applyState(columnState);
          columnsChanged = columnsChanged || column.generation !== columnGeneration;

          column.stateSortIndex = index;

          if (column.allIndex !== index) {
            needSort = columnsChanged = true;
          }
        }
      });

      if (columnsChanged) {
        me.eachSubGrid(fillSubGridColumns);
      }

      if (needSort) {
        me.eachSubGrid(subGrid => {
          subGrid.columns.records.sort(compareStateSortIndex);
          subGrid.columns.allRecords.sort(compareStateSortIndex);
        });
        me.columns.sort({
          fn: compareStateSortIndex,

          ascending: true
        });
      }

      if (me.isPainted && columnsChanged) {
        me.renderContents();
      }

      me.columns.resumeEvents();
      me.eachSubGrid(resumeStoreEvents);
    }

    if ('width' in state) {
      me.eachSubGrid(subGrid => {
        if (subGrid.region in state.width) {
          subGrid.width = state.width[subGrid.region];
        }
      });
    }

    if ('collapsed' in state) {
      me.eachSubGrid(subGrid => {
        subGrid.collapsed = state.collapsed[subGrid.region];
      });
    }

    if ('scroll' in state) {
      me.restoreScroll(state.scroll);
    }
  }


  get widgetClass() {
  }

});


const immediatePromise$4 = new Promise(resolve => resolve()),
  defaultScrollOptions$1 = {
    block: 'nearest'
  };


class SubGridScroller extends Scroller {
  scrollIntoView(element, options = defaultScrollOptions$1) {
    const me = this,
      {
        xDelta,
        yDelta
      } = me.getDeltaTo(element, options),
      result = xDelta || yDelta ? me.scrollBy(xDelta, yDelta, options) : immediatePromise$4;

    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (element instanceof Rectangle) {
            element.translate(-xDelta, -yDelta).highlight();
          } else {
            DomHelper.highlight(element);
          }
        }

        options.focus && element.focus && element.focus();
      });
    }

    return result;
  }

  scrollBy(xDelta, yDelta, options) {
    const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options),
      xPromise = xDelta && super.scrollBy(xDelta, 0, options);

    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel,
        cancelY = yPromise.cancel;

      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };

      return Promise.all([xPromise, yPromise]);
    }

    return xPromise || yPromise;
  }

  scrollTo(toX, toY, options) {
    const yPromise = toY != null && this.yScroller.scrollTo(null, toY, options),
      xPromise = toX != null && super.scrollTo(toX, null, options);


    if (!(options && options.animate)) {
      this.syncPartners();
    }

    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel,
        cancelY = yPromise.cancel;

      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };

      return Promise.all([xPromise, yPromise]);
    }

    return xPromise || yPromise;
  }

  get viewport() {
    return Rectangle.from(this.element).intersect(Rectangle.from(this.yScroller.element));
  }

  set y(y) {
    if (this.yScroller) {
      this.yScroller.y = y;
    }
  }

  get y() {
    return this.yScroller ? this.yScroller.y : 0;
  }

  get maxY() {
    return this.yScroller ? this.yScroller.maxY : 0;
  }

  get scrollHeight() {
    return this.yScroller ? this.yScroller.scrollHeight : 0;
  }

  get clientHeight() {
    return this.yScroller ? this.yScroller.clientHeight : 0;
  }

}

SubGridScroller._$name = 'SubGridScroller';


class SubGrid extends Widget {

  static get $name() {
    return 'SubGrid';
  }


  static get defaultConfig() {
    return {
      localizableProperties: ['emptyText'],
      localeClass: 'Grid',
      insertRowsBefore: null,
      appendTo: null,
      hideHeaders: null,
      monitorResize: true,


      collapsed: null,
      scrollable: {


        overflowX: true
      },
      scrollerClass: SubGridScroller,


      hasCalculatedWidth: null,


      sealedColumns: null,
      emptyText: null
    };
  }


  construct(config) {
    const me = this;
    super.construct(config);
    me.initHeader();
    me.rowManager.on('addrows', me.onAddRow, me);
  }

  doDestroy() {
    const me = this;
    me.header && me.header.destroy();
    me.footer && me.footer.destroy();
    me.fakeScroller && me.fakeScroller.destroy();
    me.virtualScrollerElement && me.virtualScrollerElement.remove();
    me.splitterElement && me.splitterElement.remove();
    super.doDestroy();
  }


  initHeader() {
    const me = this,
      sgStyle = me.element.style,
      sgWidth = sgStyle.width,
      sgFlex = sgStyle.flex,
      config = Object.assign({
        subGrid: me,
        hidden: me.hideHeaders,
        parent: me

      }, me.headerConfig);

    if (sgFlex) {
      config.flex = sgFlex;
    } else if (sgWidth) {
      config.width = sgWidth;
    }

    me.header = new me.headerClass(config);
  }


  initElements() {
    const me = this;
    me.footerElement = DomHelper.down(me.grid.element, '.b-grid-footer-scroller-' + me.region);
    me.updateHasFlex();
  }


  toggleSplitterCls(cls, add = true) {
    const me = this,
      splitters = [me.splitterElement, me.headerSplitter, me.footerSplitter, me.scrollerSplitter];
    splitters.forEach(el => el && el.classList[add ? 'add' : 'remove'](cls));
  }


  template() {
    const {
        grid,
        region
      } = this,
      isLastSubGrid = !grid || region === grid.regions[grid.regions.length - 1];


    return TemplateHelper.tpl`
            <div class="b-grid-subgrid b-grid-subgrid-${region} b-grid-horizontal-scroller ${this.collapsed ? 'b-grid-subgrid-collapsed' : ''}" data-region="${region}">
                <div reference="virtualScrollerElement" class="b-virtual-scroller" data-region="${region}">
                    <div reference="virtualScrollerWidth" class="b-virtual-width"></div>
                </div>
                ${isLastSubGrid ? '' : TemplateHelper.tpl`
                <div reference="splitterElement" data-region="${region}" class="b-grid-splitter ${this.collapsed ? 'b-grid-splitter-collapsed' : ''}">
                    <div class="b-grid-splitter-inner b-grid-splitter-main">
                        <div class="b-grid-splitter-buttons" reference="splitterButtons">
                            <i class="b-icon b-icon-collapse-gridregion"></i>
                            <i class="b-icon b-icon-expand-gridregion"></i>
                        </div>
                    </div>
                </div>`}
            </div>
        `;
  }

  rowTemplate() {
    return `<div class="b-grid-row">${this.columns.visibleColumns.map(this.cellTemplate).join('')}</div>`;
  }

  cellTemplate(column) {
    return `<div class="b-grid-cell" data-column="${column.field || ''}" data-column-id="${column.id}"></div>`;
  }


  render() {
    const me = this,
      {
        grid,
        region
      } = me,
      children = [{
        className: 'b-grid-splitter-inner'
      }],
      dataset = {
        region
      };

    if (grid) {

      grid.virtualScrollers.appendChild(me.virtualScrollerElement);
      me.renderHeader(grid.headerContainer);
      me.renderFooter(grid.footerContainer);
      me.initElements();
    }

    super.render(...arguments);

    if (me.splitterElement) {
      const className = me.splitterElement.className.trim();
      me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);

      if (me.header) {
        me.headerSplitter = DomHelper.createElement({
          className,
          children,
          dataset,
          parent: me.header.element.parentNode,
          nextSibling: me.header.element.nextSibling
        });
        EventHelper.on({
          element: me.headerSplitter,
          mouseenter: 'onSplitterMouseOver',
          mouseleave: 'onSplitterMouseOut',
          thisObj: me
        });
      }

      if (me.footer) {
        me.footerSplitter = DomHelper.createElement({
          className,
          children,
          dataset,
          parent: me.footer.element.parentNode,
          nextSibling: me.footer.element.nextSibling
        });
        EventHelper.on({
          element: me.footerSplitter,
          mouseenter: 'onSplitterMouseOver',
          mouseleave: 'onSplitterMouseOut',
          thisObj: me
        });
      }

      me.scrollerSplitter = DomHelper.createElement({
        className: `${className} b-splitter-scroller`,
        children,
        dataset,
        parent: me.virtualScrollerElement.parentNode,
        nextSibling: me.virtualScrollerElement.nextSibling
      });
      EventHelper.on({
        element: me.splitterElement,
        mouseenter: 'onSplitterMouseOver',
        mouseleave: 'onSplitterMouseOut',
        thisObj: me
      });
    }

    me._collapsed && me.collapse();
  }

  renderHeader(appendToElement) {
    if (this.header) {
      this.header.render(appendToElement, false);
    }
  }

  renderFooter(appendToElement) {
    if (this.footer) {
      this.footer.render(appendToElement, false);

      this.grid.footerContainer.classList.remove('b-hidden');
    }
  }

  refreshHeader() {
    this.header.refreshContent();
  }

  refreshFooter() {
    this.footer && this.footer.refreshContent();
  }

  eachWidget(fn, deep = true) {
    const me = this,
      widgets = [];

    if (me.header) {
      widgets.unshift(me.header);
    }

    if (me.footer) {
      widgets.push(me.footer);
    }

    for (let i = 0; i < widgets.length; i++) {
      const widget = widgets[i];

      if (fn(widget) === false) {
        return;
      }

      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    }
  }


  fixCellWidths(rowElement, visibleColumns = null) {
    if (!visibleColumns) visibleColumns = this.columns.bottomColumns.filter(col => !col.hidden);

    let cellElement = rowElement.firstElementChild,
      i = 0;

    while (cellElement) {
      const column = visibleColumns[i];

      if (column.minWidth) {
        DomHelper.setLength(cellElement, 'minWidth', column.minWidth);
      }

      if (column.flex) {
        cellElement.style.flex = column.flex;
        cellElement.style.width = '';
      } else if (column.width) {


        cellElement.style.flex = '';
        cellElement.style.width = DomHelper.setLength(column.width);


        if (BrowserHelper.isIE11) {
          cellElement.style.minWidth = cellElement.style.width;
        }
      } else {
        cellElement.style.flex = cellElement.style.width = cellElement.style.minWidth = '';
      }

      cellElement = cellElement.nextElementSibling;
      i++;
    }
  }

  get totalFixedWidth() {
    return this.columns.totalFixedWidth;
  }


  fixWidths() {
    const me = this,
      {
        element,
        header,
        footer
      } = me;

    if (!me.collapsed) {
      if (me.flex) {
        header.flex = me.flex;

        if (footer) {
          footer.flex = me.flex;
        }

        element.style.flex = me.flex;
      } else {


        if (me.hasCalculatedWidth && !me.columns.some(col => !col.hidden && col.flex) && me.totalFixedWidth !== me.width) {
          me.width = me.totalFixedWidth;


          me.hasCalculatedWidth = true;
          return;
        }

        let totalWidth = me.width;

        if (!totalWidth) {
          totalWidth = 0;


          for (const col of me.columns) {
            if (!col.flex && !col.hidden) totalWidth += col.width;
          }
        }


        element.style.width = `${totalWidth}px`;
        header.width = totalWidth;

        if (footer) {
          footer.width = totalWidth;
        }
      }

      me.syncScrollingPartners(false);
    }
  }

  fixRowWidthsInSafariEdge() {
    if (BrowserHelper.isSafari || BrowserHelper.isEdge) {
      const me = this,
        {
          region,
          header
        } = me,
        minWidth = header.calculateMinWidthForSafari();


      me.rowManager.forEach(row => {


        const element = row.getElement(region);


        if (element) {
          element.style.width = `${minWidth}px`;
        }
      });
      header.headersElement.style.width = `${minWidth}px`;
    }
  }


  set width(width) {
    const me = this;

    me.hasCalculatedWidth = false;
    super.width = width;
    if (me.header) me.header.width = width;
    if (me.footer) me.footer.width = width;

    if (me.isPainted) {
      me.onElementResize();
    }
  }

  get width() {
    return super.width;
  }


  set flex(flex) {
    const me = this;

    me.hasCalculatedWidth = false;
    if (me.header) me.header.flex = flex;
    if (me.footer) me.footer.flex = flex;
    super.flex = flex;

    if (me.isPainted) {
      me.onElementResize();
    }
  }

  get flex() {
    return super.flex;
  }


  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    const me = this,
      {
        grid
      } = me;

    super.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);

    if (me.splitterElement) {
      me.syncSplitterButtonPosition();
    }

    if (grid) {
      if (newWidth !== oldWidth) {

        grid.trigger('horizontalScroll', {
          subGrid: me,
          grid,
          scrollLeft: me.scrollable.x
        });
        me.refreshFakeScroll();
        me.fixRowWidthsInSafariEdge();
      }

      me.trigger('afterInternalResize', me);
    }
  }


  syncParallelSplitters(collapsed) {
    const me = this,
      {
        grid
      } = me;

    if (me.splitterElement) {
      me.toggleSplitterCls('b-grid-splitter-collapsed', collapsed);
    } else {

      const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));

      if (prevGrid && prevGrid.splitterElement) {
        prevGrid.syncParallelSplitters(collapsed);
      }
    }
  }

  onSplitterMouseOver() {
    const me = this,
      {
        nextSibling
      } = me;

    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.toggleSplitterCls('b-hover');
    }

    me.startSplitterButtonSyncing();
  }

  onSplitterMouseOut() {
    const me = this,
      {
        nextSibling
      } = me;
    me.toggleSplitterCls('b-hover', false);

    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.stopSplitterButtonSyncing();
    }
  }

  startSplitterButtonSyncing() {
    const me = this;

    if (me.splitterElement) {
      me.syncSplitterButtonPosition();

      if (!me.splitterSyncScrollListener) {
        me.splitterSyncScrollListener = me.grid.scrollable.on({
          scroll: 'syncSplitterButtonPosition',
          thisObj: me
        });
      }
    }
  }

  stopSplitterButtonSyncing() {
    if (this.splitterSyncScrollListener) {
      this.splitterSyncScrollListener();
      this.splitterSyncScrollListener = null;
    }
  }

  syncSplitterButtonPosition() {
    this.splitterButtons.style.transform = `translateY(${this.grid.scrollable.y + this.grid.bodyHeight / 2 - (this.headerSplitter ? this.grid.headerHeight : 0)}px)`;
  }


  get viewRectangle() {
    const me = this;
    return new Rectangle(me.scrollable.x, me.scrollable.y, me._width || 0, me.rowManager.viewHeight);
  }


  updateHasFlex() {
    const hasFlex = this.columns.visibleColumns.some(column => column.flex);
    DomHelper.toggleClasses(this.element, ['b-has-flex'], hasFlex);
  }


  refreshFakeScroll() {
    const me = this,
      {
        element,
        virtualScrollerElement,
        virtualScrollerWidth,
        totalFixedWidth,
        store
      } = me,
      scroller = me.scrollable;


    scroller.scrollWidth = store && store.count ? null : totalFixedWidth;
    virtualScrollerElement.style.width = `${element.offsetWidth}px`;


    if (totalFixedWidth > scroller.clientWidth) {
      element.classList.add('b-overflowing-horizontally');
    } else {
      element.classList.remove('b-overflowing-horizontally');
    }

    if (!me.collapsed) {


      if (scroller.scrollWidth > scroller.clientWidth + (BrowserHelper.isEdge ? 1 : 0)) {
        virtualScrollerWidth.style.width = `${scroller.scrollWidth}px`;
        me.header.element.classList.add('b-overflowing');
        me.footer && me.footer.element.classList.add('b-overflowing');
        me.overflowingHorizontally = true;


        me.grid.virtualScrollers.classList.remove('b-hide-display');
      } else {
        virtualScrollerWidth.style.width = 0;
        me.header.element.classList.remove('b-overflowing');
        me.footer && me.footer.element.classList.remove('b-overflowing');
        me.overflowingHorizontally = false;
      }
    }
  }


  initScroll() {
    const me = this,
      scroller = me.scrollable,
      virtualScrollerElement = me.virtualScrollerElement;
    me.syncPartnersOnFrame = me.createOnFrame(me.syncScrollingPartners);

    if (BrowserHelper.isFirefox) {
      scroller.element.addEventListener('wheel', event => {
        if (event.deltaX) {
          scroller.x += event.deltaX;
          event.preventDefault();
        }
      });
    }

    scroller.yScroller = me.grid.scrollable;

    scroller.yScroller.addScroller(scroller);

    me.fakeScroller = new Scroller({
      element: virtualScrollerElement,
      overflowX: true
    });


    scroller.on({
      scroll: 'onSubGridScroll',
      scrollend: 'onSubGridScrollEnd',
      thisObj: me
    });
    scroller.addPartner(me.fakeScroller, 'x');

    if (me.header) {
      scroller.addPartner(me.header.scrollable, 'x');
    }

    if (me.footer) {
      scroller.addPartner(me.footer.scrollable, 'x');
    }
  }

  onSubGridScrollEnd() {


    if (!this.forceScrollUpdate) {
      this.syncScrollingPartners();
    }

    this.scrolling = false;
  }

  onSubGridScroll() {


    if (this.forceScrollUpdate) {
      this.syncScrollingPartners();
      this.forceScrollUpdate = false;
    } else {
      this.syncPartnersOnFrame();
    }
  }

  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }

  get scrolling() {
    return this._scrolling;
  }


  syncScrollingPartners(addCls = true) {
    const subGrid = this,
      {
        grid
      } = subGrid;

    if (!subGrid.scrolling && addCls) {
      subGrid.scrolling = true;
    }

    grid.trigger('horizontalScroll', {
      subGrid,
      grid,
      scrollLeft: subGrid.scrollable.x
    });
  }


  scrollColumnIntoView(column, options) {
    const me = this,
      scroller = me.header.scrollable;

    column = column instanceof Column ? column : me.columns.get(column) || me.columns.getById(column) || me.columns.getAt(column);

    if (column) {

      const columnHeaderElement = me.header.getHeader(column.id);

      if (columnHeaderElement) {
        return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);
      }
    }
  }


  onAddRow({
             rows
           }) {
    const me = this,
      html = me.rowTemplate(),
      visibleColumns = me.columns.bottomColumns.filter(col => !col.hidden),
      frag = document.createDocumentFragment();
    rows.forEach(row => {
      const rowElement = DomHelper.createElementFromTemplate(html);
      frag.appendChild(rowElement);
      row.addElement(me.region, rowElement);

      me.fixCellWidths(rowElement, visibleColumns);
    });
    me.fixRowWidthsInSafariEdge();


    me.element.insertBefore(frag, me.insertRowsBefore);
  }


  get rowElements() {
    return this.fromCache('.b-grid-row', true);
  }


  clearRows() {
    this.emptyCache();
    const all = this.element.querySelectorAll('.b-grid-row'),
      range = document.createRange();

    if (all.length) {
      range.setStartBefore(all[0]);
      range.setEndAfter(all[all.length - 1]);
      range.deleteContents();
    }
  }

  addNewRowElement() {
    const rowElement = DomHelper.append(this.element, this.rowTemplate());
    this.fixCellWidths(rowElement);
    return rowElement;
  }

  get emptyText() {
    return this._emptyText;
  }

  set emptyText(text) {
    this._emptyText = text;
    this.element.dataset.emptyText = text;
  }


  toggleTransitionClasses(doRemove = false) {
    const me = this,
      grid = me.grid,
      nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),
      splitter = grid.resolveSplitter(nextRegion);
    nextRegion.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
    nextRegion.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
    me.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
    me.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
    splitter.classList[doRemove ? 'remove' : 'add']('b-grid-splitter-animate');
  }


  get collapsed() {
    return this._collapsed;
  }

  set collapsed(collapsed) {
    if (this.isConfiguring) {
      this._collapsed = collapsed;
    } else {
      if (collapsed) {
        this.collapse();
      } else {
        this.expand();
      }
    }
  }


  async collapse() {
    const me = this,
      grid = me.grid,
      nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),
      splitterOwner = me.splitterElement ? me : me.previousSibling;

    let expandedRegions = 0;
    grid.eachSubGrid(subGrid => {
      subGrid !== me && !subGrid._collapsed && ++expandedRegions;
    });

    if (expandedRegions === 0) {

      await nextRegion.expand();
    }

    return new Promise(resolve => {
      if (!me._beforeCollapseState) {
        me._beforeCollapseState = {};
        let widthChanged = false;

        if (me.width) {
          widthChanged = true;


          me.on({
            afterinternalresize: () => {

              resolve(me);
            },
            thisObj: me,
            once: true
          });
        }


        me._beforeCollapseState.width = me.width;
        me._beforeCollapseState.elementWidth = me.element.style.width;

        if (nextRegion.element.style.flex === '') {
          me._beforeCollapseState.nextRegionWidth = nextRegion.width;
          nextRegion.width += me._beforeCollapseState.width;
        }

        if (me.element.style.flex !== '') {
          me._beforeCollapseState.flex = me.element.style.flex;

          me.header.element.style.flex = me.element.style.flex = '';
        }

        me.element.classList.add('b-grid-subgrid-collapsed');

        me.virtualScrollerElement.classList.add('b-collapsed');
        me.header.element.classList.add('b-collapsed');
        me.footer && me.footer.element.classList.add('b-collapsed');
        me.width = '';
        me._collapsed = true;

        if (!widthChanged) {
          resolve(false);
        }
      }
    }).then(value => {
      if (!me.isDestroyed && value !== false) {
        me.syncParallelSplitters(true);
        me.grid.trigger('subGridCollapse', me);


        splitterOwner.startSplitterButtonSyncing && splitterOwner.startSplitterButtonSyncing();
      }
    });
  }


  async expand() {
    const me = this,
      grid = me.grid,
      nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),
      splitterOwner = me.splitterElement ? me : me.previousSibling;
    return new Promise(resolve => {
      if (me._beforeCollapseState != null) {


        let widthChanged = false;

        if (me.width !== me._beforeCollapseState.elementWidth) {
          widthChanged = true;


          me.on({
            afterinternalresize: () => {


              me.setTimeout(() => resolve(me), 10);
            },
            thisObj: me,
            once: true
          });
        }

        if (nextRegion.element.style.flex === '') {
          nextRegion.width = me._beforeCollapseState.nextRegionWidth;
        }

        me.element.classList.remove('b-grid-subgrid-collapsed');
        me._collapsed = false;

        me.virtualScrollerElement.classList.remove('b-collapsed');
        me.header.element.classList.remove('b-collapsed');
        me.footer && me.footer.element.classList.remove('b-collapsed');

        if (me._beforeCollapseState.flex) {

          me.width = me._beforeCollapseState.width;

          me.header.flex = me.flex = me._beforeCollapseState.flex;
          me.footer && (me.footer.flex = me._beforeCollapseState.flex);
          me._width = null;
        } else {
          me.width = me._beforeCollapseState.elementWidth;
        }

        me.element.classList.remove('b-grid-subgrid-collapsed');
        me._collapsed = false;

        if (!widthChanged) {
          resolve(false);
        }

        delete me._beforeCollapseState;
      }
    }).then(value => {
      if (value !== false) {


        splitterOwner.stopSplitterButtonSyncing();
        me.syncParallelSplitters(false);
        me.grid.trigger('subGridExpand', me);
      }
    });
  }

}

SubGrid._$name = 'SubGrid';


var GridSubGrids = (Target => class GridSubGrids extends (Target || Base) {


  initSubGrids() {
    const me = this,
      oldRegions = me._regions,
      usedRegions = new Set();
    let first = true,
      hasCalculatedWidth,
      subGridConfig,
      subGridColumns;

    for (const column of me.columns.records) {
      if (column.region && !me.subGridConfigs[column.region]) {
        me.subGridConfigs[column.region] = {};
      }

      usedRegions.add(column.region);
    }

    if (oldRegions) {
      oldRegions.forEach(region => me.subGrids[region].destroy());
    }


    me.subGrids = {};
    me._regions = Array.from(usedRegions);

    me._regions.sort();

    if (me.subGridConfigs.normal && Object.keys(me.subGridConfigs.normal).length === 0) {
      me.subGridConfigs.normal = GridBase.defaultConfig.subGridConfigs.normal;
    }

    for (const region of me._regions) {
      subGridColumns = me.columns.makeChained(column => column.region === region, ['region']);
      subGridConfig = ObjectHelper.assign({
        parent: me,
        grid: me,
        store: me.store,
        rowManager: me.rowManager,
        region: region,
        headerClass: me.subGridConfigs[region].headerClass || me.headerClass,
        columns: subGridColumns,
        hideHeaders: me.hideHeaders
      }, me.subGridConfigs[region]);
      hasCalculatedWidth = false;

      if (!subGridConfig.flex && !subGridConfig.width) {
        subGridConfig.width = subGridColumns.totalFixedWidth;
        hasCalculatedWidth = true;
      }

      me.subGrids[region] = new SubGrid(subGridConfig);

      me.subGrids[region].hasCalculatedWidth = hasCalculatedWidth;

      if (first) {

        me.subGrids[region].isFirstRegion = true;
        first = false;
      }
    }
  }

  doDestroy() {
    this.eachSubGrid(subGrid => subGrid.destroy());
    super.doDestroy();
  }

  get items() {


    return this.regions.map(r => this.subGrids[r]);
  }


  eachSubGrid(fn, thisObj = null) {
    const me = this;

    me.regions.forEach((region, i) => {
      const subGrid = me.subGrids[region];
      fn.call(thisObj || subGrid, subGrid, i++);
    });
  }

  eachWidget(fn, deep = true) {
    const me = this;
    me.regions.forEach(region => {
      const widget = me.subGrids[region];

      if (fn(widget) === false) {
        return;
      }

      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    });
  }


  callEachSubGrid(fnName, ...params) {

    let me = this,
      returnValue = null;

    me.regions.forEach((region, i) => {
      const subGrid = me.subGrids[region];

      if (subGrid[fnName]) {
        const partialReturnValue = subGrid[fnName](...params);
        if (i === 0) returnValue = partialReturnValue;
      }
    });
    return returnValue;
  }


  getLastRegions() {
    const result = this.regions.slice(-2);

    return result.length === 2 ? result : [result[0], result[0]];
  }


  getNextRegion(region) {
    const regions = this.regions;

    return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];
  }

  getPreviousRegion(region) {
    return this.regions[this.regions.indexOf(region) - 1];
  }


  getSubGrid(region) {
    return this.subGrids[region];
  }


  getSubGridFromColumn(column) {
    column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column);
    return this.getSubGrid(column.region);
  }

  get regions() {
    if (!this._regions) {
      this.initSubGrids();
    }

    return this._regions;
  }


  resolveSplitter(subGrid) {
    const me = this,
      regions = me.getLastRegions();
    let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;

    if (regions[1] === region) {
      region = regions[0];
    }

    return this.subGrids[region].splitterElement;
  }


  get widgetClass() {
  }

});

const locale$2 =   locale_zh.locale$2
for (const i in locale$1) {
  locale$2[i] = locale$1[i];
}
LocaleManagerSingelton.registerLocale('En', {
  desc: 'English',
  locale: locale$2
});


const resolvedPromise = new Promise(resolve => resolve()),
  defaultScrollOptions$2 = {
    block: 'nearest',
    inline: 'nearest'
  },
  preserveScroll = {
    dataset: 1,
    filter: 1
  };


class GridBase extends base(Container).mixes(Pluggable, State, GridElementEvents, GridFeatures, GridNavigation, GridResponsive, GridSelection, GridState, GridSubGrids) {

  static get $name() {
    return 'GridBase';
  }

  static get defaultConfig() {
    return {

      rowHeight: null,


      fixedRowHeight: null,


      defaultRowHeight: 45,


      emptyText: 'L{noRows}',


      fullRowRefresh: true,


      readOnly: null,


      hideHeaders: null,


      showRemoveRowInContextMenu: true,


      autoHeight: null,


      store: {},


      data: null,


      columns: [],


      defaultRegion: 'normal',


      destroyStore: null,


      enableTextSelection: null,


      loadMask: 'L{loadMask}',


      syncMask: 'L{syncMask}',


      columnLines: true,


      fillLastColumn: true,


      resizeToFitIncludesHeader: true,


      animateRemovingRows: !BrowserHelper.isIE11,


      disableGridRowModelWarning: null,
      loadMaskErrorIcon: 'b-icon b-icon-warning',
      headerClass: Header,
      testPerformance: false,

      positionMode: 'translate',

      rowScrollMode: 'move',


      monitorResize: true,


      features: true,


      subGridConfigs: {
        normal: {
          flex: 1
        }
      },


      scrollable: {


        overflowY: true
      },


      scrollerClass: GridScroller,


      showDirty: null,
      loadMaskHideTimeout: 3000,
      transitionDurationTimeout: 500,
      refreshSuspended: 0,


      transitionDuration: 500,


      contextMenuTriggerEvent: 'contextmenu',
      localizableProperties: ['emptyText', 'loadMask', 'syncMask'],
      localeClass: 'Grid'


    };
  }


  static getLKey() {
    return '9b14fb8a-9ef2-11ea-a249-d094663d5c88';
  }

  static get properties() {
    return {
      _selectedRecords: [],
      _verticalScrollHeight: 0,
      virtualScrollHeight: 0,
      _scrollTop: null
    };
  }


  finishConfigure(config) {
    const me = this;
    super.finishConfigure(config);
    me.scrollManager = new ScrollManager({
      grid: me,

      verticalElement: me.scrollable.element
    });


    LocaleManagerSingelton.on({
      locale: 'onBeforeLocaleChange',
      prio: 1,
      thisObj: me
    });
    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      prio: -1,
      thisObj: me
    });
    GlobalEvents.on({
      theme: 'onThemeChange',
      thisObj: me
    });
    me.on({
      subGridExpand: 'onSubGridExpand',
      prio: -1,
      thisObj: me
    });

    me.bufferedFixElementHeights = me.buffer('fixElementHeights', 350, me);

    me.setGridClassList(me.element.classList);
  }

  onSubGridExpand() {


    this.renderContents();
  }

  onBeforeLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = true;
  }

  onLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = false;

    if (this.isPainted) {
      this.renderContents();
    }
  }

  finalizeInit() {
    super.finalizeInit();

    if (this.store.isLoading) {

      this.onStoreBeforeRequest();
    }
  }


  doDestroy() {
    const me = this;

    for (const feature of Object.values(me.features)) {
      feature.destroy && feature.destroy();
    }

    if (me.columns) {
      me.columns = null;
    }

    if (me.store) {
      me.store = null;
    }

    super.doDestroy();
  }


  setGridClassList(classList) {
    const me = this;
    classList.add(`b-grid-${me.positionMode}`);

    if (!me.enableTextSelection) {
      classList.add('b-grid-notextselection');
    }

    if (me.autoHeight) {
      classList.add('b-autoheight');
    }

    if (me.readOnly) {
      classList.add('b-readonly');
    }

    if (me.fillLastColumn) {
      classList.add('b-fill-last-column');
    }

    if (me.showDirty) {
      classList.add('b-show-dirty');
    }

    for (const featureName in me.features) {
      const feature = me.features[featureName];
      let featureClass;

      if (Object.prototype.hasOwnProperty.call(feature.constructor, 'featureClass')) {
        featureClass = feature.constructor.featureClass;
      } else {
        featureClass = `b-${feature instanceof Base ? feature.$name : feature.constructor.name}`;
      }

      if (featureClass) {
        classList.add(featureClass.toLowerCase());
      }
    }
  }


  template(data) {
    const virtualScrollerStyle = BrowserHelper.isFirefox ? `style="height:${DomHelper.scrollBarWidth}px"` : '';
    return TemplateHelper.tpl`
            <div>
                <header reference="headerContainer" class="b-grid-header-container ${this.hideHeaders ? 'b-hidden' : ''}"></header>
                <div reference="bodyContainer" class="b-grid-body-container" tabIndex="-1">
                    <div reference="verticalScroller" class="b-grid-vertical-scroller"></div>
                </div>
                <div reference="virtualScrollers" class="b-virtual-scrollers ${DomHelper.scrollBarWidth ? '' : 'b-overlay-scrollbar'}" ${virtualScrollerStyle}></div>
                <footer reference="footerContainer" class="b-grid-footer-container b-hidden"></footer>
            </div>
        `;
  }

  get contentElement() {
    return this.verticalScroller;
  }

  get overflowElement() {
    return this.bodyContainer;
  }

  get focusElement() {
    return this.bodyContainer;
  }


  set columns(columns) {
    const me = this;

    if (me._columnStore) {
      if (columns) {


        me._columnStore.data = columns;
      } else {
        me._columnStore.destroy();
      }
    } else {

      if (columns instanceof ColumnStore) {
        if (!columns.grid) {
          columns.grid = me;
        }

        me._columnStore = columns;
      } else if (Array.isArray(columns)) {
        me._columnStore = new ColumnStore({
          grid: me,
          data: columns
        });
      } else if (columns) {
        me._columnStore = new ColumnStore(Object.assign({
          grid: me
        }, columns));
      }


      me._columnStore.on('change', me.onColumnsChanged, me);

      me._columnStore.on(columnResizeEvent(me.onColumnsResized, me));

      if (BrowserHelper.isTouchDevice) {
        me.touch = true;

        me._columnStore.forEach(column => {
          const touchConfig = column.touchConfig;

          if (touchConfig) {
            column.applyState(touchConfig);
          }
        });
      }
    }
  }


  get columns() {
    return this._columnStore;
  }

  onColumnsChanged({
                     action,
                     changes,
                     record: column
                   }) {
    const me = this;

    if (!me.isPainted) {
      return;
    }

    if (action === 'update') {

      if ('width' in changes || 'minWidth' in changes || 'flex' in changes) {

        if (me.isPainted) {
          const region = column.region;
          me.columns.visibleColumns.forEach(col => {
            if (col.region === region && col.repaintOnResize) {
              me.refreshColumn(col);
            }
          });
        }

        return;
      }

      if ('hidden' in changes) {
        const subGrid = me.getSubGridFromColumn(column.id);
        subGrid.header.fixHeaderWidths();

        if (subGrid.footer) {
          subGrid.footer.fixFooterWidths();
        }

        subGrid.updateHasFlex();
      }
    }

    if (action === 'dataset' || changes && 'region' in changes && !me.regions.includes(changes.region.value)) {

      me.initSubGrids();

      me.eachSubGrid(subGrid => {
        subGrid.render(me.verticalScroller);
        subGrid.initScroll();
      });
    }

    if (!me._suspendRenderContentsOnColumnsChanged) {
      me.renderContents();
    }
  }

  onColumnsResized({
                     changes,
                     record: column
                   }) {
    const me = this,
      setWidth = changes.width && column.flex == null,
      setMinWidth = changes.minWidth && column.flex == null,
      setFlex = changes.flex && column.width == null,
      domWidth = DomHelper.setLength(column.width),
      domMinWidth = DomHelper.setLength(column.minWidth),
      subGrid = me.getSubGridFromColumn(column.id);

    subGrid.header.fixHeaderWidths();

    if (subGrid.footer) {
      subGrid.footer.fixFooterWidths();
    }

    subGrid.updateHasFlex();

    if (!me.cellEls || column !== me.lastColumnResized) {
      me.cellEls = DomHelper.children(me.element, `.b-grid-cell[data-column-id=${column.id}]`);
      me.lastColumnResized = column;
    }

    for (const cell of me.cellEls) {
      if (setWidth) {


        cell.style.width = domWidth;
        cell.style.flex = '';


        if (BrowserHelper.isIE11) {
          cell.style.minWidth = domWidth;
        }
      } else if (setMinWidth) {
        cell.style.minWidth = domMinWidth;
      } else if (setFlex) {
        cell.style.flex = column.flex;
        cell.style.width = '';
      } else {
        cell.style.flex = cell.style.width = cell.style.minWidth = '';
      }
    }


    if (!me.dragResizing) {
      me.afterColumnsResized();
    }
  }

  afterColumnsResized() {
    const me = this;
    me.refreshVirtualScrollbars();
    me.eachSubGrid(subGrid => {
      if (!subGrid.collapsed) {
        subGrid.fixWidths();
        subGrid.fixRowWidthsInSafariEdge();
        subGrid.refreshFakeScroll();
      }
    });
    me.onHeightChange();
    me.lastColumnResized = me.cellEls = null;
  }

  processCellEditor(editorConfig) {
  }


  get rowManager() {
    const me = this;


    if (!me._isRowMeasured) {
      me.measureRowHeight();
    }


    return me._rowManager || (me._rowManager = new RowManager({
      grid: me,
      rowHeight: me.rowHeight,
      rowScrollMode: me.rowScrollMode || 'move',
      autoHeight: me.autoHeight,
      fixedRowHeight: me.fixedRowHeight,
      listeners: {
        changetotalheight: me.onRowManagerChangeTotalHeight,
        requestscrollchange: me.onRowManagerRequestScrollChange,
        thisObj: me
      }
    }));
  }

  getRowHeight(record) {
    return record.rowHeight;
  }


  bindStore(store) {
    const me = this;

    if (store) {
      store.on({
        name: 'store',
        refresh: me.onStoreDataChange,
        update: me.onStoreUpdateRecord,
        add: me.onStoreAdd,
        remove: me.onStoreRemove,
        move: me.onStoreMove,
        replace: me.onStoreReplace,
        removeall: me.onStoreRemoveAll,
        beforerequest: me.onStoreBeforeRequest,
        afterrequest: me.onStoreAfterRequest,
        clearchanges: me.onStoreDataChange,
        exception: me.onStoreException,
        commit: me.onStoreCommit,
        thisObj: me
      });
    }
  }

  get store() {
    return this._store;
  }


  set store(store) {
    const me = this,
      {
        rowManager
      } = me,

      features = me.initialConfig.features;

    if (store !== me._store) {
      me.detachListeners('store');

      if (store) {
        if (store instanceof Store) ; else {
          const storeCfg = {};

          if (me.data) {
            storeCfg.data = me.data;
          }

          if (features && features.tree) {
            storeCfg.tree = true;
          }

          if (!store.modelClass) {
            storeCfg.modelClass = class extends GridRowModel {
            };
          }

          store = new (store.readUrl ? AjaxStore : Store)(Object.assign(storeCfg, store));
        }

        me._store = store;
        me.bindStore(store);

        if (me.isPainted) {
          rowManager.reinitialize();
        }
      } else {
        if (me.destroyStore) {
          me._store.destroy();
        }

        me._store = null;
      }
    }
  }


  onStoreUpdateRecord({
                        source: store,
                        record,
                        changes
                      }) {
    const me = this;

    if (me.forceFullRefresh) {

      me.rowManager.refresh();
      me.forceFullRefresh = false;
    } else {
      let row;

      if (record.isFieldModified('id')) {
        row = me.getRowFor(record.meta.modified.id);
      }

      row = row || me.getRowFor(record);

      if (!row) return;


      if (me.fullRowRefresh || record.meta.specialRow) {
        const index = store.indexOf(record);

        if (index !== -1) {
          row.render(index, record);
        }
      } else {
        me.columns.visibleColumns.forEach(column => {
          const field = column.field,
            isSafe = column.constructor.simpleRenderer && !Object.prototype.hasOwnProperty.call(column.data, 'renderer');


          if (!isSafe || changes[field]) {
            const cell = row.getCell(field);

            if (cell) {
              row.renderCell(cell, record);
            }
          }
        });
      }
    }
  }

  refreshFromRowOnStoreAdd(row) {
    const me = this,
      {
        rowManager
      } = me;
    rowManager.renderFromRow(row);
    rowManager.trigger('changeTotalHeight', {
      totalHeight: rowManager.totalHeight
    });


    if (me.store.count === 1) {
      me.callEachSubGrid('refreshFakeScroll');
    }
  }


  onStoreAdd({
               source: store,
               records,
               index,
               oldIndex,
               isChild,
               oldParent,
               isMove,
               isExpandAll
             }) {

    if (!this.isPainted || isExpandAll) {
      return;
    }

    if (isChild && !records[0].ancestorsExpanded(store)) {
      return;
    }

    this.rowManager.calculateRowCount(false, true, true);
    const me = this,
      {
        rowManager
      } = me,
      {
        topIndex,
        rows,
        rowCount
      } = rowManager,
      bottomIndex = rowManager.topIndex + rowManager.rowCount - 1,
      dataStart = index,
      dataEnd = index + records.length - 1,
      atEnd = bottomIndex >= store.count - records.length - 1;


    if (oldParent || oldIndex > -1 || isChild && isMove) {
      rowManager.refresh();
    } else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    } else {


      if (atEnd && index > bottomIndex) {
        rowManager.fillBelow(me._scrollTop);
      }

      rowManager.trigger('changeTotalHeight', {
        totalHeight: rowManager.totalHeight
      });
    }
  }


  onStoreException({
                     action,
                     type,
                     response,
                     exceptionType,
                     error
                   }) {
    const me = this;

    if (me.activeMask) {
      let message;

      switch (type) {
        case 'server':
          message = response.message || me.L('unspecifiedFailure');
          break;

        case 'exception':
          message = exceptionType === 'network' ? me.L('networkFailure') : error && error.message || me.L('parseFailure');
          break;

        default:
          message = response.status && response.statusText ? `${response.status} - ${response.statusText}` : me.L('unknownFailure');
      }

      me.activeMask.icon = me.loadMaskErrorIcon;
      me.activeMask.text = `<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${action === 'read' ? me.L('loadFailedMessage') : me.L('syncFailedMessage')}</div>
                ${response && response.url ? `<div class="b-grid-load-fail">${response.url}</div>` : ''}
                ${message ? `<div class="b-grid-load-fail">${message}</div>` : ''}
            </div>`;
      me.loadmaskHideTimer = me.setTimeout(() => {
        me.unmaskBody();
      }, me.loadMaskHideTimeout);
    }
  }


  onStoreDataChange({
                      action,
                      changes,
                      source: store
                    }) {

    super.onStoreDataChange && super.onStoreDataChange(...arguments);
    const me = this,
      isGroupFieldChange = store.isGrouped && changes && store.groupers.some(grouper => grouper.field in changes);

    if (action === 'dataset') {
      me.rowManager.clearKnownHeights();
    }


    if (me.isPainted && !isGroupFieldChange) {

      me.renderRows(null, preserveScroll[action]);
    }

    me.toggleEmptyText();
  }


  onStoreBeforeRequest() {
    if (this.loadMask) {
      this.maskBody(this.loadMask);
    }
  }


  onStoreAfterRequest() {
    if (this.activeMask && !this.loadmaskHideTimer) {
      this.unmaskBody();
      this.toggleEmptyText();
    }
  }


  onStoreRemove({
                  records,
                  isCollapse,
                  isChild,
                  isMove,
                  isCollapseAll
                }) {


    if (!this.isPainted || isMove || isCollapseAll) {
      return;
    }

    super.onStoreRemove && super.onStoreRemove(...arguments);
    let topRowIndex = 2 ** 53 - 1;
    const me = this,
      {
        rowManager
      } = me,

      rowsToRemove = records.reduce((result, record) => {
        const row = rowManager.getRowById(record.id);

        if (row) {
          result.push(row);

          topRowIndex = Math.min(topRowIndex, rowManager.rows.indexOf(row));
        }

        return result;
      }, []);

    rowManager.invalidateKnownHeight(records);

    if (me.animateRemovingRows && rowsToRemove.length && !isCollapse && !isChild) {
      const topRow = rowsToRemove[0];
      me.isAnimating = true;

      EventHelper.onTransitionEnd({
        element: topRow._elementsArray[0],
        property: 'left',

        timeout: me.transitionDurationTimeout,
        thisObj: me,

        handler() {
          me.isAnimating = false;
          rowsToRemove.forEach(row => !row.isDestroyed && row.removeCls('b-removing'));
          rowManager.refresh();

          me.trigger('rowRemove');
        }

      });
      rowsToRemove.forEach(row => row.addCls('b-removing'));
    } else {

      rowManager.calculateRowCount(false, true, true);


      if (rowManager.rows[topRowIndex]) {
        rowManager.renderFromRow(rowManager.rows[topRowIndex]);
      } else {
        rowManager.trigger('changeTotalHeight', {
          totalHeight: rowManager.totalHeight
        });
      }

      me.trigger('rowRemove', {
        isCollapse
      });
    }
  }

  onStoreMove({
                from,
                to
              }) {
    const {
        rowManager
      } = this,
      {
        topIndex,
        rowCount
      } = rowManager,
      [dataStart, dataEnd] = [from, to].sort();

    if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      rowManager.renderFromRow(rowManager.rows[dataStart - topIndex]);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    }

  }

  onStoreReplace({
                   records,
                   all
                 }) {
    const {
      rowManager
    } = this;

    if (all) {
      rowManager.clearKnownHeights();
      rowManager.refresh();
    } else {
      const rows = records.reduce((rows, [, record]) => {
        const row = this.getRowFor(record);

        if (row) {
          rows.push(row);
        }

        return rows;
      }, []);

      rowManager.invalidateKnownHeight(records);
      rowManager.renderRows(rows);
    }
  }


  onStoreRemoveAll() {

    super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments);

    if (this.isPainted) {
      this.rowManager.clearKnownHeights();
      this.renderRows();
      this.toggleEmptyText();
    }
  }

  onStoreCommit({
                  changes
                }) {
    if (this.showDirty && changes.modified.length) {
      const rows = [];
      changes.modified.forEach(record => {
        const row = this.rowManager.getRowFor(record);
        row && rows.push(row);
      });
      this.rowManager.renderRows(rows);
    }
  }


  get data() {
    if (this._store) {
      return this._store.records;
    } else {
      return this._data;
    }
  }

  set data(data) {
    if (this._store) {
      this._store.data = data;
    } else {
      this._data = data;
    }
  }

  get emptyText() {
    return this._emptyText;
  }

  set emptyText(text) {
    this._emptyText = text;
    this.eachSubGrid(subGrid => subGrid.emptyText = text);
  }


  getHeaderMenuItems(column, items) {
    const me = this,
      {
        subGrids,
        regions
      } = me;
    let first = true;
    Object.entries(subGrids).forEach(([region, subGrid]) => {

      if (subGrid.sealedColumns) {
        return;
      }

      if (column.draggable && region !== column.region && (!column.parent && subGrids[column.region].columns.count > 1 || column.parent && column.parent.children.length > 1)) {
        const moveRight = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING,

          text = regions.length > 2 ? me.L('Move column to ') + region : me.L(moveRight ? 'moveColumnRight' : 'moveColumnLeft');
        items.push({
          targetSubGrid: region,
          text,
          icon: 'b-fw-icon ' + (moveRight ? 'b-icon-column-move-right' : 'b-icon-column-move-left'),
          name: 'moveColumn',
          cls: first ? 'b-separator' : '',
          onItem: ({
                     item
                   }) => {
            const {
              column
            } = item;
            column.traverse(col => col.region = region);

            me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);
            me.scrollColumnIntoView(column);
          }
        });
        first = false;
      }
    });
  }


  getCellMenuItems(column, record, items) {
    const me = this;

    if (me.showRemoveRowInContextMenu && !me.readOnly && record && !record.meta.specialRow) {
      if (me.selectedRecords.length > 1) {
        items.push({
          text: me.L('removeRows'),
          icon: 'b-fw-icon b-icon-trash',
          name: 'removeRows',
          onItem: () => me.store.remove(me.selectedRecords)
        });
      } else {
        items.push({
          text: me.L('removeRow'),
          icon: 'b-fw-icon b-icon-trash',
          name: 'removeRow',
          onItem: () => me.store.remove(record)
        });
      }
    }
  }

  getColumnDragToolbarItems(column, items) {
    return items;
  }


  normalizeCellContext(cellContext) {
    const {
      columns,
      store
    } = this;


    if (cellContext instanceof store.modelClass) {
      return {
        record: cellContext,
        id: cellContext.id,
        columnId: columns.bottomColumns[0].id
      };
    }

    if (!('columnId' in cellContext)) {
      if ('field' in cellContext) {
        const column = columns.get(cellContext.field);
        cellContext.columnId = column && column.id;
      } else if ('column' in cellContext) {
        const column = typeof cellContext.column === 'number' ? columns.bottomColumns[cellContext.column] : cellContext.column;
        cellContext.columnId = column && column.id;
      }

      if (!('columnId' in cellContext)) {
        cellContext.columnId = columns.bottomColumns[0].id;
      }
    }

    if ('id' in cellContext) {


      if (cellContext.element && !store.getById(cellContext.id)) {

        const newRec = this.getRecordFromElement(cellContext.element);

        if (newRec) {
          cellContext.id = newRec.id;
        }
      }
    } else {
      if ('row' in cellContext) {
        cellContext.id = store.getAt(cellContext.row).id;
      } else if ('record' in cellContext) {
        cellContext.id = cellContext.record.id;
      }
    }

    return cellContext;
  }


  getCell(cellContext) {
    let row,
      result = null;
    cellContext = this.normalizeCellContext(cellContext);

    if ('id' in cellContext) {
      row = this.getRowById(cellContext.id);
    }

    if (row && 'columnId' in cellContext) {
      result = row.getCell(cellContext.columnId);
    }

    return result;
  }


  getHeaderElement(columnId) {
    if (typeof columnId !== 'string') {
      columnId = columnId.id;
    }

    return this.fromCache(`.b-grid-header[data-column-id="${columnId}"]`);
  }

  getHeaderElementByField(field) {
    const column = this.columns.get(field);
    return column ? this.getHeaderElement(column) : null;
  }


  get bodyHeight() {
    return this._bodyHeight;
  }


  get headerHeight() {
    const me = this;

    if (me.isPainted && !me._headerHeight) {
      me._headerHeight = me.headerContainer.offsetHeight;
    }

    return me._headerHeight;
  }


  getRecordFromElement(element) {
    const el = element.closest('.b-grid-row');
    if (!el) return null;
    return this.store.getAt(el.dataset.index);
  }


  getColumnFromElement(element) {
    const cell = DomHelper.up(element, '.b-grid-cell, .b-grid-header');
    if (!cell) return null;

    if (cell.matches('.b-grid-header')) {
      return this.columns.getById(cell.dataset.columnId);
    }

    const cellData = DomDataStore.get(cell);
    return this.columns.getById(cellData.columnId);
  }

  get autoHeight() {
    return this._autoHeight;
  }

  set autoHeight(autoHeight) {
    ObjectHelper.assertBoolean(autoHeight, 'autoHeight');
    this._autoHeight = autoHeight;
  }


  get columnLines() {
    return this._columnLines;
  }

  set columnLines(columnLines) {
    ObjectHelper.assertBoolean(columnLines, 'columnLines');
    DomHelper.toggleClasses(this.element, 'b-no-column-lines', !columnLines);
    this._columnLines = columnLines;
  }


  set readOnly(readOnly) {
    const me = this;
    me._readOnly = readOnly;

    if (me.isPainted) {

      me.trigger('readOnly', {
        readOnly
      });


      if (readOnly) {
        me.element.classList.add('b-readonly');
      } else {
        me.element.classList.remove('b-readonly');
      }
    }
  }

  get readOnly() {
    return this._readOnly;
  }


  fixSizes() {

    this.callEachSubGrid('fixWidths');
  }

  onRowManagerChangeTotalHeight({
                                  totalHeight,
                                  immediate
                                }) {
    return this.refreshTotalHeight(totalHeight, immediate);
  }


  refreshTotalHeight(height = this.rowManager.totalHeight, immediate = false) {
    const me = this;

    if (me.renderingRows || !me.isVisible) {
      return false;
    }

    if (me.rowManager.bottomRow) {
      height = Math.max(height, me.rowManager.bottomRow.bottom);
    }

    const scroller = me.scrollable,
      delta = Math.abs(me.virtualScrollHeight - height),
      clientHeight = me._bodyRectangle.height,
      newMaxY = height - clientHeight;

    if (delta) {
      const
        isCritical = newMaxY - me._scrollTop < clientHeight * 2 ||
          me._verticalScrollHeight && me._verticalScrollHeight - clientHeight < me._scrollTop;

      scroller.scrollHeight = me.virtualScrollHeight = height;


      if (me.isPainted && (me.scrolling && !isCritical || delta < 100) && !immediate) {
        me.bufferedFixElementHeights();
      } else {
        me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();
        me.bufferedFixElementHeights.cancel();
        me.fixElementHeights();
      }
    }
  }

  fixElementHeights() {
    const me = this,
      height = me.virtualScrollHeight,
      heightInPx = `${height}px`;
    me._verticalScrollHeight = height;
    me.verticalScroller.style.height = heightInPx;
    me.virtualScrollHeightDirty = false;

    if (me.autoHeight) {
      me.bodyContainer.style.height = heightInPx;
      me._bodyHeight = height;
      me._bodyRectangle = Rectangle.client(me.bodyContainer);
    }

    me.refreshVirtualScrollbars();
  }


  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }

  get scrolling() {
    return this._scrolling;
  }


  enableScrollingCloseToEdges(subGrid) {
    if (typeof subGrid === 'string') {
      subGrid = this.subGrids[subGrid];
    }

    this.scrollManager.startMonitoring({
      element: subGrid.element
    });
  }


  disableScrollingCloseToEdges(subGrid) {
    if (typeof subGrid === 'string') {
      subGrid = this.subGrids[subGrid];
    }

    this.scrollManager.stopMonitoring(subGrid.element);
  }


  onRowManagerRequestScrollChange({
                                    bottom
                                  }) {
    this.scrollable.y = bottom - this.bodyHeight;
  }


  initScroll() {
    const me = this;


    if (!me.scrollInitialized) {
      let scrollTop;
      const onScroll = me.createOnFrame(() => {
        scrollTop = me.scrollable.y;

        if (scrollTop !== me._scrollTop) {
          me._scrollTop = scrollTop;

          if (!me.scrolling) {
            me.scrolling = true;
            me.eachSubGrid(s => s.suspendResizeMonitor = true);
          }

          me.rowManager.updateRenderedRows(scrollTop);


          me.trigger('scroll', {
            scrollTop
          });
        }
      });
      me.scrollInitialized = true;
      me.scrollable.on({
        scroll: onScroll,

        scrollend() {
          me.scrolling = false;
          me.eachSubGrid(s => s.suspendResizeMonitor = false);
        }

      });
      me.callEachSubGrid('initScroll');
    }
  }


  scrollRowIntoView(recordOrId, options = defaultScrollOptions$2) {
    const me = this,
      blockPosition = options.block || 'nearest',
      {
        rowManager
      } = me;
    recordOrId = me.store.getById(recordOrId);

    if (recordOrId) {

      if (me.store.indexOf(recordOrId) === -1) {
        return resolvedPromise;
      }

      let scroller = me.scrollable,
        recordRect = me.getRecordCoords(recordOrId);
      const scrollerRect = Rectangle.from(scroller.element);


      if (recordRect.virtual) {
        const virtualBlock = recordRect.block;


        scroller.scrollIntoView(recordRect, {
          block: 'center'
        });
        rowManager.scrollTargetRecordId = recordOrId;
        rowManager.updateRenderedRows(scroller.y, true);
        recordRect = me.getRecordCoords(recordOrId);
        rowManager.lastScrollTop = scroller.y;

        if (recordRect.virtual) {


          return resolvedPromise;
        }

        const innerOptions = blockPosition !== 'nearest' ? options : {
          block: virtualBlock
        };

        if (options.animate) {


          scroller.suspendEvents();

          if (blockPosition === 'end' || blockPosition === 'nearest' && virtualBlock === 'end') {
            scroller.y -= scrollerRect.bottom - recordRect.bottom;
          } else if (blockPosition === 'start' || blockPosition === 'nearest' && virtualBlock === 'start') {
            scroller.y += recordRect.y - scrollerRect.y;
          }

          rowManager.updateRenderedRows(scroller.y, false, true);

          if (virtualBlock === 'end') {
            scroller.y -= rowManager.appendRowBuffer * rowManager.rowHeight - 1;
          } else {
            scroller.y += rowManager.prependRowBuffer * rowManager.rowHeight - 1;
          }

          const result = scroller.scrollIntoView(me.getRecordCoords(recordOrId), Object.assign({}, options, innerOptions));

          return result.then(() => scroller.resumeEvents());
        } else {
          return me.scrollRowIntoView(recordOrId, Object.assign({}, options, innerOptions));
        }
      } else {
        let {
          column
        } = options;

        if (column) {
          if (typeof column === 'string') {
            column = me.columns.getById(column) || me.columns.get(column);
          }

          if (column) {
            scroller = me.getSubGridFromColumn(column).scrollable;
            const cellRect = Rectangle.from(rowManager.getRowFor(recordOrId).getCell(column.id));
            recordRect.x = cellRect.x;
            recordRect.width = cellRect.width;
          }
        } else {
          options.x = false;
        }

        return scroller.scrollIntoView(recordRect, options);
      }
    }
  }


  scrollColumnIntoView(column, options) {
    column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);
    return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);
  }


  scrollCellIntoView(cellContext, options) {
    return this.scrollRowIntoView(cellContext.id, Object.assign({
      column: cellContext.columnId
    }, typeof options === 'boolean' ? {
      animate: options
    } : options));
  }


  scrollToBottom(options) {

    return this.scrollRowIntoView(this.store.last, options);
  }


  scrollToTop(options) {
    return this.scrollable.scrollBy(0, -this.scrollable.y, options);
  }


  storeScroll() {
    const me = this,
      state = me.storedScrollState = {
        scrollTop: me.scrollable.y,
        scrollLeft: {}
      };


    me.eachSubGrid(subGrid => {
      state.scrollLeft[subGrid.region] = subGrid.scrollable.x;
    });
    return state;
  }


  restoreScroll(state = this.storedScrollState) {
    const me = this;


    me.eachSubGrid(subGrid => {
      subGrid.scrollable.x = state.scrollLeft[subGrid.region];
    });
    me.scrollable.y = state.scrollTop;
  }


  measureRowHeight() {
    const me = this,

      rowMeasureElement = DomHelper.createElement({
        tag: 'div',

        className: 'b-grid ' + (me.features.stripe ? 'b-stripe' : ''),
        style: 'position: absolute; visibility: hidden',
        html: '<div class="b-grid-subgrid"><div class="b-grid-row"></div></div>',
        parent: document.getElementById(me.appendTo) || document.body
      });


    const rowEl = rowMeasureElement.firstElementChild.firstElementChild,
      styleHeight = parseInt(DomHelper.getStyleValue(rowEl, 'height')),
      borderTop = parseInt(DomHelper.getStyleValue(rowEl, 'border-top-width')),
      borderBottom = parseInt(DomHelper.getStyleValue(rowEl, 'border-bottom-width'));


    if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {
      me.rowHeight = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;
      me._rowHeightFromStyle = me.rowHeight;
    }

    me._rowBorderHeight = borderTop + borderBottom;
    me._isRowMeasured = true;
    rowMeasureElement.remove();

  }


  onThemeChange({
                  theme
                }) {
    this.measureRowHeight();
    this.trigger('theme', {
      theme
    });
  }


  refreshRows(returnToTop = false) {
    this.element.classList.add('b-notransition');

    if (returnToTop) {
      this.rowManager.returnToTop();
    } else {
      this.rowManager.refresh();
    }

    this.element.classList.remove('b-notransition');
  }


  refreshColumn(column) {
    const field = column.field;
    this.rowManager.forEach(row => {
      const cell = row.getCell(field);
      row.renderCell(cell);
    });
  }


  refreshVirtualScrollbars() {


    const me = this,
      {
        headerContainer,
        footerContainer,
        virtualScrollers,
        scrollable
      } = me,
      hasVerticalOverflow = BrowserHelper.isEdge || BrowserHelper.isIE11

        ? Math.abs(scrollable.scrollHeight - scrollable.clientHeight) > 1 : scrollable.scrollHeight > scrollable.clientHeight,


      hasHorizontalOverflow = Object.values(me.subGrids).some(subGrid => subGrid.overflowingHorizontally),
      method = hasVerticalOverflow ? 'add' : 'remove';

    if (hasHorizontalOverflow) {
      virtualScrollers.classList.remove('b-hide-display');
    } else {
      virtualScrollers.classList.add('b-hide-display');
    }

    headerContainer.classList[method]('b-grid-vertical-overflow');
    footerContainer.classList[method]('b-grid-vertical-overflow');
    virtualScrollers.classList[method]('b-grid-vertical-overflow');

    me.onHeightChange();

    if (DomHelper.scrollBarWidth) {
      if (hasVerticalOverflow) {
        headerContainer.style.marginRight = footerContainer.style.paddingRight = `${DomHelper.scrollBarWidth - 1}px`;
      } else {
        headerContainer.style.marginRight = footerContainer.style.paddingRight = 0;
      }
    }
  }


  get contentHeight() {
    const rowManager = this.rowManager;
    return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);
  }

  onContentChange() {
    const me = this,
      rowManager = me.rowManager;

    if (me.isVisible) {
      rowManager.estimateTotalHeight();
      me.paintListener = null;
      me.refreshTotalHeight(me.contentHeight);
      me.callEachSubGrid('refreshFakeScroll');
      me.onHeightChange();
    } else if (!me.paintListener) {
      me.paintListener = me.on({
        paint: 'onContentChange',
        once: true,
        thisObj: me
      });
    }
  }

  onHeightChange() {
    const me = this;

    me._bodyRectangle = Rectangle.client(me.bodyContainer);
    me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;
  }


  renderHeader(headerContainer, element) {
  }


  renderFooter(footerContainer, element) {
  }

  suspendRefresh() {
    this.refreshSuspended++;
  }

  resumeRefresh(trigger) {
    if (this.refreshSuspended && !--this.refreshSuspended) {
      if (trigger) {
        this.refreshRows();
      }
    }
  }


  renderRows(keepScroll = true, returnToTop = false) {
    const me = this,
      scrollState = keepScroll && me.storeScroll();

    if (me.refreshSuspended) {
      return;
    }


    me.trigger('beforeRenderRows');
    me.renderingRows = true;

    me.element.classList.add('b-grid-refreshing');

    if (returnToTop) {
      me.scrollable.y = me._scrollTop = 0;
    }

    me.rowManager.reinitialize(returnToTop);


    me.trigger('renderRows');
    me.renderingRows = false;
    me.onContentChange();

    if (keepScroll) {
      me.restoreScroll(scrollState);
    }

    me.element.classList.remove('b-grid-refreshing');
  }


  renderContents() {
    const me = this,
      {
        element,
        headerContainer,
        footerContainer,
        rowManager
      } = me;
    me.emptyCache();

    if (me.isPainted) {

      me._headerHeight = null;
      me.callEachSubGrid('refreshHeader', headerContainer);
      me.callEachSubGrid('refreshFooter', footerContainer);

      me.renderHeader(headerContainer, element);
      me.renderFooter(footerContainer, element);
      me.fixSizes();


      const refreshContext = rowManager.removeAllRows();
      rowManager.calculateRowCount(false, true, true);

      if (rowManager.rowCount) {


        rowManager.setPosition(refreshContext);
        me.renderRows();
      }
    }
  }

  onPaint() {
    const me = this,
      {
        rowManager,
        store,
        element,
        headerContainer,
        bodyContainer,
        footerContainer
      } = me;

    if (me.isPainted) {
      return;
    }

    let columnsChanged,
      maxDepth = 0;

    me.columns.on({
      change: () => columnsChanged = true,
      single: true
    });

    me._bodyRectangle = Rectangle.client(me.bodyContainer);
    const bodyOffsetHeight = me.bodyContainer.offsetHeight;

    me.updateResponsive(me.width, 0);

    if (columnsChanged) {
      me.callEachSubGrid('refreshHeader', headerContainer);
      me.callEachSubGrid('refreshFooter', footerContainer);
    }


    me.renderHeader(headerContainer, element);
    me.renderFooter(footerContainer, element);

    if (me.autoHeight) {
      me._bodyHeight = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);
      bodyContainer.style.height = me.bodyHeight + 'px';
    } else {
      me._bodyHeight = bodyOffsetHeight;
      rowManager.initWithHeight(me._bodyHeight, true);
    }

    me.eachSubGrid(subGrid => {
      if (subGrid.header.maxDepth > maxDepth) {
        maxDepth = subGrid.header.maxDepth;
      }
    });
    headerContainer.dataset.maxDepth = maxDepth;
    me.fixSizes();

    if (store.count || !store.isLoading) {
      me.renderRows(false, false);
    }

    me.initScroll();
    me.initInternalEvents();
  }

  render() {
    const me = this;


    me.requireSize = Boolean(me.owner);

    super.render(...arguments);


    if (!me.autoHeight && me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {
      console.warn('Grid element not sized correctly, please check your CSS styles and review how you size the widget');
    }
  }


  maskBody(loadMask) {
    const me = this;

    if (!me.bodyContainer) {
      return;
    }

    me.unmaskBody();
    const {
      maskElement
    } = me.activeMask = Mask.mask(loadMask, me.element);
    maskElement.style.marginTop = `${me.bodyContainer.offsetTop}px`;
    maskElement.style.height = `${me.virtualScrollers.offsetTop + me.virtualScrollers.offsetHeight - me.bodyContainer.offsetTop}px`;
    return me.activeMask;
  }


  unmaskBody() {
    const me = this;
    me.loadmaskHideTimer && me.clearTimeout(me.loadmaskHideTimer);
    me.loadmaskHideTimer = null;
    me.activeMask && me.activeMask.destroy();
    me.activeMask = null;
  }

  toggleEmptyText() {
    if (this.bodyContainer) {
      DomHelper.toggleClasses(this.bodyContainer, 'b-grid-empty', !(this.rowManager.rowCount > 0 || this.store.isLoading || this.store.isCommitting));
    }
  }

}

GridBase.localeClass = 'Grid';
GridBase._$name = 'GridBase';
BryntumWidgetAdapterRegister.register('gridbase', GridBase);
VersionHelper.setVersion('grid', '3.1.3');


const validNonEditingKeys = {
    Enter: 1,
    F2: 1
  },
  validEditingKeys = {
    ArrowUp: 1,
    ArrowDown: 1,
    ArrowLeft: 1,
    ArrowRight: 1
  };


class CellEdit extends Delayable(InstancePlugin) {

  static get $name() {
    return 'CellEdit';
  }

  static get defaultConfig() {
    return {

      autoSelect: true,


      blurAction: 'complete',


      addNewAtEnd: null,


      autoEdit: false,


      editorClass: Editor,


      triggerEvent: 'celldblclick'
    };
  }

  static get pluginConfig() {
    return {
      assign: ['startEditing'],
      before: ['onElementKeyDown', 'onElementMouseDown'],
      chain: ['onElementClick']
    };
  }


  construct(grid, config) {
    const me = this;
    me.grid = grid;
    super.construct(grid, config);
    grid.store.on({
      update: 'onStoreUpdate',
      thisObj: me
    });
    const gridListeners = {
      beforerenderrows: 'onGridBeforeRenderRows',
      cellclick: 'onCellClick',
      thisObj: me
    };

    if (me.triggerEvent !== 'cellclick') {
      gridListeners[me.triggerEvent] = 'onTriggerEditEvent';
    }

    grid.on(gridListeners);
  }


  async confirm(options) {
    let result = true;

    if (this.editorContext) {


      md.owner = this.editorContext.editor.inputField;
      result = await md.confirm(options);
      md.owner = null;
    }

    return result === md.yesButton;
  }

  doDestroy() {
    this.cancelEditing(true);

    this.grid.columns.allRecords.forEach(column => {
      if (column._cellEditor) {
        column._cellEditor.destroy();
      }
    });
    super.doDestroy();
  }

  doDisable(disable) {
    if (disable) {
      this.cancelEditing(true);
    }

    super.doDisable(disable);
  }

  set disabled(disabled) {
    super.disabled = disabled;
  }

  get disabled() {
    const {
      grid
    } = this;
    return Boolean(super.disabled || grid.disabled || grid.readOnly);
  }


  get isEditing() {
    return Boolean(this.editorContext);
  }


  get activeRecord() {
    return this.editorContext && this.editorContext.record || null;
  }


  getEditorForCell({
                     cell,
                     column,
                     selector,
                     editor
                   }) {
    const me = this,
      grid = me.grid;

    let cellEditor = column._cellEditor;
    let leftOffset = 0;


    if (column.editTargetSelector) {
      const editorTarget = cell.querySelector(column.editTargetSelector);
      leftOffset = editorTarget.offsetLeft;
    }

    editor.autoSelect = me.autoSelect;

    if (cellEditor) {


      if (cellEditor.inputField !== editor) {
        cellEditor.remove(cellEditor.items[0]);
        cellEditor.add(editor);
      }

      cellEditor.align.offset[0] = leftOffset;
    } else {
      cellEditor = column._cellEditor = new me.editorClass({
        cls: 'b-cell-editor',
        inputField: editor,
        blurAction: 'none',
        invalidAction: column.invalidAction,
        completeKey: false,
        cancelKey: false,
        owner: grid,
        align: {
          align: 't0-t0',
          offset: [leftOffset, 0]
        },
        listeners: me.getEditorListeners()
      });
    }

    if (column.instantUpdate && !editor.cellEditValueSetter) {
      ObjectHelper.wrapProperty(editor, 'value', null, value => {
        const {
          editorContext
        } = me;

        if (editorContext && editorContext.editor.isValid && !ObjectHelper.isEqual(editorContext.record[editorContext.column.field], value)) {
          editorContext.record[editorContext.column.field] = value;
        }
      });
      editor.cellEditValueSetter = true;
    }

    Object.assign(cellEditor.element.dataset, {
      rowId: selector.id,
      columnId: selector.columnId,
      field: column.field
    });

    cellEditor.inputField.revertOnEscape = column.revertOnEscape;
    return me.editor = cellEditor;
  }

  getEditorListeners() {
    return {
      focusout: 'onEditorFocusOut',
      focusin: 'onEditorFocusIn',
      start: 'onEditorStart',
      beforecomplete: 'onEditorBeforeComplete',
      complete: 'onEditorComplete',
      cancel: 'onEditorCancel',
      thisObj: this
    };
  }

  onEditorStart({
                  source: editor
                }) {
    const me = this,
      editorContext = me.editorContext = editor.cellEditorContext;

    if (editorContext) {
      const {
          grid
        } = me,
        {
          cell
        } = editorContext;
      cell.classList.add('b-editing');
      me.grid.on({
        cellclick: 'onCellClickWhileEditing'
      }, me);


      me.removeEditingListeners = GlobalEvents.addListener({
        globaltap: 'onTapOut',
        thisObj: me
      });


      grid.trigger('startCellEdit', {
        grid,
        editorContext
      });
    }
  }

  onEditorBeforeComplete(context) {
    const {
        grid
      } = this,
      editor = context.source,
      editorContext = editor.cellEditorContext;
    context.grid = grid;
    context.editorContext = editorContext;


    return grid.trigger('beforeFinishCellEdit', context);
  }

  onEditorComplete({
                     source: editor
                   }) {
    const {
        grid
      } = this,
      editorContext = editor.cellEditorContext;

    editorContext.value = editor.inputField.value;


    grid.trigger('finishCellEdit', {
      grid,
      editorContext
    });
    this.cleanupAfterEdit(editorContext);
  }

  onEditorCancel() {
    const {
      editorContext,
      muteEvents,
      grid
    } = this;

    if (editorContext) {
      this.cleanupAfterEdit(editorContext);
    }

    if (!muteEvents) {

      grid.trigger('cancelCellEdit', {
        grid
      });
    }
  }

  cleanupAfterEdit(editorContext) {
    const me = this,
      {
        editor
      } = editorContext;
    editorContext.cell.classList.remove('b-editing');
    editor.cellEditorContext = me.editorContext = null;
    me.grid.un({
      cellclick: 'onCellClickWhileEditing',
      viewportResize: 'onViewportResizeWhileEditing'
    }, me);
    me.removeEditingListeners();


    GlobalEvents.suspendFocusEvents();
    editor.element.remove();
    GlobalEvents.resumeFocusEvents();
  }


  getAdjacentEditableCell(cellInfo, isForward) {
    const addNewAtEnd = this.addNewAtEnd,
      grid = this.grid,
      store = grid.store,
      rowManager = grid.rowManager,
      columns = grid.columns;
    let rowId = cellInfo.id,
      columnId = cellInfo.columnId,
      column = columns.getAdjacentLeaf(columnId, isForward);

    while (rowId) {
      const record = store.getById(rowId);

      if (column) {
        columnId = column.id;

        if (!column.hidden && column.editor && column.canEdit(record)) {
          return {
            id: rowId,
            columnId: column.id
          };
        }

        column = columns.getAdjacentLeaf(columnId, isForward);
      } else {
        let editRec = store.getAdjacent(cellInfo.id, isForward, false, true);

        if (!editRec && isForward && addNewAtEnd) {
          editRec = store.add(typeof addNewAtEnd === 'object' ? ObjectHelper.clone(addNewAtEnd) : {})[0];


          if (!rowManager.getRowFor(editRec)) {
            rowManager.displayRecordAtBottom();
          }
        }

        rowId = editRec && editRec.id;

        if (editRec) {
          column = isForward ? columns.first : columns.leaves[columns.leaves.length - 1];
        }
      }
    }

    return null;
  }


  getEditingContext(cellContext) {
    cellContext = this.grid.normalizeCellContext(cellContext);
    const me = this,
      {
        grid
      } = me,
      column = grid.columns.getById(cellContext.columnId),
      record = grid.store.getById(cellContext.id),
      cell = grid.getCell(cellContext);


    if (cell && column && !column.hidden && column.editor && record && !record.meta.specialRow && column.canEdit(record)) {
      const value = record && record[column.field];
      return {
        column,
        record,
        cell,
        value: value === undefined ? null : value,
        selector: cellContext,
        editor: column.editor
      };
    } else {
      return false;
    }
  }


  startEditing(cellContext = {}) {
    const me = this;

    if (!(me.editorContext || me.disabled)) {
      const {
          grid
        } = me,
        normalizedContext = grid.normalizeCellContext(cellContext);

      grid.focusCell(cellContext);
      const editorContext = me.getEditingContext(normalizedContext);


      if (!editorContext || grid.trigger('beforeCellEditStart', {
        grid,
        editorContext
      }) === false) {
        return false;
      }


      if (editorContext) {


        DomHelper.focusWithoutScrolling(grid.focusElement);
        const editor = editorContext.editor = me.getEditorForCell(editorContext),
          {
            cell,
            record,
            column
          } = editorContext;

        editor.inputField.highlightExternalChange = false;
        editor.cellEditorContext = editorContext;
        editor.render(me.grid.getSubGridFromColumn(column).element);


        editor.startEdit({
          target: cell,
          record,
          field: editor.inputField.name || editorContext.column.field
        });
        return true;
      }
    }

    return false;
  }


  cancelEditing(silent = false) {
    const me = this,
      {
        editorContext,
        editor,
        grid
      } = me;

    if (editorContext) {

      if (editor.containsFocus) {


        me.editorContext = null;

        if (editor.inputField.owns(DomHelper.activeElement)) {
          DomHelper.focusWithoutScrolling(grid.focusElement);
        }

        me.editorContext = editorContext;
      }

      me.muteEvents = silent;
      editor.cancelEdit();
      me.muteEvents = false;
    }
  }


  async finishEditing() {
    const {
      editorContext
    } = this;
    let result = false;

    if (editorContext) {
      const {
        column
      } = editorContext;


      result = await editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));
    }

    return result;
  }


  onCellClickWhileEditing({
                            event,
                            cellSelector
                          }) {
    const me = this;

    if (me.editorContext && !me.editorContext.editor.owns(event.target)) {
      if (me.getEditingContext(cellSelector)) {


        if (me.finishEditing()) {
          me.startEditing(cellSelector);
        } else {
          me.grid.focusCell(me.editorContext.selector);
          me.editor.inputField.focus();
        }
      } else {
        me.finishEditing();
      }
    }
  }


  onCellClick({
                source: grid,
                record,
                cellSelector,
                cellElement,
                target,
                event
              }) {
    const selected = grid.focusedCell || {},
      column = grid.columns.getById(cellSelector.columnId);

    if (column.onCellClick) {
      column.onCellClick({
        grid,
        column,
        record,
        cellSelector,
        cellElement,
        target,
        event
      });
    } else if (target.closest('.b-tree-expander')) {
      this.cancelEditing();
      return false;
    } else if (DomHelper.isTouchEvent && cellSelector.id == selected.id && cellSelector.columnId == selected.columnId) {
      this.startEditing(cellSelector);
    } else if (this.triggerEvent === 'cellclick') {
      this.onTriggerEditEvent({
        cellSelector
      });
    }
  }


  onTriggerEditEvent({
                       cellSelector
                     }) {
    const me = this;

    if (me.editorContext && !me.finishEditing()) {
      return;
    }

    me.startEditing(cellSelector);
  }


  onStoreUpdate({
                  changes,
                  record
                }) {
    const {
      editorContext
    } = this;

    if (editorContext && editorContext.editor.isVisible) {
      if (record === editorContext.record && editorContext.editor.dataField in changes) {
        editorContext.editor.refreshEdit();
      }
    }
  }


  onGridBeforeRenderRows() {


    if (this.editorContext && this.editorContext.editor.isVisible) {
      this.cancelEditing();
    }
  }


  async onElementKeyDown(event) {
    const me = this;

    if (event.handled || !me.grid.focusElement.contains(event.target)) return;

    if (!me.editorContext) {
      const key = event.key,
        editingStartedWithCharacterKey = me.autoEdit && (key.length === 1 || key === 'Backspace');

      if ((editingStartedWithCharacterKey || validNonEditingKeys[key]) && me.grid.focusedCell) {
        event.preventDefault();

        if (!me.startEditing(me.grid.focusedCell)) {
          return;
        }

        const inputField = me.editor.inputField,
          input = inputField.input;

        if (editingStartedWithCharacterKey && input) {


          input.value = key === 'Backspace' ? '' : key;
          inputField.internalOnInput(event);

          inputField.moveCaretToEnd();
        }
      }
    } else {

      if (event.key === 'Enter') {
        event.preventDefault();
        event.stopPropagation();

        if (await me.finishEditing()) {

          if (!me.isEditing) {


            if (event.ctrlKey || event.metaKey || event.altKey || me.grid.touch) {
              return;
            } else if (event.shiftKey) {
              if (me.grid.navigateUp()) {
                me.startEditing(me.grid.focusedCell);
              }
            } else if (me.grid.navigateDown()) {
              me.startEditing(me.grid.focusedCell);
            }
          }
        }
      }

      if (event.key === 'F2') {
        event.preventDefault();
        me.finishEditing();
      }

      if (event.key === 'Escape') {
        event.stopPropagation();
        event.preventDefault();
        me.cancelEditing();
      }

      if (event.key === 'Tab') {
        event.preventDefault();
        const {
          focusedCell
        } = me.grid;

        if (focusedCell) {
          const cellInfo = me.getAdjacentEditableCell(focusedCell, !event.shiftKey);

          if (cellInfo) {
            if (await me.finishEditing()) {
              me.grid.focusCell(cellInfo, {
                animate: 100
              });
              me.startEditing(cellInfo);
            }
          }
        }
      }

      if (validEditingKeys[event.key]) {
        event.handled = true;
      }
    }
  }

  onElementMouseDown(event) {


    if (event.button === 2 && this.editorContext) {
      event.preventDefault();
    }
  }


  onEditorFocusOut(event) {
    const me = this,
      {
        grid
      } = me;


    if (me.editorContext && !me.editor.isFinishing && me.editor.inputField.owns(event.target) && (event.toWidget !== grid || grid.isLocationEqual(me.grid.focusedCell, me.editorContext.selector))) {
      if (me.blurAction === 'cancel') {
        me.cancelEditing();
      } else {
        me.finishEditing();
      }
    }
  }

  onEditorFocusIn(event) {
    const widget = event.toWidget;

    if (widget === this.editor.inputField) {
      if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {
        widget.selectAll();
      }
    }
  }


  onTapOut({
             event
           }) {
    const me = this;

    if (!me.grid.bodyContainer.contains(event.target)) {
      if (!me.editor.owns(event.target)) {
        if (me.blurAction === 'cancel') {
          me.cancelEditing();
        } else {
          me.finishEditing();
        }
      }
    }
  }


  onElementClick(event) {
    const me = this;

    if (event.target.classList.contains('b-grid-body-container') && me.editorContext) {
      me.finishEditing();
    }
  }

}

CellEdit._$name = 'CellEdit';
GridFeatureManager.registerFeature(CellEdit, true);


class Grid extends GridBase {
  static get $name() {
    return 'Grid';
  }

}

Grid._$name = 'Grid';
BryntumWidgetAdapterRegister.register('grid', Grid);


class TreeGrid extends Grid {
  static get $name() {
    return 'TreeGrid';
  }


  set store(store) {
    if (store && !store.tree) {

      if (store instanceof Store) {
        throw new Error('TreeGrid requires a Store configured with tree : true');
      } else {
        store.tree = true;
      }
    }

    super.store = store;
  }

  get store() {
    return super.store;
  }

}

TreeGrid._$name = 'TreeGrid';
BryntumWidgetAdapterRegister.register('treegrid', TreeGrid);


var AjaxTransport = (Target => class AjaxTransport extends (Target || Base) {

  static get defaultMethod() {
    return {
      load: 'GET',
      sync: 'POST'
    };
  }


  cancelRequest(requestPromise) {
    requestPromise.abort();
  }

  shouldUseBodyForRequestData(packCfg, method, paramName) {
    return !(method === 'HEAD' || method === 'GET') && !paramName;
  }


  sendRequest(config) {
    const me = this,
      {
        data
      } = config,
      transportConfig = me.transport[config.type] || {},

      requestConfig = Object.assign({}, transportConfig, transportConfig.requestConfig);
    requestConfig.method = requestConfig.method || AjaxTransport.defaultMethod[config.type];
    requestConfig.params = requestConfig.params || {};
    let {
      paramName
    } = requestConfig;

    if (me.shouldUseBodyForRequestData(transportConfig, requestConfig.method, paramName)) {
      requestConfig.body = data;

      requestConfig.headers = requestConfig.headers || {};
      requestConfig.headers['Content-Type'] = requestConfig.headers['Content-Type'] || 'application/json';
    } else {

      paramName = paramName || 'data';
      requestConfig.params[paramName] = data;
    }

    if (!requestConfig.url) {
      throw new Error('Trying to request without URL specified');
    }

    delete requestConfig.requestConfig;
    delete requestConfig.paramName;


    me.trigger('beforeSend', {
      params: requestConfig.params,
      type: config.type,
      requestConfig,
      config
    });

    requestConfig.queryParams = requestConfig.params;
    delete requestConfig.params;
    const fetchOptions = Object.assign({}, requestConfig, requestConfig.fetchOptions),
      ajaxPromise = AjaxHelper.fetch(requestConfig.url, fetchOptions);
    ajaxPromise.catch(error => {
      const signal = fetchOptions.abortController && fetchOptions.abortController.signal;

      if (signal && !signal.aborted) {
        console.warn(error);
      }
    }).then(response => {
      if (response && response.ok) {
        config.success && config.success.call(config.thisObj || me, response, fetchOptions);
      } else {
        config.failure && config.failure.call(config.thisObj || me, response, fetchOptions);
      }
    });
    return ajaxPromise;
  }

});


const storeSortFn = function (lhs, rhs, sortProperty) {

    if (lhs.store) {
      lhs = lhs.store;
    }

    if (rhs.store) {
      rhs = rhs.store;
    }

    lhs = lhs[sortProperty] || 0;
    rhs = rhs[sortProperty] || 0;
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  },

  storeLoadSortFn = function (lhs, rhs) {
    return storeSortFn(lhs, rhs, 'loadPriority');
  },

  storeSyncSortFn = function (lhs, rhs) {
    return storeSortFn(lhs, rhs, 'syncPriority');
  },
  nullFn$1 = () => {
  };


var AbstractCrudManagerMixin = (Target => class AbstractCrudManagerMixin extends Delayable(Target) {

  static get defaultConfig() {
    return {


      crudRevision: null,


      crudStores: [],


      storeIdProperty: 'storeId',


      crudFilterParam: 'filter',


      transport: {},


      trackResponseType: false,


      phantomIdField: '$PhantomId',


      phantomParentIdField: '$PhantomParentId',


      autoLoad: false,


      autoSyncTimeout: 100,


      autoSync: false,


      resetIdsBeforeSync: true,


      syncApplySequence: [],
      orderedCrudStores: [],


      writeAllFields: false,
      crudIgnoreUpdates: 0,

      crudLoaded: false,
      createMissingRecords: false,
      autoSyncTimerId: null,
      applyingLoadResponse: false,
      applyingSyncResponse: false,
      callOnFunctions: true
    };
  }

  get isCrudManager() {
    return true;
  }

  construct(config = {}) {
    this._requestId = 0;
    this.activeRequests = {};
    this.crudStoresIndex = {};
    super.construct(config);
  }

  afterConstruct() {
    super.afterConstruct();

    if (this.autoLoad) {
      this.load().catch(error => {
        if (!this.isValidResponse(error.rawResponse, error.response)) {
          throw error;
        }
      });
    }
  }


  getStoreDescriptor(storeId) {
    if (!storeId) return null;
    if (storeId instanceof Store) return this.crudStores.find(storeDesc => storeDesc.store === storeId);
    if (typeof storeId === 'object') return this.crudStoresIndex[storeId.storeId];
    return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));
  }

  fillStoreDescriptor(descriptor) {
    const {
        store
      } = descriptor,
      {
        storeIdProperty = this.storeIdProperty,
        modelClass
      } = store;

    if (!descriptor.storeId) {
      descriptor.storeId = store[storeIdProperty];
    }

    if (!descriptor.idField) {
      descriptor.idField = modelClass.idField;
    }

    if (!descriptor.phantomIdField) {
      descriptor.phantomIdField = modelClass.phantomIdField;
    }

    if (!descriptor.phantomParentIdField) {
      descriptor.phantomParentIdField = modelClass.phantomParentIdField;
    }

    if (!('writeAllFields' in descriptor)) {
      descriptor.writeAllFields = store.writeAllFields;
    }

    return descriptor;
  }

  updateCrudStoreIndex() {
    const crudStoresIndex = this.crudStoresIndex = {};
    this.crudStores.forEach(store => store.storeId && (crudStoresIndex[store.storeId] = store));
  }


  getCrudStore(storeId) {
    const storeInfo = this.getStoreDescriptor(storeId);
    return storeInfo && storeInfo.store;
  }

  forEachCrudStore(fn, thisObj = this) {
    if (!fn) return;
    this.crudStores.every(store => fn.call(thisObj, store.store, store.storeId, store) !== false);
  }

  set crudStores(stores) {
    this._crudStores = [];
    this.addCrudStore(stores);


    for (const store of this._crudStores) {
      store.loadPriority = store.syncPriority = 0;
    }
  }

  get crudStores() {
    return this._crudStores;
  }

  get orderedCrudStores() {
    return this._orderedCrudStores;
  }

  set orderedCrudStores(stores) {
    return this._orderedCrudStores = stores;
  }

  set syncApplySequence(stores) {
    this._syncApplySequence = [];
    this.addStoreToApplySequence(stores);
  }

  get syncApplySequence() {
    return this._syncApplySequence;
  }

  internalAddCrudStore(store) {
    const me = this;
    let storeInfo;

    if (store instanceof Store) {
      storeInfo = {
        store
      };
    } else if (typeof store === 'object') {

      if (store.stores) {
        if (!Array.isArray(store.stores)) {
          store.stores = [store.stores];
        }

        store.stores.forEach((subStore, j) => {
          let subStoreInfo = subStore;

          if (typeof subStore === 'string') {
            subStoreInfo = {
              storeId: subStore
            };
          }

          subStoreInfo.masterStoreInfo = store;
          store.stores[j] = subStoreInfo;
        });
      }

      storeInfo = store;
    } else {
      storeInfo = {
        store: Store.getStore(store)
      };
    }

    me.fillStoreDescriptor(storeInfo);

    store = storeInfo.store;

    if (store.setCrudManager) {
      store.setCrudManager(me);
    } else {
      store.crudManager = me;
    }


    store.pageSize = null;

    if (me.overrideCrudStoreLoad && store.load) {
      store.load = store.commit = () => {
      };
    }

    me.bindCrudStoreListeners(store);
    return storeInfo;
  }


  addCrudStore(store, position, fromStore) {
    if (!store) return;
    if (!Array.isArray(store)) store = [store];
    if (!store.length) return;
    const me = this,
      stores = store.map(me.internalAddCrudStore, me);

    if (typeof position === 'undefined') {
      me.crudStores.push(...stores);
    } else {
      let pos = position;

      if (fromStore) {
        if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);

        pos += me.crudStores.indexOf(fromStore);
      }


      me.crudStores.splice(pos, 0, ...stores);
    }

    me.orderedCrudStores.push(...stores);
    me.updateCrudStoreIndex();
  }


  addPrioritizedStore(store) {
    const me = this;

    if (!me.hasCrudStore(store)) {
      this.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));
    }

    if (!me.hasApplySequenceStore(store)) {
      this.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));
    }
  }

  hasCrudStore(store) {
    return this.crudStores.some(s => s === store || s.store === store || s.storeId === store);
  }


  removeCrudStore(store) {
    const me = this,
      stores = me.crudStores;

    for (let i = 0, l = stores.length; i < l; i++) {
      const s = stores[i];

      if (s === store || s.store === store || s.storeId === store) {

        me.unbindCrudStoreListeners(s.store);
        delete me.crudStoresIndex[s.storeId];
        stores.splice(i, 1);

        if (me.syncApplySequence) {
          me.removeStoreFromApplySequence(store);
        }

        break;
      }
    }
  }


  bindCrudStoreListeners(store) {
    store.on({
      name: 'store',
      change: 'onCrudStoreChange',
      thisObj: this
    });
  }

  unbindCrudStoreListeners() {
    this.detachListeners('store');
  }


  addStoreToApplySequence(store, position, fromStore) {
    if (!store) return;
    if (!Array.isArray(store)) store = [store];
    const me = this,

      data = store.reduce((collection, store) => {
        const s = me.getStoreDescriptor(store);
        if (s) collection.push(s);
        return collection;
      }, []);

    if (typeof position === 'undefined') {
      me.syncApplySequence.push(...data);
    } else {
      let pos = position;

      if (fromStore) {
        if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);

        pos += me.syncApplySequence.indexOf(fromStore);
      }


      me.syncApplySequence.splice(pos, 0, ...data);
    }

    const sequenceKeys = me.syncApplySequence.map(desc => desc.storeId);
    me.orderedCrudStores = [...me.syncApplySequence];
    me.crudStores.forEach(desc => {
      if (!sequenceKeys.includes(desc.storeId)) {
        me.orderedCrudStores.push(desc);
      }
    });
  }


  removeStoreFromApplySequence(store) {
    const index = this.syncApplySequence.findIndex(s => s === store || s.store === store || s.storeId === store);

    if (index > -1) {
      this.syncApplySequence.splice(index, 1);

      this.orderedCrudStores.splice(index, 1);
    }
  }

  hasApplySequenceStore(store) {
    return this.syncApplySequence.some(s => s === store || s.store === store || s.storeId === store);
  }


  onCrudStoreChange() {
    const me = this;
    if (me.crudIgnoreUpdates) return;


    if (me.crudStoreHasChanges()) {
      me.trigger('hasChanges');

      if (me.autoSync) {

        if (!me.autoSyncTimerId) {
          me.autoSyncTimerId = me.setTimeout(() => {
            me.autoSyncTimerId = null;
            me.sync().catch(error => {
              if (!me.isValidResponse(error.rawResponse, error.response)) {
                throw error;
              }
            });
          }, me.autoSyncTimeout);
        }
      }
    } else {
      me.trigger('noChanges');
    }
  }

  async internalOnResponse(requestType, responseText, fetchOptions, options) {

    const me = this;
    me.activeRequests[requestType] = null;
    const response = responseText ? me.decode(responseText) : null;

    if (!response || !response.success) {

      me.trigger('requestFail', {
        requestType,
        response,
        responseText,
        responseOptions: fetchOptions
      });


      me.trigger(requestType + 'Fail', {
        response,
        responseOptions: fetchOptions,
        responseText,
        options
      });
      return response;
    }


    if (me.trigger('beforeResponseApply', {
      requestType,
      response
    }) !== false && me.trigger('before' + StringHelper.capitalizeFirstLetter(requestType) + 'Apply', {
      response,
      options
    }) !== false) {
      me.crudRevision = response.revision;
      await me.applyResponse(requestType, response, options);


      me.trigger('requestDone', {
        requestType,
        response,
        responseOptions: fetchOptions
      });


      me.trigger(requestType, {
        response,
        responseOptions: fetchOptions,
        options
      });

      if (requestType === 'load' || !me.crudStoreHasChanges()) {

        me.trigger('noChanges');
      }
    }

    return response;
  }

  async internalOnLoad(responseText, fetchOptions, options) {

    this.crudLoaded = true;
    return this.internalOnResponse('load', responseText, fetchOptions, options);
  }

  async internalOnSync(responseText, fetchOptions, options) {
    return this.internalOnResponse('sync', responseText, fetchOptions, options);
  }


  suspendChangesTracking() {
    this.crudIgnoreUpdates++;
  }

  resumeChangesTracking(triggerCheck) {
    if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates) {
      if (triggerCheck) {
        this.onCrudStoreChange();
      }
    }
  }


  crudStoreHasChanges(storeId) {
    if (storeId) {
      const store = this.getCrudStore(storeId);
      return store && this.isCrudStoreDirty(store);
    }

    return this.crudStores.some(this.isCrudStoreDirty);


  }

  isCrudStoreDirty(store) {
    return store.store.changes != null;
  }


  emitCrudStoreEvents(stores, eventName) {
    const event = {
      action: 'read' + eventName
    };

    for (const store of this.crudStores) {
      if (stores.includes(store.storeId)) {
        store.store.trigger(eventName, event);
      }
    }
  }

  getLoadPackage(options) {
    const pack = {
        type: 'load',
        requestId: this.requestId
      },
      stores = this.crudStores,
      optionsCopy = Object.assign({}, options);
    pack.stores = stores.map(store => {
      const opts = optionsCopy && optionsCopy[store.storeId],
        pageSize = store.pageSize || store.store && store.store.pageSize;


      if (opts || pageSize) {
        const params = Object.assign({
          storeId: store.storeId,
          page: 1
        }, opts);

        if (pageSize) {
          params.pageSize = pageSize;
        }

        store.currentPage = params.page;

        if (opts) {
          delete optionsCopy[store.storeId];
        }

        return params;
      }

      return store.storeId;
    });

    Object.assign(pack, optionsCopy);
    return pack;
  }

  loadCrudStore(store, data, options) {
    const rows = data && data.rows;

    if (options && options.append || data.append) {
      store.add(rows);
    } else {
      store.data = rows;
    }

    store.trigger('load', {
      source: store,
      data: rows
    });
  }

  loadDataToCrudStore(storeDesc, data, options) {
    const me = this,
      store = storeDesc.store,

      subStores = storeDesc.stores,
      idField = storeDesc.idField || 'id',

      isTree = store.tree,
      rows = data && data.rows;
    store.__loading = true;


    if (rows) {
      let subData;

      if (subStores) {
        subData = me.getSubStoresData(rows, subStores, idField, isTree);
      }

      me.loadCrudStore(store, data, options, storeDesc);

      if (subData) {

        subData.forEach(sub => {
          me.loadDataToCrudStore(Object.assign({
            store: store.getById(sub.id).get(sub.storeDesc.storeId)

          }, sub.storeDesc), sub.data);
        });
      }
    }

    store.__loading = false;
  }

  loadCrudManagerData(response, options = {}) {

    this.suspendChangesTracking();

    this.crudStores.forEach(storeDesc => {
      const storeId = storeDesc.storeId,
        data = response[storeId];

      if (data) {
        this.loadDataToCrudStore(storeDesc, data, options[storeId]);
      }
    });
    this.resumeChangesTracking();
  }


  get isCrudManagerLoading() {
    return Boolean(this.activeRequests.load || this.applyingLoadResponse);
  }

  get isLoadingOrSyncing() {
    return Boolean(this.activeRequests.load || this.activeRequests.sync);
  }


  load(options) {
    const me = this,
      pack = me.getLoadPackage(options);
    return new Promise((resolve, reject) => {

      if (me.trigger('beforeLoad', {
        pack
      }) !== false) {

        if (me.activeRequests.load) {
          me.cancelRequest(me.activeRequests.load.desc);
          me.trigger('loadCanceled', {
            pack
          });
        }

        me.activeRequests.load = {
          options,
          pack,
          resolve,
          reject,
          id: pack.requestId,
          desc: me.sendRequest({
            data: me.encode(pack),
            type: 'load',
            success: me.onLoadSuccess,
            failure: me.onLoadFailure,
            thisObj: me
          })
        };
        me.emitCrudStoreEvents(pack.stores, 'loadStart');
        me.trigger('loadStart', {
          pack
        });
      } else {

        me.trigger('loadCanceled', {
          pack
        });
        me.processPromise(reject, null, {
          action: 'load',
          cancelled: true
        });
      }
    });
  }

  async onLoadSuccess(rawResponse, fetchOptions) {
    let responseText = '';
    const request = this.activeRequests.load,
      {
        options
      } = request;
    await rawResponse.text().then(value => responseText = value).catch(nullFn$1);
    const response = await this.internalOnLoad(responseText, fetchOptions, options);
    this.emitCrudStoreEvents(request.pack.stores, 'afterRequest');

    if (response && response.success) {
      request.resolve({
        response,
        rawResponse,
        responseText,
        options
      });
    } else {
      this.processPromise(request.reject, request.resolve, {
        action: 'load',
        cancelled: false,
        response,
        rawResponse,
        responseText,
        options
      });
    }
  }

  async onLoadFailure(rawResponse, fetchOptions = {}) {
    const request = this.activeRequests.load,
      {
        options
      } = request,
      signal = fetchOptions.abortController && fetchOptions.abortController.signal,
      wasAborted = Boolean(signal && signal.aborted);

    if (!wasAborted) {
      let responseText = '';

      if (rawResponse) {
        await rawResponse.text().then(value => responseText = value).catch(nullFn$1);
      }

      const response = await this.internalOnLoad(responseText, fetchOptions, options);
      this.emitCrudStoreEvents(request.pack.stores, 'afterRequest');
      this.processPromise(request.reject, null, {
        action: 'load',
        cancelled: wasAborted,
        response,
        rawResponse,
        responseText,
        options,
        request
      });
    }
  }

  getSubStoresData(rows, subStores, idField, isTree) {
    if (!rows) return;
    const result = [];

    function processRow(row, subStores) {
      subStores.forEach(subStore => {
        const storeId = subStore.storeId;

        if (row[storeId]) {

          result.push({
            id: row[idField],
            storeDesc: subStore,
            data: row[storeId]
          });

          delete row[storeId];
        }
      });
    }

    if (isTree) {

      rows.forEach(row => {
        processRow(row, subStores);

        const childrenSubData = this.getSubStoresData(row.children, subStores, idField, true);

        if (childrenSubData) {
          result.push(...childrenSubData);
        }
      });
    } else {
      rows.forEach(row => processRow(row, subStores));
    }

    return result;
  }


  prepareAdded(list, storeInfo) {
    const {
        store,
        stores
      } = storeInfo,
      {
        isTree
      } = store,
      phantomIdField = storeInfo.phantomIdField || this.phantomIdField,
      phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField;
    return list.filter(record => record.isValid).map(record => {
      const cls = record.constructor,
        data = Object.assign(record.persistableData, {
          [phantomIdField]: record.id
        });

      if (isTree) {
        const {
          parent
        } = record;

        if (parent && !parent.isRoot && parent.isPhantom) {
          data[phantomParentIdField] = parent.id;
        }
      }

      if (this.resetIdsBeforeSync) delete ObjectHelper.deletePath(data, cls.getFieldDataSource(cls.idField));

      if (stores) {
        this.processSubStores(record, data, stores);
      }

      return data;
    });
  }

  prepareUpdated(list, storeInfo) {
    const {
        store,
        stores
      } = storeInfo,
      {
        isTree
      } = store,
      writeAllFields = storeInfo.writeAllFields || storeInfo.writeAllFields !== false && this.writeAllFields,
      phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField;


    if (storeInfo.store.tree) {
      const rootNode = storeInfo.store.rootNode;
      list = list.filter(record => record !== rootNode);
    }

    return list.filter(record => record.isValid).reduce((data, record) => {
      let recordData;

      if (writeAllFields) {
        recordData = record.persistableData;
      } else {
        recordData = record.modificationData;


      }

      if (isTree) {
        const {
          parent
        } = record;

        if (parent && !parent.isRoot && parent.isPhantom) {
          recordData[phantomParentIdField] = parent.id;
        }
      }

      if (stores) {
        this.processSubStores(record, recordData, stores);
      }

      if (!ObjectHelper.isEmpty(recordData)) {
        data.push(recordData);
      }

      return data;
    }, []);
  }

  prepareRemoved(list) {
    return list.map(record => {
      const cls = record.constructor;
      return ObjectHelper.setPath({}, cls.getFieldDataSource(cls.idField), record.id);
    });
  }

  processSubStores(record, data, stores) {
    stores.forEach(store => {
      const id = store.storeId,
        subStore = record.get(id);

      if (subStore) {

        const changes = this.getCrudStoreChanges(Object.assign({
          store: subStore
        }, store));

        if (changes) {
          data[id] = Object.assign(changes, {
            $store: true
          });
        } else {
          delete data[id];
        }
      } else {
        delete data[id];
      }
    });
  }

  getCrudStoreChanges(storeDescriptor) {
    const {
      store
    } = storeDescriptor;
    let added = store.added.values,
      updated = store.modified.values,
      removed = store.removed.values,

      result;
    if (added.length) added = this.prepareAdded(added, storeDescriptor);
    if (updated.length) updated = this.prepareUpdated(updated, storeDescriptor);
    if (removed.length) removed = this.prepareRemoved(removed);

    if (added.length || updated.length || removed.length) {
      result = {};
      if (added.length) result.added = added;
      if (updated.length) result.updated = updated;
      if (removed.length) result.removed = removed;
    }

    return result;
  }

  getChangeSetPackage() {
    const pack = {
      type: 'sync',
      requestId: this.requestId,
      revision: this.crudRevision
    };
    let found = 0;
    this.crudStores.forEach(store => {
      const changes = this.getCrudStoreChanges(store);

      if (changes) {
        found++;
        pack[store.storeId] = changes;
      }
    });
    return found ? pack : null;
  }


  applyChangesToRecord(record, rawChanges, stores) {
    const me = this,
      modelClass = record.constructor,
      {
        fieldDataSourceMap
      } = modelClass,
      recProto = modelClass.prototype,
      changes = {},
      data = record.data,
      done = {
        [me.phantomIdField]: true
      };
    let hasChanges;

    if (stores) {

      stores.forEach(store => {
        const name = store.storeId;

        if (Object.prototype.hasOwnProperty.call(rawChanges, name)) {

          done[name] = true;
          const subStore = record.get(name);

          if (subStore) {
            me.applyChangesToStore(Object.assign({
              store: subStore
            }, store), rawChanges[name]);
          } else {
            console.log('Can\'t find store for the response sub-package');
          }
        }
      });
    }

    const rawChangesFiltered = {};

    for (const key in rawChanges) {
      if (Object.prototype.hasOwnProperty.call(rawChanges, key) && !done[key]) {
        rawChangesFiltered[key] = rawChanges[key];
      }
    }

    const rowChangesSimplePaths = ObjectHelper.pathifyKeys(rawChangesFiltered);

    for (const dataSource in rowChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource],
        propName = field ? field.name : dataSource,
        value = modelClass.processField(propName, rowChangesSimplePaths[dataSource]),
        oldValue = dataSource in recProto ? record[propName] : ObjectHelper.getPath(data, dataSource);

      if (!ObjectHelper.isEqual(oldValue, value)) {
        hasChanges = true;
        changes[propName] = value;
      }
    }

    if (hasChanges) {
      me.suspendChangesTracking();

      for (const fieldName in changes) {
        record[fieldName] = changes[fieldName];
      }


      me.resumeChangesTracking();
    }


    record.clearChanges(true, false);
  }

  applyRemovals(store, removed, context) {
    const {
        removed: removedStash,
        modelClass
      } = store,
      findByIdFn = context.findByIdFn,
      removeRecordFn = context.removeRecordFn,
      dataSource = modelClass.getFieldDataSource(modelClass.idField);
    let applied = 0;
    removed.forEach(remove => {
      const id = remove[dataSource];
      let done = false;

      if (removedStash.includes(id)) {
        removedStash.remove(id);
        done = true;

        applied++;
      }


      if (!done) {
        const record = findByIdFn(id);

        if (record) {
          this.suspendChangesTracking();
          removeRecordFn(record);
          removedStash.remove(record);

          applied++;
          this.resumeChangesTracking();
        } else {
          console.log('Can\'t find record to remove from the response package');
        }
      }
    });
    return applied;
  }

  getApplyChangesToStoreHelpers(store) {

    if (store.tree) {
      return {
        findByPhantomFn: id => store.getById(id),
        findByIdFn: id => store.getById(id),

        addRecordFn: data => {
          const parent = data.parentId && store.getById(data.parentId) || store.rootNode;
          return parent.appendChild(data);
        },
        removeRecordFn: record => record.remove()
      };
    } else {
      return {
        findByPhantomFn: id => store.getById(id),
        findByIdFn: id => store.getById(id),
        addRecordFn: data => store.add(data)[0],
        removeRecordFn: record => store.remove(record)
      };
    }
  }

  applyChangesToStore(storeDesc, storeResponse) {
    const me = this,
      phantomIdField = storeDesc.phantomIdField || me.phantomIdField,
      store = storeDesc.store,
      {
        modelClass
      } = store,
      idDataSource = modelClass.getFieldDataSource(modelClass.idField),
      {
        findByPhantomFn,
        findByIdFn,
        addRecordFn,
        removeRecordFn
      } = me.getApplyChangesToStoreHelpers(store),
      {
        rows,
        removed
      } = storeResponse;

    if (rows) {

      const stores = storeDesc.stores;
      rows.forEach(data => {
        const phantomId = data[phantomIdField],
          id = ObjectHelper.getPath(data, idDataSource);
        let record = null;

        if (phantomId != null) {
          record = findByPhantomFn(phantomId);
        } else if (id != null) {
          record = findByIdFn(id);
        }

        if (record) {
          me.applyChangesToRecord(record, data, stores, store);
        } else {
          me.suspendChangesTracking();

          record = addRecordFn(data);
          me.resumeChangesTracking();
          record.clearChanges();
        }
      });
    }

    if (removed && me.applyRemovals(store, removed, {
      findByIdFn,
      removeRecordFn
    })) {
      store.trigger('dataChanged', {
        source: store
      });
    }
  }

  applySyncResponse(response) {
    const me = this,
      stores = me.orderedCrudStores;
    me.applyingSyncResponse = true;

    for (const store of stores) {
      const storeResponse = response[store.storeId];

      if (storeResponse) {
        me.applyChangesToStore(store, storeResponse);
      }
    }

    me.applyingSyncResponse = false;
  }

  applyLoadResponse(response, options) {
    this.applyingLoadResponse = true;
    this.loadCrudManagerData(response, options);
    this.applyingLoadResponse = false;
  }

  async applyResponse(requestType, response, options) {

    if (this.trackResponseType) {
      requestType = response.type || requestType;
    }

    switch (requestType) {
      case 'load':
        this.applyLoadResponse(response, options);
        break;

      case 'sync':
        this.applySyncResponse(response);
        break;
    }
  }


  get requestId() {
    return Number.parseInt(`${Date.now()}${this._requestId++}`);
  }


  sync() {
    const me = this;

    if (me.activeRequests.sync) {


      me.trigger('syncDelayed');

      return me.activeSyncPromise = me.activeSyncPromise.then(() => me.sync(), () => me.sync());
    }


    return me.activeSyncPromise = new Promise((resolve, reject) => {

      const pack = me.getChangeSetPackage();

      if (!pack) {
        resolve(null);
        return;
      }


      if (me.trigger('beforeSync', {
        pack
      }) !== false) {
        me.trigger('syncStart', {
          pack
        });

        me.activeRequests.sync = {
          pack,
          resolve,
          reject,
          id: pack.requestId,
          desc: me.sendRequest({
            data: me.encode(pack),
            type: 'sync',
            success: me.onSyncSuccess,
            failure: me.onSyncFailure,
            thisObj: me
          })
        };
      } else {


        me.trigger('syncCanceled', {
          pack
        });
        this.processPromise(reject, null, {
          action: 'sync',
          cancelled: true
        });
      }
    });
  }

  async onSyncSuccess(rawResponse, fetchOptions) {
    let responseText = '';
    await rawResponse.text().then(value => responseText = value).catch(nullFn$1);
    const request = this.activeRequests.sync,
      response = await this.internalOnSync(responseText, fetchOptions);

    if (response && response.success) {
      request.resolve({
        response,
        rawResponse,
        responseText,
        request
      });
    } else {
      this.processPromise(request.reject, request.resolve, {
        action: 'sync',
        cancelled: false,
        response,
        rawResponse,
        responseText,
        request
      });
    }
  }

  async onSyncFailure(rawResponse, fetchOptions = {}) {
    const request = this.activeRequests.sync,
      {
        options
      } = request,
      signal = fetchOptions.abortController && fetchOptions.abortController.signal,
      wasAborted = Boolean(signal && signal.aborted);

    if (!wasAborted) {
      let responseText = '';

      if (rawResponse) {
        await rawResponse.text().then(value => responseText = value).catch(nullFn$1);
      }

      const response = await this.internalOnSync(responseText, fetchOptions, options);
      this.processPromise(request.reject, null, {
        action: 'sync',
        cancelled: wasAborted,
        response,
        rawResponse,
        responseText,
        options,
        request
      });
    }
  }


  commitCrudStores() {
    this.crudStores.forEach(store => store.store.commit());
  }


  rejectCrudStores() {
    this.orderedCrudStores.forEach(store => store.store.clearChanges());
  }


  doDestroy() {
    const me = this;
    me.activeRequests.load && me.cancelRequest(me.activeRequests.load.desc);
    me.activeRequests.sync && me.cancelRequest(me.activeRequests.sync.desc);

    while (me.crudStores.length > 0) {
      me.removeCrudStore(me.crudStores[0]);
    }

    clearTimeout(me.autoSyncTimerId);
    me.destroyed = true;
    super.doDestroy && super.doDestroy();
  }


  isValidResponse(rawResponse, response) {
    return rawResponse && (rawResponse.ok && response || [500, 404].includes(rawResponse.status));
  }

  processPromise(reject, resolve, context) {
    const {
      cancelled,
      action,
      rawResponse,
      response
    } = context;

    if (resolve && this.isValidResponse(rawResponse, response)) {
      resolve(context);
    } else {
      const message = `${StringHelper.capitalizeFirstLetter(action)} ${cancelled ? 'canceled' : 'failed'}`,
        error = new Error(message);
      Object.assign(error, context);
      reject(error);
    }
  }

});


class AbstractCrudManager extends AbstractCrudManagerMixin(Events(Base)) {


  get revision() {
    return this.crudRevision;
  }

  set revision(value) {
    this.crudRevision = value;
  }

  static get defaultConfig() {

    return Object.assign({}, this.crudManagerDefaultConfig, {
      overrideCrudStoreLoad: true,


      stores: null


    });
  }


  construct(config = {}) {
    if (config.stores) {
      config.crudStores = config.stores;
      delete config.stores;
    }

    super.construct(config);
  }


  set stores(stores) {

    if (stores !== this.crudStores) {
      this.crudStores = stores;
    }
  }


  get stores() {
    return this.crudStores;
  }


  get isLoading() {
    return this.isCrudManagerLoading;
  }


  commit() {
    this.commitCrudStores();
  }


  reject() {
    this.rejectCrudStores();
  }


  addStore(...args) {
    return this.addCrudStore(...args);
  }

  removeStore(...args) {
    return this.removeCrudStore(...args);
  }

  getStore(...args) {
    return this.getCrudStore(...args);
  }

  hasChanges(...args) {
    return this.crudStoreHasChanges(...args);
  }

  loadData(...args) {
    return this.loadCrudManagerData(...args);
  }

}

AbstractCrudManager._$name = 'AbstractCrudManager';


var CrudManagerView = (Target => class CrudManagerView extends Target {

  static get $name() {
    return 'CrudManagerView';
  }

  static get defaultConfig() {
    return {

      crudManagerClass: null,


      crudManager: null
    };
  }


  afterConstruct() {
    const me = this;

    if (me.crudManager && me.loadMask && me.crudManager.isCrudManagerLoading) {

      me.maskBody(me.loadMask);
    }
  }


  bindCrudManager(crudManager) {
    this.detachListeners('crudManager');
    crudManager && crudManager.on({
      name: 'crudManager',
      loadStart: 'onCrudManagerLoadStart',
      load: 'onCrudManagerLoad',
      loadCanceled: 'onCrudManagerLoadCanceled',
      syncStart: 'onCrudManagerSyncStart',
      sync: 'onCrudManagerSync',
      syncCanceled: 'onCrudManagerSyncCanceled',
      requestFail: 'onCrudManagerRequestFail',
      thisObj: this
    });
  }

  onCrudManagerLoadStart() {

    if (this.loadMask) {
      this.maskBody(this.loadMask);
    }

    this.toggleEmptyText();
  }

  onCrudManagerSyncStart() {
    if (this.syncMask) {
      this.maskBody(this.syncMask);
    }
  }

  onCrudManagerRequestFinalize(successful = true, requestType, response) {
    var me = this;
    if (!me.activeMask) return;

    if (successful) {
      me.unmaskBody();
      me.toggleEmptyText();
    } else {
      me.activeMask.icon = me.loadMaskErrorIcon;
      me.activeMask.text = `<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${me.L(`${requestType}FailedMessage`)}</div>
                ${response && response.message ? `<div class="b-grid-load-fail">${me.L('serverResponseLabel')} ${response.message}</div>` : ''}
            </div>`;
      me.loadmaskHideTimer = me.setTimeout(() => {
        me.onCrudManagerRequestFinalize();
      }, me.loadMaskHideTimeout);
    }
  }

  onCrudManagerLoadCanceled() {
    this.onCrudManagerRequestFinalize();
  }

  onCrudManagerSyncCanceled() {
    this.onCrudManagerRequestFinalize();
  }

  onCrudManagerLoad() {
    this.onCrudManagerRequestFinalize();
  }

  onCrudManagerSync() {
    this.onCrudManagerRequestFinalize();
  }

  onCrudManagerRequestFail({
                             requestType,
                             response
                           }) {
    this.onCrudManagerRequestFinalize(false, requestType, response);
  }


  get crudManager() {
    return this._crudManager;
  }

  set crudManager(crudManager) {
    const me = this;

    if (crudManager && crudManager.isCrudManager) {
      me._crudManager = crudManager;
    } else if (crudManager && me.crudManagerClass) {


      crudManager = new me.crudManagerClass(Object.assign({
        scheduler: me
      }, crudManager));
    } else {
      me._crudManager = null;
    }

    me.bindCrudManager(me._crudManager);
  }

});


class ModelPersistencyManager extends Base {

  set eventStore(newEventStore) {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me._eventStore = newEventStore;

    if (newEventStore && newEventStore.autoCommit) {
      me.eventStoreDetacher = newEventStore.on({
        beforecommit: me.onEventStoreBeforeSync,
        thisObj: me,
        detachable: true,

        prio: 100
      });
    }
  }

  get eventStore() {
    return this._eventStore;
  }

  set resourceStore(newResourceStore) {
    const me = this;
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    me._resourceStore = newResourceStore;

    if (newResourceStore && newResourceStore.autoCommit) {
      me.resourceStoreDetacher = newResourceStore.on({
        beforecommit: me.onResourceStoreBeforeSync,
        thisObj: me,
        detachable: true,

        prio: 100
      });
    }
  }

  get resourceStore() {
    return this._resourceStore;
  }

  set assignmentStore(newAssignmentStore) {
    const me = this;
    me.assignmentStoreDetacher && me.assignmentStoreDetacher();
    me._assignmentStore = newAssignmentStore;

    if (newAssignmentStore && newAssignmentStore.autoSync) {
      me.assignmentStoreDetacher = newAssignmentStore.on({
        beforecommit: me.onAssignmentStoreBeforeSync,
        thisObj: me,
        detachable: true,

        prio: 100
      });
    }
  }

  get assignmentStore() {
    return this._assignmentStore;
  }

  set dependencyStore(newDependencyStore) {
    const me = this;
    me.dependencyStoreDetacher && me.dependencyStoreDetacher();
    me._dependencyStore = newDependencyStore;

    if (newDependencyStore && newDependencyStore.autoSync) {
      me.dependencyStoreDetacher = newDependencyStore.on({
        beforecommit: me.onDependencyStoreBeforeSync,
        thisObj: me,
        detachable: true,

        prio: 100
      });
    }
  }

  get dependencyStore() {
    return this._dependencyStore;
  }


  onEventStoreBeforeSync({
                           changes
                         }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  onResourceStoreBeforeSync({
                              changes
                            }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  onAssignmentStoreBeforeSync({
                                changes
                              }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  onDependencyStoreBeforeSync({
                                changes
                              }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }


  removeNonPersistableRecordsToCreate(changes) {
    let recordsToCreate = changes.added || [],
      r,
      i;

    for (i = recordsToCreate.length - 1; i >= 0; --i) {
      r = recordsToCreate[i];

      if (!r.isPersistable) {
        recordsToCreate.splice(recordsToCreate.indexOf(r), 1);
      }
    }

    if (recordsToCreate.length === 0) {
      changes.added.length = 0;
    }
  }

  shallContinueSync(options) {
    return Boolean(options.added && options.added.length > 0 || options.modified && options.modified.length > 0 || options.removed && options.removed.length > 0);
  }

}

ModelPersistencyManager._$name = 'ModelPersistencyManager';


class AssignmentModel extends Model {

  static get fields() {
    return [

      {
        name: 'resourceId'
      },

      {
        name: 'eventId'
      }];
  }

  static get relationConfig() {
    return [

      {
        relationName: 'resource',
        fieldName: 'resourceId',
        store: 'resourceStore',
        collectionName: 'assignments'
      },

      {
        relationName: 'event',
        fieldName: 'eventId',
        store: 'eventStore',
        collectionName: 'assignments'
      }];
  }


  get eventResourceKey() {
    return `${this.event ? this.eventId : this.data.eventId || this.internalId}-${this.resource ? this.resourceId : this.data.resourceId || this.internalId}`;
  }


  get assignmentStore() {
    return this.stores && this.stores[0];
  }


  get eventStore() {
    const {
      assignmentStore
    } = this;
    return assignmentStore && assignmentStore.eventStore;
  }


  get resourceStore() {
    const {
      eventStore
    } = this;
    return eventStore && eventStore.resourceStore;
  }


  get eventName() {
    return this.event && this.event.name;
  }


  get resourceName() {
    return this.resource && this.resource.name;
  }


  getResource(resourceStore = this.resourceStore) {


    return resourceStore && resourceStore.getById(this.resourceId);
  }


  get isAssignment() {
    return true;
  }


  get isPersistable() {
    const {
        event,
        resource,
        stores,
        unjoinedStores
      } = this,
      store = stores[0];
    let result;

    if (store) {


      result = this.isValid && (store.crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);
    } else {
      result = unjoinedStores[0];
    }

    return Boolean(result);
  }

  get isValid() {
    return this.resource != null && this.event != null;
  }

  fullCopy() {


    throw new Error('Not implemented');
  }

  get eventResourceCompositeKey() {
    return AssignmentModel.makeAssignmentEventResourceCompositeKey(this.eventId, this.resourceId);
  }

  static makeAssignmentEventResourceCompositeKey(eventId, resourceId) {
    return `event(${eventId})-resource(${resourceId})`;
  }

}

AssignmentModel.exposeProperties();
AssignmentModel._$name = 'AssignmentModel';


var EventStoreMixin = (Target => class EventStoreMixin extends (Target || Base) {


  get resourceStore() {
    return this._resourceStore;
  }

  set resourceStore(resourceStore) {
    const me = this,
      oldStore = me._resourceStore;

    if (oldStore) {
      oldStore.eventStore = null;
      if (me.modelPersistencyManager) me.modelPersistencyManager.resourceStore = null;
    }

    me._resourceStore = resourceStore || null;

    if (resourceStore) {
      if (me.modelPersistencyManager) me.modelPersistencyManager.resourceStore = me._resourceStore;
      resourceStore.eventStore = me;
    }

    if (!me.isConfiguring) {
      me.initRelations(true);
    }

    if ((oldStore || resourceStore) && oldStore !== resourceStore) {

      me.trigger('resourceStoreChange', {
        newResourceStore: resourceStore,
        oldResourceStore: oldStore
      });
    }
  }


  get assignmentStore() {
    return this._assignmentStore;
  }

  set assignmentStore(assignmentStore) {
    const me = this,
      oldStore = me._assignmentStore;

    if (oldStore) {
      oldStore.eventStore = null;
      if (me.modelPersistencyManager) me.modelPersistencyManager.assignmentStore = null;
    }

    me._assignmentStore = assignmentStore || null;

    if (assignmentStore) {
      if (me.modelPersistencyManager) me.modelPersistencyManager.assignmentStore = me._assignmentStore;
      assignmentStore.eventStore = me;
    }

    if (!me.isConfiguring) {
      me.initRelations(true);
    }

    if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {

      me.trigger('assignmentStoreChange', {
        newAssignmentStore: assignmentStore,
        oldAssignmentStore: oldStore
      });
    }
  }


  get dependencyStore() {
    return this._dependencyStore;
  }

  set dependencyStore(dependencyStore) {
    const me = this,
      oldStore = me._dependencyStore;

    if (oldStore) {
      oldStore.eventStore = null;
      if (me.modelPersistencyManager) me.modelPersistencyManager.dependencyStore = null;
    }

    me._dependencyStore = dependencyStore || null;

    if (me._dependencyStore) {
      if (me.modelPersistencyManager) me.modelPersistencyManager.dependencyStore = me._dependencyStore;
      me._dependencyStore.eventStore = me;
    }

    if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {

      me.trigger('dependencyStoreChange', {
        newDependencyStore: dependencyStore,
        oldDependencyStore: oldStore
      });
    }
  }


  construct(config) {
    const me = this;
    super.construct(config);
    Object.assign(me, {
      isEventStore: true,
      autoTree: true,
      modelPersistencyManager: me.createModelPersistencyManager()
    });
  }


  createModelPersistencyManager() {
    const me = this;
    return new ModelPersistencyManager({
      eventStore: me,
      resourceStore: me.resourceStore,
      assignmentStore: me.assignmentStore,
      dependencyStore: me.dependencyStore
    });
  }


  getEventsInTimeSpan(start, end, allowPartial = true, onlyAssigned = false) {
    const events = [];
    this.forEachScheduledEvent((event, eventStart, eventEnd) => {
      if (allowPartial && DateHelper.intersectSpans(eventStart, eventEnd, start, end) || !allowPartial && eventStart - start >= 0 && end - eventEnd >= 0) {
        if (!onlyAssigned || event.resources.length > 0) {
          events.push(event);
        }
      }
    });
    return events;
  }


  getEventsByStartDate(start) {
    const events = [];
    this.forEachScheduledEvent((event, eventStart, eventEnd) => {
      if (DateHelper.isEqual(eventStart, start, 'day')) {
        events.push(event);
      }
    });
    return events;
  }


  forEachScheduledEvent(fn, thisObj = this) {
    this.forEach(event => {
      const eventStart = event.startDate,
        eventEnd = event.endDate;
      if (eventStart && eventEnd) return fn.call(thisObj, event, eventStart, eventEnd);
    });
  }


  getTotalTimeSpan() {
    let earliest = new Date(9999, 0, 1),
      latest = new Date(0);
    this.forEach(r => {
      if (r.startDate) earliest = DateHelper.min(r.startDate, earliest);
      if (r.endDate) latest = DateHelper.max(r.endDate, latest);
    });

    earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
    latest = latest > new Date(0) ? latest : null;

    return this.lastTotalTimeSpan = {
      startDate: earliest || null,
      endDate: latest || earliest || null
    };
  }


  isEventPersistable(event) {
    let result = true;

    if (!this.assignmentStore) {
      const store = event.stores[0],
        crudManager = store && store.crudManager;

      if (store) {


        result = crudManager || !event.resource || !event.resource.hasGeneratedId;
      } else {
        result = true;
      }
    }

    return result;
  }


  isDateRangeAvailable(start, end, excludeEvent, resource) {
    if (excludeEvent instanceof AssignmentModel) {
      const currentEvent = excludeEvent.event,
        resources = currentEvent.resources,
        allEvents = new Set(resource.events);
      resources.forEach(resource => {
        resource.events.forEach(e => allEvents.add(e));
      });
      allEvents.delete(currentEvent);
      return !Array.from(allEvents).some(ev => DateHelper.intersectSpans(start, end, ev.startDate, ev.endDate));
    }

    return !this.getEventsForResource(resource).some(ev => !(excludeEvent === ev || !DateHelper.intersectSpans(start, end, ev.startDate, ev.endDate)));
  }


  filterEventsForResource(resource, fn, thisObj = this) {

    return resource.getEvents(this).filter(fn.bind(thisObj));
  }


  getResourcesForEvent(event) {
    if (this.assignmentStore) {
      return this.assignmentStore.getResourcesForEvent(event);
    }

    event = this.getById(event);
    return event.resource && !event.resource.placeHolder ? [event.resource] : [];
  }


  getEventsForResource(resource) {
    if (this.assignmentStore) {
      return this.assignmentStore.getEventsForResource(resource);
    }

    resource = Model.asId(resource);

    const cache = this.relationCache.resource && this.relationCache.resource[resource];

    return cache ? cache.slice() : [];
  }


  getAssignmentsForEvent(event) {
    return this.assignmentStore && this.assignmentStore.getAssignmentsForEvent(event) || [];
  }


  getAssignmentsForResource(resource) {
    return this.assignmentStore && this.assignmentStore.getAssignmentsForResource(resource) || [];
  }


  assignEventToResource(event, resource, removeExistingAssignments = false) {
    if (this.assignmentStore) {
      this.assignmentStore.assignEventToResource(event, resource, undefined, removeExistingAssignments);
    } else {
      event = this.getById(event);

      if (Array.isArray(resource)) {
        resource = resource[0];
      }

      if (event) {
        event.resourceId = Model.asId(resource);
      }
    }
  }


  unassignEventFromResource(event, resource) {
    if (this.assignmentStore) {
      this.assignmentStore.unassignEventFromResource(event, resource);
    } else {
      event = this.getById(event);
      resource = Model.asId(resource);

      if (event && event.resourceId == resource) {
        event.resourceId = null;
      }
    }
  }


  reassignEventFromResourceToResource(event, oldResource, newResource) {
    const me = this,
      {
        assignmentStore
      } = me,
      newResourceId = Model.asId(newResource),
      oldResourceId = Model.asId(oldResource);

    if (assignmentStore) {
      const assignment = assignmentStore.getAssignmentForEventAndResource(event, oldResource);

      if (assignment) {
        assignment.resourceId = newResourceId;
      } else {
        assignmentStore.assignEventToResource(event, newResource);
      }
    } else {
      event = me.getById(event);

      if (event.resourceId == oldResourceId) {
        event.resourceId = newResourceId;
      }
    }
  }


  isEventAssignedToResource(event, resource) {
    if (this.assignmentStore) {
      return this.assignmentStore.isEventAssignedToResource(event, resource);
    }

    event = this.getById(event);
    resource = Model.asId(resource);
    return event && event.resourceId == resource || false;
  }


  removeAssignmentsForEvent(event) {
    if (this.assignmentStore) {
      this.assignmentStore.removeAssignmentsForEvent(event);
    } else {
      event = this.getById(event);

      if (event) {

        event.resourceId = null;
      }
    }
  }


  removeAssignmentsForResource(resource) {
    const {
      assignmentStore,
      resourceStore
    } = this;

    if (assignmentStore) {
      assignmentStore.removeAssignmentsForResource(resource);
    } else if (resourceStore) {
      resource = resourceStore.getById(resource);


    } else {
      resource = Model.asId(resource);

      this.forEach(event => event.resourceId == resource && (event.resourceId = null));
    }
  }

});


class DelayedCallsManager extends Delayable(Events()) {
  get delayedCallTimeout() {
    return !isNaN(this._delayedCallTimeout) ? this._delayedCallTimeout : 100;
  }

  set delayedCallTimeout(value) {
    this._delayedCallTimeout = value;
  }

  cancel(...callIds) {
    const {
      delayedCalls
    } = this;

    if (delayedCalls) {
      const ids = callIds.length ? callIds : Object.keys(delayedCalls);

      for (let i = ids.length - 1; i >= 0; i--) {
        const id = ids[i],
          delayedCall = delayedCalls[id];

        if (delayedCall && delayedCall.timer) {
          this.clearTimeout(delayedCall.timer);
          delayedCall.timer = null;
        }
      }
    }
  }

  invoke(delayedCall) {
    const {
        id,
        scope,
        beforeFn
      } = delayedCall,
      Id = StringHelper.capitalizeFirstLetter(id);
    this.trigger(`delayed${Id}Start`, delayedCall);
    beforeFn && beforeFn.call(scope, delayedCall);

    const {
      afterFn,
      fn,
      entries
    } = delayedCall;
    let args,
      result = [];

    while (args = entries.shift()) {
      result.push(fn.call(scope, delayedCall, ...args));
    }

    afterFn && afterFn.call(scope, delayedCall);
    this.trigger(`delayed${Id}End`, delayedCall);
    delayedCall.delete();
    return result;
  }


  execute(config = {}) {
    return new Promise((resolve, reject) => {
      const me = this;
      me.delayedCalls = me.delayedCalls || {};
      const {
        id,
        args,
        timeout
      } = config;

      if (!me.delayedCalls[id]) {
        me.delayedCalls[id] = Object.assign({
          delete: () => delete me.delayedCalls[id],
          entries: [],
          scope: this,
          id
        }, config);
        delete me.delayedCalls[id].args;
      }

      const delayedCall = me.delayedCalls[id];

      me.cancel(id);

      delayedCall.entries.push(args || []);

      delayedCall.timer = me.setTimeout(() => {
        delayedCall.results = me.invoke(delayedCall);
        resolve(delayedCall);
      }, timeout || me.delayedCallTimeout);
    });
  }

}

DelayedCallsManager._$name = 'DelayedCallsManager';

class AbstractRecurrenceIterator extends Base {
  static get frequency() {
    return 'NONE';
  }

  static get MAX_OCCURRENCES_COUNT() {
    return 1000000;
  }


  static getNthDayInPeriod(startDate, endDate, day, index) {
    let result, sign, borderDate;

    if (index) {
      const dayDurationInMs = 86400000,
        weekDurationInMs = 604800000;

      if (index > 0) {
        sign = 1;
        borderDate = startDate;
      } else {
        sign = -1;
        borderDate = endDate;
      }

      const delta = day - borderDate.getDay();


      if (sign * delta < 0) {
        index += sign;
      }

      result = new Date(borderDate.getTime() + (index - sign) * weekDurationInMs + delta * dayDurationInMs);


      if (result < startDate || result > endDate) {
        result = null;
      }
    }

    return result;
  }

  static buildDate(year, month, date) {
    const dt = new Date(year, month, date);

    if (dt.getFullYear() == year && dt.getMonth() == month && dt.getDate() == date) {
      return dt;
    }
  }

  static isValidPosition(position) {
    return Boolean(position);
  }

  static forEachDateAtPositions(dates, positions, fn, scope) {
    const datesLength = dates.length,
      processed = {};

    for (let i = 0; i < positions.length; i++) {
      const index = positions[i];

      if (this.isValidPosition(index)) {
        const date = index > 0 ? dates[index - 1] : dates[datesLength + index];

        if (date && !processed[date.getTime()]) {

          processed[date.getTime()] = true;

          if (fn.call(scope, date) === false) {
            return false;
          }
        }
      }
    }
  }

}

AbstractRecurrenceIterator._$name = 'AbstractRecurrenceIterator';

class DailyRecurrenceIterator extends AbstractRecurrenceIterator {
  static get frequency() {
    return 'DAILY';
  }

  static forEachDate(config) {
    const me = this,
      {
        recurrence,
        fn,
        scope = me
      } = config,
      {
        timeSpan,
        endDate: until,
        interval
      } = recurrence,
      timeSpanStart = timeSpan.startDate;
    let startDate = config.startDate || timeSpanStart,
      endDate = config.endDate || until,
      count = recurrence.count,
      counter = 0;

    if (until && endDate && endDate > until) {
      endDate = until;
    }

    if (timeSpanStart > startDate) {
      startDate = timeSpanStart;
    }

    const delay = startDate - timeSpanStart,

      intervalDuration = interval * 86400000,
      delayInIntervals = Math.floor(delay / intervalDuration);

    if (!endDate && !count) {
      count = me.MAX_OCCURRENCES_COUNT;
    }

    let date = DateHelper.add(timeSpanStart, delayInIntervals, 'day');

    while (!endDate || date <= endDate) {
      counter++;

      if (date >= startDate && (endDate && date > endDate || fn.call(scope, date, counter) === false || count && counter >= count)) {
        break;
      }

      date = DateHelper.add(date, interval, 'day');
    }
  }

}

DailyRecurrenceIterator._$name = 'DailyRecurrenceIterator';

const dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
const days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

class RecurrenceDayRuleEncoder extends Base {
  static decodeDay(rawDay) {
    let parsedDay, result;

    if (parsedDay = dayParseRegExp.exec(rawDay)) {
      result = [days.indexOf(parsedDay[2])];

      if (parsedDay[1]) {
        parsedDay[1] = parseInt(parsedDay[1], 10);
        result.push(parsedDay[1]);
      }
    }

    return result;
  }

  static encodeDay(day) {
    let position;

    if (Array.isArray(day)) {
      [day, position] = day;
    }

    return (position ? position.toString() : '') + days[day];
  }


  static decode(rawDays) {
    let result = [],
      parsedDay;

    if (rawDays) {
      for (let i = 0; i < rawDays.length; i++) {
        if (parsedDay = this.decodeDay(rawDays[i])) {
          result.push(parsedDay);
        }
      }
    }

    return result;
  }

  static encode(days) {
    let result = [],
      day;

    if (days) {
      for (let i = 0; i < days.length; i++) {
        if (day = this.encodeDay(days[i])) {
          result.push(day);
        }
      }
    }

    return result;
  }

}

RecurrenceDayRuleEncoder._$name = 'RecurrenceDayRuleEncoder';

class WeeklyRecurrenceIterator extends AbstractRecurrenceIterator {
  static get frequency() {
    return 'WEEKLY';
  }

  static forEachDate(config) {
    const me = this,
      {
        fn,
        recurrence,
        scope = me
      } = config,
      {
        timeSpan,
        interval,
        days,
        endDate: until
      } = recurrence,
      timeSpanStart = timeSpan.startDate;
    let counter = 0,
      startDate = config.startDate || timeSpanStart,
      endDate = config.endDate || until,
      {
        count
      } = recurrence,
      weekDays = RecurrenceDayRuleEncoder.decode(days),
      weekStartDate,
      date;

    if (until && endDate && endDate > until) {
      endDate = until;
    }

    if (weekDays && weekDays.length) {
      weekDays.sort((a, b) => a[0] - b[0]);
    } else {
      weekDays = [[timeSpanStart.getDay()]];
    }

    if (timeSpanStart > startDate) {
      startDate = timeSpanStart;
    }


    weekStartDate = DateHelper.getNext(count ? timeSpanStart : startDate, 'week', 0, 0);

    if (!endDate && !count) {
      count = me.MAX_OCCURRENCES_COUNT;
    }

    while (!endDate || weekStartDate <= endDate) {
      for (let i = 0; i < weekDays.length; i++) {
        date = DateHelper.copyTimeValues(DateHelper.add(weekStartDate, weekDays[i][0], 'day'), timeSpanStart);

        if (date >= timeSpanStart) {
          counter++;

          if (date >= startDate && (endDate && date > endDate || fn.call(scope, date, counter) === false || count && counter >= count)) {
            return;
          }
        }
      }

      weekStartDate = DateHelper.getNext(weekStartDate, 'week', interval, 0);
    }
  }

}

WeeklyRecurrenceIterator._$name = 'WeeklyRecurrenceIterator';

class MonthlyRecurrenceIterator extends AbstractRecurrenceIterator {
  static get frequency() {
    return 'MONTHLY';
  }

  static getNthDayOfMonth(date, dayNum) {
    const daysInMonth = DateHelper.daysInMonth(date);
    let result = null;

    if (dayNum && Math.abs(dayNum) <= daysInMonth) {
      result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);
    }

    return result;
  }

  static isValidPosition(position) {
    return position && Math.abs(position) > 0 && Math.abs(position) <= 31;
  }

  static forEachDate(config) {
    const me = this,
      {
        fn,
        recurrence,
        scope = me
      } = config,
      {
        timeSpan,
        interval,
        days,
        endDate: until,
        count,
        positions
      } = recurrence,
      eventStart = timeSpan.startDate,
      weekDays = RecurrenceDayRuleEncoder.decode(days),
      hasPositions = positions && positions.length,
      processedDate = {};
    let startDate = config.startDate || eventStart,
      endDate = config.endDate || until,
      {
        monthDays
      } = recurrence,
      counter = 0,
      weekDayPosition,
      monthStartDate,
      monthEndDate,
      dates,
      date,
      i;

    if (until && endDate && endDate > until) {
      endDate = until;
    }

    if (eventStart > startDate) {
      startDate = eventStart;
    }


    monthStartDate = DateHelper.startOf(count ? eventStart : startDate, 'month');
    monthEndDate = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);

    if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {
      monthDays = [eventStart.getDate()];
    }

    if (weekDays && weekDays.length) {

      weekDays.forEach(day => {
        if (day[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day[0]] = day[1];
        }
      });
    }

    while ((!endDate || endDate >= monthStartDate) && (!count || counter < count)) {
      dates = [];

      if (weekDays && weekDays.length) {
        weekDays.forEach(day => {
          const weekDay = day[0];
          let from = 1,
            till = 53;

          if (day[1]) {
            from = till = day[1];
          }

          for (i = from; i <= till; i++) {
            if (date = me.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i)) {
              date = DateHelper.copyTimeValues(date, eventStart);

              if (!processedDate[date.getTime()]) {

                processedDate[date.getTime()] = true;
                dates.push(date);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);

        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            date = dates[i];

            if (date >= eventStart) {
              counter++;

              if (date >= startDate && (endDate && date > endDate || fn.call(scope, date, counter) === false || count && counter >= count)) {
                return false;
              }
            }
          }
        }
      } else {
        const sortedMonthDates = [];

        for (i = 0; i < monthDays.length; i++) {

          if ((date = me.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[date.getTime()]) {
            processedDate[date.getTime()] = true;
            sortedMonthDates.push(date);
          }
        }

        sortedMonthDates.sort((a, b) => a - b);

        for (i = 0; i < sortedMonthDates.length; i++) {
          date = DateHelper.copyTimeValues(sortedMonthDates[i], eventStart);

          if (hasPositions) {
            dates.push(date);
          } else if (date >= eventStart) {
            counter++;

            if (date >= startDate && (
              endDate && date > endDate || fn.call(scope, date, counter) === false || count && counter >= count)) {
              return;
            }
          }
        }
      }

      if (hasPositions && dates.length) {
        me.forEachDateAtPositions(dates, positions, date => {
          if (date >= eventStart) {
            counter++;

            if (date >= startDate && (!endDate || date <= endDate) && (
              fn.call(scope, date, counter) === false || count && counter >= count)) {
              return false;
            }
          }
        });
      }

      monthStartDate = DateHelper.getNext(monthStartDate, 'month', interval);
      monthEndDate = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);
    }
  }

}

MonthlyRecurrenceIterator._$name = 'MonthlyRecurrenceIterator';

class YearlyRecurrenceIterator extends AbstractRecurrenceIterator {
  static get frequency() {
    return 'YEARLY';
  }

  static forEachDate(config) {
    const me = this,
      {
        fn,
        recurrence,
        scope = me
      } = config,
      {
        timeSpan,
        interval,
        days,
        count,
        positions,
        endDate: until
      } = recurrence,
      timeSpanStart = timeSpan.startDate,
      weekDays = RecurrenceDayRuleEncoder.decode(days),
      hasPositions = positions && positions.length,
      processedDate = {};
    let startDate = config.startDate || timeSpanStart,
      endDate = config.endDate || until,
      {
        months
      } = recurrence,
      counter = 0,
      i,
      date,
      dates,
      yearStartDate,
      yearEndDate,
      weekDayPosition;

    if (until && endDate && endDate > until) {
      endDate = until;
    }

    if (timeSpanStart > startDate) {
      startDate = timeSpanStart;
    }


    yearStartDate = DateHelper.startOf(count ? timeSpanStart : startDate, 'year');
    yearEndDate = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);
    months && months.sort((a, b) => a - b);

    if (!(months && months.length) && !(weekDays && weekDays.length)) {
      months = [timeSpanStart.getMonth() + 1];
    }

    if (weekDays && weekDays.length) {

      weekDays.forEach(day => {
        if (day[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day[0]] = day[1];
        }
      });
    }

    while ((!endDate || endDate >= yearStartDate) && (!count || counter < count)) {
      dates = [];

      if (weekDays && weekDays.length) {
        weekDays.forEach(day => {
          let weekDay = day[0],
            from = 1,
            till = 53;

          if (day[1]) {
            from = till = day[1];
          }

          for (i = from; i <= till; i++) {
            if (date = me.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i)) {
              date = DateHelper.copyTimeValues(date, timeSpanStart);

              if (!processedDate[date.getTime()]) {

                processedDate[date.getTime()] = true;
                dates.push(date);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);

        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            date = dates[i];

            if (date >= timeSpanStart) {
              counter++;

              if (date >= startDate && (endDate && date > endDate || fn.call(scope, date, counter) === false || count && counter >= count)) {
                return;
              }
            }
          }
        }
      } else {
        for (i = 0; i < months.length; i++) {
          if (date = me.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate())) {
            date = DateHelper.copyTimeValues(date, timeSpanStart);

            if (!processedDate[date.getTime()]) {
              processedDate[date.getTime()] = true;

              if (hasPositions) {
                dates.push(date);
              } else if (date >= timeSpanStart) {
                counter++;

                if (date >= startDate && (endDate && date > endDate || fn.call(scope, date, counter) === false || count && counter >= count)) {
                  return;
                }
              }
            }
          }
        }
      }

      if (hasPositions && dates.length) {
        me.forEachDateAtPositions(dates, positions, date => {
          if (date >= timeSpanStart) {
            counter++;

            if (date >= startDate && (!endDate || date <= endDate)) {

              if (fn.call(scope, date, counter) === false || count && counter >= count) {
                return false;
              }
            }
          }
        });
      }

      yearStartDate = DateHelper.getNext(yearStartDate, 'year', interval);
      yearEndDate = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);
    }
  }

}

YearlyRecurrenceIterator._$name = 'YearlyRecurrenceIterator';


var RecurringTimeSpansMixin = (Target => class RecurringTimeSpansMixin extends (Target || Base) {
  static get $name() {
    return 'RecurringTimeSpansMixin';
  }


  get supportsRecurringTimeSpans() {
    return true;
  }


  get delayedCallTimeout() {
    return !isNaN(this._delayedCallTimeout) ? this._delayedCallTimeout : 100;
  }

  set delayedCallTimeout(value) {
    this._delayedCallTimeout = value;
  }


  get delayedCallsManager() {
    this._delayedCallsManager = this._delayedCallsManager || new DelayedCallsManager({
      delayedCallTimeout: this.delayedCallTimeout
    });
    return this._delayedCallsManager;
  }

  setupRecurringTimeSpans() {
    const me = this;
    me.recurrenceIterators = me.recurrenceIterators || [];
    me.addRecurrenceIterators(DailyRecurrenceIterator, WeeklyRecurrenceIterator, MonthlyRecurrenceIterator, YearlyRecurrenceIterator);
    me.relayEvents(me.delayedCallsManager, ['delayedRegenerateOccurrencesStart', 'delayedRegenerateOccurrencesEnd', 'delayedGenerateOccurrencesStart', 'delayedGenerateOccurrencesEnd']);
    me.delayedCallsManager.on({
      'delayedRegenerateOccurrencesEnd': me.onDelayedRegenerateOccurrencesFinish,
      'delayedGenerateOccurrencesEnd': me.onDelayedGenerateOccurrencesFinish,
      thisObj: me
    });
  }

  doDestroy() {
    this.delayedCallsManager.destroy();
  }

  addRecurrenceIterators(...iterators) {
    iterators.forEach(iterator => this.recurrenceIterators[iterator.frequency] = iterator);
  }

  getRecurrenceIteratorForTimeSpan(timeSpan) {
    return this.recurrenceIterators[timeSpan.recurrence.frequency];
  }


  buildOccurrencesForTimeSpan(timeSpan, startDate, endDate, skipExisting) {
    const occurrences = [];

    if (timeSpan.isRecurring && timeSpan.startDate) {
      const me = this,
        recurrence = timeSpan.recurrence,
        iterator = me.getRecurrenceIteratorForTimeSpan(timeSpan);
      const hasExceptionOnDate = timeSpan.exceptionDates ? timeSpan.exceptionDates.reduce((map, date) => {
        map[date.getTime()] = true;
        return map;
      }, {}) : {};
      iterator.forEachDate({
        recurrence,
        startDate,
        endDate,

        fn(date) {

          if (!hasExceptionOnDate[date.getTime()] && (!skipExisting || !timeSpan.getOccurrenceByStartDate(date))) {
            occurrences.push(timeSpan.buildOccurrence(date));
          }
        }

      });
    }

    return occurrences;
  }

  mergeDelayedCallEntries(delayedCall) {
    let entries = delayedCall.entries,
      byTimeSpanId = {},
      startDate,
      endDate,
      timeSpans,
      timeSpan,
      args;

    for (let i = 0; i < entries.length; i++) {
      args = entries[i];
      [timeSpans, startDate, endDate] = args;


      for (let j = 0; j < timeSpans.length; j++) {
        timeSpan = timeSpans[j];
        const savedArgs = byTimeSpanId[timeSpan.id];

        if (savedArgs) {
          if (savedArgs[1] > startDate) savedArgs[1] = startDate;
          if (savedArgs[2] < endDate) savedArgs[2] = endDate;
        } else {
          byTimeSpanId[timeSpan.id] = [[timeSpan], ...args.slice(1)];
        }
      }
    }

    entries = Object.values(byTimeSpanId);

    const combinedEntries = {};

    for (let i = 0; i < entries.length; i++) {
      args = entries[i];
      [timeSpan, startDate, endDate] = args;
      const key = (startDate ? startDate.getTime() : '') + '-' + (endDate ? endDate.getTime() : '');

      if (combinedEntries[key]) {

        combinedEntries[key][0] = combinedEntries[key][0].concat(timeSpan);

      } else {
        combinedEntries[key] = args;
      }
    }

    delayedCall.entries = Object.values(combinedEntries);
  }


  regenerateOccurrencesForTimeSpansBuffered(timeSpans, startDate, endDate) {
    const me = this;

    if (!Array.isArray(timeSpans)) {
      timeSpans = [timeSpans];
    }

    timeSpans = timeSpans.filter(timeSpan => timeSpan.isRecurring);

    if (timeSpans.length) {
      return new Promise(async (resolve, reject) => {
        const delayedCall = await me.delayedCallsManager.execute({
          id: 'regenerateOccurrences',
          beforeFn: me.mergeDelayedCallEntries,
          args: [timeSpans, startDate, endDate],

          fn(delayedCall, timeSpans, startDate, endDate) {

            const toRemove = delayedCall.toRemove = delayedCall.toRemove || [];
            toRemove.push(...me.getOccurrencesForTimeSpans(timeSpans));

            delayedCall.added = me.generateOccurrencesForTimeSpans(timeSpans, startDate, endDate, false);
          },


          afterFn(delayedCall) {
            const {
              toRemove
            } = delayedCall;

            if (toRemove.length) {
              delayedCall.removed = me.remove(toRemove);
            }
          }

        });
        resolve({
          added: delayedCall.added,
          removed: delayedCall.removed
        });
      });
    }

    return Promise.resolve();
  }


  generateOccurrencesForTimeSpansBuffered(timeSpans, startDate, endDate, preserveExisting = true) {
    const me = this;

    if (!Array.isArray(timeSpans)) {
      timeSpans = [timeSpans];
    }

    timeSpans = timeSpans.filter(timeSpan => timeSpan.isRecurring);

    if (timeSpans.length) {
      return new Promise(async resolve => {
        const delayedCall = await me.delayedCallsManager.execute({
          id: 'generateOccurrences',
          beforeFn: me.mergeDelayedCallEntries,
          args: [timeSpans, startDate, endDate, preserveExisting],

          fn(delayedCall, ...args) {

            delayedCall.added = me.generateOccurrencesForTimeSpans(...args);
          }

        });
        resolve({
          added: delayedCall.added
        });
      });
    }

    return Promise.resolve();
  }


  generateOccurrencesForTimeSpans(timeSpans, startDate, endDate, preserveExisting = true) {
    const allOccurrences = [];

    if (timeSpans) {
      const me = this;
      let occurrences = [];

      if (!Array.isArray(timeSpans)) {
        timeSpans = [timeSpans];
      }

      if (timeSpans.length) {
        for (let i = 0; i < timeSpans.length; i++) {
          let timeSpan = timeSpans[i],
            firstOccurrenceStartDate,
            firstOccurrence,
            eventStartDate;

          if (occurrences = me.buildOccurrencesForTimeSpan(timeSpan, startDate, endDate, preserveExisting)) {
            eventStartDate = timeSpan.startDate;


            if (startDate <= eventStartDate) {

              if (firstOccurrence = occurrences.shift()) {
                firstOccurrenceStartDate = firstOccurrence.startDate;

                if (firstOccurrenceStartDate - eventStartDate) {
                  timeSpan.setStartEndDate(firstOccurrenceStartDate, firstOccurrence.endDate);


                  timeSpan.recurrence.sanitize();
                }
              }
            }

            allOccurrences.push(...occurrences);
          }
        }

        if (allOccurrences.length) {
          me.add(allOccurrences);
        }
      }
    }

    return allOccurrences;
  }


  generateOccurrencesForAll(startDate, endDate, preserveExisting = false) {
    const me = this,
      timeSpans = me.getRecurringTimeSpans();
    let result = [];

    if (timeSpans.length) {
      me.trigger('generateOccurrencesAllStart', {
        timeSpans,
        startDate,
        endDate,
        preserveExisting
      });
      result = me.generateOccurrencesForTimeSpans(timeSpans, startDate, endDate, preserveExisting);
      me.trigger('generateOccurrencesAllEnd', {
        timeSpans,
        startDate,
        endDate,
        preserveExisting
      });
    }

    return result;
  }


  getRecurringTimeSpans() {
    return this.query(record => record.supportsRecurring && record.isRecurring);
  }


  getOccurrencesForTimeSpans(records) {
    const result = [];

    if (!Array.isArray(records)) {
      records = [records];
    }

    if (records.length) {
      for (let i = 0; i < records.length; i++) {
        const recordId = records[i].id;

        result.push(...this.query(record => record.supportsRecurring && record.recurringTimeSpanId == recordId));
      }
    }

    return result;
  }


  getOccurrencesForAll() {
    return this.query(record => record.supportsRecurring && record.isOccurrence);
  }


  removeOccurrencesForTimeSpans(timeSpans) {
    return this.remove(this.getOccurrencesForTimeSpans(timeSpans));
  }


  removeOccurrencesForAll() {
    return this.remove(this.getOccurrencesForAll());
  }

  onDelayedRegenerateOccurrencesFinish() {

    this.trigger('occurrencesReady');
  }

  onDelayedGenerateOccurrencesFinish() {
    this.trigger('occurrencesReady');
  }

});


var RecurringEventsMixin = (Target => class RecurringEventsMixin extends RecurringTimeSpansMixin(Target || Base) {
  static get $name() {
    return 'RecurringEventsMixin';
  }


  get supportsRecurringEvents() {
    return true;
  }

  setupRecurringEvents(...args) {
    return this.setupRecurringTimeSpans(...args);
  }

  generateOccurrencesForEvents(...args) {
    return this.generateOccurrencesForTimeSpans(...args);
  }


  generateOccurrencesForEventsBuffered(...args) {
    return this.generateOccurrencesForTimeSpansBuffered(...args);
  }

  regenerateOccurrencesForEvents(...args) {
    return this.regenerateOccurrencesForTimeSpans(...args);
  }


  regenerateOccurrencesForEventsBuffered(...args) {
    return this.regenerateOccurrencesForTimeSpansBuffered(...args);
  }


  getRecurringEvents() {
    return this.getRecurringTimeSpans();
  }


  getOccurrencesForEvents(events) {
    return this.getOccurrencesForTimeSpans(events);
  }


  removeOccurrencesForEvents(events) {
    return this.removeOccurrencesForTimeSpans(events);
  }

  isEventPersistable(event) {

    return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);
  }

});


class TimeSpan extends Model {

  static get fields() {
    return [

      {
        name: 'startDate',
        type: 'date'
      },

      {
        name: 'endDate',
        type: 'date'
      },

      {
        name: 'duration',
        type: 'number',
        allowNull: true
      },

      {
        name: 'durationUnit',
        type: 'string',
        defaultValue: 'd'
      }, {
        name: 'fullDuration',
        persist: false
      },

      {
        name: 'cls',
        defaultValue: ''
      },

      'iconCls',

      {
        name: 'style',
        type: 'object'
      },

      {
        name: 'name',
        type: 'string'
      }];
  }


  afterConstruct() {
    super.afterConstruct();

    this.normalize();
  }

  normalize() {
    const me = this,
      {
        startDate,
        endDate,
        duration,
        durationUnit
      } = me,
      hasDuration = duration != null;

    if (startDate && endDate && !hasDuration) {
      me.setData('duration', DateHelper.diff(startDate, endDate, durationUnit, true));
    } else if (startDate && !endDate && hasDuration) {
      me.setData('endDate', DateHelper.add(startDate, duration, durationUnit));
    } else if (!startDate && endDate && hasDuration) {
      me.setData('startDate', DateHelper.add(endDate, -duration, durationUnit));
    }

    this.clearCachedValues();
  }


  get cls() {
    if (!this._cls) {
      this._cls = new DomClassList(super.get('cls'));
    }

    return this._cls;
  }

  set cls(cls) {
    const me = this;

    if (me._cls) {
      me._cls.value = cls;
    } else {
      me._cls = new DomClassList(cls);
    }

    me.set('cls', me._cls.value);
  }

  get startDate() {
    return this.get('startDate');
  }

  set startDate(date) {
    this.setStartDate(date);
  }

  get endDate() {
    return this.get('endDate');
  }

  set endDate(date) {
    this.setEndDate(date);
  }

  get duration() {
    return this.get('duration');
  }

  set duration(duration) {
    this.setDuration(duration, this.durationUnit);
  }

  get durationUnit() {
    return this.get('durationUnit');
  }


  setDuration(duration, durationUnit = this.durationUnit) {

    duration = parseFloat(duration);
    const toSet = {
      duration,
      durationUnit
    };

    if (this.startDate) {
      toSet.endDate = DateHelper.add(this.startDate, duration, durationUnit);
    } else if (this.endDate) {
      toSet.startDate = DateHelper.add(this.endDate, -duration, durationUnit);
    }

    this.set(toSet);
  }


  get fullDuration() {

    return new Duration({
      unit: this.durationUnit,
      magnitude: this.duration
    });
  }

  set fullDuration(duration) {
    if (typeof duration === 'string') {
      duration = DateHelper.parseDuration(duration, true, this.durationUnit);
    }

    this.setDuration(duration.magnitude, duration.unit);
  }


  setStartDate(date, keepDuration = true) {
    const me = this,
      toSet = {
        startDate: date
      };

    if (date) {
      let calcEndDate;

      if (keepDuration) {
        calcEndDate = me.duration != null;
      } else {
        if (me.endDate) {
          toSet.duration = DateHelper.diff(date, me.endDate, me.durationUnit, true);
          if (toSet.duration < 0) throw new Error('Negative duration');
        } else {
          calcEndDate = this.duration != null;
        }
      }

      if (calcEndDate) {
        toSet.endDate = DateHelper.add(date, me.duration, me.durationUnit);
      }
    } else {
      toSet.duration = null;
    }

    me.set(toSet);
  }


  setEndDate(date, keepDuration = false) {
    const me = this,
      toSet = {
        endDate: date
      };

    if (date) {
      let calcStartDate;

      if (keepDuration === true) {
        calcStartDate = me.duration != null;
      } else {
        if (me.startDate) {
          toSet.duration = DateHelper.diff(me.startDate, date, me.durationUnit, true);
          if (toSet.duration < 0) throw new Error('Negative duration');
        } else {
          calcStartDate = this.duration != null;
        }
      }

      if (calcStartDate) {
        toSet.startDate = DateHelper.add(date, -me.duration, me.durationUnit);
      }
    }

    me.set(toSet);
  }


  setStartEndDate(start, end) {
    this.set({
      startDate: start,
      endDate: end
    });
  }


  get dates() {
    const dates = [],
      startDate = DateHelper.startOf(this.startDate, 'day'),
      endDate = this.endDate;

    for (let date = startDate; date < endDate; date = DateHelper.add(date, 1, 'day')) {
      dates.push(date);
    }

    return dates;
  }


  get durationMS() {
    if (this.endDate && this.startDate) {
      return this.endDateMS - this.startDateMS;
    } else {
      return DateHelper.asMilliseconds(this.duration || 0, this.durationUnit);
    }
  }

  clearCachedValues() {
    this._startDateMS = null;
    this._endDateMS = null;
    this._isMilestone = null;
  }

  get endDateMS() {
    const me = this;

    if (me._endDateMS == null) {
      me._endDateMS = me.endDate && me.endDate.getTime();
    }

    return me._endDateMS;
  }

  get startDateMS() {
    const me = this;

    if (me._startDateMS == null) {
      me._startDateMS = me.startDate && me.startDate.getTime();
    }

    return me._startDateMS;
  }

  get isMilestone() {
    const me = this;

    if (me._isMilestone == null) {
      me._isMilestone = me.durationMS === 0;
    }

    return me._isMilestone;
  }

  inSetNormalize(field) {
    if (typeof field !== 'string') {


      field = Object.assign({}, field);

      if ('duration' in field) {
        if (field.startDate && !field.endDate) {
          field.endDate = DateHelper.add(field.startDate, field.duration, field.durationUnit || this.durationUnit, true, true);
        }

        if (!field.startDate && field.endDate) {
          field.startDate = DateHelper.add(field.endDate, -field.duration, field.durationUnit || this.durationUnit, true, true);
        }
      } else if (field.startDate && field.endDate) {
        field.duration = DateHelper.diff(field.startDate, field.endDate, field.durationUnit || this.durationUnit, true);
      }

      return field;
    }
  }

  inSet(field, value, silent, fromRelationUpdate) {
    this.clearCachedValues();
    field = this.inSetNormalize(field) || field;
    return super.inSet(field, value, silent, fromRelationUpdate);
  }

  beginBatch() {
    this.clearCachedValues();
    super.beginBatch();
  }


  forEachDate(func, thisObj) {
    return this.dates.forEach(func.bind(thisObj));
  }


  get isScheduled() {
    const me = this;
    return Boolean(me.startDate && me.endDate && me.hasValidDates);
  }

  get isValid() {
    const me = this;
    let result = true;

    if (result) {
      const start = me.startDate,
        end = me.endDate;
      result = !start || !end || end - start >= 0;
    }

    return result;
  }

  get hasValidDates() {
    const me = this,
      start = me.startDateMS,
      end = me.endDateMS;
    return !start || !end || end - start >= 0;
  }


  shift(amount, unit = this.durationUnit) {

    if (typeof amount === 'string') {
      const u = amount;
      amount = unit;
      unit = u;
    }

    this.setStartDate(DateHelper.add(this.startDate, amount, unit, true), true);
  }


  get wbsCode() {
    return this.indexPath.join('.');
  }

  fullCopy() {

    return this.copy.apply(this, arguments);
  }

  intersects(timeSpan) {
    return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);
  }

  intersectsRange(start, end) {
    const myStart = this.startDate,
      myEnd = this.endDate;
    return myStart && myEnd && DateHelper.intersectSpans(myStart, myEnd, start, end);
  }


  split(splitPoint = 0.5) {
    const me = this,
      clone = this.copy(),
      eventStore = me.firstStore,
      assignmentStore = eventStore && eventStore.assignmentStore,
      ownNewDuration = me.duration * splitPoint,
      cloneDuration = me.duration - ownNewDuration;

    if (splitPoint <= 0 || splitPoint >= 1) {
      throw new Error('Split point must be > 0 and < 1');
    }

    me.duration = ownNewDuration;
    clone.startDate = me.endDate;
    clone.duration = cloneDuration;

    if (eventStore) {
      eventStore.add(clone);
    }

    if (assignmentStore) {
      assignmentStore.add(me.assignments.map(assignment => {
        const clonedData = Object.assign({}, assignment.data, {
          eventId: clone.id
        });
        delete clonedData.id;
        return clonedData;
      }));
    }

    return clone;
  }

}

TimeSpan._$name = 'TimeSpan';


function convertStringOfIntegerItemsValue(value) {
  if (value) {
    if (typeof value == 'string') {
      value = value.split(',').map(item => parseInt(item, 10));
    }
  } else {
    value = null;
  }

  return value;
}

function convertStringOfItemsValue(value) {
  if (value) {
    if (typeof value == 'string') {
      value = value.split(',');
    }
  } else {
    value = null;
  }

  return value;
}

function isEqualAsString(value1, value2) {
  return String(value1) === String(value2);
}

function convertInteger(value) {
  if (this.defaultValue && value === undefined) {
    return this.defaultValue;
  }

  if (this.allowNull && value == null) {
    return null;
  }

  value = parseInt(value);
  if (isNaN(value)) value = undefined;
  return value;
}


class RecurrenceModel extends Model {

  get isRecurrenceModel() {
    return true;
  }

  static get fields() {
    return [

      {
        name: 'frequency',
        defaultValue: 'DAILY'
      },

      {
        name: 'interval',
        defaultValue: 1,
        convert: convertInteger
      },

      {
        name: 'endDate',
        type: 'date'
      },

      {
        name: 'count',
        allowNull: true,
        convert: convertInteger
      },

      {
        name: 'days',
        convert: convertStringOfItemsValue,
        isEqual: isEqualAsString
      },

      {
        name: 'monthDays',
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },

      {
        name: 'months',
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },

      {
        name: 'positions',
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      }];
  }

  get dateFormat() {
    return this._dateFormat || 'YYYYMMDDTHHmmss';
  }

  set dateFormat(format) {
    this._dateFormat = format;
  }


  get timeSpan() {
    return this._timeSpan;
  }

  set timeSpan(value) {
    this._timeSpan = value;
  }


  get rule() {
    const me = this,
      result = [];

    if (me.frequency) {
      result.push(`FREQ=${me.frequency}`);

      if (me.interval > 1) {
        result.push(`INTERVAL=${me.interval}`);
      }

      if (me.days && me.days.length) {
        result.push('BYDAY=' + me.days.join(','));
      }

      if (me.monthDays && me.monthDays.length) {
        result.push('BYMONTHDAY=' + me.monthDays.join(','));
      }

      if (me.months && me.months.length) {
        result.push('BYMONTH=' + me.months.join(','));
      }

      if (me.count) {
        result.push(`COUNT=${me.count}`);
      }

      if (me.endDate) {
        result.push('UNTIL=' + DateHelper.format(me.endDate, me.dateFormat));
      }

      if (me.positions && me.positions.length) {
        result.push('BYSETPOS=' + me.positions.join(','));
      }
    }

    return result.join(';');
  }

  set rule(rule) {
    const me = this;
    me.beginBatch();

    if (rule) {
      const parts = rule.split(';');

      for (let i = 0, len = parts.length; i < len; i++) {
        const part = parts[i].split('='),
          value = part[1];

        switch (part[0]) {
          case 'FREQ':
            me.frequency = value;
            break;

          case 'INTERVAL':
            me.interval = value;
            break;

          case 'COUNT':
            me.count = value;
            me.until = null;
            break;

          case 'UNTIL':
            if (value) {
              me.endDate = DateHelper.parse(value, me.dateFormat);
            } else {
              me.endDate = null;
            }

            me.count = null;
            break;

          case 'BYDAY':
            me.days = value;
            break;

          case 'BYMONTHDAY':
            me.monthDays = value;
            break;

          case 'BYMONTH':
            me.months = value;
            break;

          case 'BYSETPOS':
            me.positions = value;
            break;
        }
      }

      me.sanitize();
    } else {
      me.set({
        frequency: null,
        interval: null,
        count: null,
        endDate: null,
        days: null,
        monthDays: null,
        months: null,
        positions: null
      });
    }

    me.endBatch();
  }

  construct(data = {}) {
    const me = this,
      {
        rule,
        timeSpan
      } = data;
    me._suspendedTimeSpanNotifying = 0;
    delete data.timeSpan;
    delete data.rule;
    super.construct(...arguments);

    if (rule) {
      me.suspendTimeSpanNotifying();
      me.rule = rule;
      me.resumeTimeSpanNotifying();
    }

    me.timeSpan = timeSpan;
  }


  sanitize() {
    const me = this,
      timeSpan = me.timeSpan,
      timeSpanStartDate = timeSpan && timeSpan.startDate;
    me.beginBatch();
    me.isSanitizing = true;

    switch (me.frequency) {
      case 'DAILY':
        me.positions = null;
        me.days = null;
        me.monthDays = null;
        me.months = null;
        break;

      case 'WEEKLY':
        me.positions = null;
        me.monthDays = null;
        me.months = null;
        const days = me.days;

        if (timeSpanStartDate && days && days.length == 1 && days[0] == RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {
          me.days = null;
        }

        break;

      case 'MONTHLY':
        if (me.monthDays && me.monthDays.length) {
          me.positions = null;
          me.days = null;
        }

        me.months = null;
        const monthDays = me.monthDays;

        if (timeSpanStartDate && monthDays && monthDays.length == 1 && monthDays[0] == timeSpanStartDate.getDate()) {
          me.monthDays = null;
        }

        break;

      case 'YEARLY':
        me.monthDays = null;
        const months = me.months;

        if (timeSpanStartDate && months && months.length == 1 && months[0] == timeSpanStartDate.getMonth() + 1) {
          me.months = null;
        }

        break;
    }

    me.isSanitizing = false;
    me.endBatch();
  }

  copy(...args) {
    const result = super.copy(...args);
    result.dateFormat = this.dateFormat;
    result.timeSpan = this.timeSpan;
    return result;
  }

  afterChange(toSet, wasSet, silent) {
    const result = super.afterChange(toSet, wasSet, silent);

    if (!this.isSanitizing) {

      this.sanitize();
    }

    const {
      timeSpan
    } = this;

    if (timeSpan && !this.isTimeSpanNotifyingSuspended) {
      timeSpan.onRecurrenceChanged();
    }

    return result;
  }

  get count() {
    return this.get('count');
  }

  set count(value) {
    if (value) this.endDate = null;
    this.set('count', value);
  }

  get endDate() {
    return this.get('endDate');
  }

  set endDate(value) {
    if (value) this.count = null;
    this.set('endDate', value);
  }

  get isTimeSpanNotifyingSuspended() {
    return Boolean(this._suspendedTimeSpanNotifying);
  }

  suspendTimeSpanNotifying() {
    this._suspendedTimeSpanNotifying++;
  }

  resumeTimeSpanNotifying() {
    if (this._suspendedTimeSpanNotifying) this._suspendedTimeSpanNotifying--;
  }

}

RecurrenceModel._$name = 'RecurrenceModel';

function convertExceptionDatesValue(value) {
  if (value) {
    const dateFormat = this.dateFormat;
    value = typeof value == 'string' ? value.split(',') : value;
    value = value.map(item => {
      if (typeof item == 'string') {
        item = DateHelper.parse(item, dateFormat);
      }

      return item;
    });
  }

  return value;
}


var RecurringTimeSpan = (Target => class RecurringTimeSpan extends (Target || TimeSpan) {

  get supportsRecurring() {
    return true;
  }

  static get fields() {
    return [

      {
        name: 'recurringTimeSpanId'
      },

      {
        name: 'recurrenceRule'
      },

      {
        name: 'exceptionDates',
        convert: convertExceptionDatesValue
      }];
  }


  get recurrenceModel() {
    return this._recurrenceModel || RecurrenceModel;
  }

  set recurrenceModel(model) {
    this._recurrenceModel = model;
  }


  setRecurrence(frequency, interval, recurrenceEnd) {
    const me = this;
    let recurrence, recurrenceRule;

    if (frequency) {
      if (frequency.isRecurrenceModel) {
        recurrence = frequency;
      } else if (typeof frequency == 'string') {
        recurrence = new this.recurrenceModel();
        recurrence.frequency = frequency;

        if (interval) {
          recurrence.interval = interval;
        }

        if (recurrenceEnd) {
          if (recurrenceEnd instanceof Date) {
            recurrence.endDate = recurrenceEnd;
          } else {
            recurrence.count = recurrenceEnd;
          }
        }
      } else {
        recurrence = new this.recurrenceModel(frequency);
      }

      recurrence.timeSpan = me;
      recurrenceRule = recurrence.rule;
    }

    me.recurrence = recurrence;
    me.recurrenceRule = recurrenceRule;
  }


  get recurrence() {
    const me = this,
      rule = me.recurrenceRule;

    if (!me._recurrence && rule) {
      me._recurrence = new me.recurrenceModel({
        rule,
        timeSpan: me
      });
    }

    return me._recurrence;
  }

  set recurrence(recurrence) {
    const me = this;
    let previousRecurrence;

    if (me.isOccurrence) {
      const recurringTimeSpan = me.recurringTimeSpan;
      previousRecurrence = recurringTimeSpan && recurringTimeSpan.recurrence;
      me.recurringTimeSpanId = null;
    }

    if (recurrence) {


      if (previousRecurrence) {
        previousRecurrence.endDate = new Date(me.startDate - 1);
      }
    }

    me._recurrence = recurrence;

    if (recurrence) {

      recurrence.timeSpan = me;
      me.recurrenceRule = recurrence.rule;
    } else {
      me.recurrenceRule = null;
    }
  }


  get isRecurring() {
    return this.recurrence && !this.isOccurrence;
  }


  get isOccurrence() {
    return Boolean(this.recurringTimeSpanId);
  }


  get recurringTimeSpan() {
    const masterEventId = this.recurringTimeSpanId,
      store = this.stores[0];
    return masterEventId && store && store.getById(masterEventId);
  }

  getOccurrenceByStartDate(startDate) {
    let result, occurrences;

    if (startDate) {
      occurrences = this.occurrences;

      for (let i = 0; i < occurrences.length; i++) {
        if (occurrences[i].startDate - startDate === 0) {
          result = occurrences[i];
          break;
        }
      }
    }

    return result;
  }


  get occurrences() {
    const store = this.stores[0];
    return store && store.getOccurrencesForTimeSpans && store.getOccurrencesForTimeSpans(this);
  }


  removeOccurrences() {
    const store = this.stores[0];
    return store && store.removeOccurrencesForTimeSpans && store.removeOccurrencesForTimeSpans(this);
  }


  onRecurrenceChanged() {
    this.recurrenceRule = this.recurrence && this.recurrence.rule || null;
  }


  buildOccurrence(startDate) {
    const copy = this.copy(null);
    copy.beginBatch();
    copy.setStartDate(startDate);
    copy.recurringTimeSpanId = this.id;
    copy.endBatch();
    return copy;
  }

  afterChange(toSet, wasSet, silent, ...args) {

    if ('recurrenceRule' in wasSet) {
      this._recurrence = null;
    }

    return super.afterChange(toSet, wasSet, silent, ...args);
  }


  addExceptionDate(date) {
    const me = this,
      dates = me.exceptionDates || [];

    if (date) {
      me.exceptionDates = dates.concat(date);
    }
  }

  beforeStartDateChange() {
    this._startDateValue = this.startDate;
  }

  afterStartDateChange() {
    if (this._startDateValue - this.startDate && this.exceptionDates) {
      this.exceptionDates = null;
    }
  }

});


class EventModel extends RecurringTimeSpan() {


  static get fields() {
    return [


      {
        name: 'resourceId'
      },

      {
        name: 'draggable',
        type: 'boolean',
        persist: false,
        defaultValue: true
      },


      {
        name: 'resizable',
        persist: false,
        defaultValue: true
      },


      'eventStyle',

      'eventColor',

      'milestoneWidth'];
  }


  static get relationConfig() {
    return [{
      relationName: 'resource',
      fieldName: 'resourceId',
      store: 'resourceStore',
      collectionName: 'events'
    }];
  }


  get eventStore() {
    const me = this;

    if (!me._eventStore) {
      me._eventStore = me.stores && me.stores.find(s => s.isEventStore);
    }

    return me._eventStore;
  }


  get resourceStore() {
    const eventStore = this.eventStore;
    return eventStore && eventStore.resourceStore;
  }


  get assignmentStore() {
    const eventStore = this.eventStore;
    return eventStore && eventStore.assignmentStore;
  }


  get resources() {
    return this.eventStore && this.eventStore.getResourcesForEvent(this) || [];
  }


  forEachResource(fn, thisObj = this) {
    for (let resource of this.resources) {
      if (fn.call(thisObj, resource) === false) return;
    }
  }


  getResource(resourceId = this.resourceId) {
    let me = this,
      eventStore = me.eventStore,
      resourceStore = eventStore && eventStore.resourceStore;

    if (eventStore && resourceId) {
      let result = eventStore.getResourcesForEvent(me);
      if (result.length == 1) return result[0];
      if (result.length > 1) throw new Error('Event::getResource() is not applicable for events with multiple assignments, please use Event::resources instead.');
      return null;
    }

    if (resourceStore) return resourceStore ? resourceStore.getById(resourceId) : null;
  }


  get isEvent() {
    return true;
  }


  get isDraggable() {
    return this.draggable;
  }


  get isResizable() {
    return !this.isMilestone && this.resizable;
  }


  get isPersistable() {
    const me = this,
      eventStore = me.eventStore;
    return eventStore && eventStore.isEventPersistable(me);
  }


  assign(resource) {
    const me = this,
      eventStore = me.eventStore;
    resource = Model.asId(resource);

    if (eventStore) {
      eventStore.assignEventToResource(me, resource);
    } else {
      me.resourceId = resource;
    }
  }


  unassign(resource, removingResource) {
    const me = this,
      eventStore = me.eventStore;
    resource = Model.asId(resource);

    me.meta.removingResource = removingResource;

    if (eventStore) {
      eventStore.unassignEventFromResource(me, resource);
    } else if (me.resourceId == resource) {
      me.resourceId = null;
    }

    me.meta.removingResource = null;
  }


  reassign(oldResourceId, newResourceId) {
    const me = this,
      eventStore = me.eventStore;
    oldResourceId = Model.asId(oldResourceId);
    newResourceId = Model.asId(newResourceId);

    if (eventStore) {
      eventStore.reassignEventFromResourceToResource(me, oldResourceId, newResourceId);
    } else {
      me.resourceId = newResourceId;
    }
  }


  isAssignedTo(resource) {
    let me = this,
      eventStore = me.eventStore;
    resource = Model.asId(resource);
    if (eventStore) return eventStore.isEventAssignedToResource(me, resource);
    return me.resourceId == resource;
  }


  get recurringEvent() {
    return this.recurringTimeSpan;
  }

}

EventModel.exposeProperties();
EventModel._$name = 'EventModel';


class EventStore extends RecurringEventsMixin(EventStoreMixin(AjaxStore)) {
  static get defaultConfig() {
    return {

      loadPriority: 100,


      syncPriority: 200,


      modelClass: EventModel,
      storeId: 'events'
    };
  }


  construct(config) {
    super.construct(config, true);
    this.setupRecurringEvents();

    if (this.modelClass !== EventModel && !(this.modelClass.prototype instanceof EventModel)) {
      throw new Error('The model for the EventStore must subclass EventModel');
    }
  }


  append(record) {
    this.add(record);
  }

}

EventStore._$name = 'EventStore';


class ViewPreset extends Model {
  static get fields() {
    return [

      {
        name: 'name',
        type: 'string'
      },

      {
        name: 'rowHeight',
        defaultValue: 24
      },

      {
        name: 'tickWidth',
        defaultValue: 50
      },

      {
        name: 'tickHeight',
        defaultValue: 50
      },

      {
        name: 'displayDateFormat',
        defaultValue: 'HH:mm'
      },

      {
        name: 'shiftUnit',
        defaultValue: 'hour'
      },

      {
        name: 'shiftIncrement',
        defaultValue: 1
      },

      {
        name: 'defaultSpan',
        defaultValue: 12
      },

      'timeResolution',

      'headers',

      'mainHeaderLevel',

      'columnLinesFor'];
  }

  construct(data) {
    super.construct(...arguments);
    this.normalizeUnits();
  }

  static processData(data, ...args) {


    if (data.headerConfig) {
      VersionHelper.deprecate('Scheduler', '4.0.0', 'ViewPreset headerConfig config replaced by headers config. See https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
      data = ObjectHelper.assign({}, data);
      this.normalizeHeaderConfig(data);
    }

    return super.processData(data, ...args);
  }

  generateId(owner) {
    const me = this,
      {
        headers
      } = me,
      parts = [];

    let result = Object.getPrototypeOf(me.data).id;

    if (!result) {
      for (let {
        length
      } = headers, i = length - 1; i >= 0; i--) {
        parts.push(i ? headers[i].unit : StringHelper.capitalizeFirstLetter(headers[i].unit));
      }

      result = parts.join('And');
    }

    if (owner.includes(result)) {
      result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;

      if (owner.includes(result)) {
        result += `-${me.bottomHeader.increment}`;

        if (owner.includes(result)) {
          result = IdHelper.generateId(`${result}-`);
        }
      }
    }

    return result;
  }

  normalizeUnits() {
    const me = this,
      {
        timeResolution,
        headers
      } = me;

    for (let i = 0, {
      length
    } = headers; i < length; i++) {
      const header = headers[i];
      header.unit = DateHelper.normalizeUnit(header.unit);

      if (header.splitUnit) {
        header.splitUnit = DateHelper.normalizeUnit(header.splitUnit);
      }

      if (!('increment' in header)) {
        headers[i] = Object.assign({
          increment: 1
        }, header);
      }
    }

    if (timeResolution) {
      timeResolution.unit = DateHelper.normalizeUnit(timeResolution.unit);
    }

    if (me.shiftUnit) {
      me.shiftUnit = DateHelper.normalizeUnit(me.shiftUnit);
    }
  }

  static normalizeHeaderConfig(data) {
    const {
        headerConfig,
        columnLinesFor,
        mainHeaderLevel
      } = data,
      headers = data.headers = [];

    if (headerConfig.top) {
      if (columnLinesFor == 'top') {
        data.columnLinesFor = 0;
      }

      if (mainHeaderLevel == 'top') {
        data.mainHeaderLevel = 0;
      }

      headers[0] = headerConfig.top;
    }

    if (headerConfig.middle) {
      if (columnLinesFor == 'middle') {
        data.columnLinesFor = headers.length;
      }

      if (mainHeaderLevel == 'middle') {
        data.mainHeaderLevel = headers.length;
      }

      headers.push(headerConfig.middle);
    } else {
      throw new Error('ViewPreset.headerConfig must be configured with a middle');
    }

    if (headerConfig.bottom) {

      data.mainHeaderLevel = headers.length - 1;


      if (columnLinesFor == null) {
        data.columnLinesFor = headers.length - 1;
      } else if (columnLinesFor == 'bottom') {
        data.columnLinesFor = headers.length;
      }


      if (mainHeaderLevel == null) {
        data.mainHeaderLevel = headers.length - 1;
      }

      if (mainHeaderLevel == 'bottom') {
        data.mainHeaderLevel = headers.length;
      }

      headers.push(headerConfig.bottom);
    }
  }

  set() {
  }

  inSet() {
  }

  get columnLinesFor() {
    return 'columnLinesFor' in this.data ? this.data.columnLinesFor : this.headers.length - 1;
  }

  get tickSize() {
    return this._tickSize || this.tickWidth;
  }

  get tickWidth() {
    return 'tickWidth' in this.data ? this.data.tickWidth : 50;
  }

  get tickHeight() {
    return 'tickHeight' in this.data ? this.data.tickHeight : 50;
  }

  get headerConfig() {

    if (this.data.headerConfig) {
      return this.data.headerConfig;
    }

    const result = {},
      {
        headers
      } = this,
      {
        length
      } = headers;

    switch (length) {
      case 1:
        result.middle = headers[0];
        break;

      case 2:
        if (this.mainHeaderLevel === 0) {
          result.middle = headers[0];
          result.bottom = headers[1];
        } else {
          result.top = headers[0];
          result.middle = headers[1];
        }

        break;

      case 3:
        result.top = headers[0];
        result.middle = headers[1];
        result.bottom = headers[2];
        break;

      default:
        throw new Error('headerConfig object not supported for >3 header levels');
    }

    return result;
  }

  set mainHeaderLevel(mainHeaderLevel) {
    this.data.mainHeaderLevel = mainHeaderLevel;
  }

  get mainHeaderLevel() {
    if ('mainHeaderLevel' in this.data) {
      return this.data.mainHeaderLevel;
    }

    if (this.data.headers.length === 3) {
      return 1;
    }


    return this.headers.length - 1;
  }

  get mainHeader() {
    return this.headers[this.mainHeaderLevel];
  }

  get bottomHeader() {
    return this.headers[this.headers.length - 1];
  }

  get leafUnit() {
    return this.bottomHeader.unit;
  }

  get mainUnit() {
    return this.mainHeader;
  }

  get msPerPixel() {
    const {
      bottomHeader
    } = this;
    return Math.round(DateHelper.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);
  }

  get isValid() {
    const me = this;
    let valid = true;

    for (const header of me.headers) {
      valid = valid && Boolean(DateHelper.normalizeUnit(header.unit));
    }

    if (me.timeResolution) {
      valid = valid && DateHelper.normalizeUnit(me.timeResolution.unit);
    }

    if (me.shiftUnit) {
      valid = valid && DateHelper.normalizeUnit(me.shiftUnit);
    }

    return valid;
  }

}

ViewPreset._$name = 'ViewPreset';


class PresetStore extends Localizable(Store) {
  static get defaultConfig() {
    return {
      useRawData: true,
      modelClass: ViewPreset,


      zoomOrder: 1
    };
  }

  set storage(storage) {
    super.storage = storage;

    this.storage.addSorter((lhs, rhs) => {
      const leftBottomHeader = lhs.bottomHeader,
        rightBottomHeader = rhs.bottomHeader;


      const order = rhs.msPerPixel - lhs.msPerPixel || unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] || leftBottomHeader.increment - rightBottomHeader.increment;
      return order * this.zoomOrder;
    });
  }

  get storage() {
    return super.storage;
  }

  createRecord(data) {

    if (data.preset && !data.base) {
      VersionHelper.deprecate('Scheduler', '4.0.0', 'ViewPreset preset config replaced by base config. See https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
      data.base = data.preset;
    }

    if (data.base) {
      const base = this.getById(data.base) || pm.getById(data.base);
      data = Object.setPrototypeOf(data, base.data);
    }

    return super.createRecord(...arguments);
  }

  updateLocalization() {
    super.updateLocalization();
    this.forEach(preset => {
      const locale = this.L(preset.id);

      if (locale) {
        locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
        locale.middleDateFormat && preset.headerConfig.middle && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
        locale.topDateFormat && preset.headerConfig.top && (preset.headerConfig.top.dateFormat = locale.topDateFormat);
        locale.bottomDateFormat && preset.headerConfig.bottom && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
      }
    });
  }

}

PresetStore._$name = 'PresetStore';


class PresetManager extends PresetStore {
  static get defaultConfig() {
    return {

      preventSubClassingModel: true,
      basePresets: {
        secondAndMinute: {
          name: 'Seconds',
          tickWidth: 30,

          tickHeight: 40,
          displayDateFormat: 'll LTS',

          shiftIncrement: 10,

          shiftUnit: 'minute',

          defaultSpan: 24,

          timeResolution: {

            unit: 'second',

            increment: 5
          },


          headers: [{
            unit: 'minute',
            dateFormat: 'llll'
          }, {
            unit: 'second',
            increment: 10,
            dateFormat: 'ss'
          }]
        },
        minuteAndHour: {
          name: 'Minutes',
          tickWidth: 60,

          tickHeight: 60,
          displayDateFormat: 'll LT',

          shiftIncrement: 1,

          shiftUnit: 'hour',

          defaultSpan: 24,

          timeResolution: {

            unit: 'minute',

            increment: 30
          },
          headers: [{
            unit: 'hour',
            dateFormat: 'ddd MM/DD, hA'
          }, {
            unit: 'minute',
            increment: 30,
            dateFormat: 'mm'
          }]
        },
        hourAndDay: {
          name: 'Hours',
          tickWidth: 70,
          tickHeight: 40,
          displayDateFormat: 'll LT',
          shiftIncrement: 1,
          shiftUnit: 'day',
          defaultSpan: 24,
          timeResolution: {
            unit: 'minute',
            increment: 30
          },
          headers: [{
            unit: 'day',
            dateFormat: 'ddd DD/MM'

          }, {
            unit: 'hour',
            dateFormat: 'LT'
          }]
        },
        day: {
          name: 'Hours 2',
          displayDateFormat: 'LT',
          shiftIncrement: 1,
          shiftUnit: 'day',
          defaultSpan: 1,
          timeResolution: {
            unit: 'minute',
            increment: 30
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: 'day',
            dateFormat: 'ddd DD/MM',

            splitUnit: 'day'
          }, {
            unit: 'hour',

            renderer(value) {
              return `
                                    <div class="b-sch-calendarcolumn-ct"><span class="b-sch-calendarcolumn-hours">${DateHelper.format(value, 'HH')}</span>
                                    <span class="b-sch-calendarcolumn-minutes">${DateHelper.format(value, 'mm')}</span></div>
                                `;
            }

          }]
        },
        week: {
          name: 'Week/hours',
          displayDateFormat: 'LT',
          shiftIncrement: 1,
          shiftUnit: 'week',
          defaultSpan: 24,
          timeResolution: {
            unit: 'minute',
            increment: 30
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: 'week',
            dateFormat: 'D d',
            splitUnit: 'day'
          }, {
            unit: 'hour',
            dateFormat: 'LT',


            renderer(value) {
              return `
                                    <div class="sch-calendarcolumn-ct">
                                    <span class="sch-calendarcolumn-hours">${DateHelper.format(value, 'HH')}</span>
                                    <span class="sch-calendarcolumn-minutes">${DateHelper.format(value, 'mm')}</span>
                                    </div>
                                `;
            }

          }]
        },
        dayAndWeek: {
          name: 'Days 2',
          tickWidth: 100,
          tickHeight: 80,
          displayDateFormat: 'll LT',
          shiftUnit: 'day',
          shiftIncrement: 1,
          defaultSpan: 5,
          timeResolution: {
            unit: 'hour',
            increment: 1
          },
          headers: [{
            unit: 'week',

            renderer(start) {
              return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');
            }

          }, {
            unit: 'day',
            dateFormat: 'dd DD'
          }]
        },
        weekAndDay: {
          name: 'Days',
          tickWidth: 100,
          tickHeight: 80,
          displayDateFormat: 'll hh:mm A',
          shiftUnit: 'week',
          shiftIncrement: 1,
          defaultSpan: 1,
          timeResolution: {
            unit: 'day',
            increment: 1
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: 'week',
            dateFormat: 'YYYY MMMM DD'

          }, {
            unit: 'day',
            increment: 1,
            dateFormat: 'DD MMM'
          }]
        },
        weekAndMonth: {
          name: 'Weeks',
          tickWidth: 100,
          tickHeight: 105,
          displayDateFormat: 'll',
          shiftUnit: 'week',
          shiftIncrement: 5,
          defaultSpan: 6,
          timeResolution: {
            unit: 'day',
            increment: 1
          },
          headers: [{
            unit: 'month',
            dateFormat: 'MMM YYYY'

          }, {
            unit: 'week',
            dateFormat: 'DD MMM'
          }]
        },
        weekAndDayLetter: {
          name: 'Weeks 2',
          tickWidth: 20,
          tickHeight: 50,
          displayDateFormat: 'll',
          shiftUnit: 'week',
          shiftIncrement: 1,
          defaultSpan: 10,
          timeResolution: {
            unit: 'day',
            increment: 1
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: 'week',
            dateFormat: 'ddd DD MMM YYYY',
            verticalColumnWidth: 115
          }, {
            unit: 'day',
            dateFormat: 'd1',
            verticalColumnWidth: 25
          }]
        },
        weekDateAndMonth: {
          name: 'Weeks 3',
          tickWidth: 30,
          tickHeight: 40,
          displayDateFormat: 'll',
          shiftUnit: 'week',
          shiftIncrement: 1,
          defaultSpan: 10,
          timeResolution: {
            unit: 'day',
            increment: 1
          },
          headers: [{
            unit: 'month',
            dateFormat: 'YYYY MMMM'
          }, {
            unit: 'week',
            dateFormat: 'DD'
          }]
        },
        monthAndYear: {
          name: 'Months',
          tickWidth: 110,
          tickHeight: 110,
          displayDateFormat: 'll',
          shiftIncrement: 3,
          shiftUnit: 'month',
          defaultSpan: 12,
          timeResolution: {
            unit: 'day',
            increment: 1
          },
          headers: [{
            unit: 'year',
            dateFormat: 'YYYY'

          }, {
            unit: 'month',
            dateFormat: 'MMM YYYY'

          }]
        },
        year: {
          name: 'Years',
          tickWidth: 100,
          tickHeight: 100,
          resourceColumnWidth: 100,
          displayDateFormat: 'll',
          shiftUnit: 'year',
          shiftIncrement: 1,
          defaultSpan: 1,
          timeResolution: {
            unit: 'month',
            increment: 1
          },
          headers: [{
            unit: 'year',
            dateFormat: 'YYYY'
          }, {
            unit: 'quarter',

            renderer(start, end, cfg) {
              return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);
            }

          }]
        },
        manyYears: {
          name: 'Years 2',
          tickWidth: 40,
          tickHeight: 50,
          displayDateFormat: 'll',
          shiftUnit: 'year',
          shiftIncrement: 1,
          defaultSpan: 1,
          timeResolution: {
            unit: 'year',
            increment: 1
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: 'year',
            dateFormat: 'YYYY',
            increment: 5
          }, {
            unit: 'year',
            dateFormat: 'YY',
            increment: 1
          }]
        }
      },


      defaultPresets: [
        'manyYears', {
          width: 80,
          increment: 1,
          resolution: 1,
          preset: 'manyYears',
          resolutionUnit: 'YEAR'
        },
        'year', {
          width: 30,
          increment: 1,
          resolution: 1,
          preset: 'year',
          resolutionUnit: 'MONTH'
        }, {
          width: 50,
          increment: 1,
          resolution: 1,
          preset: 'year',
          resolutionUnit: 'MONTH'
        }, {
          width: 200,
          increment: 1,
          resolution: 1,
          preset: 'year',
          resolutionUnit: 'MONTH'
        },
        'monthAndYear',
        'weekDateAndMonth',
        'weekAndMonth',
        'weekAndDayLetter',
        'weekAndDay', {
          width: 54,
          increment: 1,
          resolution: 1,
          preset: 'weekAndDay',
          resolutionUnit: 'HOUR'
        },
        'hourAndDay', {
          width: 64,
          increment: 6,
          resolution: 30,
          preset: 'hourAndDay',
          resolutionUnit: 'MINUTE'
        }, {
          width: 100,
          increment: 6,
          resolution: 30,
          preset: 'hourAndDay',
          resolutionUnit: 'MINUTE'
        }, {
          width: 64,
          increment: 2,
          resolution: 30,
          preset: 'hourAndDay',
          resolutionUnit: 'MINUTE'
        },
        'minuteAndHour', {
          width: 30,
          increment: 15,
          resolution: 5,
          preset: 'minuteAndHour'
        }, {
          width: 130,
          increment: 15,
          resolution: 5,
          preset: 'minuteAndHour'
        }, {
          width: 60,
          increment: 5,
          resolution: 5,
          preset: 'minuteAndHour'
        }, {
          width: 100,
          increment: 5,
          resolution: 5,
          preset: 'minuteAndHour'
        },
        'secondAndMinute', {
          width: 60,
          increment: 10,
          resolution: 5,
          preset: 'secondAndMinute'
        }, {
          width: 130,
          increment: 5,
          resolution: 5,
          preset: 'secondAndMinute'
        }],
      listeners: {
        locale: 'updateLocalization'
      }
    };
  }

  set basePresets(basePresets) {
    const presetCache = this._basePresets = {};

    for (const id in basePresets) {
      basePresets[id].id = id;
      presetCache[id] = this.createRecord(basePresets[id]);
    }
  }

  get basePresets() {
    return this._basePresets;
  }

  set defaultPresets(defaultPresets) {
    for (let i = 0, {
      length
    } = defaultPresets; i < length; i++) {
      const presetAdjustment = defaultPresets[i],
        isBase = typeof presetAdjustment === 'string',
        baseType = isBase ? presetAdjustment : presetAdjustment.preset;
      let preset;

      if (isBase) {
        preset = this.basePresets[baseType];
      } else {
        const config = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), {
            id: baseType
          }),
          {
            timeResolution
          } = config,
          bottomHeader = config.headers[config.headers.length - 1];
        config.id = undefined;

        if ('width' in presetAdjustment) {
          config.tickWidth = presetAdjustment.width;
        }

        if ('height' in presetAdjustment) {
          config.tickHeight = presetAdjustment.height;
        }

        if ('increment' in presetAdjustment) {
          bottomHeader.increment = presetAdjustment.increment;
        }

        if ('resolution' in presetAdjustment) {
          timeResolution.increment = presetAdjustment.resolution;
        }

        if ('resolutionUnit' in presetAdjustment) {
          timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);
        }

        preset = this.createRecord(config);
      }

      this.add(preset);
    }
  }

  getById(id) {


    return super.getById(id) || this.basePresets[id];
  }


  registerPreset(id, config) {
    const preset = this.createRecord(Object.assign({
        id
      }, config)),
      existingDuplicate = this.find(p => p.equals(preset));

    if (existingDuplicate) {
      return existingDuplicate;
    }

    if (preset.isValid) {
      this.add(preset);
    } else {
      throw new Error('Invalid preset, please check your configuration');
    }

    return preset;
  }

  getPreset(preset) {
    if (typeof preset === 'number') {
      preset = this.getAt(preset);
    }

    if (typeof preset === 'string') {
      preset = this.getById(preset);
    } else if (!(preset instanceof ViewPreset)) {
      preset = this.createRecord(preset);
    }

    return preset;
  }


  normalizePreset(preset) {
    let me = this;

    if (!(preset instanceof ViewPreset)) {
      if (typeof preset === 'string') {
        preset = me.getPreset(preset);

        if (!preset) {
          throw new Error('You must define a valid view preset. See PresetManager for reference');
        }
      } else if (typeof preset === 'object') {

        if (preset.base) {
          const base = this.getById(preset.base);

          if (!base) {
            throw new Error(`ViewPreset base '${preset.base}' does not exist`);
          }

          preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);
        }


        if (preset.id) {
          preset = me.createRecord(preset);
        } else {
          preset = me.createRecord(ObjectHelper.assign({}, preset));
          preset.id = preset.generateId(preset);
        }
      }
    }

    return preset;
  }


  deletePreset(presetOrId) {
    if (typeof presetOrId === 'string') {
      presetOrId = this.getById(presetOrId);
    } else if (typeof presetOrId === 'number') {
      presetOrId = this.getAt(presetOrId);
    }

    if (presetOrId) {
      this.remove(presetOrId);

      delete this.basePresets[presetOrId.id];
    }
  }

}

const pm = new PresetManager();


class TimeAxis extends Store {


  static get defaultConfig() {
    return {
      modelClass: TimeSpan,


      continuous: true,
      originalContinuous: null,


      include: null,


      autoAdjust: true,
      unit: null,
      increment: null,
      resolutionUnit: null,
      resolutionIncrement: null,
      weekStartDay: null,
      mainUnit: null,
      shiftUnit: null,
      shiftIncrement: 1,


      adjustedStart: null,
      adjustedEnd: null,

      visibleTickStart: null,

      visibleTickEnd: null,
      defaultSpan: 1,
      tickCache: {},
      viewPreset: null
    };
  }


  construct(config) {
    const me = this;

    me.generateTicksValidatorFn = () => true;

    super.construct(config);
    me.originalContinuous = me.continuous;
    me.on({
      change: ({
                 action
               }) => {


        if (action !== 'filter') {
          me.trigger('reconfigure', {
            supressRefresh: false
          });
        }
      },
      refresh: () => me.trigger('reconfigure', {
        supressRefresh: false
      }),
      endreconfigure: event => me.trigger('reconfigure', event)
    });

    if (me.startDate) {
      me.internalOnReconfigure();
      me.trigger('reconfigure');
    } else if (me.viewPreset) {
      const range = me.getAdjustedDates(new Date());
      me.startDate = range.startDate;
      me.endDate = range.endDate;
    }
  }

  get isTimeAxis() {
    return true;
  }


  reconfigure(config, suppressRefresh = false, preventThrow = false) {
    const me = this,
      normalized = me.getAdjustedDates(config.startDate, config.endDate);

    if (me.trigger('beforeReconfigure', {
      startDate: normalized.startDate,
      endDate: normalized.endDate,
      config
    }) !== false) {
      me.trigger('beginReconfigure');
      me._configuredStartDate = config.startDate;
      me._configuredEndDate = config.endDate;
      Object.assign(me, config);

      if (me.internalOnReconfigure(preventThrow) === false) {
        return false;
      }

      me.trigger('endReconfigure', {
        suppressRefresh,
        config
      });
    }
  }

  internalOnReconfigure(preventThrow = false) {
    const me = this;
    me.isConfigured = true;
    const adjusted = me.getAdjustedDates(me.startDate, me.endDate, true),
      normalized = me.getAdjustedDates(me.startDate, me.endDate),
      start = normalized.startDate,
      end = normalized.endDate;

    if (start >= end) {
      throw new Error(`Invalid start/end dates. Start date must less than end date. Start date: ${start}. End date: ${end}.`);
    }

    const unit = me.unit,
      increment = me.increment || 1,
      ticks = me.generateTicks(start, end, unit, increment);

    me.suspendEvents();
    me.data = ticks;
    const {
      count
    } = me;

    if (count === 0) {
      if (preventThrow) {
        me.resumeEvents();
        return false;
      }

      throw new Error('Invalid time axis configuration or filter, please check your input data.');
    }

    me.startDate = me.first.startDate;
    me.resumeEvents();
    let checkEnd = me.last.endDate;

    if (me.isContinuous) {
      me.adjustedStart = adjusted.startDate;
      me.adjustedEnd = DateHelper.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);
    } else {
      me.adjustedStart = me.startDate;
      me.adjustedEnd = checkEnd;
    }


    do {

      me.visibleTickStart = (me.startDate - me.adjustedStart) / (DateHelper.asMilliseconds(unit) * increment);

      if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);
      if (me.visibleTickStart >= 1) me.adjustedStart = DateHelper.getNext(me.adjustedStart, unit, increment, me.weekStartDay);
    } while (me.visibleTickStart >= 1);

    do {
      me.visibleTickEnd = count - (me.adjustedEnd - checkEnd) / (DateHelper.asMilliseconds(unit) * increment);
      if (count - me.visibleTickEnd >= 1) me.adjustedEnd = DateHelper.getNext(me.adjustedEnd, unit, -1, me.weekStartDay);
    } while (count - me.visibleTickEnd >= 1);

    me.updateTickCache(true);
  }


  get viewPreset() {
    return this._viewPreset;
  }

  set viewPreset(preset) {
    const me = this;
    preset = pm.getPreset(preset);

    if (!(preset instanceof ViewPreset)) {
      throw new Error('TimeAxis must be configured with the ViewPreset instance that the Scheduler is using');
    }

    me._viewPreset = preset;
    Object.assign(me, {
      unit: preset.bottomHeader.unit,
      increment: preset.bottomHeader.increment || 1,
      resolutionUnit: preset.timeResolution.unit,
      resolutionIncrement: preset.timeResolution.increment,
      mainUnit: preset.mainHeader.unit,
      shiftUnit: preset.shiftUnit,
      shiftIncrement: preset.shiftIncrement || 1,
      defaultSpan: preset.defaultSpan || 1,
      presetName: preset.id,


      headers: preset.headers
    });
  }


  set weekStartDay(day) {
    this._weekStartDay = day;
  }

  get weekStartDay() {
    if (this._weekStartDay == null) {
      return DateHelper.weekStartDay;
    }

    return this._weekStartDay;
  }

  get resolution() {
    return {
      unit: this.resolutionUnit,
      increment: this.resolutionIncrement
    };
  }

  set resolution(resolution) {
    this.resolutionUnit = resolution.unit;
    this.resolutionIncrement = resolution.increment;
  }

  get resolutionUnit() {
    return this._resolutionUnit;
  }

  set resolutionUnit(resolutionUnit) {
    this._resolutionUnit = resolutionUnit;
  }

  get resolutionIncrement() {
    return this._resolutionIncrement;
  }

  set resolutionIncrement(resolutionIncrement) {
    this._resolutionIncrement = resolutionIncrement || 1;
  }

  set mainUnit(mainUnit) {
    this._mainUnit = mainUnit;
  }

  get mainUnit() {
    return this._mainUnit;
  }

  set shiftUnit(shiftUnit) {
    this._shiftUnit = shiftUnit;
  }

  get shiftUnit() {
    return this._shiftUnit || this._mainUnit;
  }

  set shiftIncrement(shiftIncrement) {
    this._shiftIncrement = shiftIncrement;
  }

  get shiftIncrement() {
    return this._shiftIncrement || 1;
  }

  set unit(unit) {
    this._unit = unit;
  }

  get unit() {
    return this._unit;
  }

  set increment(increment) {
    this._increment = increment;
  }

  get increment() {
    return this._increment;
  }

  get defaultSpan() {
    return this._defaultSpan;
  }

  set defaultSpan(defaultSpan) {
    this._defaultSpan = defaultSpan;
  }


  setTimeSpan(newStartDate, newEndDate, preventThrow = false) {
    const me = this,
      {
        startDate,
        endDate
      } = me.getAdjustedDates(newStartDate, newEndDate);

    if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {
      return me.reconfigure({
        startDate,
        endDate
      }, false, preventThrow);
    }
  }


  shift(amount, unit = this.shiftUnit) {
    const me = this;
    let {
      startDate,
      endDate
    } = me;


    if (me.isFiltered) {
      startDate = me.allRecords[0].startDate;
      endDate = me.allRecords[me.allCount - 1].endDate;
    }

    let tries = 0;

    do {
      startDate = DateHelper.add(startDate, amount, unit);
      endDate = DateHelper.add(endDate, amount, unit);
    } while (tries++ < 100 && me.setTimeSpan(startDate, endDate, true) === false);
  }


  shiftNext(amount = this.shiftIncrement) {
    this.shift(amount);
  }


  shiftPrevious(amount = this.shiftIncrement) {
    this.shift(-amount);
  }


  filterBy(fn, thisObj = this) {
    const me = this;
    me.filters.clear();
    super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));

    if (me.count === 0) {
      me.trigger('invalidFilter');
      me.clearFilters();
    }
  }

  triggerFilterEvent(event) {
    const me = this;

    if (!event.filters.count) {
      me.continuous = me.originalContinuous;
    } else {
      me.continuous = false;
    }


    me.updateTickCache();
    super.triggerFilterEvent(event);
  }


  get isContinuous() {
    return this.continuous !== false && !this.filtered;
  }


  getAdjustedDates(startDate, endDate, forceAdjust = false) {
    const me = this;
    startDate = startDate || me.startDate;
    endDate = endDate || DateHelper.add(startDate, me.defaultSpan, me.mainUnit);
    return me.autoAdjust || forceAdjust ? {
      startDate: me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),
      endDate: me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)
    } : {
      startDate: startDate,
      endDate: endDate
    };
  }


  get startDate() {

    return this._start || (this.first ? new Date(this.first.startDate) : null);
  }

  set startDate(start) {
    this._start = DateHelper.parse(start);
  }


  get endDate() {
    return this._end || (this.last ? new Date(this.last.endDate) : null);
  }

  set endDate(end) {
    if (end) this._end = DateHelper.parse(end);
  }

  get startMS() {
    return this._startMS;
  }

  get endMS() {
    return this._endMS;
  }


  floorDate(date, relativeToStart, resolutionUnit, incr) {
    relativeToStart = relativeToStart !== false;

    const me = this,
      relativeTo = relativeToStart ? DateHelper.clone(me.startDate) : null,
      increment = incr || me.resolutionIncrement,
      unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),
      snap = (value, increment) => Math.floor(value / increment) * increment;

    if (relativeToStart) {
      const snappedDuration = snap(DateHelper.diff(relativeTo, date, unit), increment);

      return DateHelper.add(relativeTo, snappedDuration, unit);
    }

    let dt = DateHelper.clone(date);

    if (unit === 'week') {
      let day = dt.getDay() || 7,
        startDay = me.weekStartDay || 7;
      dt = DateHelper.add(DateHelper.startOf(dt, 'day'), day >= startDay ? startDay - day : -(7 - startDay + day), 'day');

      if (dt.getDay() !== startDay && dt.getHours() === 23) {
        dt = DateHelper.add(dt, 1, 'hour');
      }
    } else {

      dt = DateHelper.startOf(dt, unit);

      let modifier = ['day', 'year'].includes(unit) ? 1 : 0,
        useUnit = unit === 'day' ? 'date' : unit,
        snappedValue = snap(DateHelper.get(dt, useUnit) - modifier, increment) + modifier;
      dt = DateHelper.set(dt, useUnit, snappedValue);
    }

    return dt;
  }


  roundDate(date, relativeTo) {
    const me = this,
      dt = DateHelper.clone(date),
      increment = me.resolutionIncrement || 1;
    relativeTo = DateHelper.clone(relativeTo || me.startDate);

    switch (me.resolutionUnit) {
      case 'week':
        DateHelper.startOf(dt, 'day');
        let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,
          toAdd;

        if (distanceToWeekStartDay < 0) {
          distanceToWeekStartDay = 7 + distanceToWeekStartDay;
        }

        if (Math.round(distanceToWeekStartDay / 7) === 1) {
          toAdd = 7 - distanceToWeekStartDay;
        } else {
          toAdd = -distanceToWeekStartDay;
        }

        return DateHelper.add(dt, toAdd, 'day');

      case 'month':
        const nbrMonths = DateHelper.diff(relativeTo, dt, 'month') + DateHelper.as('month', dt.getDay() / DateHelper.daysInMonth(dt)),

          snappedMonths = Math.round(nbrMonths / increment) * increment;
        return DateHelper.add(relativeTo, snappedMonths, 'month');

      case 'quarter':
        DateHelper.startOf(dt, 'month');
        return DateHelper.add(dt, 'month', 3 - dt.getMonth() % 3);

      default:
        const duration = DateHelper.as(me.resolutionUnit, DateHelper.diff(relativeTo, dt)),

          offset = DateHelper.as(me.resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),

          snappedDuration = Math.round((duration + offset) / increment) * increment;


        return DateHelper.add(relativeTo, snappedDuration - offset, me.resolutionUnit);
    }
  }

  ceilDate(date, relativeToStart, resolutionUnit, increment) {
    const me = this;
    relativeToStart = relativeToStart !== false;
    increment = increment || (relativeToStart ? this.resolutionIncrement : 1);
    let dt = DateHelper.clone(date),
      doCall = false,
      unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit);

    switch (unit) {
      case 'minute':
        doCall = !DateHelper.isStartOf(dt, 'minute');
        break;

      case 'hour':
        doCall = !DateHelper.isStartOf(dt, 'hour');
        break;

      case 'day':
      case 'date':
        doCall = !DateHelper.isStartOf(dt, 'day');
        break;

      case 'week':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getDay() !== me.weekStartDay || !DateHelper.isEqual(dt, date);
        break;

      case 'month':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getDate() !== 1 || !DateHelper.isEqual(dt, date);
        break;

      case 'quarter':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date);
        break;

      case 'year':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getMonth() !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date);
        break;
    }

    if (doCall) return DateHelper.getNext(dt, unit, increment, me.weekStartDay);
    return dt;
  }


  get include() {
    return this._include;
  }

  set include(include) {
    const me = this;
    me._include = include;
    me.continuous = !include;

    if (!me.isConfiguring) {
      me.startDate = me._configuredStartDate;
      me.endDate = me._configuredEndDate;
      me.internalOnReconfigure();
      me.trigger('includeChange');
    }
  }

  processExclusion(startDate, endDate, unit) {
    const {
      include
    } = this;

    if (include) {
      return Object.entries(include).some(([includeUnit, rule]) => {
        if (!rule) {
          return false;
        }

        const {
          from,
          to
        } = rule;


        if (DateHelper.compareUnits('day', unit) >= 0 && DateHelper.getLargerUnit(includeUnit) === unit) {
          if (from) {
            DateHelper.set(startDate, includeUnit, from);
          }

          if (to) {
            let stepUnit = unit;

            if (unit === 'day') {
              stepUnit = 'date';
            }


            DateHelper.set(endDate, {
              [stepUnit]: DateHelper.get(endDate, stepUnit) - 1,
              [includeUnit]: to
            });
          }
        }


        if (DateHelper.compareUnits(includeUnit, unit) >= 0) {
          const datePart = includeUnit === 'day' ? startDate.getDay() : DateHelper.get(startDate, includeUnit);

          if (from && datePart < from || to && datePart >= to) {
            return true;
          }
        }
      });
    }

    return false;
  }

  initExclusion() {
    Object.entries(this.include).forEach(([unit, rule]) => {
      if (rule) {
        const {
          from,
          to
        } = rule;


        rule.lengthFactor = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from);

        rule.lengthFactorExcl = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from - 1);

        rule.center = from + from / (rule.lengthFactor - 1);
      }
    });
  }


  generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {
    const me = this,
      ticks = [],
      usesExclusion = Boolean(me.include);
    let intervalEnd,
      tickEnd,
      isExcluded,
      dstDiff = 0,
      {
        startDate,
        endDate
      } = me.getAdjustedDates(axisStartDate, axisEndDate);
    me.tickCache = {};

    if (usesExclusion) {
      me.initExclusion();
    }

    while (startDate < endDate) {
      intervalEnd = DateHelper.getNext(startDate, unit, increment, me.weekStartDay);

      if (!me.autoAdjust && intervalEnd > endDate) {
        intervalEnd = endDate;
      }


      if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {
        const prev = ticks[ticks.length - 1];
        dstDiff = (prev.startDate.getHours() + increment) % 24 - prev.endDate.getHours();

        if (dstDiff !== 0) {

          intervalEnd = DateHelper.add(intervalEnd, dstDiff, 'hour');
        }
      }

      isExcluded = false;

      if (usesExclusion) {
        tickEnd = new Date(intervalEnd.getTime());
        isExcluded = me.processExclusion(startDate, intervalEnd, unit);
      } else {
        tickEnd = intervalEnd;
      }

      if (me.generateTicksValidatorFn(startDate) && !isExcluded) {
        ticks.push({
          id: ticks.length + 1,
          startDate,
          endDate: intervalEnd
        });
        me.tickCache[startDate.getTime()] = ticks.length - 1;
      }

      startDate = tickEnd;
    }

    return ticks;
  }

  get visibleTickTimeSpan() {
    const me = this;
    return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;
  }


  getTickFromDate(date) {
    const me = this,
      ticks = me.records;
    let begin = 0,
      end = ticks.length - 1,
      middle,
      tick,
      tickStart,
      tickEnd;

    if (!ticks.length || date < ticks[0].startDate || date > ticks[end].endDate) {
      return -1;
    }

    if (me.isContinuous) {


      while (begin < end) {
        middle = begin + end + 1 >> 1;

        if (date > ticks[middle].endDate) {
          begin = middle + 1;
        } else if (date < ticks[middle].startDate) {
          end = middle - 1;
        } else {
          begin = middle;
        }
      }

      tick = ticks[begin];
      tickStart = tick.startDate;
      tickEnd = tick.endDate;

      if (date > tickStart) {
        begin += (date - tickStart) / (tickEnd - tickStart);
      }

      return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);
    } else {
      for (let i = 0; i <= end; i++) {
        tickEnd = ticks[i].endDate;

        if (date <= tickEnd) {
          tickStart = ticks[i].startDate;

          tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);
          return tick;
        }
      }
    }
  }


  getDateFromTick(tick, roundingMethod) {
    const me = this;

    if (tick === me.visibleTickEnd) {
      return me.endDate;
    }

    const wholeTick = Math.floor(tick),
      fraction = tick - wholeTick,
      t = me.getAt(wholeTick);

    if (!t) {
      return null;
    }

    let start = wholeTick === 0 ? me.adjustedStart : t.startDate,

      end = wholeTick === me.count - 1 && me.isContinuous ? me.adjustedEnd : t.endDate,
      date = DateHelper.add(start, fraction * (end - start), 'millisecond');

    if (roundingMethod) {
      date = me[roundingMethod + 'Date'](date);
    }

    return date;
  }


  get ticks() {
    return this.records;
  }


  updateTickCache(onlyStartEnd = false) {
    const me = this;

    if (me.count) {
      me._start = me.first.startDate;
      me._end = me.last.endDate;
      me._startMS = me.startDate.getTime();
      me._endMS = me.endDate.getTime();
    } else {
      me._start = me._end = me._startMs = me._endMS = null;
    }


    if (!onlyStartEnd) {
      me.tickCache = {};
      me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);
    }
  }


  dateInAxis(date, inclusiveEnd = false) {
    const me = this,
      axisStart = me.startDate,
      axisEnd = me.endDate;

    if (me.isContinuous) {
      return inclusiveEnd ? DateHelper.betweenLesserEqual(date, axisStart, axisEnd) : DateHelper.betweenLesser(date, axisStart, axisEnd);
    } else {
      let length = me.getCount(),
        tickStart,
        tickEnd,
        tick;

      for (let i = 0; i < length; i++) {
        tick = me.getAt(i);
        tickStart = tick.startDate;
        tickEnd = tick.endDate;

        if (inclusiveEnd && date <= tickEnd || !inclusiveEnd && date < tickEnd) {
          return date >= tickStart;
        }
      }
    }

    return false;
  }


  timeSpanInAxis(start, end) {
    const me = this;

    if (!end || end.getTime() === start.getTime()) {
      return this.dateInAxis(start, true);
    }

    if (me.isContinuous) {
      return DateHelper.intersectSpans(start, end, me.startDate, me.endDate);
    }

    return start < me.startDate && end > me.endDate || me.getTickFromDate(start) !== me.getTickFromDate(end);
  }

  isTimeSpanInAxis(timeSpan) {
    const me = this,
      startMS = timeSpan.startDateMS,
      endMS = timeSpan.endDateMS;

    if (!startMS || !endMS) return false;

    if (endMS === startMS) {
      return this.dateInAxis(timeSpan.startDate, true);
    }

    if (me.isContinuous) {
      return endMS > me.startMS && startMS < me.endMS;
    }

    return startMS < me.startMS && endMS > me.endMS || me.getTickFromDate(timeSpan.startDate) !== me.getTickFromDate(timeSpan.endDate);
  }


  forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {
    let end = this.endDate,
      dt = this.startDate,
      i = 0,
      intervalEnd;
    if (dt > end) throw new Error('Invalid time axis configuration');

    while (dt < end) {
      intervalEnd = DateHelper.min(DateHelper.getNext(dt, unit, increment, this.weekStartDay), end);
      iteratorFn.call(thisObj, dt, intervalEnd, i);
      dt = intervalEnd;
      i++;
    }
  }

}

TimeAxis._$name = 'TimeAxis';


class AssignmentStore extends AjaxStore {
  static get defaultConfig() {
    return {

      loadPriority: 300,


      syncPriority: 300,
      modelClass: AssignmentModel
    };
  }

  add(newAssignments) {
    if (!Array.isArray(newAssignments)) {
      newAssignments = [newAssignments];
    }

    for (let i = 0; i < newAssignments.length; i++) {
      let a = newAssignments[i];

      if (!(a instanceof Model)) {
        newAssignments[i] = a = this.createRecord(a);
      }

      if (this.storage.findIndex('eventResourceKey', a.eventResourceKey, true) !== -1) {
        throw new Error(`Duplicate assignment Event: ${a.eventId} to resource: ${a.resourceId}`);
      }
    }

    return super.add(newAssignments);
  }

  set storage(storage) {
    super.storage = storage;


    this.storage.addIndex('eventResourceKey');
  }

  get storage() {
    return super.storage;
  }

  doDestroy() {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    super.doDestroy();
  }


  get eventStore() {
    return this._eventStore;
  }

  set eventStore(eventStore) {
    const me = this,
      oldStore = me._eventStore;
    me._eventStore = eventStore || null;
    me.attachToEventStore(me._eventStore);

    if ((oldStore || eventStore) && oldStore !== eventStore) {

      me.trigger('eventStoreChange', {
        newEventStore: eventStore,
        oldEventStore: oldStore
      });
    }
  }

  attachToEventStore(eventStore) {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();

    if (eventStore) {
      me.eventStoreDetacher = eventStore.on({
        remove: me.onEventRemove,
        resourcestorechange: me.onEventStoreResourceStoreChange,
        thisObj: me,
        prio: 200

      });
    }

    if (!me.isConfiguring) {
      me.initRelations(true);
    }

    me.attachToResourceStore(eventStore && eventStore.resourceStore);
  }

  attachToResourceStore(resourceStore) {
    const me = this;
    me.resourceStore = resourceStore;
    me.resourceStoreDetacher && me.resourceStoreDetacher();

    if (resourceStore) {
      me.resourceStoreDetacher = resourceStore.on({
        remove: me.onResourceRemove,
        removeAll: me.onResourceRemoveAll,
        thisObj: me,
        prio: 200

      });

      if (!me.isConfiguring) {
        me.initRelations(true);
      }
    }
  }

  onEventStoreResourceStoreChange({
                                    newResourceStore
                                  }) {
    this.attachToResourceStore(newResourceStore);
  }


  onEventRemove({
                  records,
                  isMove,
                  isCollapse
                }) {
    if (!isMove && !isCollapse) {
      const assignments = [];
      records.forEach(record => {

        record.traverse(eventRecord => {
          assignments.push(...eventRecord.assignments);
        });
      });

      this.isRemovingEvent = true;
      assignments.length && this.remove(assignments);
      this.isRemovingEvent = false;
    }
  }

  onResourceRemove({
                     records,
                     isMove,
                     isCollapse
                   }) {
    if (!isMove && !isCollapse) {
      const assignments = [];
      records.forEach(record => {

        record.traverse(resourceRecord => {
          assignments.push(...resourceRecord.assignments);
        });
      });

      assignments.length && this.remove(assignments);
    }
  }

  onResourceRemoveAll() {

    this.removeAll();
  }


  mapAssignmentsForEvent(event, fn, filterFn) {
    const me = this,
      fnSet = Boolean(fn),
      filterFnSet = Boolean(filterFn),
      eventId = Model.asId(event),
      assignmentCache = me.relationCache.event && me.relationCache.event[eventId];
    if (!assignmentCache) return [];

    fn = fn || (a => a);

    filterFn = filterFn || (() => true);

    if (fnSet || filterFnSet) {
      return assignmentCache.reduce((result, assignment) => {
        const mapResult = fn(assignment);

        if (filterFn(mapResult)) {

          result.push(mapResult);
        }

        return result;
      }, []);
    }

    return assignmentCache;
  }


  mapAssignmentsForResource(resource, fn, filterFn) {
    const me = this,
      fnSet = Boolean(fn),
      filterFnSet = Boolean(filterFn),
      resourceId = Model.asId(resource),
      assignmentCache = me.relationCache.resource && me.relationCache.resource[resourceId];
    if (!assignmentCache) return [];

    fn = fn || (a => a);

    filterFn = filterFn || (() => true);

    if (fnSet || filterFnSet) {
      return assignmentCache.reduce((result, assignment) => {
        const mapResult = fn(assignment);

        if (filterFn(mapResult)) {

          result.push(mapResult);
        }

        return result;
      }, []);
    }

    return assignmentCache;
  }


  getAssignmentsForEvent(event) {
    return event.assignments;
  }


  removeAssignmentsForEvent(event) {
    return this.remove(event.assignments);
  }


  getAssignmentsForResource(resource) {
    return this.mapAssignmentsForResource(resource);
  }


  removeAssignmentsForResource(resource) {
    this.remove(this.getAssignmentsForResource(resource));
  }


  getResourcesForEvent(event) {
    const me = this;


    return me.mapAssignmentsForEvent(event, assignment => assignment.resource, resource => Boolean(resource));
  }


  getEventsForResource(resource) {
    const me = this;

    return me.mapAssignmentsForResource(resource, assignment => assignment.event, event => !!event);
  }


  assignEventToResource(event, resources, assignmentSetupFn = o => o, removeExistingAssignments = false) {
    const me = this,
      oldAutoCommit = me.autoCommit;
    resources = Array.isArray(resources) ? resources : [resources];
    let newAssignments = [];
    me.autoCommit = false;

    if (removeExistingAssignments && event.resources) {

      event.resources.forEach(resource => {
        if (!resources.includes(resource)) {
          me.unassignEventFromResource(event, resource);
        }
      });
    }

    resources.forEach(resource => {
      if (!me.isEventAssignedToResource(event, resource)) {
        let assignment = new me.modelClass({
          eventId: Model.asId(event),
          resourceId: Model.asId(resource)
        });
        assignment = assignmentSetupFn(assignment);
        newAssignments.push(assignment);
      }
    });
    newAssignments = me.add(newAssignments);

    me.autoCommit = oldAutoCommit;
    return newAssignments;
  }


  unassignEventFromResource(event, resources) {
    const me = this,
      assignmentsToRemove = [];

    if (!resources) {
      return me.removeAssignmentsForEvent(event);
    }

    if (!Array.isArray(resources)) {
      resources = [resources];
    }

    for (let i = 0; i < resources.length; i++) {
      if (me.isEventAssignedToResource(event, resources[i])) {
        assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));
      }
    }

    return me.remove(assignmentsToRemove);
  }


  isEventAssignedToResource(event, resource) {
    const me = this,
      records = me.getResourcesForEvent(event),
      resourceId = Model.asId(resource);

    return records.some(res => res.id == resourceId);
  }


  getAssignmentForEventAndResource(event, resource) {
    const me = this;
    event = me.eventStore.getById(event);
    resource = me.resourceStore.getById(resource);


    return me.records.find(assignment => assignment.event == event && assignment.resource == resource);
  }

}

AssignmentStore._$name = 'AssignmentStore';


class CalendarDayModel extends Model {
  static get fields() {
    return [


      {
        name: 'date',
        type: 'date',
        format: 'YYYY-MM-DD',
        persist: true
      },

      {
        name: 'weekday',
        type: 'int'
      },

      {
        name: 'overrideStartDate',
        type: 'date',
        dateFormat: 'YYYY-MM-DD'
      },

      {
        name: 'overrideEndDate',
        type: 'date',
        dateFormat: 'YYYY-MM-DD'
      },

      {
        name: 'type',
        defaultValue: 'DAY'

      },

      {
        name: 'isWorkingDay',
        type: 'boolean',
        defaultValue: false
      },

      {
        name: 'cls'


      },

      {
        name: 'name'
      },

      {
        name: 'availability',
        persist: true


      }];
  }

  set date(date) {
    if (date) date = DateHelper.startOf(date, 'day');
    this.set('date', date);
  }

  get date() {
    return this.get('date');
  }


  clearDate() {
    this.set('date', null);
  }

  get availability() {
    return this.get('availability');
  }

  set availability(intervals) {

    this.availabilityCache = null;
    this.set('availability', this.stringifyIntervals(intervals));

    this.getAvailability();
  }


  getAvailability(asString) {
    const me = this;

    if (asString) return me.get('availability');
    if (me.availabilityCache) return me.availabilityCache;
    const parsed = me.get('availability').map(value => typeof value === 'string' ? me.parseInterval(value) : value);
    me.verifyAvailability(parsed);
    return me.availabilityCache = parsed;
  }

  verifyAvailability(intervals) {
    const me = this;
    intervals.sort((a, b) => a.startTime - b.startTime);
    intervals.forEach((interval, i) => {
      if (interval.startTime > interval.endTime) {
        throw new Error(`Start time ${DateHelper.format(interval.startTime, 'HH:mm')} is greater than end time ${DateHelper.format(interval.endTime, 'HH:mm')}`);
      }

      if (i > 0 && intervals[i - 1].endTime > interval.startTime) {
        throw new Error(`Availability intervals should not intersect: [${me.stringifyInterval(intervals[i - 1])}] and [${me.stringifyInterval(interval)}]`);
      }
    });
  }


  stringifyInterval(interval) {
    const startTime = interval.startTime,
      endTime = interval.endTime;
    return DateHelper.format(startTime, 'HH:mm') + '-' + DateHelper.format(endTime, 'HH:mm');

  }

  stringifyIntervals(intervals) {
    const me = this;
    return intervals.map(interval => typeof interval === 'string' ? interval : me.stringifyInterval(interval));
  }

  parseInterval(string) {
    const match = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);
    if (!match) throw new Error(`Invalid format for availability string: ${String}. It should have exact format: hh:mm-hh:mm`);
    return {
      startTime: new Date(0, 0, 0, match[1], match[2]),
      endTime: new Date(0, 0, 0, match[3], match[4])
    };
  }


  get totalHours() {
    return this.getTotalMS() / 1000 / 60 / 60;
  }


  get totalMS() {
    return this.getAvailability().reduce((totalMS, interval) => totalMS += interval.endTime - interval.startTime, 0);
  }


  addAvailabilityInterval(startTime, endTime) {
    let interval;

    if (startTime instanceof Date) {
      interval = {
        startTime: startTime,
        endTime: endTime
      };
    } else {
      interval = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
    }

    const intervals = this.getAvailability().concat(interval);
    this.verifyAvailability(intervals);
    this.setAvailability(intervals);
  }


  removeAvailabilityInterval(index) {
    const intervals = this.getAvailability();
    intervals.splice(index, 1);
    this.setAvailability(intervals);
  }


  getAvailabilityIntervalsFor(timeDate) {
    timeDate = typeof timeDate === 'number' ? new Date(timeDate) : timeDate;
    const year = timeDate.getFullYear(),
      month = timeDate.getMonth(),
      date = timeDate.getDate();
    return this.getAvailability().map(interval => {
      const endDate = interval.endTime.getDate();
      return {
        startDate: new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()),
        endDate: new Date(year, month, date + (endDate == 1 ? 1 : 0), interval.endTime.getHours(), interval.endTime.getMinutes())
      };
    });
  }


  getAvailabilityStartFor(timeDate) {
    const intervals = this.getAvailabilityIntervalsFor(timeDate);
    if (!intervals.length) return null;
    return intervals[0].startDate;
  }


  getAvailabilityEndFor(timeDate) {
    const intervals = this.getAvailabilityIntervalsFor(timeDate);
    if (!intervals.length) return null;
    return intervals[intervals.length - 1].endDate;
  }

}

CalendarDayModel._$name = 'CalendarDayModel';


class Calendar extends AjaxStore {
  static get defaultConfig() {
    return {
      modelClass: CalendarDayModel,


      daysPerMonth: 30,


      daysPerWeek: 7,


      hoursPerDay: 24,
      unitsInMs: null,
      defaultNonWorkingTimeCssCls: 'b-nonworkingtime',


      weekendsAreWorkdays: false,


      weekendFirstDay: 6,


      weekendSecondDay: 0,
      holidaysCache: null,
      availabilityIntervalsCache: null,
      daysIndex: null,

      weekAvailability: null,

      defaultWeekAvailability: null,
      nonStandardWeeksByStartDate: null,
      nonStandardWeeksStartDates: null,


      calendarId: null,


      parent: null,


      defaultAvailability: ['00:00-24:00'],


      name: null,
      suspendCacheUpdate: 0,


      availabilitySearchLimit: 1825

    };
  }


  static get allCalendars() {
    return (Store.stores || []).filter(store => store instanceof Calendar);
  }


  get calendarId() {
    return this._calendarId;
  }


  set parent(parentOrId) {
    const me = this,
      parent = Calendar.getCalendar(parentOrId);
    if (parentOrId && !parent) throw new Error('Invalid parent specified for the calendar');

    if (me.parent != parent) {
      const listeners = {
        calendarchange: me.clearCache,
        destroy: me.onParentDestroy,
        thisObj: me
      };
      const oldParent = me.parent;
      if (oldParent) oldParent.un(listeners);
      me._parent = parent;
      if (parent) parent.on(listeners);
      me.params = Object.assign(me.params || {}, {
        parentId: parent ? parent.calendarId : null
      });
      me.clearCache();


      me.trigger('parentChange', {
        newParent: parent,
        oldParent
      });
    }
  }

  construct(config) {
    const me = this;
    super.construct(config);

    me.unitsInMs = {
      MILLI: 1,
      SECOND: 1000,
      MINUTE: 60 * 1000,
      HOUR: 60 * 60 * 1000,
      DAY: me.hoursPerDay * 60 * 60 * 1000,
      WEEK: me.daysPerWeek * me.hoursPerDay * 60 * 60 * 1000,
      MONTH: me.daysPerMonth * me.hoursPerDay * 60 * 60 * 1000,
      QUARTER: 3 * me.daysPerMonth * 24 * 60 * 60 * 1000,
      YEAR: 4 * 3 * me.daysPerMonth * 24 * 60 * 60 * 1000
    };
    me.defaultWeekAvailability = me.getDefaultWeekAvailability();


    me.on({

      change: me.clearCache,
      thisObj: me
    });
    me.clearCache();
  }


  static getCalendar(id) {
    if (id instanceof Calendar) return id;
    return Store.getStore(id);
  }

  set calendarId(id) {
    const me = this;
    me._calendarId = id;

    if (id != null) {
      me.storeId = 'GNT_CALENDAR:' + id;
    } else {
      me.storeId = null;
    }

    me.params = Object.assign(me.params || {}, {
      calendarId: id
    });
  }

  getDefaultWeekAvailability() {
    let availability = this.defaultAvailability,
      weekendFirstDay = this.weekendFirstDay,
      weekendSecondDay = this.weekendSecondDay,
      res = [];

    for (let i = 0; i < 7; i++) {
      res.push(this.weekendsAreWorkdays || i != weekendFirstDay && i != weekendSecondDay ? new this.modelClass({
        type: 'WEEKDAY',
        weekday: i,
        availability: availability && availability.slice() || [],
        isWorkingDay: true
      }) : new this.modelClass({
        type: 'WEEKDAY',
        weekday: i,
        availability: []
      }));
    }

    return res;
  }


  removeAll() {
    Calendar.allCalendars.forEach(calendar => {
      calendar.storeId = null;

      calendar.destroy();
    });
  }


  intersectsWithCurrentWeeks(startDate, endDate) {
    let result = false;
    this.forEachNonStandardWeek(week => {
      const weekStartDate = week.startDate,
        weekEndDate = week.endDate;

      if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
        result = true;

        return false;
      }
    });
    return result;
  }

  clearCache() {
    const me = this;
    if (me.suspendCacheUpdate > 0) return;
    me.holidaysCache = {};
    me.availabilityIntervalsCache = {};
    const daysIndex = me.daysIndex = {},
      weekAvailability = me.weekAvailability = [],
      nonStandardWeeksStartDates = me.nonStandardWeeksStartDates = [],
      nonStandardWeeksByStartDate = me.nonStandardWeeksByStartDate = {};
    me.forEach(function (calendarDay) {

      let id = calendarDay.id,
        overrideMatch = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id),
        weekDayMatch = /^WEEKDAY:(\d+)$/.exec(id),
        type = calendarDay.type,
        weekDay = calendarDay.weekday;

      if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
        let startDate, endDate;

        if (type == 'WEEKDAYOVERRIDE') {
          startDate = calendarDay.overrideStartDate;
          endDate = calendarDay.overrideEndDate;
        }

        if (overrideMatch) {
          startDate = DateHelper.parse(overrideMatch[2], 'YYYY/MM/DD');
          endDate = DateHelper.parse(overrideMatch[3], 'YYYY/MM/DD');
          weekDay = overrideMatch[1];
        }

        if (startDate && endDate && weekDay != null) {
          const startDateNum = startDate - 0;

          if (!nonStandardWeeksByStartDate[startDateNum]) {
            nonStandardWeeksByStartDate[startDateNum] = {
              startDate: new Date(startDate),
              endDate: new Date(endDate),
              name: calendarDay.getName(),
              weekAvailability: [],

              mainDay: null
            };
            nonStandardWeeksStartDates.push(startDateNum);
          }

          if (weekDay >= 0) {
            nonStandardWeeksByStartDate[startDateNum].weekAvailability[weekDay] = calendarDay;
          } else {
            nonStandardWeeksByStartDate[startDateNum].mainDay = calendarDay;
          }
        }
      } else if (type == 'WEEKDAY' || weekDayMatch) {
        if (weekDayMatch) weekDay = weekDayMatch[1];

        if (weekDay != null) {
          if (weekDay < 0 || weekDay > 6) {
            throw new Error('Incorrect week day index');
          }

          weekAvailability[weekDay] = calendarDay;
        }
      } else {
        const date = calendarDay.date;
        if (date) daysIndex[date - 0] = calendarDay;
      }
    });

    nonStandardWeeksStartDates.sort((a, b) => a - b);


    me.trigger('calendarChange');
  }


  addNonStandardWeek(startDate, endDate, weekAvailability, name) {
    startDate = DateHelper.clearTime(startDate);
    endDate = DateHelper.clearTime(endDate);

    if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
      throw new Error('Can not add intersecting week');
    }

    const DayModel = this.modelClass,
      days = [];
    weekAvailability.forEach((day, index) => {
      if (day instanceof CalendarDayModel) {
        day.type = 'WEEKDAYOVERRIDE';
        day.overrideStartDate = startDate;
        day.overrideEndDate = endDate;
        day.weekday = index;
        day.name = name || 'Week override';
        days.push(day);
      } else if (Array.isArray(day)) {
        const newDay = new DayModel();
        newDay.type = 'WEEKDAYOVERRIDE';
        newDay.overrideStartDate = startDate;
        newDay.overrideEndDate = endDate;
        newDay.weekday = index;
        newDay.name = name || 'Week override';
        newDay.setAvailability(day);
        days.push(newDay);
      }
    });
    const mainDay = new DayModel();
    mainDay.type = 'WEEKDAYOVERRIDE';
    mainDay.overrideStartDate = startDate;
    mainDay.overrideEndDate = endDate;
    mainDay.weekday = -1;
    mainDay.name = name || 'Week override';
    days.push(mainDay);
    this.add(days);
  }


  getNonStandardWeekByStartDate(startDate) {
    return this.nonStandardWeeksByStartDate[DateHelper.clearTime(startDate) - 0] || null;
  }


  removeNonStandardWeek(startDate) {
    startDate = DateHelper.clearTime(startDate) - 0;
    const week = this.getNonStandardWeekByStartDate(startDate);
    if (!week) return;
    this.remove(ArrayHelper.clean(week.weekAvailability).concat(week.mainDay));
  }


  getNonStandardWeekByDate(timeDate) {
    timeDate = DateHelper.clearTime(timeDate) - 0;
    const nonStandardWeeksStartDates = this.nonStandardWeeksStartDates,
      nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;

    for (let i = 0; i < nonStandardWeeksStartDates.length; i++) {
      const week = nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]];


      if (week.startDate > timeDate) break;

      if (week.startDate <= timeDate && timeDate <= week.endDate) {
        return week;
      }
    }

    return null;
  }


  setWeekendsAreWorkDays(value) {
    const me = this;

    if (value !== me.weekendsAreWorkdays) {
      me.weekendsAreWorkdays = value;

      me.defaultWeekAvailability = me.getDefaultWeekAvailability();
      me.clearCache();
    }
  }


  areWeekendsWorkDays() {
    return this.weekendsAreWorkdays;
  }


  forEachNonStandardWeek(func, thisObj) {
    const me = this,
      nonStandardWeeksStartDates = this.nonStandardWeeksStartDates,
      nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;

    for (let i = 0; i < nonStandardWeeksStartDates.length; i++) {
      if (func.call(thisObj || me, nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]]) === false) return false;
    }
  }


  getCalendarDay(timeDate) {
    timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
    return this.getOverrideDay(timeDate) || this.getWeekDay(timeDate.getDay(), timeDate) || this.getDefaultCalendarDay(timeDate.getDay());
  }


  getOverrideDay(timeDate) {
    return this.getOwnCalendarDay(timeDate) || this.parent && this.parent.getOverrideDay(timeDate) || null;
  }


  getOwnCalendarDay(timeDate) {
    timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
    return this.daysIndex[DateHelper.clearTime(timeDate) - 0];
  }


  getWeekDay(weekDayIndex, timeDate) {

    if (timeDate) {
      const week = this.getNonStandardWeekByDate(timeDate);
      if (week && week.weekAvailability[weekDayIndex]) return week.weekAvailability[weekDayIndex];
    }

    return this.weekAvailability[weekDayIndex] || this.parent && this.parent.getWeekDay(weekDayIndex, timeDate) || null;
  }


  isHoliday(timeDate) {
    const secondsSinceEpoch = timeDate - 0,
      holidaysCache = this.holidaysCache;

    if (holidaysCache[secondsSinceEpoch] != null) {
      return holidaysCache[secondsSinceEpoch];
    }

    timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
    const day = this.getCalendarDay(timeDate);
    if (!day) throw new Error("Can't find day for " + timeDate);
    return holidaysCache[secondsSinceEpoch] = !day.isWorkingDay;
  }


  getDefaultCalendarDay(weekDayIndex) {
    if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
      return this.parent.getDefaultCalendarDay(weekDayIndex);
    }

    return this.defaultWeekAvailability[weekDayIndex];
  }


  isWorkingDay(date) {
    return !this.isHoliday(date);
  }


  isWeekend(timeDate) {
    const dayIndex = timeDate.getDay();
    return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
  }


  convertMSDurationToUnit(durationInMs, unit) {
    return durationInMs / this.unitsInMs[DateHelper.getUnitByName(unit)];
  }


  convertDurationToMs(duration, unit) {
    return duration * this.unitsInMs[DateHelper.getUnitByName(unit)];
  }


  forEachAvailabilityInterval(options, func, thisObj) {
    thisObj = thisObj || this;
    let me = this,
      startDate = options.startDate,
      endDate = options.endDate,

      isForward = options.isForward !== false;

    if (isForward ? !startDate : !endDate) {
      throw new Error('At least `startDate` or `endDate` is required, depending from the `isForward` option');
    }

    let cursorDate = new Date(isForward ? startDate : endDate),
      DATE = DateHelper;

    if (isForward) {
      if (!endDate) {
        endDate = DATE.add(startDate, options.availabilitySearchLimit || me.availabilitySearchLimit || 5 * 365, 'day');
      }
    } else {
      if (!startDate) {
        startDate = DATE.add(endDate, -(options.availabilitySearchLimit || me.availabilitySearchLimit || 5 * 365), 'day');
      }
    }


    let noNeedToClearTime = false;

    while (isForward ? cursorDate < endDate : cursorDate > startDate) {


      let intervals = me.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1), isForward ? noNeedToClearTime : false);

      for (let i = isForward ? 0 : intervals.length - 1; isForward ? i < intervals.length : i >= 0; isForward ? i++ : i--) {
        let interval = intervals[i],
          intervalStartDate = interval.startDate,
          intervalEndDate = interval.endDate;

        if (intervalStartDate >= endDate || intervalEndDate <= startDate) continue;
        let countingFrom = intervalStartDate < startDate ? startDate : intervalStartDate,
          countingTill = intervalEndDate > endDate ? endDate : intervalEndDate;
        if (func.call(thisObj, countingFrom, countingTill) === false) return false;
      }

      cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime) : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);
      noNeedToClearTime = true;
    }
  }


  calculateDuration(startDate, endDate, unit) {
    let duration = 0;
    this.forEachAvailabilityInterval({
      startDate: startDate,
      endDate: endDate
    }, (intervalStartDate, intervalEndDate) => {
      let dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
      duration += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
    });
    return this.convertMSDurationToUnit(duration, unit);
  }


  getHolidaysRanges(startDate, endDate, includeWeekends) {
    if (startDate > endDate) {
      throw new Error("startDate can't be bigger than endDate");
    }

    startDate = DateHelper.clearTime(startDate);
    endDate = DateHelper.clearTime(endDate);
    let ranges = [],
      currentRange,
      date;

    for (date = startDate; date < endDate; date = DateHelper.getNext(date, 'day', 1)) {
      if (this.isHoliday(date) || this.weekendsAreWorkdays && includeWeekends && this.isWeekend(date)) {
        const day = this.getCalendarDay(date),
          cssClass = day && day.cls || this.defaultNonWorkingTimeCssCls,
          nextDate = DateHelper.getNext(date, 'day', 1);

        if (!currentRange) {
          currentRange = new TimeSpan({
            startDate: date,
            endDate: nextDate,
            cls: cssClass
          });
        } else {

          if (currentRange.cls.isEqual(cssClass)) {
            currentRange.endDate = nextDate;
          } else {
            ranges.push(currentRange);
            currentRange = new TimeSpan({
              startDate: date,
              endDate: nextDate,
              cls: cssClass
            });
          }
        }
      } else {
        if (currentRange) {
          ranges.push(currentRange);
          currentRange = null;
        }
      }
    }

    if (currentRange) {
      ranges.push(currentRange);
    }

    return ranges;
  }


  calculateEndDate(startDate, duration, unit) {

    if (!duration) {
      return new Date(startDate);
    }

    let DATE = DateHelper,
      endDate;
    duration = this.convertDurationToMs(duration, unit);
    let startFrom =

      duration === 0 && DATE.clearTime(startDate, true) - startDate === 0 ? DATE.add(startDate, -1, 'day') : startDate;
    this.forEachAvailabilityInterval({
      startDate: startFrom
    }, function (intervalStartDate, intervalEndDate) {
      let diff = intervalEndDate - intervalStartDate,
        dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

      if (diff >= duration) {
        endDate = new Date(intervalStartDate - 0 + duration);
        return false;
      } else {
        duration -= diff + dstDiff * 60 * 1000;
      }
    });
    return endDate;
  }


  skipNonWorkingTime(date, isForward) {
    let found = false;

    this.forEachAvailabilityInterval(isForward ? {
      startDate: date
    } : {
      endDate: date,
      isForward: false
    }, (intervalStartDate, intervalEndDate) => {
      date = isForward ? intervalStartDate : intervalEndDate;
      found = true;
      return false;
    });
    if (!found) throw new Error('skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified');
    return new Date(date);
  }


  calculateStartDate(endDate, duration, unit) {

    if (!duration) {
      return new Date(endDate);
    }

    let startDate;
    duration = this.convertDurationToMs(duration, unit);
    this.forEachAvailabilityInterval({
      endDate: endDate,
      isForward: false
    }, (intervalStartDate, intervalEndDate) => {
      const diff = intervalEndDate - intervalStartDate;

      if (diff >= duration) {
        startDate = new Date(intervalEndDate - duration);
        return false;
      } else {
        duration -= diff;
      }
    });
    return startDate;
  }


  skipWorkingTime(date, duration, unit) {
    return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
  }

  isChildOf(calendar) {
    let parent = this,
      found = false;

    while (parent && !found) {
      found = parent === calendar;
      parent = parent.parent;
    }

    return found;
  }

  getParentableCalendars() {
    const me = this,
      calendars = Calendar.getAllCalendars();
    return calendars.reduce((result, calendar) => {
      if (calendar !== me && !calendar.isChildOf(me)) {
        result.push({
          id: calendar.calendarId,
          name: calendar.name || calendar.calendarId
        });
      }

      return result;
    }, []);
  }

  get parent() {
    return this._parent;
  }


  getAvailabilityIntervalsFor(timeDate, noNeedToClearTime) {
    if (noNeedToClearTime) {
      timeDate = timeDate.valueOf();
    } else if (timeDate instanceof Date) {
      timeDate = new Date(timeDate.getFullYear(), timeDate.getMonth(), timeDate.getDate()).valueOf();
    } else {
      timeDate = DateHelper.clearTime(new Date(timeDate)).valueOf();
    }

    return this.availabilityIntervalsCache[timeDate] = this.availabilityIntervalsCache[timeDate] || this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate);
  }

  onParentDestroy() {
    this.parent = null;
  }

  isAvailabilityIntersected(withCalendar, startDate, endDate) {
    let ownWeekDay, ownAvailability, testWeekDay, testAvailability;


    for (let i = 0; i < 7; i++) {
      ownWeekDay = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
      testWeekDay = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);
      if (!ownWeekDay || !testWeekDay) continue;

      ownAvailability = ownWeekDay.getAvailability();
      testAvailability = testWeekDay.getAvailability();

      for (let j = 0, l = ownAvailability.length; j < l; j++) {
        for (let k = 0, ll = testAvailability.length; k < ll; k++) {
          if (testAvailability[k].startTime < ownAvailability[j].endTime && testAvailability[k].endTime > ownAvailability[j].startTime) {
            return true;
          }
        }
      }
    }

    let result = false;
    this.forEachNonStandardWeek(week => {
      if (week.startDate >= endDate) return false;

      if (startDate < week.endDate) {
        result = true;

        return false;
      }
    });
    return result;
  }

}

Calendar._$name = 'Calendar';


var JsonEncoder = (Target => class JsonEncoder extends (Target || Base) {


  encode(requestConfig) {
    return StringHelper.safeJsonStringify(requestConfig);
  }


  decode(responseText) {
    return StringHelper.safeJsonParse(responseText);
  }

});


var ResourceStoreMixin = (Target => class ResourceStoreMixin extends (Target || Base) {

  get eventStore() {
    return this._eventStore;
  }

  set eventStore(eventStore) {
    const me = this;

    if (me._eventStore !== eventStore) {
      const oldStore = me._eventStore;
      me._eventStore = eventStore || null;

      if (eventStore && !eventStore.resourceStore) {
        eventStore.resourceStore = me;
      }


      me.trigger('eventStoreChange', {
        newEventStore: eventStore,
        oldEventStore: oldStore
      });
    }
  }

  getScheduledEventsInTimeSpan(start, end, eventStore = this.eventStore) {

    return this.reduce((events, resource) => {
      events.concat(eventStore.getEventsForResource(resource).reduce((events, event) => {
        if (event.intersectsRange(start, end)) events.push(event);
      }));
    });
  }

});


class ResourceModel extends GridRowModel {

  static get fields() {
    return [


      {
        name: 'name',
        type: 'string',
        persist: true
      },

      'eventColor',

      'eventStyle',

      'imageUrl',

      'image'];
  }


  get resourceStore() {
    return this.stores && this.stores[0];
  }


  get eventStore() {
    const resourceStore = this.resourceStore;

    return resourceStore && resourceStore.eventStore || this.parentNode && this.parentNode.eventStore;
  }


  get assignmentStore() {
    const eventStore = this.eventStore;
    return eventStore && eventStore.assignmentStore;
  }


  get events() {


    return this.eventStore && this.eventStore.getEventsForResource(this);
  }


  getEvents(eventStore = this.eventStore) {
    return eventStore && eventStore.getEventsForResource(this) || [];
  }


  get isPersistable() {
    const parent = this.parentNode;

    return !parent || !parent.phantom || parent.isRoot && parent.isRoot();
  }


  isAbove(otherResource) {
    let me = this,
      store = me.resourceStore,
      current,
      myAncestors,
      otherAncestors,
      commonAncestorsLength,
      lastCommonAncestor;
    if (me === otherResource) return false;

    if (store.tree) {


      current = me;
      myAncestors = [];

      while (current) {
        myAncestors.push(current);
        current = current.parentNode;
      }

      current = otherResource;
      otherAncestors = [];

      while (current) {
        otherAncestors.push(current);
        current = current.parentNode;
      }

      commonAncestorsLength = 0;

      while (commonAncestorsLength < myAncestors.length - 1 && commonAncestorsLength < otherAncestors.length - 1 && myAncestors[commonAncestorsLength] == otherAncestors[commonAncestorsLength]) {
        ++commonAncestorsLength;
      }

      lastCommonAncestor = myAncestors[commonAncestorsLength];


      me = myAncestors[commonAncestorsLength + 1];
      otherResource = otherAncestors[commonAncestorsLength + 1];
      return lastCommonAncestor.indexOf(me) < lastCommonAncestor.indexOf(otherResource);
    }

    return store.indexOf(me) < store.indexOf(otherResource);
  }


  unassignAll(removingResource) {
    this.events && this.events.slice().forEach(event => event.unassign(this, removingResource));
  }

}

ResourceModel.exposeProperties();
ResourceModel._$name = 'ResourceModel';


class ResourceStore extends ResourceStoreMixin(AjaxStore) {
  static get defaultConfig() {
    return {

      loadPriority: 200,


      syncPriority: 100,
      modelClass: ResourceModel,
      storeId: 'resources',
      autoTree: true
    };
  }

  construct(config) {
    super.construct(config);

    if (this.modelClass !== ResourceModel && !(this.modelClass.prototype instanceof ResourceModel)) {
      throw new Error('Model for ResourceStore must subclass ResourceModel');
    }
  }

  remove(recordsOrIds) {
    recordsOrIds = Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds];

    for (let r of recordsOrIds) {
      const record = this.getById(r);

      record.unassignAll(true);
    }

    super.remove(recordsOrIds);
  }

  removeAll() {
    this.traverse(resourceRecord => resourceRecord.unassignAll(true));
    super.removeAll();
  }

}

ResourceStore._$name = 'ResourceStore';


const canonicalDependencyTypes = ['SS', 'SF', 'FS', 'FF'];


class DependencyBaseModel extends Model {


  static get Type() {
    return {
      StartToStart: 0,
      StartToEnd: 1,
      EndToStart: 2,
      EndToEnd: 3
    };
  }

  static get fields() {
    return [


      {
        name: 'from'
      },

      {
        name: 'to'
      },

      {
        name: 'type',
        type: 'int',
        defaultValue: 2
      },

      {
        name: 'cls',
        defaultValue: ''
      },

      {
        name: 'bidirectional',
        type: 'boolean'
      },

      {
        name: 'fromSide',
        type: 'string'
      },

      {
        name: 'toSide',
        type: 'string'
      },

      {
        name: 'lag',
        type: 'number',
        allowNull: true,
        defaultValue: 0
      },

      {
        name: 'lagUnit',
        type: 'string',
        defaultValue: 'd'
      }
    ];
  }

  static get relationConfig() {
    return [{
      relationName: 'sourceEvent',
      fieldName: 'from',
      store: 'eventStore',
      collectionName: 'successors'
    }, {
      relationName: 'targetEvent',
      fieldName: 'to',
      store: 'eventStore',
      collectionName: 'predecessors'
    }];
  }


  construct(data) {
    super.construct(...arguments);

    if (data) {

      if (data.from && data.from instanceof TimeSpan) {
        this.sourceEvent = data.from;
        delete data.from;
      }

      if (data.to && data.to instanceof TimeSpan) {
        this.targetEvent = data.to;
        delete data.to;
      }
    }
  }

  get eventStore() {
    const {
      stores,
      unjoinedStores
    } = this;
    return stores[0] && stores[0].eventStore || unjoinedStores[0] && unjoinedStores[0].eventStore;
  }


  get hardType() {
    return this.getHardType();
  }

  set hardType(type) {
    this.setHardType(type);
  }


  getHardType() {
    return this.get('type');
  }


  setHardType(type) {
    let result;

    if (type !== this.getHardType()) {
      result = this.set({
        type,
        fromSide: null,
        toSide: null
      });
    }

    return result;
  }

  get lag() {
    return this.get('lag');
  }

  set lag(lag) {
    if (typeof lag === 'number') {
      this.set({
        lag
      });
    } else {
      this.setLag(lag);
    }
  }


  setLag(lag, lagUnit) {


    if (arguments.length === 1) {
      if (typeof lag === 'number') {
        this.lag = lag;
      } else {
        lag = DateHelper.parseDuration(lag);
        this.set({
          lag: lag.magnitude,
          lagUnit: lag.unit
        });
      }

      return;
    }

    lag = parseFloat(lag);
    this.set({
      lag,
      lagUnit
    });
  }

  getLag() {
    if (this.lag) {
      return `${this.lag < 0 ? '-' : '+'}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;
    }

    return '';
  }


  get fullLag() {
    return {
      unit: this.lagUnit,
      magnitude: this.lag
    };
  }

  set fullLag(lag) {
    if (typeof lag === 'string') {
      this.setLag(lag);
    } else {
      this.setLag(lag.magnitude, lag.unit);
    }
  }


  set sourceEvent(event) {
    this.from = event.id;
  }


  set targetEvent(event) {
    this.to = event.id;
  }


  get isPersistable() {
    const me = this,
      {
        stores,
        unjoinedStores
      } = me;
    let store = stores[0],
      result;

    if (store) {
      const source = me.getSourceEvent(),
        target = me.getTargetEvent(),
        crudManager = store.crudManager;


      result = source && (crudManager || !source.hasGeneratedId) && target && (crudManager || !target.hasGeneratedId);
    } else {
      result = Boolean(unjoinedStores[0]);
    }

    return result;
  }


  getSourceEvent(eventStore = this.eventStore) {
    if (!eventStore && this.unjoinedStores.length) {
      eventStore = this.leftProjectEventStore;
    }

    return eventStore && eventStore.getById(this.from);
  }


  getTargetEvent(eventStore = this.eventStore) {
    if (!eventStore && this.unjoinedStores.length) {
      eventStore = this.leftProjectEventStore;
    }

    return eventStore && eventStore.getById(this.to);
  }

  getDateRange(doNotNormalize = false) {
    const sourceTask = this.sourceEvent,
      targetTask = this.targetEvent;

    if (sourceTask && targetTask && sourceTask.isScheduled && targetTask.isScheduled) {
      let Type = DependencyBaseModel.Type,
        sourceDate,
        targetDate;

      switch (this.type) {
        case Type.StartToStart:
          sourceDate = sourceTask.startDate;
          targetDate = targetTask.startDate;
          break;

        case Type.StartToEnd:
          sourceDate = sourceTask.startDate;
          targetDate = targetTask.endDate;
          break;

        case Type.EndToEnd:
          sourceDate = sourceTask.endDate;
          targetDate = targetTask.endDate;
          break;

        case Type.EndToStart:
          sourceDate = sourceTask.endDate;
          targetDate = targetTask.startDate;
          break;
      }

      return {
        start: doNotNormalize ? sourceDate : DateHelper.min(sourceDate, targetDate),
        end: doNotNormalize ? targetDate : DateHelper.max(sourceDate, targetDate)
      };
    }

    return null;
  }


  highlight(cls) {
    const me = this,
      h = me.highlighted ? me.highlighted.split(' ') : [];
    if (!h.includes(cls)) me.highlighted = h.concat(cls).join(' ');
  }


  unhighlight(cls) {
    const me = this,
      highlighted = me.highlighted;

    if (highlighted) {
      const h = highlighted.split(' '),
        idx = h.findIndex(i => i === cls);

      if (idx >= 0) {
        h.splice(idx, 1);
        me.highlighted = h.join(' ');
      }
    }
  }


  isHighlightedWith(cls) {
    const me = this,
      highlighted = me.highlighted;
    return highlighted && highlighted.split(' ').includes(cls);
  }

  getConnectorString(raw) {
    const rawValue = canonicalDependencyTypes[this.type];

    if (raw) {
      return rawValue;
    }

    if (this.type === DependencyBaseModel.Type.EndToStart) {
      return '';
    }

    const locale = LocaleManagerSingelton.locale;

    if (locale) {
      const localized = locale.Scheduler && locale.Scheduler[rawValue];

      if (localized) {
        return localized;
      }
    }

    return rawValue;
  }

  toString() {
    return `${this.from}${this.getConnectorString()}${this.getLag()}`;
  }


  isValid(taskStore) {
    const {
      from,
      to,
      type
    } = this;
    return typeof type === 'number' && from && from !== '' && to != null && to !== '' && from !== to;
  }

}

DependencyBaseModel.exposeProperties();
DependencyBaseModel._$name = 'DependencyBaseModel';


class DependencyModel extends DependencyBaseModel {


  getTypeFromSides(fromSide, toSide, rtl) {
    const types = DependencyBaseModel.Type,
      startSide = rtl ? 'right' : 'left',
      endSide = rtl ? 'left' : 'right';

    if (fromSide === startSide) {
      return toSide === startSide ? types.StartToStart : types.StartToEnd;
    }

    return toSide === endSide ? types.EndToEnd : types.EndToStart;
  }

}

DependencyModel.exposeProperties();
DependencyModel._$name = 'DependencyModel';


class DependencyStore extends AjaxStore {
  static get defaultConfig() {
    return {

      loadPriority: 400,


      syncPriority: 400,
      modelClass: DependencyModel,
      storeId: 'dependencies'
    };
  }

  doDestroy() {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    super.doDestroy();
  }


  get eventStore() {
    return this._eventStore;
  }

  set eventStore(eventStore) {
    const me = this,
      oldStore = me._eventStore;
    me._eventStore = eventStore;

    if (eventStore) {
      me.attachToEventStore(eventStore);

      if (!me.isConfiguring) {
        me.initRelations(true);
      }
    }

    if ((oldStore || eventStore) && oldStore !== eventStore) {

      me.trigger('eventStoreChange', {
        newEventStore: eventStore,
        oldEventStore: oldStore
      });
    }
  }

  attachToEventStore(eventStore) {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me.eventStoreDetacher = eventStore.on({
      'remove': me.onEventRemove,
      thisObj: me,
      detachable: true
    });
  }

  onEventRemove({
                  records,
                  isMove = false,
                  isCollapse = false
                }) {
    if (!isMove && !isCollapse) {
      records.forEach(record => {

        record.traverse(eventRecord => this.removeEventDependencies(eventRecord, false));
      });
    }
  }

  reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {


    depsGetterFn = depsGetterFn || (event => {
      return this.getEventDependencies(event);


    });

    event = Array.isArray(event) ? event : [event];
    event.reduce((result, event) => {
      if (event.children && !flat) {
        event.traverse(evt => {
          result = depsGetterFn(evt).reduce(reduceFn, result);
        });
      } else {
        result = depsGetterFn(event).reduce(reduceFn, result);
      }
    }, result);
    return result;
  }

  reduceEventPredecessors(event, reduceFn, result, flat) {
    const me = this;
    return me.reduceEventDependencies(event, reduceFn, result, flat, evt => {


    });
  }

  reduceEventSuccessors(event, reduceFn, result, flat) {
    const me = this;
    return me.reduceEventDependencies(event, reduceFn, result, flat, evt => {


    });
  }

  mapEventDependencies(event, fn, filterFn, flat, depsGetterFn) {
    return this.reduceEventDependencies(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat, depsGetterFn);
  }

  mapEventPredecessors(event, fn, filterFn, flat) {
    return this.reduceEventPredecessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }

  mapEventSuccessors(event, fn, filterFn, flat) {
    return this.reduceEventSuccessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }


  getEventDependencies(event, flat = false) {
    return [].concat(event.predecessors || [], event.successors || []);
  }


  getEventPredecessors(event, flat = false) {

    return event.predecessors;
  }


  getEventSuccessors(event, flat = false) {

    return event.successors;
  }

  getUnique(array) {
    return [...new Set(array)];
  }

  removeEventDependencies(event, flat) {
    const me = this,
      dependencies = me.getEventDependencies(event, flat);
    dependencies.length && me.remove(me.getUnique(dependencies));
  }

  removeEventPredecessors(event, flat) {
    const me = this,
      dependencies = me.getEventPredecessors(event, flat);
    dependencies.length && me.remove(me.getUnique(dependencies));
  }

  removeEventSuccessors(event, flat) {
    const me = this,
      dependencies = me.getEventSuccessors(event, flat);
    dependencies.length && me.remove(me.getUnique(dependencies));
  }

  getBySourceTargetId(key) {

    return this.records.find(r => key == DependencyStore.makeDependencySourceTargetCompositeKey(r.from, r.to));
  }


  getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {

    const me = this;
    sourceEvent = Model.asId(sourceEvent);
    targetEvent = Model.asId(targetEvent);
    return me.getBySourceTargetId(DependencyStore.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
  }


  getEventsLinkingDependency(sourceEvent, targetEvent) {
    const me = this;
    return me.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) || me.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);
  }


  isValidDependency(dependencyOrFromId, toId, type) {
    if (arguments.length === 1) {
      type = dependencyOrFromId.type;
      toId = dependencyOrFromId.to;
      dependencyOrFromId = dependencyOrFromId.from;
    }

    return dependencyOrFromId != null && toId != null && dependencyOrFromId !== toId;
  }


  isValidDependencyToCreate(fromId, toId, type) {
    return this.isValidDependency(fromId, toId, type);
  }


  getHighlightedDependencies(cls) {
    return this.records.reduce((result, dep) => {
      if (dep.isHighlightedWith(cls)) result.push(dep);
      return result;
    }, []);
  }

  static makeDependencySourceTargetCompositeKey(from, to) {
    return `source(${from})-target(${to})`;
  }

  getTimeSpanDependencies(record) {
    return this.getEventDependencies(record);
  }

}

DependencyStore._$name = 'DependencyStore';


class CrudManager extends JsonEncoder(AjaxTransport(AbstractCrudManager)) {

  static get defaultConfig() {
    return {
      resourceStoreClass: ResourceStore,
      eventStoreClass: EventStore,
      assignmentStoreClass: AssignmentStore,
      dependencyStoreClass: DependencyStore,


      resourceStore: {},


      eventStore: {},


      assignmentStore: null,


      dependencyStore: null,


      addRelatedStores: true
    };
  }

  construct(config = {}) {
    if (config.scheduler) {
      this.scheduler = config.scheduler;


      this.scheduler._crudManager = this;
    }

    super.construct(config);
  }

  afterConstruct() {
    const me = this,
      scheduler = me.scheduler;

    if (scheduler) {


      if (scheduler.isVertical || scheduler.isHorizontal && !scheduler.store) {
        scheduler.resourceStore = me.resourceStore;
        scheduler.eventStore = me.eventStore;
      }


      const {
        dependencies,
        timeRanges,
        resourceTimeRanges
      } = scheduler.features;

      if (dependencies) {
        me.dependencyStore = dependencies.dependencyStore;
      }

      if (timeRanges) {
        me.addCrudStore(timeRanges.store);
        me._timeRangesStore = timeRanges.store;
      }

      if (resourceTimeRanges) {
        me.addCrudStore(resourceTimeRanges.store);
        me._resourceTimeRangesStore = resourceTimeRanges.store;
      }
    }

    super.afterConstruct();
  }


  get timeRangesStore() {
    return this._timeRangesStore;
  }


  addFeaturedStore(store) {
    this.addPrioritizedStore(store);
  }

  static getEventStoreInfo(eventStore, config) {
    if (!(eventStore instanceof EventStore)) {
      if (typeof eventStore === 'string') {
        eventStore = Store.getStore(eventStore);
      } else {
        eventStore = eventStore.store;
      }
    }

    let result = {},
      assignmentStore = config.assignmentStore,
      resourceStore = config.resourceStore,
      dependencyStore = config.dependencyStore;
    !assignmentStore && (result.assignmentStore = eventStore.assignmentStore);
    !resourceStore && (result.resourceStore = eventStore.resourceStore);
    !dependencyStore && (result.dependencyStore = eventStore.dependencyStore);
    return result;
  }


  get resourceStore() {
    return this._resourceStore && this._resourceStore.store;
  }

  set resourceStore(store) {
    const me = this;
    me.setFeaturedStore('_resourceStore', store, me.resourceStoreClass);
    me.eventStore.resourceStore = me._resourceStore && me._resourceStore.store;
  }


  get eventStore() {
    return this._eventStore && this._eventStore.store;
  }

  set eventStore(store) {
    const me = this;
    me.setFeaturedStore('_eventStore', store, me.eventStoreClass);
    store = me._eventStore && me._eventStore.store;

    if (me.isConfiguring && store && me.addRelatedStores !== false) {
      let extracted = CrudManager.getEventStoreInfo(store, me.initialConfig),
        assignmentStore = extracted.assignmentStore,
        resourceStore = extracted.resourceStore,
        dependencyStore = extracted.dependencyStore;

      if (assignmentStore) {
        me.assignmentStore = assignmentStore;
      }

      if (resourceStore) {
        me.resourceStore = resourceStore;
      }

      if (dependencyStore) {
        me.dependencyStore = dependencyStore;
      }
    }
  }


  get assignmentStore() {
    return this._assignmentStore && this._assignmentStore.store;
  }

  set assignmentStore(store) {
    this.setFeaturedStore('_assignmentStore', store, this.assignmentStoreClass);
  }


  get dependencyStore() {
    return this._dependencyStore && this._dependencyStore.store;
  }

  set dependencyStore(store) {
    this.setFeaturedStore('_dependencyStore', store, this.dependencyStoreClass);
  }

  setFeaturedStore(property, store, storeClass) {
    const me = this,
      oldStore = me[property];
    store = Store.getStore(store, store && store.storeClass || storeClass);

    if (oldStore) {
      me.removeStore(oldStore);
    }

    me[property] = store && {
      store
    } || null;
    me.addFeaturedStore(me[property]);
    return me[property];
  }

}

CrudManager._$name = 'CrudManager';


class ColumnLines extends InstancePlugin {

  static get $name() {
    return 'ColumnLines';
  }

  static get properties() {
    return {
      tickColor: '#e6e6e6',
      majorTickColor: '#999',
      tickStyle: 'solid',
      majorTickStyle: 'solid'
    };
  }

  static get pluginConfig() {
    return {
      after: ['render', 'updateCanvasSize']
    };
  }


  construct(client, config) {
    const me = this;
    client.useBackgroundCanvas = true;
    super.construct(client, config);
    me.timeAxisViewModel = client.timeAxisViewModel;
    client.on({
      theme: 'onThemeChange',
      thisObj: me
    });
  }

  doDestroy() {
    this.timeAxisViewModelDetatcher && this.timeAxisViewModelDetatcher();
    super.doDestroy();
  }

  doDisable(disable) {
    if (!this.isConfiguring) {
      if (disable) {
        DomHelper.removeEachSelector(this.client.backgroundCanvas, '.b-column-line-major');
        this.client.backgroundCanvas.style.backgroundImage = 'none';
      } else {
        this.drawLines();
      }
    }

    super.doDisable(disable);
  }


  getColorsFromCSS() {
    const me = this;

    if (!me.GotColors) {
      const element = DomHelper.createElement({
          style: 'position: absolute; visibility: hidden',
          html: '<div class="b-column-line"></div><div class="b-column-line-major"></div>',
          parent: document.body
        }),
        tickColor = DomHelper.getStyleValue(element.firstElementChild, 'border-left-color'),
        majorColor = DomHelper.getStyleValue(element.lastElementChild, 'border-left-color'),
        tickStyle = DomHelper.getStyleValue(element.firstElementChild, 'border-left-style'),
        majorTickStyle = DomHelper.getStyleValue(element.lastElementChild, 'border-left-style');

      if (tickColor) {
        me.tickColor = tickColor;
      }

      if (majorColor) {
        me.majorTickColor = majorColor;
      }

      if (tickStyle) {
        me.tickStyle = tickStyle;
      }

      if (majorTickStyle) {
        me.majorTickStyle = majorTickStyle;
      }

      element.remove();
      me.GotColors = true;
    }
  }

  onThemeChange() {
    this.GotColors = false;
    this.render();
  }


  render() {
    this.getColorsFromCSS();
    this.drawLines();
  }


  drawLines() {

    if (!this.client.timeAxis.startDate) {
      return;
    }


    const me = this,
      {
        client
      } = me,
      {
        timeAxis
      } = client,
      axisStart = timeAxis.startDate,
      viewModel = client.timeAxisViewModel,
      tickSize = viewModel.tickSize,
      element = client.backgroundCanvas,
      canvas = document.createElement('canvas'),
      ctx = canvas.getContext('2d'),
      linesForLevel = viewModel.columnLinesFor,

      targetHeader = viewModel.headers[linesForLevel],
      headers = viewModel.headers,

      upperHeader = headers[headers.indexOf(targetHeader) - 1] || headers[0],

      lowerHeader = headers[headers.length - 1],

      startDate = timeAxis.floorDate(axisStart, false, upperHeader.unit, upperHeader.unit === 'year' ? 1 : upperHeader.increment || 1),
      endDate = DateHelper.getNext(startDate, upperHeader.unit, upperHeader.increment || 1, timeAxis.weekStartDay),

      ticksInHeader = Math.round(DateHelper.getDurationInUnit(startDate, endDate, lowerHeader.unit)) / (lowerHeader.increment || 1),
      nbrLinesToDraw = Math.round(DateHelper.getDurationInUnit(startDate, endDate, targetHeader.unit)) / (targetHeader.increment || 1),

      ratio = ticksInHeader / nbrLinesToDraw;

    if (client.isHorizontal) {
      if (axisStart) {
        const doUnitsAlign = headers.length > 1 && DateHelper.doesUnitsAlign(upperHeader.unit, targetHeader.unit),
          offsetDate = doUnitsAlign ? startDate : timeAxis.floorDate(axisStart, false, targetHeader.unit, targetHeader.increment),

          offset = !timeAxis.isContinuous ? 0 : DateHelper.getDurationInUnit(offsetDate, axisStart, lowerHeader.unit, true) / timeAxis.increment * tickSize,

          startPos = 10,
          height = 20;
        DomHelper.removeEachSelector(element, '.b-column-line-major');
        let isMajor = false,
          majorHeaderIsRegular = true;

        if (targetHeader !== upperHeader && doUnitsAlign && lowerHeader.unit === 'day' && DateHelper.compareUnits(upperHeader.unit, 'month') !== -1) {


          majorHeaderIsRegular = false;
          timeAxis.forEachAuxInterval(upperHeader.unit, upperHeader.increment, (start, end) => {
            DomHelper.append(element, {
              tag: 'div',
              className: 'b-column-line-major',
              style: `left:${viewModel.getPositionFromDate(end) - 1}px;`
            });
          });
        }

        canvas.width = Math.min(ticksInHeader * 2 * tickSize, 32767);
        canvas.height = height;
        ctx.translate(-0.5, -0.5);
        ctx.lineWidth = 2;

        for (let i = 0; i < nbrLinesToDraw; i++) {

          if (i === 0) {

            isMajor = upperHeader !== targetHeader && doUnitsAlign && majorHeaderIsRegular && timeAxis.isContinuous;
          } else {
            isMajor = false;
          }

          const tickStyle = isMajor && me.majorTickStyle || !isMajor && me.tickStyle;

          if (tickStyle !== 'solid') {
            switch (tickStyle) {
              case 'dashed':
                ctx.setLineDash([6, 4]);
                break;

              case 'dotted':
                ctx.setLineDash([2, 3]);
                break;
            }
          }

          ctx.beginPath();
          ctx.strokeStyle = isMajor ? me.majorTickColor : me.tickColor;

          ctx.moveTo(i * ratio * tickSize * 2 + startPos - 1, 0);
          ctx.lineTo(i * ratio * tickSize * 2 + startPos - 1, height + 2);
          ctx.stroke();
        }

        element.style.backgroundImage = `url(${canvas.toDataURL()})`;
        element.style.backgroundSize = `${canvas.width / 2}px`;
        element.style.backgroundPositionX = `${-(startPos / 2 + offset)}px`;
      }
    } else {

      canvas.width = client.timeAxisColumn.resourceColumns.columnWidth * 2;
      canvas.height = 2;
      ctx.translate(-0.5, -0.5);
      ctx.lineWidth = 2;

      if (axisStart) {
        DomHelper.removeEachSelector(element, '.b-column-line-major');

        if (targetHeader !== upperHeader) {
          timeAxis.forEachAuxInterval(upperHeader.unit, upperHeader.increment, (start, end) => {
            DomHelper.append(element, {
              tag: 'div',
              className: 'b-column-line-major',
              style: `top:${viewModel.getPositionFromDate(end) - 1}px;`
            });
          });
        }

        if (me.tickStyle !== 'solid') {
          switch (me.tickStyle) {
            case 'dashed':
              ctx.setLineDash([6, 4]);
              break;

            case 'dotted':
              ctx.setLineDash([2, 3]);
              break;
          }
        }

        const height = ratio * tickSize * 2;
        canvas.height = height;
        ctx.beginPath();
        ctx.strokeStyle = me.tickColor;
        ctx.lineWidth = 2;

        ctx.moveTo(0, height - 1);
        ctx.lineTo(canvas.width + 2, height - 1);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.strokeStyle = me.tickColor;

      ctx.moveTo(canvas.width - 1, 0);
      ctx.lineTo(canvas.width - 1, canvas.height + 2);
      ctx.stroke();

      element.style.backgroundImage = `url(${canvas.toDataURL()})`;
      element.style.backgroundSize = `${canvas.width / 2}px`;
      element.style.backgroundPositionX = '0';
    }
  }


  updateCanvasSize() {
    if (!this.disabled) {
      this.drawLines();
    }
  }

}

ColumnLines._$name = 'ColumnLines';
GridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt']);


const applyNamedItems = function (items, namedItems) {
  for (const ref in items) {
    let item = items[ref];

    if (item) {
      if (ref in namedItems) {
        item = items[ref] = typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
      }


      const menu = item.menu;

      if (menu) {
        applyNamedItems('items' in menu ? menu.items : menu, namedItems);
      }
    }
  }
};


class TimeSpanRecordContextMenuBase extends InstancePlugin {

  static get defaultConfig() {
    return {

      defaultItems: null,


      items: null,


      processItems: null,


      triggerEvent: null
    };
  }

  static get pluginConfig() {
    return {
      assign: ['showEventContextMenu'],
      chain: ['onElementContextMenu', 'onElementClick', 'onElementDblClick', 'onEventSpaceKey']
    };
  }


  doDestroy() {
    if (this.menu) {
      this.menu.destroy();
    }
  }


  onElementContextMenu(event) {
    this.triggerEvent === 'contextmenu' && this.showEventContextMenu(event);
  }

  onElementClick(event) {
    this.triggerEvent === 'click' && this.showEventContextMenu(event);
  }

  onElementDblClick(event) {
    this.triggerEvent === 'dblclick' && this.showEventContextMenu(event);
  }

  onEventSpaceKey(keyEvent) {
    const targetPoint = Rectangle.from(keyEvent.target).center,
      contextmenuEvent = new MouseEvent('contextmenu', Object.assign({
        clientX: targetPoint.x,
        clientY: targetPoint.y
      }, keyEvent));
    Object.defineProperty(contextmenuEvent, 'target', {
      get() {
        return keyEvent.target;
      }

    });
    this.showEventContextMenu(contextmenuEvent);
  }


  showEventContextMenu(event) {
    const me = this,
      client = me.client,
      target = event.target,
      eventElement = DomHelper.up(target, client.eventSelector) || target;

    if (eventElement) {
      const record = me.resolveRecord(eventElement);

      if (record) {
        event.preventDefault();
        me.showContextMenuFor(record, {
          targetElement: eventElement,
          event
        });
      }
    }
  }


  showContextMenuFor(record, options) {
  }

  beforeContextMenuShow() {
  }


  showContextMenu(eventParams) {
    if (this.disabled) {
      return;
    }

    const me = this,
      event = eventParams.event,
      menuType = eventParams.menuType.toLowerCase(),
      eventType = StringHelper.lowercaseFirstLetter(menuType),
      clientGetItemsMethod = `get${StringHelper.capitalizeFirstLetter(menuType)}MenuItems`,
      {
        client,
        processItems,
        defaultItems,
        namedItems
      } = me,
      point = event ? [event.clientX + 1, event.clientY + 1] : Rectangle.from(eventParams.targetElement).center;
    let items = eventParams.items = ObjectHelper.isEmpty(me.items) ? ObjectHelper.clone(defaultItems) : ObjectHelper.merge(ObjectHelper.clone(defaultItems), me.items);
    eventParams.namedItems = namedItems;
    eventParams.selection = client.selectedRecords;
    const column = client.getColumnFromElement(eventParams.targetElement),
      cellItems = [];

    if (column) {
      client.getCellMenuItems(column, eventParams.taskRecord, cellItems);
      const namedCellItems = cellItems.reduce((result, item) => {
        result[item.name] = item;
        return result;
      }, {});
      items = eventParams.items = ObjectHelper.copyPropertiesIf(items, namedCellItems, Object.keys(namedCellItems));
    }


    applyNamedItems(items, namedItems);


    if (client[clientGetItemsMethod]) {
      client[clientGetItemsMethod](eventParams, items);
    }

    if ((!processItems || processItems(eventParams) !== false) && !ObjectHelper.isEmpty(eventParams.items)) {


      if (me.beforeContextMenuShow(eventParams) !== false) {

        if (client.trigger(`${eventType}ContextMenuBeforeShow`, eventParams) !== false) {
          me.menu = WidgetHelper.showContextMenu(point, {
            owner: client,
            scrollAction: 'hide',
            clippedBy: [client.timeAxisSubGridElement, client.bodyContainer],
            constrainTo: window,
            items,

            onDestroy() {
              me.menu = null;
            },


            onBeforeItem: itemEvent => {
              Object.assign(itemEvent, eventParams);
            },
            onItem: itemEvent => client.trigger(`${eventType}ContextMenuItem`, itemEvent),
            listeners: {
              show({
                     source: menu
                   }) {
                eventParams.menu = menu;
                client.trigger(`${eventType}ContextMenuShow`, eventParams);
              }

            }
          });
        }
      }
    }
  }


  hideContextMenu(animate) {
    this.menu && this.menu.hide(animate);
  }


  set defaultItems(defaultItems) {
    this._defaultItems = defaultItems;
  }

  get defaultItems() {
    const result = ObjectHelper.clone(this._defaultItems);

    if (this.client.readOnly) {
      for (const item in result) {
        result[item] = false;
      }
    }

    return result;
  }

  get triggerEvent() {
    return this._triggerEvent || this.client.contextMenuTriggerEvent;
  }

  set triggerEvent(value) {
    this._triggerEvent = value;
  }

}

TimeSpanRecordContextMenuBase._$name = 'TimeSpanRecordContextMenuBase';


class EventContextMenu extends TimeSpanRecordContextMenuBase {

  static get $name() {
    return 'EventContextMenu';
  }

  static get defaultConfig() {
    return {

      items: null,


      processItems: null,


      defaultItems: {
        deleteEvent: true,
        unassignEvent: true
      }
    };
  }


  resolveRecord(element) {
    return this.client.resolveEventRecord(element);
  }


  showContextMenuFor(eventRecord, {
    targetElement,
    event
  } = {}) {
    const me = this,
      {
        client
      } = me;

    if (!targetElement) {
      targetElement = client.getElementsFromEventRecord(eventRecord)[0];

      if (!targetElement) {
        return;
      }
    }

    me.showContextMenu({
      menuType: 'event',
      eventElement: targetElement,
      targetElement,
      eventRecord,
      resourceRecord: client.resolveResourceRecord(targetElement),
      assignmentRecord: client.resolveAssignmentRecord(targetElement),
      event
    });
  }

  set defaultItems(defaultItems) {
    this._defaultItems = defaultItems;
  }

  get defaultItems() {
    const result = super.defaultItems;

    if (!this.client.assignmentStore) {
      result.unassignEvent = false;
    }

    return result;
  }

  get namedItems() {
    const me = this,
      {
        client
      } = me;

    if (!me._namedItems) {
      me._namedItems = {
        deleteEvent: {
          text: client.L('Delete event'),
          icon: 'b-icon b-icon-trash',
          weight: -160,
          onItem: ({
                     menu,
                     eventRecord
                   }) => {


            const revertTarget = menu.focusInEvent && menu.focusInEvent.relatedTarget;

            if (revertTarget) {
              revertTarget.focus();
              client.navigator.activeItem = revertTarget;
            }

            client.removeRecords([eventRecord]);
          }
        },
        unassignEvent: {
          text: client.L('Unassign event'),
          icon: 'b-icon b-icon-unassign',
          weight: -150,
          name: 'unassignEvent',
          onItem: ({
                     menu,
                     eventRecord,
                     resourceRecord
                   }) => {


            const revertTarget = menu.focusInEvent && menu.focusInEvent.relatedTarget;

            if (revertTarget) {
              revertTarget.focus();
              client.navigator.activeItem = revertTarget;
            }

            eventRecord.unassign(resourceRecord);
          }
        }
      };
    }

    return me._namedItems;
  }

}

EventContextMenu.featureClass = '';
EventContextMenu._$name = 'EventContextMenu';
GridFeatureManager.registerFeature(EventContextMenu, true, 'Scheduler');


class ClockTemplate extends Base {
  static get defaultConfig() {
    return {
      minuteHeight: 8,
      minuteTop: 2,
      hourHeight: 8,
      hourTop: 2,
      handLeft: 10,
      div: document.createElement('div'),
      scheduler: null,


      template: function (data) {
        return `<div class="b-sch-clockwrap b-sch-clock-${this.mode} ${data.cls || ''}">
                    <div class="b-sch-clock">
                        <div class="b-sch-hour-indicator">${DateHelper.format(data.date, 'MMM')}</div>
                        <div class="b-sch-minute-indicator">${DateHelper.format(data.date, 'D')}</div>
                        <div class="b-sch-clock-dot"></div>
                    </div>
                    <span class="b-sch-clock-text">${data.text}</span>
                </div>`;
      }
    };
  }

  construct(config) {
    super.construct(config);
  }

  generateContent(data) {
    const me = this,
      date = data.date,
      html = me.template(data),
      div = me.div;
    div.innerHTML = html;
    me.updateDateIndicator(div, date);
    return div.innerHTML;
  }

  updateDateIndicator(el, date) {
    const hourIndicatorEl = el.querySelector('.b-sch-hour-indicator'),
      minuteIndicatorEl = el.querySelector('.b-sch-minute-indicator');

    if (date && hourIndicatorEl && minuteIndicatorEl) {
      if (this.mode === 'hour') {
        hourIndicatorEl.style.transform = `rotate(${date.getHours() % 12 * 30}deg)`;
        minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;
      } else {
        hourIndicatorEl.style.transform = 'none';
        minuteIndicatorEl.style.transform = 'none';
      }
    }
  }


  get mode() {
    const unitLessThanDay = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, 'day') < 0,
      formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);
    return unitLessThanDay && formatContainsHourInfo ? 'hour' : 'day';
  }

  set template(template) {
    this._template = template;
  }


  get template() {
    return this._template;
  }

}

ClockTemplate._$name = 'ClockTemplate';


class DragBase extends InstancePlugin {

  static get defaultConfig() {
    return {

      dragTipTemplate: data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `,

      constrainDragToResource: true,


      showTooltip: true,


      showExactDropPosition: false,


      constrainDragToTimeline: true,


      store: null,


      dragHelperConfig: null,
      tooltipCls: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }


  render() {
    const me = this,
      view = me.client;

    if (me.drag) {
      me.drag.destroy();
    }

    me.drag = new DragHelper(Object.assign({
      name: me.constructor.name,

      mode: 'translateXY',
      [this.client.isHorizontal ? 'lockY' : 'lockX']: me.constrainDragToResource,
      [this.client.isHorizontal ? 'lockX' : 'lockY']: me.constrainDragToTimeSlot,
      minX: true,

      maxX: true,

      constrain: false,
      cloneTarget: !me.constrainDragToTimeline,
      dragWithin: me.constrainDragToTimeline ? null : document.body,
      hideOriginalElement: true,
      outerElement: view.timeAxisSubGridElement,
      targetSelector: view.eventSelector,
      isElementDraggable: (el, event) => !view.readOnly && me.isElementDraggable(el, event),
      scrollManager: me.constrainDragToTimeline ? view.scrollManager : null,
      transitionDuration: view.transitionDuration,
      listeners: {
        beforedragstart: 'onBeforeDragStart',
        dragstart: 'onDragStart',
        drag: 'onDrag',
        drop: 'onDrop',
        abort: 'onDragAbort',
        reset: 'onDragReset',
        thisObj: me
      }
    }, me.dragHelperConfig));
    view.rowManager.on({
      changeTotalHeight: 'updateYConstraint',
      thisObj: me
    });

    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        scheduler: view
      });
    }
  }

  doDestroy() {
    const me = this;
    me.drag && me.drag.destroy();
    me.clockTemplate && me.clockTemplate.destroy();
    me.tip && me.tip.destroy();
    super.doDestroy();
  }


  onBeforeDragStart({
                      context,
                      event
                    }) {
    const me = this,
      client = me.client,
      name = client.scheduledEventName,
      eventRecord = client.resolveEventRecord(context.element);

    if (me.disabled || !eventRecord || !eventRecord.isDraggable) {
      return false;
    }


    context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);
    const result = client.trigger(`before${name}Drag`, {
      eventRecord,
      context: me.dragData
    }) !== false;

    if (result !== false) {
      me.updateYConstraint(eventRecord);
    }

    return result;
  }

  set constrainDragToTimeSlot(value) {
    const axis = this.client.isHorizontal ? 'lockX' : 'lockY';
    this._constrainDragToTimeSlot = value;

    if (this.drag) {
      this.drag[axis] = value;
    }
  }

  get constrainDragToTimeSlot() {
    return this._constrainDragToTimeSlot;
  }

  set constrainDragToResource(value) {
    const axis = this.client.isHorizontal ? 'lockY' : 'lockX';
    this._constrainDragToResource = value;

    if (this.drag) {
      this.drag[axis] = value;
    }
  }

  get constrainDragToResource() {
    return this._constrainDragToResource;
  }


  onDragStart({
                context,
                event
              }) {
    const me = this,
      client = me.client,
      name = client.scheduledEventName;
    me.currentOverClient = client;
    me.scrollClients = {};
    me.onMouseOverNewTimeline(client);
    const dragData = me.dragData = me.getDragData(context, event);

    if (me.showTooltip) {
      const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;

      if (!me.tip) {
        me.tip = new Tooltip({
          id: `${client.id}-event-drag-tip`,
          align: 'b-t',
          autoShow: true,
          updateContentOnMouseMove: true,
          clippedBy: me.constrainDragToTimeline ? [client.timeAxisSubGridElement, client.bodyContainer] : null,
          forElement: tipTarget,
          getHtml: me.getTipHtml.bind(me),

          style: 'pointer-events:none',
          cls: me.tooltipCls
        });
        me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
      } else {
        me.tip.showBy(tipTarget);
      }
    }


    client.trigger(`${name}DragStart`, {
      [`${name}Records`]: dragData.draggedRecords,
      context: dragData
    });
  }

  updateDateIndicator() {
    const {
        startDate,
        endDate
      } = this.dragData,
      tip = this.tip,
      endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');
    this.clockTemplate.updateDateIndicator(tip.element, startDate);
    endDateElement && this.clockTemplate.updateDateIndicator(endDateElement, endDate);
  }


  onDrag({
           context,
           event
         }) {
    const me = this,
      dd = me.dragData,
      start = dd.startDate;
    let client;

    if (me.constrainToTimeline) {
      client = me.client;
    } else {
      let target = event.target;

      if (/^touch/.test(event.type)) {
        const center = Rectangle.from(dd.context.element, null, true).center;
        target = DomHelper.elementFromPoint(center.x, center.y);
      }

      client = IdHelper.fromElement(target, 'timelinebase');
    }

    const depFeature = me.client.features.dependencies,
      x = context.newX,
      y = context.newY;

    if (!client) {
      if (depFeature) {
        depFeature.updateDependenciesForTimeSpan(dd.draggedRecords[0], dd.context.element);
      }

      return;
    }

    if (client !== me.currentOverClient) {
      me.onMouseOverNewTimeline(client);
    }

    me.updateDragContext(context, event);

    if (me.constrainDragToTimeline && (me.showExactDropPosition || me.client.timeAxisViewModel.snap)) {
      const newDate = client.getDateFromCoordinate(me.getCoordinate(dd.draggedRecords[0], context.element, [x, y])),
        timeDiff = newDate - dd.sourceDate,
        realStart = new Date(dd.origStart - 0 + timeDiff),
        offset = client.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);

      if (dd.startDate >= client.timeAxis.startDate && offset != null) {
        DomHelper.addTranslateX(context.element, offset);
      }
    }

    me.triggerEventDrag(dd, start);
    let valid = me.checkDragValidity(dd, event);

    if (valid && typeof valid !== 'boolean') {
      context.message = valid.message || '';
      valid = valid.valid;
    }

    context.valid = valid !== false;

    if (me.showTooltip) {
      me.tip.realign();
    }

    if (depFeature) {
      depFeature.updateDependenciesForTimeSpan(dd.draggedRecords[0], dd.context.element.querySelector(client.eventInnerSelector));
    }
  }

  onMouseOverNewTimeline(newTimeline) {
    const me = this,
      scrollClients = me.scrollClients;
    me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);
    newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);

    if (!(newTimeline.id in scrollClients)) {
      const scrollManager = newTimeline.scrollManager;
      scrollManager.startMonitoring({
        element: newTimeline.timeAxisSubGridElement
      });
      scrollClients[newTimeline.id] = newTimeline;
    }

    me.currentOverClient = newTimeline;
  }


  onDrop({
           context,
           event
         }) {
    const me = this,
      {
        currentOverClient,
        dragData
      } = me;

    if (!context.valid) {
      return me.onInvalidDrop({
        context,
        event
      });
    }

    let modified = false;
    me.updateDragContext(context, event);

    if (me.tip) {
      me.tip.hide();
    }

    if (context.valid && dragData.startDate && dragData.endDate) {
      dragData.finalize = (...params) => {
        me.finalize(...params);
        context.finalize(...params);
      };


      currentOverClient.trigger(`before${currentOverClient.capitalizedEventName}DropFinalize`, {
        context: dragData,
        event
      });
      context.async = dragData.async;

      if (!context.async && me.isValidDrop(dragData)) {
        modified = dragData.startDate - dragData.origStart !== 0 || dragData.newResource !== dragData.resourceRecord;
      }
    }

    if (!context.async) {
      me.finalize(dragData.valid && context.valid && modified);
    }
  }

  onDragAbort({
                context
              }) {
    const me = this,
      {
        dragData,
        client
      } = me,
      {
        draggedRecords
      } = dragData;
    client.currentOrientation.onDragAbort(context);

    me.dragData.record.instanceMeta(client).retainElement = false;

    if (me.tip) {
      me.tip.hide();
    }

    client.trigger(`${client.capitalizedEventName}DragAbort`, {
      [`${client.scheduledEventName}Records`]: draggedRecords,
      context: dragData
    });
  }


  onInvalidDrop() {
    const me = this;
    me.dragData.draggedRecords.forEach(record => me.resumeElementRedrawing(record));

    if (me.tip) {
      me.tip.hide();
    }
  }

  onDragReset({
                source: dragHelper
              }) {
    const me = this;

    for (const managerId in me.scrollClients || {}) {
      me.scrollClients[managerId].scrollManager.stopMonitoring(me.scrollClients[managerId].timeAxisSubGridElement);
    }

    if (dragHelper.context && dragHelper.context.started) {
      const {
        eventBarEls
      } = me.dragData;
      eventBarEls[0].classList.remove('b-drag-main');
    }

    me.scrollClients = null;

    if (me.currentOverClient) {
      me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);
    }


    if (me.dragData && !me.dragData.context.valid) {
      const dependencies = me.currentOverClient.features.dependencies;

      if (dependencies) {
        dependencies.scheduleDraw(true);
      }
    }


  }


  onInternalInvalidDrop() {
    const me = this,
      {
        currentOverClient
      } = me;

    if (me.tip) {
      me.tip.hide();
    }

    me.drag.abort();

    currentOverClient.trigger(`after${currentOverClient.capitalizedEventName}Drop`, {
      [currentOverClient.scheduledEventName + 'Records']: me.dragData.draggedRecords,
      valid: false,
      context: me.dragData
    });
  }


  async finalize(updateRecords) {
    const me = this,
      {
        currentOverClient: client,
        dragData
      } = me,
      {
        context,
        draggedRecords
      } = dragData;
    let result;
    draggedRecords.forEach((record, i) => {
      me.resumeElementRedrawing(record);


      dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);
    });

    if (updateRecords) {


      result = me.updateRecords(dragData);


      if (result instanceof Promise) {
        context.async = true;
        await result;
      }

      if (!dragData.valid) {
        me.onInternalInvalidDrop();
      } else {
        me.drag.reset();

        client.trigger(`after${client.capitalizedEventName}Drop`, {
          [`${client.scheduledEventName}Records`]: draggedRecords,
          valid: true,
          context: dragData
        });
      }
    } else {
      me.onInternalInvalidDrop();
    }

    return result;
  }


  updateDragContext(info, event) {
    const me = this,
      {
        drag
      } = me,
      dd = me.dragData,
      client = me.currentOverClient,
      {
        isHorizontal
      } = client,
      element = info.element,
      proxyRegion = Rectangle.from(element, client.timeAxisSubGridElement),
      record = dd.draggedRecords[0],
      eventRecord = record.isAssignment ? record.event : record,
      constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);
    dd.browserEvent = event;

    if (constrainToTimeSlot) {
      dd.timeDiff = 0;
    } else {
      if (client.timeAxis.isContinuous) {
        const {
            dateConstraints
          } = dd,
          {
            timeAxisSubGrid
          } = client,
          {
            scrollable
          } = timeAxisSubGrid,
          timeAxisRegion = scrollable.viewport,
          timeAxisPosition = client.isHorizontal ? info.clientX - timeAxisRegion.x + scrollable.x : info.clientY - timeAxisRegion.y + scrollable.y,


          pointerDate = client.timeAxisViewModel.getDateFromPosition(timeAxisPosition, null, true),
          timeDiff = dd.timeDiff = pointerDate - info.pointerStartDate;

        dd.startDate = me.adjustStartDate(dd.origStart, timeDiff);

        if (dateConstraints) {
          dd.startDate = DateHelper.constrain(dd.startDate, dateConstraints.start, new Date(dateConstraints.end - eventRecord.durationMS));
        }

        dd.endDate = new Date(dd.startDate - 0 + dd.duration);
      } else {
        const range = me.resolveStartEndDates(proxyRegion);
        dd.startDate = range.startDate;
        dd.endDate = range.endDate;
      }

      dd.timeDiff = dd.startDate - dd.origStart;
    }

    Object.assign(dd, me.getProductDragContext(dd));

    if (dd.valid) {

      if (dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate) {
        dd.context.valid = false;
        dd.context.message = me.L('noDropOutsideTimeline');
      } else {
        const result = !event || me.checkDragValidity(dd, event);

        if (!result || typeof result === 'boolean') {
          dd.context.valid = result !== false;
          dd.context.message = '';
        } else {
          dd.context.valid = result.valid !== false;
          dd.context.message = result.message;
        }
      }
    } else {
      dd.context.valid = false;
    }
  }

  suspendElementRedrawing(record, suspend = true) {
    record.instanceMeta(this.client).retainElement = suspend;
  }

  resumeElementRedrawing(record) {
    this.suspendElementRedrawing(record, false);
  }


  getDragData(info, event) {
    const me = this,
      client = me.client,
      {
        record,
        dateConstraints,
        eventBarEls,
        draggedRecords
      } = me.setupProductDragData(info);
    let origStart = record.startDate,
      origEnd = record.endDate,
      timeAxis = client.timeAxis,
      startsOutsideView = origStart < timeAxis.startDate,
      endsOutsideView = origEnd > timeAxis.endDate;
    const coordinate = me.getCoordinate(record, info.element, [info.elementStartX, info.elementStartY]),
      clientCoordinate = me.getCoordinate(record, info.element, [info.startClientX, info.startClientY]);

    draggedRecords.forEach(record => me.suspendElementRedrawing(record));

    if (me.drag.startEvent.ctrlKey) {
      me.client.selectEvent(draggedRecords[0], true);
    }

    const dragData = {
      context: info,
      dateConstraints,
      eventBarEls,
      record,
      draggedRecords,
      sourceDate: startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),
      screenSourceDate: client.getDateFromCoordinate(clientCoordinate, null, false),
      origStart: origStart,
      origEnd: origEnd,
      startDate: origStart,
      endDate: origEnd,
      timeDiff: 0,
      startsOutsideView,
      endsOutsideView,
      duration: origEnd - origStart,
      browserEvent: event

    };
    eventBarEls.forEach((el, i) => {
      el.classList.add(me.drag.draggingCls);
      el.classList.remove('b-sch-event-hover');
      el.classList.remove('b-active');
      el.classList.remove('b-first-render');
    });

    if (eventBarEls.length > 1) {

      info.relatedElements = eventBarEls.slice(1);
      info.relatedElStartPos = [];
      info.relatedElDragFromPos = [];

      if (me.unifiedDrag) {

        me.client.isAnimating = true;
        EventHelper.on({
          element: eventBarEls[1],
          transitionend: e => {
            me.client.isAnimating = false;
          },
          once: true
        });

        eventBarEls[0].classList.add('b-drag-main');
        let [x, y] = DomHelper.getTranslateXY(info.element);
        info.relatedElements.forEach((el, i) => {

          info.relatedElStartPos[i] = DomHelper.getTranslateXY(el);

          x += 10;
          y += 10;
          DomHelper.setTranslateXY(el, x, y);
          info.relatedElDragFromPos[i] = [x, y];
        });
      } else {

        info.relatedElements.forEach((el, i) => {
          info.relatedElStartPos[i] = info.relatedElDragFromPos[i] = DomHelper.getTranslateXY(el);
        });
      }
    }

    return dragData;
  }

  getRelatedRecords(record) {
    return [];
  }


  setupConstraints(constrainRegion, elRegion, tickSize, constrained) {
    const me = this,
      xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,
      yTickSize = 0;


    if (constrained) {
      me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);
    } else {


      me.setXConstraint(true, true, xTickSize);
    }

    me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);
  }

  updateYConstraint(eventRecord) {
    const me = this,
      {
        client
      } = me,
      {
        context
      } = me.drag,
      tickSize = client.timeAxisViewModel.snapPixelAmount;


    if (context && !me.drag.lockY) {
      let constrainRegion;

      if (me.constrainDragToTimeline) {
        constrainRegion = client.getScheduleRegion(null, eventRecord);
      } else {
        me.setYConstraint(null, null, tickSize);
        return;
      }

      me.setYConstraint(constrainRegion.top, constrainRegion.bottom - context.element.offsetHeight, tickSize);
    } else {
      me.setYConstraint(null, null, tickSize);
    }
  }

  setXConstraint(iLeft, iRight, iTickSize) {
    const me = this,
      drag = me.drag;
    drag.leftConstraint = iLeft;
    drag.rightConstraint = iRight;
    drag.minX = iLeft;
    drag.maxX = iRight;
  }

  setYConstraint(iUp, iDown, iTickSize) {
    const me = this,
      drag = me.drag;
    drag.topConstraint = iUp;
    drag.bottomConstraint = iDown;
    drag.minY = iUp;
    drag.maxY = iDown;
  }


  adjustStartDate(startDate, timeDiff) {
    return this.client.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), this.client.snapRelativeToEventStartDate ? startDate : false);
  }

  resolveStartEndDates(proxyRect) {
    const {
      start,
      end
    } = this.client.getStartEndDatesFromRectangle(proxyRect, 'round', this.dragData.duration);
    return {
      startDate: start,
      endDate: end
    };
  }


  getTipHtml() {
    const me = this,
      {
        startDate,
        endDate,
        draggedRecords
      } = me.dragData,
      startText = me.client.getFormattedDate(startDate),
      endText = me.client.getFormattedEndDate(endDate, startDate),
      {
        valid,
        message
      } = me.dragData.context;
    return me.dragTipTemplate({
      valid,
      startDate,
      endDate,
      startText,
      endText,
      message: message || '',
      [me.client.scheduledEventName + 'Record']: draggedRecords[0],
      dragData: me.dragData,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: draggedRecords[0].isMilestone ? '' : me.clockTemplate.template({
        date: endDate,
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })
    });
  }


  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;
  }


  isValidDrop(dragData) {
    throw new Error('Implement in subclass');
  }

  checkDragValidity(dragData) {
    throw new Error('Implement in subclass');
  }

  updateRecords(context) {
    throw new Error('Implement in subclass');
  }

  isElementDraggable(el, event) {
    throw new Error('Implement in subclass');
  }

  getCoordinate(record, element, coord) {
    throw new Error('Implement in subclass');
  }

  setupProductDragData(info) {
    throw new Error('Implement in subclass');
  }

  getProductDragContext(dd) {
    throw new Error('Implement in subclass');
  }

}

DragBase._$name = 'DragBase';


var GridFeatureDataLayer = (Target => class GridFeatureDataLayer extends (Target || Base) {
  static get defaultConfig() {
    return {

      dataLayerStores: ['store']
    };
  }

  startConfigure(config) {
    this.configDataLayer(this.client, config);
    super.startConfigure(config);
  }

  doDestroy() {
    (this.dataLayerStores || []).forEach(s => {
      if (s === 'columns') {
        s = 'columnStore';
      }

      this[s] = null;
    });
    return super.doDestroy();
  }


  configDataLayer(client, config) {
    return (config.dataLayerStores || []).reduce((config, s) => {
      if (s === 'columnStore' || s === 'columns') {
        s = 'columnStore';
        config.columnStore = config.columnStore || config.columns || this.obtainColumnStore(client, config);
      } else {
        const obtainFnName = `obtain${StringHelper.capitalizeFirstLetter(s)}`,
          obtainFn = this[obtainFnName];
        config[s] = config[s] || obtainFn && obtainFn.call(this, client, config);
      }

      if (!Reflect.has(this, s) && Object.isExtensible(this) && !Object.isSealed(this) && !Object.isFrozen(this)) {
        Object.defineProperty(this, s, {
          get: function () {
            return this[`_${s}`];
          },
          set: function (store) {
            this.setDataLayerStore(s, store);
          }
        });
      }

      return config;
    }, config);
  }


  attachToDataLayer(force = false) {
    (this.dataLayerStores || []).forEach(s => {
      if (s === 'columns') {
        s = 'columnStore';
      }

      const obtainFnName = `obtain${StringHelper.capitalizeFirstLetter(s)}`,
        obtainFn = this[obtainFnName];

      if ((!this[s] || force) && obtainFn) {
        this[s] = obtainFn.call(this, this.client);
      }
    });
  }

  setDataLayerStore(propName, store) {
    const privPropName = `_${propName}`,
      detacherName = `_${propName}Detacher`,
      onChangeTplMethodName = `on${StringHelper.capitalizeFirstLetter(propName)}Change`,
      listenersGetterName = `get${StringHelper.capitalizeFirstLetter(propName)}ListenersConfig`;

    if (this[privPropName] !== store) {
      if (this[detacherName]) {
        this[detacherName]();
        this[detacherName] = null;
      }

      if (this[onChangeTplMethodName]) {
        this[onChangeTplMethodName](store, this[privPropName]);
      }

      this[privPropName] = store;

      if (store && this[listenersGetterName]) {
        const listeners = this[listenersGetterName]();

        if (listeners) {
          this[detacherName] = store.on(Object.assign({
            thisObj: this,
            detachable: true
          }, listeners));
        }
      }
    }
  }

  obtainStore(client, config) {
    return client.store;
  }

  obtainColumnStore(client, config) {
    return client.columns;
  }

});


var SchedulerFeatureDataLayer = (Target => class SchedulerFeatureDataLayer extends GridFeatureDataLayer(Target || Base) {
  static get defaultConfig() {
    return {
      dataLayerStores: ['resourceStore', 'dependencyStore', 'assignmentStore', 'eventStore']
    };
  }

  obtainResourceStore(scheduler, config) {
    return scheduler.store;
  }

  obtainDependencyStore(scheduler, config) {
    return scheduler.dependencyStore;
  }

  obtainAssignmentStore(scheduler, config) {
    return scheduler.assignmentStore;
  }

  obtainEventStore(scheduler, config) {
    return scheduler.eventStore;
  }

});


var EventAPI = (Target => class EventAPI extends (Target || Base) {
  addEventToResource({
                       event,
                       resource,
                       eventStore,
                       assignmentStore
                     }) {
    event = eventStore.add(event)[0];
    const {
      assignment
    } = this.addAssignment({
      event,
      resource,
      assignmentStore
    });
    return {
      event,
      assignment: assignment !== event ? assignment : null
    };
  }

  getEventDependencies({
                         event,
                         dependencyStore
                       }) {
    return dependencyStore.getEventDependencies(event);
  }

  getEventAssignments({
                        event,
                        assignmentStore
                      }) {
    return event.assignments || [];
  }

  getEventResource({
                     event,
                     resourceStore
                   }) {
    return event.resource;
  }

  isEventAssignedToResource({
                              event,
                              resource,
                              resourceStore,
                              assignmentStore
                            }) {
    let result = false;

    if (!assignmentStore) {
      result = event.resource === resource;
    } else {
      result = this.getEventAssignments({
        event,
        assignmentStore
      }).some(assignment => this.isAssignmentForResource({
        assignment,
        resource,
        resourceStore
      }));
    }

    return result;
  }

  assignEventToResource({
                          event,
                          resource,
                          assignmentStore
                        }) {
    let assignment;

    if (assignmentStore) {
      assignment = assignmentStore.add({
        eventId: event.id,
        resourceId: resource.id
      })[0];
    } else {
      event.resourceId = resource.id;
    }

    return assignment || event;
  }

});


var AssignmentAPI = (Target => class AssignmentAPI extends (Target || Base) {
  isAssignmentEventAssigned({
                              assignment
                            }) {
    return !!assignment.event;
  }

  isAssignmentResourceAssigned({
                                 assignment
                               }) {
    return !!assignment.resource;
  }

  isAssignmentAssigned({
                         assignment
                       }) {
    return !!assignment.event && !!assignment.resource;
  }

  isAssignmentForResource({
                            assignment,
                            resource,
                            resourceStore
                          }) {
    return assignment.resource === resource;
  }

  getAssignmentResource({
                          assignment,
                          resourceStore
                        }) {
    return assignment.resource;
  }

  getAssignmentEvent({
                       assignment,
                       eventStore
                     }) {
    return assignment.event;
  }

  getAssignmentDependencies({
                              assignment,
                              dependencyStore
                            }) {
    const event = assignment.event;
    return event ? this.getEventDependencies({
      event,
      dependencyStore
    }) : [];
  }

  addAssignment({
                  event,
                  resource,
                  assignmentStore,
                  assignmentConfig
                }) {
    return {
      assignment: assignmentStore.add(Object.assign({}, assignmentConfig, {
        eventId: event.id,
        resourceId: resource.id
      }))[0]
    };
  }

});


var DependencyAPI = (Target => class DependencyAPI extends (Target || Base) {
  getDependencySourceEvent({
                             dependency,
                             eventStore
                           }) {
    return dependency.sourceEvent;
  }

  getDependencyTargetEvent({
                             dependency,
                             eventStore
                           }) {
    return dependency.targetEvent;
  }

  getDependencySourceAssignments({
                                   dependency,
                                   assignmentStore
                                 }) {
    const event = dependency.sourceEvent;
    return event ? this.getEventAssignments({
      event,
      assignmentStore
    }) : [];
  }

  getDependencyTargetAssignments({
                                   dependency,
                                   assignmentStore
                                 }) {
    const event = dependency.targetEvent;
    return event ? this.getEventAssignments({
      event,
      assignmentStore
    }) : [];
  }

  getDependencyAssignments({
                             dependency,
                             assignmentStore
                           }) {
    [].concat(this.getDependencySourceAssignments({
      dependency,
      assignmentStore
    }), this.getDependencyTargetAssignments({
      dependency,
      assignmentStore
    }));
  }

  getDependencyAssignmentsAsFromToArray({
                                          dependency,
                                          assignmentStore
                                        }) {
    const fromAssignments = this.getDependencySourceAssignments({
        dependency,
        assignmentStore
      }),
      toAssignments = this.getDependencyTargetAssignments({
        dependency,
        assignmentStore
      });
    return fromAssignments.reduce((assignments, from) => {
      return toAssignments.reduce((assignments, to) => {
        assignments.push({
          from,
          to
        });
        return assignments;
      }, assignments);
    }, []);
  }

  isDependencySourceAssignment({
                                 dependency,
                                 assignment
                               }) {
    return dependency.from === assignment.eventId;
  }

  isDependnecyTargetAssignment({
                                 dependency,
                                 assignment
                               }) {
    return dependency.to === assignment.eventId;
  }

  isValidDependency({
                      sourceEvent,
                      targetEvent,
                      type,
                      dependencyStore
                    }) {
    return dependencyStore.isValidDependency(sourceEvent.id, targetEvent.id, type);
  }

  isValidDependencyToCreate({
                              sourceEvent,
                              targetEvent,
                              type,
                              dependencyStore
                            }) {
    return dependencyStore.isValidDependencyToCreate(sourceEvent.id, targetEvent.id, type);
  }

  createDependency({
                     sourceEvent,
                     targetEvent,
                     type,
                     fromSide,
                     toSide,
                     dependencyStore
                   }) {
    return dependencyStore.add({
      from: sourceEvent.id,
      to: targetEvent.id,
      type,
      fromSide,
      toSide
    })[0];
  }

});


var ResourceAPI = (Target => class ResourceAPI extends (Target || Base) {
});


var DataAPI = (Target => {

  const APIs = [AssignmentAPI, DependencyAPI, EventAPI, ResourceAPI

  ];
  const RAW_API = base(Base).mixes(...APIs);
  return class DataAPI extends (Target || Base) {

    get dataApi() {
      if (!this._dataApi) {
        this._dataApi = new RAW_API({
          host: this.dataApiHost || this
        });
      }

      return this._dataApi;
    }

  };
});


const nullResourceArray = [null];


class EventDrag extends base(DragBase).mixes(SchedulerFeatureDataLayer, DataAPI) {

  static get $name() {
    return 'EventDrag';
  }

  static get defaultConfig() {
    return {


      constrainDragToResource: false,


      constrainDragToTimeSlot: false,


      validatorFn: () => {
      },


      validatorFnThisObj: null,


      unifiedDrag: null
    };
  }


  get scheduler() {
    return this.client;
  }

  get store() {
    return this.eventStore;
  }


  isElementDraggable(el, event) {
    const {
        scheduler
      } = this,
      eventElement = DomHelper.up(el, scheduler.eventSelector),
      {
        eventResize
      } = scheduler.features;

    if (!eventElement || this.disabled) {
      return false;
    }

    if (el.matches('[class$="-handle"]')) {
      return false;
    }

    const eventRecord = scheduler.resolveEventRecord(eventElement);


    if (eventResize && !eventRecord.isMilestone && eventResize.resize.overAnyHandle(event, eventElement)) {
      return false;
    }

    return true;
  }

  triggerEventDrag(dd, start) {

    if (dd.startDate - start !== 0 || dd.newResource !== dd.resourceRecord) {
      this.scheduler.trigger('eventDrag', {
        eventRecords: dd.draggedRecords,
        startDate: dd.startDate,
        endDate: dd.endDate,
        newResource: dd.newResource,
        context: dd
      });
    }
  }

  onDragStart({
                context,
                event
              }) {
    const eventContextMenuFeature = this.client.features.eventContextMenu;
    super.onDragStart({
      context,
      event
    });

    if (eventContextMenuFeature) {
      eventContextMenuFeature.hideContextMenu(false);
    }
  }


  isValidDrop(dragData) {
    const {
      newResource,
      resourceRecord
    } = dragData;
    let sourceRecord = dragData.draggedRecords[0];

    if (newResource.meta.specialRow) {
      return false;
    }


    if (resourceRecord !== newResource) {

      if (sourceRecord instanceof AssignmentModel) {
        sourceRecord = this.dataApi.getAssignmentEvent({
          assignment: sourceRecord,
          eventStore: this.eventStore
        });
        return !this.dataApi.isAssignmentForResource({
          assignment: sourceRecord,
          resource: newResource,
          resourceStore: this.resourceStore
        });
      } else {
        return !this.dataApi.isEventAssignedToResource({
          event: sourceRecord,
          resource: newResource,
          resourceStore: this.resourceStore,
          assignmentStore: this.assignmentStore
        });
      }
    }

    return true;
  }

  checkDragValidity(dragData, event) {
    const me = this,
      scheduler = this.currentOverClient;
    let result = me.dragData.context.valid;

    if (result) {

      if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(dragData.startDate, dragData.endDate, dragData.draggedRecords[0], dragData.newResource)) {
        result = {
          valid: false,
          message: me.L('eventOverlapsExisting')
        };
      } else {
        result = me.validatorFn.call(me.validatorFnThisObj || me, dragData, event);
      }
    }

    return result;
  }


  updateRecords(context) {
    const me = this,
      fromScheduler = me.scheduler,
      toScheduler = me.currentOverClient,
      copyKeyPressed = false,

      {
        assignmentStore,
        eventStore
      } = fromScheduler,
      {
        draggedRecords
      } = context;
    let result;


    if (eventStore !== toScheduler.eventStore) {

      eventStore.remove(draggedRecords);

      toScheduler.eventStore.add(draggedRecords);
    }

    if (assignmentStore) {
      if (toScheduler !== fromScheduler) {
        throw new Error('Assignments cannot be dragged cross-scheduler');
      }

      result = me.updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
    } else {
      result = me.updateRecordsSingleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
    }

    toScheduler.trigger('eventDrop', {
      eventRecords: draggedRecords,
      isCopy: copyKeyPressed,
      event: context.browserEvent,
      targetEventRecord: context.targetEventRecord,
      targetResourceRecord: context.newResource,
      context
    });
    return result;
  }


  updateRecordsSingleAssignmentMode(fromScheduler, toScheduler, context, copy) {

    const me = this,
      isCrossScheduler = fromScheduler !== toScheduler,
      isVertical = toScheduler.mode === 'vertical',
      {
        eventStore: fromEventStore,
        resourceStore
      } = fromScheduler,
      {
        draggedRecords,
        timeDiff,
        resourceRecord: fromResource,
        newResource: toResource
      } = context,
      unifiedDrag = me.unifiedDrag || isCrossScheduler && draggedRecords.length > 1,
      toAdd = [],

      indexDiff = me.constrainDragToResource ? 0 : resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource),
      event1Date = me.adjustStartDate(draggedRecords[0].startDate, timeDiff);
    let updated;

    if (isVertical) {
      draggedRecords.forEach((draggedEvent, i) => {
        const eventBar = context.eventBarEls[i];
        delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;


        if (eventBar.dataset.transient) {
          eventBar.remove();
        }
      });
    }

    draggedRecords.forEach((draggedEvent, i) => {
      const eventBar = context.eventBarEls[i],
        oldGeneration = draggedEvent.generation,


        relatedResources = isCrossScheduler ? nullResourceArray : draggedEvent.resources;


      eventBar.querySelector(fromScheduler.eventInnerSelector).classList.add(fromScheduler.committingCls);

      if (copy) {
        draggedEvent = draggedEvent.fullCopy(null);
        toAdd.push(draggedEvent);
      } else if (fromEventStore !== toScheduler.eventStore) {

        fromEventStore.remove(draggedRecords);

        toScheduler.eventStore.add(draggedRecords);

        draggedEvent.instanceMeta(toScheduler).fromDragProxy = true;
      }

      draggedEvent.beginBatch();

      const newStartDate = unifiedDrag ? event1Date : me.adjustStartDate(draggedEvent.startDate, timeDiff);
      (indexDiff !== 0 || unifiedDrag || isCrossScheduler) && relatedResources.length && relatedResources.forEach(r => {
        let newResource = toResource;


        if (!unifiedDrag && !isCrossScheduler) {
          let newIndex = resourceStore.indexOf(r) - indexDiff;

          if (newIndex < 0) {
            newIndex = 0;
          } else if (newIndex >= resourceStore.getCount()) {
            newIndex = resourceStore.getCount() - 1;
          }

          newResource = resourceStore.getAt(newIndex);
        }

        if (r) {
          draggedEvent.reassign(r, newResource);
        } else {
          draggedEvent.assign(newResource);
        }

        if (!isVertical) {
          const isRendered = toScheduler.rowManager.getRowFor(newResource) && toScheduler.isInTimeAxis(draggedEvent),
            newId = isRendered ? toScheduler.getEventRenderId(draggedEvent, newResource) : null;


          if (newId) {


            if (isCrossScheduler) {
              const elRect = Rectangle.from(context.context.element, toScheduler.foregroundCanvas, true),
                clone = context.context.element.cloneNode(true);


              DomHelper.setTranslateXY(clone, elRect.x, elRect.y);
              clone.classList.remove('b-first-render');
              clone.classList.remove('b-active');
              clone.classList.remove('b-drag-proxy');
              clone.classList.remove('b-dragging');


              toScheduler.currentOrientation.cacheTimeSpanElement(draggedEvent, newResource, clone);
            } else {
              toScheduler.currentOrientation.releaseTimeSpanDiv(eventBar, true);
              toScheduler.currentOrientation.updateElementId(eventBar, newId);
            }
          } else {
            eventBar.remove();
          }
        }
      });
      draggedEvent.setStartDate(newStartDate, true, fromEventStore.skipWeekendsDuringDragDrop);
      draggedEvent.endBatch();


      if (draggedEvent.generation !== oldGeneration) {
        updated = true;
      }
    });

    if (toAdd.length) {
      const count = fromEventStore.count;
      fromEventStore.add(toAdd);

      if (fromEventStore.count !== count) {
        updated = true;
      }
    }

    if (!updated) {
      context.valid = false;
    }
  }


  updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copy) {
    const me = this,
      isCrossScheduler = fromScheduler !== toScheduler,
      {
        eventStore
      } = fromScheduler,
      {
        draggedRecords,
        timeDiff,
        resourceRecord: fromResource,
        newResource: toResource
      } = context,


      handledEventsMap = {};
    let updated;
    draggedRecords.forEach((assignment, i) => {
      const event = assignment.event,
        eventBar = context.eventBarEls[i],
        oldGeneration = event.generation,
        newId = fromScheduler.getEventRenderId(assignment.event, toResource);

      if (handledEventsMap[event.id]) {
        return;
      }

      handledEventsMap[event.id] = true;

      if (toScheduler.mode === 'vertical') {


        if (eventBar.dataset.transient) {
          eventBar.retainElement = false;
        }
      } else {

        if (newId) {


          if (isCrossScheduler) {
            toScheduler.currentOrientation.cacheTimeSpanElement(event, eventBar);
          } else {
            toScheduler.currentOrientation.updateElementId(eventBar, newId);
          }
        }
      }

      event.setStartDate(me.adjustStartDate(event.startDate, timeDiff), true, eventStore.skipWeekendsDuringDragDrop);

      if (fromResource !== toResource) {
        if (copy) {
          event.assign(toResource);
        } else if (!event.isAssignedTo(toResource)) {
          event.reassign(assignment.resource, toResource);
        } else {
          event.unassign(assignment.resource);
        }
      }


      updated = updated || assignment.resource !== fromResource || event.generation !== oldGeneration;
    });

    if (!updated) {
      context.valid = false;
    }
  }


  getProductDragContext(dd) {
    const targetEventRecord = this.scheduler.resolveEventRecord(dd.browserEvent.target);
    let newResource;

    if (this.constrainDragToResource) {
      newResource = dd.resourceRecord;
    } else if (!this.constrainDragToTimeline) {

      newResource = this.resolveResource();
    } else {
      newResource = this.resolveResource() || dd.newResource || dd.resourceRecord;
    }

    return {
      valid: Boolean(newResource),
      newResource,
      targetEventRecord
    };
  }

  setupProductDragData(info) {
    const me = this,
      scheduler = me.scheduler,
      element = info.grabbed,
      eventRecord = scheduler.resolveEventRecord(element),
      resourceRecord = scheduler.resolveResourceRecord(element),
      assignmentRecord = scheduler.resolveAssignmentRecord(element),
      eventRegion = Rectangle.from(element),
      draggedRecords = [assignmentRecord || eventRecord],
      eventBarEls = [];

    if (me.constrainDragToResource && !resourceRecord) {
      throw new Error('Resource could not be resolved for event: ' + eventRecord.id);
    }

    const dateConstraints = scheduler.getDateConstraints(me.constrainDragToResource ? resourceRecord : null, eventRecord);

    if (me.constrainDragToTimeline) {
      me.setupConstraints(scheduler.getScheduleRegion(me.constrainDragToResource ? resourceRecord : null, eventRecord), eventRegion, scheduler.timeAxisViewModel.snapPixelAmount, Boolean(dateConstraints));
    }


    if (scheduler.multiEventSelect && (scheduler.isEventSelected(draggedRecords[0]) || me.drag.startEvent.ctrlKey)) {
      draggedRecords.push.apply(draggedRecords, me.getRelatedRecords(assignmentRecord || eventRecord));
    }

    draggedRecords.forEach(r => {
      let eventBarEl;

      if (r instanceof AssignmentModel) {
        eventBarEl = scheduler.getElementFromEventRecord(r.event, r.resource);
      } else {
        eventBarEl = scheduler.getElementFromEventRecord(r, r.resource);
      }


      if (!eventBarEl) {
        eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(r);
        eventBarEl = eventBarEl.innerElement;
      }

      eventBarEls.push(eventBarEl);
    });

    eventBarEls.forEach((el, i) => eventBarEls[i] = el.parentNode);
    return {
      record: eventRecord,
      dateConstraints,
      eventBarEls,
      draggedRecords
    };
  }


  getDragData(info, event) {
    return Object.assign(super.getDragData(info, event), {
      resourceRecord: this.scheduler.resolveResourceRecord(info.grabbed)
    });
  }


  getRelatedRecords(eventRecord) {
    return this.scheduler.selectedEvents.filter(selectedRecord => selectedRecord !== eventRecord && selectedRecord.isDraggable);
  }


  getCoordinate(eventRecord, element, coord) {
    const scheduler = this.currentOverClient;

    if (scheduler.isHorizontal) {
      let x = coord[0];

      if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {
        switch (scheduler.milestoneAlign) {
          case 'center':
            x += element.offsetWidth / 2;
            break;

          case 'end':
            x += element.offsetWidth;
            break;
        }
      }

      return x;
    } else {
      let y = coord[1];

      if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {
        switch (scheduler.milestoneAlign) {
          case 'center':
            y += element.offsetHeight / 2;
            break;

          case 'end':
            y += element.offsetHeight;
            break;
        }
      }

      return y;
    }
  }


  resolveResource() {
    const me = this,
      client = me.currentOverClient,
      {
        isHorizontal
      } = client,
      {
        context
      } = me.dragData,
      element = context.dragProxy || context.element,

      pageRect = Rectangle.from(element, null, true),
      y = client.isVertical || me.unifiedDrag ? context.clientY : pageRect.center.y,

      localRect = Rectangle.from(element, me.currentOverClient.timeAxisSubGridElement, true),
      {
        x: lx,
        y: ly
      } = localRect.center;


    if (isHorizontal) {
      const row = client.rowManager.getRowAt(y);
      return row && client.resourceStore.getAt(row.dataIndex);
    }


    return client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);
  }


  adjustStartDate(startDate, timeDiff) {
    const scheduler = this.currentOverClient;
    return scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);
  }

  resolveStartEndDates(proxyRect) {
    const scheduler = this.currentOverClient,
      dd = this.dragData;
    let {
      start: startDate,
      end: endDate
    } = scheduler.getStartEndDatesFromRectangle(proxyRect, 'round', dd.duration);

    if (!dd.startsOutsideView) {


      if (startDate && !scheduler.timeAxis.dateInAxis(startDate, false)) {
        const tick = scheduler.timeAxis.getTickFromDate(startDate);

        if (tick >= 0) {
          startDate = scheduler.timeAxis.getDateFromTick(tick);
        }
      }

      endDate = DateHelper.add(startDate, dd.duration, 'ms');
    } else if (!dd.endsOutsideView) {
      startDate = DateHelper.add(endDate, -dd.duration, 'ms');
    }

    return {
      startDate,
      endDate
    };
  }

}

EventDrag._$name = 'EventDrag';
GridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');


class DragCreateBase extends InstancePlugin {

  static get defaultConfig() {
    return {

      showTooltip: true,


      dragTolerance: 2,

      preventMultiple: false,
      validatorFn: () => {
      },


      validatorFnThisObj: null,


      proxyCls: 'b-sch-dragcreator-proxy',
      tipTemplate: data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove'],
      before: ['onElementContextMenu']
    };
  }

  doDestroy() {
    this.tip && this.tip.destroy();
    this.resize && this.resize.destroy();
    super.doDestroy();
  }


  addProxy(config) {
    const me = this,
      {
        client
      } = me,
      {
        barMargin
      } = client,
      region = client.currentOrientation.getRowRegion(config.rowRecord);
    let width, height, proxyX, proxyY;

    if (client.isHorizontal) {
      proxyX = 'currentX' in config ? Math.min(config.startX, config.currentX + 1) : config.startX;
      proxyY = region.y + barMargin;
      width = config.width || me.dragTolerance;
      height = region.height - barMargin * 2;
    } else {
      proxyX = region.x + barMargin;
      proxyY = 'currentY' in config ? Math.min(config.startY, config.currentY + 1) : config.startY;
      width = region.width - barMargin * 2;
      height = config.height || me.dragTolerance;
    }

    client.element.classList.add('b-dragcreating');

    client.element.classList.add('b-dragcreating-proxy-sizing');


    return me.proxy = DomHelper.createElement({
      parent: client.foregroundCanvas,
      className: me.proxyCls,
      style: `transform:translate(${proxyX}px, ${proxyY}px);width:${width}px;height:${height}px`,

      retainElement: true
    });
  }


  removeProxy() {
    const me = this;

    if (me.proxy) {
      me.proxy.remove();
      me.resize.destroy();
      me.proxy = me.resize = null;

      me.client.element.classList.remove('b-dragcreating');

      me.client.element.classList.remove('b-dragcreating-proxy-sizing');
      me.tip && me.tip.hide();
    }
  }


  initResizer(event, data) {
    const me = this;
    let edge;

    if (me.client.isHorizontal) {
      edge = data.currentX > data.startX ? 'right' : 'left';
    } else {
      edge = data.currentY > data.startY ? 'bottom' : 'top';
    }

    me.resize && me.resize.destroy();
    me.resize = new ResizeHelper({
      name: me.constructor.name,

      direction: me.client.isVertical ? 'vertical' : 'horizontal',
      isTouch: event.type.startsWith('touch'),
      grab: {
        element: me.proxy,
        edge,
        event: data.startEvent
      },
      allowEdgeSwitch: true,

      outerElement: me.client.timeAxisSubGridElement,

      scrollManager: me.client.scrollManager,
      scroller: me.client.timeAxisSubGrid.scrollable,

      listeners: {
        resizing: me.onResizing,
        resize: me.onResize,
        cancel: me.onCancel,
        thisObj: me
      }
    });
    me.resize.context.resource = data.resource;
  }


  initTooltip() {
    const me = this,
      client = me.client;

    if (me.showTooltip) {
      if (me.tip) {
        me.tip.showBy(me.getTooltipTarget());
      } else {
        me.clockTemplate = new ClockTemplate({
          scheduler: client
        });
        me.tip = new Tooltip({
          id: `${client.id}-drag-create-tip`,
          autoShow: true,
          trackMouse: false,
          updateContentOnMouseMove: true,
          getHtml: me.getTipHtml.bind(me),
          align: client.isVertical ? 't-b' : 'b100-t100',
          hideDelay: 0,
          axisLock: true

        });
        me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
      }
    }
  }

  updateDateIndicator() {
    const me = this,
      {
        startDate,
        endDate
      } = me.createContext,
      tip = me.tip,
      endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');

    if (startDate && endDate) {
      me.clockTemplate.updateDateIndicator(tip.element, startDate);
      endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, endDate);
    }
  }


  getTipHtml() {
    if (!this.resize.context) return;

    const me = this,
      client = me.client,
      {
        edge,
        newX,
        newY,
        elementStartX,
        elementStartY,
        elementWidth,
        elementHeight,
        newWidth,
        newHeight,
        valid,
        message
      } = me.resize.context;
    let start, end;

    if (client.isHorizontal) {
      const x = edge === 'left' ? newX : elementStartX,

        endX = Math.min(Math.max(x + (newWidth || elementWidth) - 1, 0), client.timeAxisViewModel.totalSize - 1);
      start = client.getDateFromCoordinate(x, 'round', true);
      end = client.getDateFromCoordinate(endX, 'round', true);
    } else {
      const y = edge === 'top' ? newY : elementStartY,

        endY = Math.min(Math.max(y + (newHeight || elementHeight) - 1, 0), client.timeAxisViewModel.totalSize - 1);
      start = client.getDateFromCoordinate(y, 'round', true);
      end = client.getDateFromCoordinate(endY, 'round', true);
    }

    const first = DateHelper.min(start, end),
      last = DateHelper.max(start, end),
      startText = first && client.getFormattedDate(first),
      endText = last && end && client.getFormattedEndDate(last, first);
    return me.tipTemplate({
      valid: valid,
      startDate: first,
      endDate: last,
      startText: startText,
      endText: endText,
      message: message,
      startClockHtml: me.clockTemplate.template({
        date: first,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: me.clockTemplate.template({

        date: client.getDisplayEndDate(last, first),
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })
    });
  }


  finalize(doCreate) {
    const me = this;

    const resetFinalization = () => {
      me.proxy.retainElement = false;
      me.reset();
    };

    const completeFinalization = () => {
      me.client.trigger('afterDragCreate', {
        proxyElement: me.proxy
      });
      resetFinalization();
    };

    if (doCreate) {

      const result = me.finalizeDragCreate(me.createContext);

      if (result instanceof Promise) {
        result.then(completeFinalization, resetFinalization);
      } else {
        completeFinalization();
      }
    } else {
      completeFinalization();
    }
  }


  onElementMouseDown(event) {
    const me = this,
      {
        client
      } = me;

    if (event.button === 0 && event.target.matches('.b-sch-timeaxis-cell') && !me.disabled && !client.readOnly) {
      const rowRecord = client.isVertical ? client.resolveResourceRecord(event) : client.getRecordFromElement(event.target);

      if (rowRecord.meta.specialRow) {
        return;
      }

      if (me.preventMultiple && !me.isRowEmpty(rowRecord)) {
        return;
      }

      me.monitorMove = true;
      me.createContext = {
        startEvent: event,
        startScreenX: event.screenX,
        startScreenY: event.screenY,
        startX: event.offsetX,
        startY: event.offsetY,
        cellElement: event.target,
        rowRecord
      };
      me.mouseUpDetacher = EventHelper.on({
        element: document.body,
        mouseup: 'onMouseUp',
        once: true,
        thisObj: this
      });
    }
  }

  onElementMouseMove(event) {
    const me = this;

    if (me.monitorMove) {
      const {
          createContext,
          client
        } = me,
        delta = me.client.isVertical ? createContext.startScreenY - event.screenY : createContext.startScreenX - event.screenX;

      if (Math.abs(delta) > me.dragTolerance) {
        const dateTime = client.getDateFromDomEvent(event),
          region = Rectangle.from(client.timeAxisSubGridElement, null, true);

        if (me.handleBeforeDragCreate(dateTime, event) === false) {
          me.monitorMove = false;
          return;
        }


        createContext.currentX = Math.max(event.clientX - region.x + client.timeAxisSubGrid.scrollable.x, 0);
        createContext.currentY = Math.max(event.clientY - region.y + client.timeAxisSubGrid.scrollable.y, 0);
        me.addProxy(me.createContext);
        me.initResizer(event, me.createContext);
        me.initTooltip();
        me.monitorMove = false;
        client.trigger('dragCreateStart', {
          proxyElement: me.proxy
        });
      }
    }


    if (me.proxy && me.showTooltip && me.resize.context) {
      me.tip.alignTo(me.getTooltipTarget());
    }
  }

  getTooltipTarget() {
    const me = this,
      target = Rectangle.from(me.proxy, null, true);

    if (me.client.isVertical) {

      if (me.resize.context.edge === 'bottom') {
        target.y = target.bottom - 1;
      }

      target.height = me.tip.anchorSize[1] / 2;
    } else {

      if (me.resize.context.edge === 'right') {
        target.x = target.right - 1;
      }

      target.width = me.tip.anchorSize[0] / 2;
    }

    return {
      target
    };
  }

  onMouseUp() {
    const me = this;
    me.client.element.classList.remove('b-dragcreating-proxy-sizing');
    me.monitorMove = false;
  }


  onElementContextMenu() {
    if (this.proxy) return false;
  }

  onResizing({
               context,
               event
             }) {
    const me = this,
      client = me.client,
      x = context.edge === 'left' ? context.newX : context.elementStartX,
      y = context.edge === 'top' ? context.newY : context.elementStartY,

      endX = Math.min(x + Math.max((context.newWidth || context.elementWidth) - 1, 0), client.timeAxisViewModel.totalSize - 1),
      endY = Math.min(y + Math.max((context.newHeight || context.elementHeight) - 1, 0), client.timeAxisViewModel.totalSize - 1),
      startCoord = client.isVertical ? y : x,
      endCoord = client.isVertical ? endY : endX,
      first = client.getDateFromCoordinate(startCoord, 'round', true),
      last = client.getDateFromCoordinate(endCoord, 'round', true),
      dc = me.dateConstraints;
    let start = DateHelper.min(first, last),
      end = DateHelper.max(first, last);

    if (dc) {
      end = DateHelper.constrain(end, dc.start, dc.end);
      start = DateHelper.constrain(start, dc.start, dc.end);
    }

    Object.assign(me.createContext, {
      startDate: start,
      endDate: end
    });
    context.valid = me.checkValidity(me.createContext, event);
    context.message = '';

    if (context.valid && typeof context.valid !== 'boolean') {
      context.message = context.valid.message;
      context.valid = context.valid.valid;
    }

    context.valid = context.valid !== false;
  }

  onResize({
             context: {
               valid
             },
             event
           }) {
    const me = this,
      {
        startDate,
        endDate
      } = me.createContext;
    if (!startDate || !endDate || endDate - startDate <= 0) valid = false;
    me.createContext = me.prepareCreateContextForFinalization(me.createContext, event, me.finalize.bind(me));

    if (valid) {
      me.client.trigger('beforeDragCreateFinalize', {
        context: me.createContext,
        event,
        proxyElement: me.proxy
      });
    }

    if (me.createContext) {

      me.resize.context.async = me.createContext.async;

      if (!me.createContext.async) {
        me.finalize(valid);
      } else {


        me.resize.removeListeners();
      }
    }
  }

  prepareCreateContextForFinalization(createContext, event, finalize, async = false) {
    return Object.assign({}, createContext, {
      async,
      event,
      finalize
    });
  }

  get dragging() {
    return this.resize;
  }

  onCancel() {
    this.cancel();
  }

  cancel() {
    this.reset();
    this.mouseUpDetacher && this.mouseUpDetacher();
  }

  reset() {
    const me = this;
    me.removeProxy();
    me.createContext = null;
    me.monitorMove = false;
  }


  checkValidity(context, event) {
    throw new Error('Implement in subclass');
  }

  triggerDragCreateEnd(newRecord, context) {
    throw new Error('Implement in subclass');
  }

  handleBeforeDragCreate(dateTime, event) {
    throw new Error('Implement in subclass');
  }

  isRowEmpty(rowRecord) {
    throw new Error('Implement in subclass');
  }

}

DragCreateBase._$name = 'DragCreateBase';


class EventDragCreate extends DragCreateBase {

  static get $name() {
    return 'EventDragCreate';
  }

  static get defaultConfig() {
    return {

      validatorFn: () => {
      }
    };
  }


  construct(scheduler, config) {
    const me = this;
    me.scheduler = scheduler;

    me.store = scheduler.eventStore;
    super.construct(scheduler, config);
  }


  finalizeDragCreate(context) {
    const newEventRecord = new this.store.modelClass({
      startDate: context.startDate,
      endDate: context.endDate
    });
    this.proxy.dataset.eventId = newEventRecord.id;
    this.scheduler.trigger('dragCreateEnd', {
      newEventRecord,
      resourceRecord: context.rowRecord,
      event: context.event,
      proxyElement: this.proxy
    });
  }

  handleBeforeDragCreate(dateTime, event) {
    const me = this,
      result = me.scheduler.trigger('beforeDragCreate', {
        resourceRecord: me.createContext.rowRecord,
        date: dateTime,
        event
      });

    if (result) {


      const tipFeature = me.scheduler.features.scheduleTooltip;

      if (tipFeature) {
        tipFeature.hoverTip && tipFeature.hoverTip.hide();
      }
    }

    me.dateConstraints = me.scheduler.getDateConstraints(me.createContext.rowRecord, dateTime);
    return result;
  }

  checkValidity(context, event) {
    const me = this,
      client = me.client;

    context.resourceRecord = context.rowRecord;
    return (client.allowOverlap || client.isDateRangeAvailable(context.startDate, context.endDate, null, context.resourceRecord)) && me.validatorFn.call(me.validatorFnThisObj || me, context, event);
  }

  isRowEmpty(resourceRecord) {
    const events = this.store.getEventsForResource(resourceRecord);
    return !events || !events.length;
  }

}

EventDragCreate._$name = 'EventDragCreate';
GridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');


const DH = DateHelper,
  makeDate = fields => {

    if (fields.length === 1) return fields[0].value;
    else if (fields.length === 2) {
      const [date, time] = fields[0] instanceof DateField ? fields : fields.reverse(),
        dateValue = DH.parse(date.value);

      if (dateValue) {
        dateValue.setHours(time.value.getHours(), time.value.getMinutes(), time.value.getSeconds(), time.value.getMilliseconds());
      }

      return dateValue;
    }

    return null;
  },
  copyTime = (dateTo, dateFrom) => {
    let d = new Date(dateTo.getTime());
    d.setHours(dateFrom.getHours(), dateFrom.getMinutes());
    return d;
  },
  adjustEndDate = (startDate, startTime, me) => {

    if (startDate && startTime) {
      const newEndDate = DH.add(copyTime(me.startDateField.value, me.startTimeField.value), me.eventRecord.durationMS, 'milliseconds');
      me.endDateField.value = newEndDate;
      me.endTimeField.value = DH.clone(newEndDate);
    }
  };


class EditBase extends InstancePlugin {


  static get defaultConfig() {
    return {

      autoClose: true,


      saveAndCloseOnEnter: true,
      triggerEvent: null,


      showDeleteButton: true,


      showNameField: true,


      startTimeConfig: null,


      startDateConfig: null,


      endTimeConfig: null,


      endDateConfig: null,


      dateFormat: 'L',


      timeFormat: 'LT',


      editorConfig: null,


      extraItems: null,


      extraWidgets: null
    };
  }


  construct(client, config) {
    const me = this;
    client.eventEdit = me;
    super.construct(client, config);
    me.clientListenersDetacher = client.on({
      [me.triggerEvent]: me.onActivateEditor,
      dragcreateend: me.onDragCreateEnd,
      thisObj: me
    });
  }

  doDestroy() {
    this.clientListenersDetacher();
    this.editor && this.editor.destroy();
    super.doDestroy();
  }


  get editorConfig() {
    return this._editorConfig;
  }

  set editorConfig(editorConfig) {
    const me = this,
      defaultEditorConfig = me.getDefaultConfiguration().editorConfig;

    editorConfig = ObjectHelper.assign({}, defaultEditorConfig, editorConfig);
    editorConfig.items = editorConfig.items || [];

    me.insertExtraWidgetsIntoDefaultWidgets(editorConfig);
    me._editorConfig = editorConfig;
  }

  get extraWidgets() {
    if (!this._skipWarn) {
      console.warn('`extraWidgets` was deprecated in 2.1, please change your code to use `extraItems`');
    }

    return this._extraItems;
  }

  set extraWidgets(widgets) {
    console.warn('`extraWidgets` was deprecated in 2.1, please change your code to use `extraItems`');
    this._extraItems = widgets;
  }

  get extraItems() {
    const me = this;

    me._skipWarn = true;

    me._thisIsAUsedExpression(me.extraWidgets);

    me._skipWarn = false;
    return me._extraItems;
  }

  set extraItems(items) {
    this._extraItems = items;
  }


  insertExtraWidgetsIntoDefaultWidgets(editorConfig) {
    const me = this;

    if (!me.extraItems || !me.extraItems.length) {
      return;
    }

    let index = editorConfig.items.findIndex(widget => widget.type === 'extraItems'),
      tail;

    if (index > -1) {

      editorConfig.items.splice(index, 1);

      tail = editorConfig.items.splice(index);
    }

    let withIndex = me.extraItems.filter(widget => widget.index >= 0),
      withoutIndex = me.extraItems.filter(widget => !(widget.index >= 0));

    editorConfig.items = editorConfig.items.concat(withoutIndex);

    withIndex.sort((widgetA, widgetB) => widgetA.index - widgetB.index);

    withIndex.forEach(widget => editorConfig.items.splice(widget.index, 0, widget));

    if (tail && tail.length) {

      editorConfig.items = editorConfig.items.concat(tail);
    }
  }

  onDatesChange(params) {
    const me = this,
      field = params.source,
      value = params.value;

    switch (field.ref) {
      case 'startDateField':
        me.startTimeField && adjustEndDate(value, me.startTimeField.value, me);
        break;

      case 'startTimeField':
        me.startDateField && adjustEndDate(me.startDateField.value, value, me);
        break;
    }

    if (me.endTimeField) {


      if (DH.isEqual(DH.clearTime(me.startDateField.value), DH.clearTime(me.endDateField.value))) {
        me.endTimeField.min = me.startTimeField.value;
      } else {
        me.endTimeField.min = null;
      }
    }
  }


  async save() {
    throw new Error('Implement in subclass');
  }

  get isValid() {
    const me = this;
    return Object.values(me.editor.widgetMap).every(field => {
      if (!field.name || field.hidden) {
        return true;
      }

      return field.isValid !== false;
    });
  }

  get values() {
    const me = this,
      startFields = [],
      endFields = [],
      values = {};
    me.editor.eachWidget(widget => {
      const name = widget.name;

      if (!name || widget.hidden) {
        return;
      }

      switch (name) {
        case 'startDate':
          startFields.push(widget);
          break;

        case 'endDate':
          endFields.push(widget);
          break;

        case 'resource':
          values[name] = widget.record;
          break;

        default:
          values[name] = widget.value;
      }
    }, true);
    values.startDate = makeDate(startFields);
    values.endDate = makeDate(endFields);


    values.duration = DH.diff(values.startDate, values.endDate, me.editor.record.durationUnit, true);
    return values;
  }


  onBeforeSave(eventRecord) {
  }


  onAfterSave(eventRecord) {
  }


  updateRecord(record) {
    const {
      values
    } = this;

    if (this.scheduler.assignmentStore) {
      delete values.resource;
    }

    record.set(values);
  }


  resetEditingContext() {
    const me = this;

    me.isEditing = false;
    me.client.element.classList.remove('b-eventeditor-editing');
    me.phantomEventElement && me.phantomEventElement.remove();
    me.phantomEventElement = null;
  }

  onPopupKeyDown({
                   event
                 }) {
    if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {

      event.preventDefault();

      if (event.target.name === 'startDate') {
        adjustEndDate(this.startDateField.value, this.startTimeField.value, this);
      }

      this.onSaveClick();
    }
  }

  async onSaveClick() {
    const saved = await this.save();

    if (saved) {
      this.editor.close();
    }
  }

  async onDeleteClick() {
    const removed = await this.deleteEvent();

    if (removed) {


      if (!this.editor.autoClose || this.editor.containsFocus) {
        this.editor.close();
      }
    }
  }

  onCancelClick() {
    this.editor.close();
  }

}

EditBase._$name = 'EditBase';


class EventEditor extends Popup {
  static get $name() {
    return 'EventEditor';
  }

  static get defaultConfig() {
    return {
      items: [],
      draggable: {
        handleSelector: ':not(button,.b-field-inner)'

      },
      axisLock: 'flexible',
      scrollable: {

        overflowY: true
      }
    };
  }

  processWidgetConfig(widget) {
    const me = this,
      eventEditFeature = me.eventEditFeature;

    if (widget.type === 'extraItems') {
      return false;
    }

    let fieldConfig = {};

    if (widget.ref === 'resourceField') {
      if (!eventEditFeature.showResourceField) return false;

      me.resourceStore = widget.store = eventEditFeature.resourceStore.makeChained(record => !record.meta.specialRow, null, {

        excludeCollapsedRecords: false
      });
      widget.multiSelect = Boolean(eventEditFeature.scheduler.assignmentStore);
      if (eventEditFeature.resourceFieldConfig) fieldConfig = eventEditFeature.resourceFieldConfig;
    }

    if (widget.ref === 'nameField' && !eventEditFeature.showNameField) return false;
    if (widget.ref === 'deleteButton' && !eventEditFeature.showDeleteButton) return false;

    if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'date') {
      fieldConfig.format = eventEditFeature.dateFormat;
    }

    if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'time') {
      fieldConfig.format = eventEditFeature.timeFormat;
    }

    if (eventEditFeature.startDateConfig && widget.name === 'startDate' && widget.type === 'date') {
      fieldConfig = eventEditFeature.startDateConfig;
    }

    if (eventEditFeature.startTimeConfig && widget.name === 'startDate' && widget.type === 'time') {
      fieldConfig = eventEditFeature.startTimeConfig;
    }

    if (eventEditFeature.endDateConfig && widget.name === 'endDate' && widget.type === 'date') {
      fieldConfig = eventEditFeature.endDateConfig;
    }

    if (eventEditFeature.endTimeConfig && widget.name === 'endDate' && widget.type === 'time') {
      fieldConfig = eventEditFeature.endTimeConfig;
    }

    Object.assign(widget, fieldConfig);
    return super.processWidgetConfig(widget);
  }

  show(...args) {

    if (this.resourceStore) {
      this.resourceStore.fillFromMaster();
    }

    super.show(...args);
  }

  afterShow(...args) {
    const deleteButton = this.widgetMap.deleteButton;

    if (deleteButton) {
      deleteButton.hidden = this.readOnly || !this.record.stores.length;
    }

    super.afterShow(...args);
  }

  onInternalKeyDown(event) {
    this.trigger('keyDown', {
      event
    });
    super.onInternalKeyDown(event);
  }

  set readOnly(readOnly) {
    const {
      deleteButton,
      saveButton,
      cancelButton
    } = this.widgetMap;
    this._readOnly = readOnly;
    this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');
    this.eachWidget(widget => {
      if (!('_originalReadOnly' in widget)) {

        widget._originalReadOnly = widget._readOnly || false;
      }

      if (readOnly) {
        widget.readOnly = readOnly;
      } else {
        widget.readOnly = widget._originalReadOnly;
      }
    });

    if (deleteButton) {
      deleteButton.hidden = readOnly;
    }

    if (saveButton) {
      saveButton.hidden = readOnly;
    }

    if (cancelButton) {
      cancelButton.hidden = readOnly;
    }
  }

  get readOnly() {
    return this._readOnly;
  }

}

EventEditor._$name = 'EventEditor';


class RecurrenceConfirmationPopup extends Popup {
  static get $name() {
    return 'RecurrenceConfirmationPopup';
  }

  static get defaultConfig() {
    return {
      localizableProperties: [],
      align: 'b-t',
      autoShow: false,
      autoClose: false,
      centered: true,
      scrollAction: 'realign',
      constrainTo: window,
      draggable: true,
      closable: true,
      floating: true,
      eventRecord: null,
      cls: 'b-sch-recurrenceconfirmation',
      bbar: [

        {
          color: 'b-green',
          localeClass: this,
          text: 'L{Yes}',
          ref: 'changeMultipleButton'
        },

        {
          color: 'b-gray',
          localeClass: this,
          text: 'L{update-only-this-btn-text}',
          ref: 'changeSingleButton'
        },

        {
          color: 'b-gray',
          localeClass: this,
          text: 'L{Cancel}',
          ref: 'cancelButton'
        }]
    };
  }

  construct(...args) {
    const me = this;
    super.construct(...args);
    const {
      changeMultipleButton,
      changeSingleButton,
      cancelButton
    } = me.widgetMap;
    changeMultipleButton && changeMultipleButton.on('click', me.onChangeMultipleButtonClick, me);
    changeSingleButton && changeSingleButton.on('click', me.onChangeSingleButtonClick, me);
    cancelButton && cancelButton.on('click', me.onCancelButtonClick, me);
    me.on('toolclick', me.onToolClick, me);
  }

  onChangeMultipleButtonClick() {
    this.processMultipleRecords();
    this.close();
  }

  onChangeSingleButtonClick() {
    this.processSingleRecord();
    this.close();
  }

  onCancelButtonClick() {
    this.cancelFn && this.cancelFn.call(this.thisObj);
    this.close();
  }

  onToolClick({
                tool
              }) {
    if (tool.handler === 'close' && this.cancelFn) {
      this.cancelFn.call(this.thisObj);
    }
  }


  confirm(config = {}) {
    const me = this;
    ['actionType', 'eventRecord', 'title', 'html', 'changerFn', 'cancelFn', 'thisObj'].forEach(prop => {
      if (prop in config) me[prop] = config[prop];
    });
    me.updatePopupContent();
    return super.show(config);
  }

  updatePopupContent() {
    const me = this,
      {
        changeMultipleButton,
        changeSingleButton,
        cancelButton
      } = me.widgetMap;
    let {
        eventRecord,
        actionType = 'update'
      } = me,
      isMaster = eventRecord && eventRecord.isRecurring;


    if (isMaster) {
      changeMultipleButton.text = me.L('Yes');
      me.html = me.L(`${actionType}-all-message`);
    } else {
      changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);
      me.html = me.L(`${actionType}-further-message`);
    }

    changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);
    cancelButton.text = me.L('Cancel');

    if (isMaster) {
      changeSingleButton.hide();
    } else {
      changeSingleButton.show();
    }

    me.width = me.L('width');


    me.title = me.L(`${actionType}-title`);
  }

  processMultipleRecords() {
    const {
        eventRecord,
        changerFn,
        thisObj
      } = this,
      {
        recurringEvent
      } = eventRecord,
      stopDate = new Date(eventRecord.startDate - 1);
    eventRecord.beginBatch();

    changerFn.call(thisObj, eventRecord);

    eventRecord.recurringTimeSpanId = null;
    eventRecord.endBatch();

    if (recurringEvent) {
      recurringEvent.recurrence.endDate = stopDate;
    }
  }

  processSingleRecord() {
    const {
        eventRecord,
        changerFn,
        thisObj
      } = this,
      {
        recurringEvent,
        startDate
      } = eventRecord;
    eventRecord.beginBatch();
    changerFn.call(thisObj);
    eventRecord.recurrence = null;
    eventRecord.endBatch();
    recurringEvent.addExceptionDate(startDate);
  }

  updateLocalization() {
    this.updatePopupContent();
    super.updateLocalization();
  }

}

RecurrenceConfirmationPopup._$name = 'RecurrenceConfirmationPopup';
BryntumWidgetAdapterRegister.register('recurrenceconfirmation', RecurrenceConfirmationPopup);


class RecurrenceFrequencyCombo extends LocalizableComboItems(Combo) {
  static get $name() {
    return 'RecurrenceFrequencyCombo';
  }

  static get defaultConfig() {
    return {
      editable: false,
      displayField: 'text',
      valueField: 'value'
    };
  }

  buildLocalizedItems() {
    return [{
      value: 'DAILY',
      text: this.L('Daily')
    }, {
      value: 'WEEKLY',
      text: this.L('Weekly')
    }, {
      value: 'MONTHLY',
      text: this.L('Monthly')
    }, {
      value: 'YEARLY',
      text: this.L('Yearly')
    }];
  }

}

RecurrenceFrequencyCombo._$name = 'RecurrenceFrequencyCombo';
BryntumWidgetAdapterRegister.register('recurrencefrequencycombo', RecurrenceFrequencyCombo);


class RecurrenceCombo extends RecurrenceFrequencyCombo {
  static get $name() {
    return 'RecurrenceCombo';
  }

  static get defaultConfig() {
    return {
      customValue: 'custom',
      placeholder: 'None',

      splitCls: 'b-recurrencecombo-split',
      items: true,
      highlightExternalChange: false
    };
  }

  buildLocalizedItems() {
    const me = this;
    return [{
      value: 'none',
      text: me.L('None')
    }, ...super.buildLocalizedItems(), {
      value: me.customValue,
      text: me.L('Custom...'),
      cls: me.splitCls
    }];
  }

  set value(value) {

    value = value || 'none';
    super.value = value;
  }

  get value() {
    return super.value;
  }

  set recurrence(recurrence) {
    const me = this;

    if (recurrence) {
      me.value = me.isCustomRecurrence(recurrence) ? me.customValue : recurrence.frequency;
    } else {
      me.value = null;
    }
  }

  isCustomRecurrence(recurrence) {
    const {
      interval,
      days,
      monthDays,
      months
    } = recurrence;
    return Boolean(interval > 1 || days && days.length || monthDays && monthDays.length || months && months.length);
  }

}

RecurrenceCombo._$name = 'RecurrenceCombo';
BryntumWidgetAdapterRegister.register('recurrencecombo', RecurrenceCombo);


class RecurrenceLegend extends Localizable() {
  static get $name() {
    return 'RecurrenceLegend';
  }

  static get allDaysValue() {
    return 'SU,MO,TU,WE,TH,FR,SA';
  }

  static get workingDaysValue() {
    return 'MO,TU,WE,TH,FR';
  }

  static get nonWorkingDaysValue() {
    return 'SU,SA';
  }


  static getLegend(recurrence, timeSpanStartDate) {
    const me = this,
      {
        timeSpan,
        interval,
        days,
        monthDays,
        months,
        positions
      } = recurrence,
      startDate = timeSpanStartDate || timeSpan.startDate,
      tplData = {
        interval
      };
    let fn;

    switch (recurrence.frequency) {
      case 'DAILY':
        return interval == 1 ? me.L('Daily') : me.L('Every {0} days', tplData);

      case 'WEEKLY':
        if (days && days.length) {
          tplData.days = me.getDaysLegend(days);
        } else if (startDate) {
          tplData.days = DateHelper.getDayName(startDate.getDay());
        }

        return me.L(interval == 1 ? 'Weekly on {1}' : 'Every {0} weeks on {1}', tplData);

      case 'MONTHLY':
        if (days && days.length && positions && positions.length) {
          tplData.days = me.getDaysLegend(days, positions);
        } else if (monthDays && monthDays.length) {

          monthDays.sort((a, b) => a - b);
          tplData.days = me.arrayToText(monthDays);
        } else if (startDate) {
          tplData.days = startDate.getDate();
        }

        return me.L(interval == 1 ? 'Monthly on {1}' : 'Every {0} months on {1}', tplData);

      case 'YEARLY':
        if (days && days.length && positions && positions.length) {
          tplData.days = me.getDaysLegend(days, positions);
        } else {
          tplData.days = startDate.getDate();
        }

        if (months && months.length) {

          months.sort((a, b) => a - b);

          if (months.length > 2) {
            fn = month => DateHelper.getMonthShortName(month - 1);
          } else {
            fn = month => DateHelper.getMonthName(month - 1);
          }

          tplData.months = me.arrayToText(months, fn);
        } else {
          tplData.months = DateHelper.getMonthName(startDate.getMonth());
        }

        return me.L(interval == 1 ? 'Yearly on {1} of {2}' : 'Every {0} years on {1} of {2}', tplData);
    }
  }

  static getDaysLegend(days, positions) {
    const me = this;
    let tplData = {
        position: ''
      },
      fn;

    if (positions && positions.length) {


      tplData.position = me.arrayToText(positions, position => me.L(`position${position}`));
    }

    if (days.length) {
      days.sort((a, b) => RecurrenceDayRuleEncoder.decodeDay(a)[0] - RecurrenceDayRuleEncoder.decodeDay(b)[0]);

      switch (days.join(',')) {
        case me.allDaysValue:
          tplData.days = me.L('day');
          break;

        case me.workingDaysValue:
          tplData.days = me.L('weekday');
          break;

        case me.nonWorkingDaysValue:
          tplData.days = me.L('weekend day');
          break;

        default:
          if (days.length > 2) {
            fn = day => DateHelper.getDayShortName(RecurrenceDayRuleEncoder.decodeDay(day)[0]);
          } else {
            fn = day => DateHelper.getDayName(RecurrenceDayRuleEncoder.decodeDay(day)[0]);
          }

          tplData.days = me.arrayToText(days, fn);
      }
    }

    return me.L('daysFormat', tplData);
  }


  static arrayToText(array, fn) {
    if (fn) {
      array = array.map(fn);
    }

    return array.join(', ').replace(/,(?=[^,]*$)/, this.L(' and '));
  }

}

RecurrenceLegend._$name = 'RecurrenceLegend';


class RecurrenceLegendButton extends Button {
  static get $name() {
    return 'RecurrenceLegendButton';
  }

  static get defaultConfig() {
    return {
      localizableProperties: [],
      recurrence: null
    };
  }


  set recurrence(recurrence) {
    this._recurrence = recurrence;
    this.updateLegend();
  }

  get recurrence() {
    return this._recurrence;
  }

  set eventStartDate(eventStartDate) {
    this._eventStartDate = eventStartDate;
    this.updateLegend();
  }

  get eventStartDate() {
    return this._eventStartDate;
  }

  updateLegend() {
    const me = this,
      {
        recurrence
      } = me;
    me.text = recurrence ? RecurrenceLegend.getLegend(recurrence, me.eventStartDate) : '';
  }

  onLocaleChange() {

    this.updateLegend();
  }

  updateLocalization() {
    this.onLocaleChange();
    super.updateLocalization();
  }

}

RecurrenceLegendButton._$name = 'RecurrenceLegendButton';
BryntumWidgetAdapterRegister.register('recurrencelegendbutton', RecurrenceLegendButton);


class RecurrenceDaysCombo extends LocalizableComboItems(Combo) {
  static get $name() {
    return 'RecurrenceDaysCombo';
  }

  static get defaultConfig() {
    const allDaysValue = 'SU,MO,TU,WE,TH,FR,SA';
    return {
      allDaysValue,
      editable: false,
      defaultValue: allDaysValue,
      workingDaysValue: 'MO,TU,WE,TH,FR',
      nonWorkingDaysValue: 'SU,SA',
      splitCls: 'b-recurrencedays-split',
      displayField: 'text',
      valueField: 'value'
    };
  }

  buildLocalizedItems() {
    const me = this;
    me._weekDays = null;
    return me.weekDays.concat([{
      value: me.allDaysValue,
      text: me.L('day'),
      cls: me.splitCls
    }, {
      value: me.workingDaysValue,
      text: me.L('weekday')
    }, {
      value: me.nonWorkingDaysValue,
      text: me.L('weekend day')
    }]);
  }

  get weekDays() {
    const me = this;

    if (!me._weekDays) {
      const weekStartDay = DateHelper.weekStartDay;
      const dayNames = DateHelper.getDayNames().map((text, index) => ({
        text,
        value: RecurrenceDayRuleEncoder.encodeDay(index)
      }));

      me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));
    }

    return me._weekDays;
  }

  set value(value) {
    const me = this;

    if (value && Array.isArray(value)) {
      value = value.join(',');
    }

    if (!value || !me.store.findRecord('value', value)) {
      value = me.defaultValue;
    }

    super.value = value;
  }

  get value() {
    let value = super.value;

    if (value && Array.isArray(value)) {
      value = value.join(',');
    }

    return value;
  }

}

RecurrenceDaysCombo._$name = 'RecurrenceDaysCombo';
BryntumWidgetAdapterRegister.register('recurrencedayscombo', RecurrenceDaysCombo);


class RecurrenceDaysButtonGroup extends ButtonGroup {
  static get $name() {
    return 'RecurrenceDaysButtonGroup';
  }

  static get defaultConfig() {
    return {
      defaults: {
        cls: 'b-raised',
        toggleable: true
      }
    };
  }

  construct(config = {}) {
    const me = this;
    config.columns = 7;
    config.items = me.buildItems();
    super.construct(config);
  }

  updateItemText(item) {
    const day = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];
    item.text = DateHelper.getDayName(day).substring(0, 3);
  }

  buildItems() {
    const me = this;

    if (!me.__items) {
      const weekStartDay = DateHelper.weekStartDay;
      const dayNames = DateHelper.getDayNames().map((text, index) => ({
        text: text.substring(0, 3),
        value: RecurrenceDayRuleEncoder.encodeDay(index)
      }));

      me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));
    }

    return me.__items;
  }

  set value(value) {
    if (value && Array.isArray(value)) {
      value = value.join(',');
    }

    super.value = value;
  }

  get value() {
    let value = super.value;

    if (value && Array.isArray(value)) {
      value = value.join(',');
    }

    return value;
  }

  onLocaleChange() {

    this.items.forEach(this.updateItemText, this);
  }

  updateLocalization() {
    this.onLocaleChange();
    super.updateLocalization();
  }

  get widgetClassList() {
    const classList = super.widgetClassList;

    classList.push('b-field');
    return classList;
  }

}

RecurrenceDaysButtonGroup._$name = 'RecurrenceDaysButtonGroup';
BryntumWidgetAdapterRegister.register('recurrencedaysbuttongroup', RecurrenceDaysButtonGroup);


class RecurrenceMonthDaysButtonGroup extends ButtonGroup {
  static get $name() {
    return 'RecurrenceMonthDaysButtonGroup';
  }

  static get defaultConfig() {
    return {
      defaults: {
        toggleable: true,
        cls: 'b-raised'
      }
    };
  }

  get minValue() {
    return 1;
  }

  get maxValue() {
    return 31;
  }

  construct(config = {}) {
    const me = this;
    config.columns = 7;
    config.items = me.buildItems();
    super.construct(config);
  }

  buildItems() {
    const me = this,
      items = [];

    for (let value = me.minValue; value <= me.maxValue; value++) {

      items.push({
        text: value + '',
        value
      });
    }

    return items;
  }

  get widgetClassList() {
    const classList = super.widgetClassList;

    classList.push('b-field');
    return classList;
  }

}

RecurrenceMonthDaysButtonGroup._$name = 'RecurrenceMonthDaysButtonGroup';
BryntumWidgetAdapterRegister.register('recurrencemonthdaysbuttongroup', RecurrenceMonthDaysButtonGroup);


class RecurrenceMonthsButtonGroup extends ButtonGroup {
  static get $name() {
    return 'RecurrenceMonthsButtonGroup';
  }

  static get defaultConfig() {
    return {
      defaults: {
        toggleable: true,
        cls: 'b-raised'
      }
    };
  }

  construct(config = {}) {
    const me = this;
    config.columns = 4;
    config.items = me.buildItems();
    super.construct(config);
  }

  buildItems() {
    return DateHelper.getMonthNames().map((item, index) => ({
      text: item.substring(0, 3),
      value: index + 1

    }));
  }

  updateItemText(item) {
    item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);
  }

  onLocaleChange() {

    this.items.forEach(this.updateItemText, this);
  }

  updateLocalization() {
    this.onLocaleChange();
    super.updateLocalization();
  }

  get widgetClassList() {
    const classList = super.widgetClassList;

    classList.push('b-field');
    return classList;
  }

}

RecurrenceMonthsButtonGroup._$name = 'RecurrenceMonthsButtonGroup';
BryntumWidgetAdapterRegister.register('recurrencemonthsbuttongroup', RecurrenceMonthsButtonGroup);


class RecurrenceStopConditionCombo extends LocalizableComboItems(Combo) {
  static get $name() {
    return 'RecurrenceStopConditionCombo';
  }

  static get defaultConfig() {
    return {
      editable: false,
      placeholder: 'Never',
      displayField: 'text',
      valueField: 'value'
    };
  }

  buildLocalizedItems() {
    return [{
      value: 'never',
      text: this.L('Never')
    }, {
      value: 'count',
      text: this.L('After')
    }, {
      value: 'date',
      text: this.L('On date')
    }];
  }

  set value(value) {

    value = value || 'never';
    super.value = value;
  }

  get value() {
    return super.value;
  }

  get recurrence() {
    return this._recurrence;
  }

  set recurrence(recurrence) {
    let value = null;

    if (recurrence.endDate) {
      value = 'date';
    } else if (recurrence.count) {
      value = 'count';
    }

    this._recurrence = recurrence;
    this.value = value;
  }

}

RecurrenceStopConditionCombo._$name = 'RecurrenceStopConditionCombo';
BryntumWidgetAdapterRegister.register('recurrencestopconditioncombo', RecurrenceStopConditionCombo);


class RecurrencePositionsCombo extends LocalizableComboItems(Combo) {
  static get $name() {
    return 'RecurrencePositionsCombo';
  }

  static get defaultConfig() {
    return {
      editable: false,
      splitCls: 'b-sch-recurrencepositions-split',
      displayField: 'text',
      valueField: 'value',
      defaultValue: 1,
      maxPosition: 5
    };
  }

  buildLocalizedItems() {
    const me = this;
    return me.buildDayNumbers().concat([


      {
        value: '-1',
        text: me.L('position-1'),
        cls: me.splitCls
      }]);
  }

  buildDayNumbers() {
    const me = this;


    return ArrayHelper.populate(me.maxPosition, i => ({
      value: i,
      text: me.L(`position${i}`)
    }));
  }

  set value(value) {
    const me = this;

    if (value && Array.isArray(value)) {
      value = value.join(',');
    }

    if (!value || !me.store.findRecord('value', value)) {
      value = me.defaultValue;
    }

    super.value = value;
  }

  get value() {
    const value = super.value;
    return value ? `${value}`.split(',').map(item => parseInt(item, 10)) : [];
  }

}

RecurrencePositionsCombo._$name = 'RecurrencePositionsCombo';
BryntumWidgetAdapterRegister.register('recurrencepositionscombo', RecurrencePositionsCombo);


class RecurrenceEditor extends Popup {
  static get $name() {
    return 'RecurrenceEditor';
  }

  static get defaultConfig() {
    return {
      draggable: true,
      closable: true,
      floating: true,
      cls: 'b-recurrenceeditor',
      title: 'L{Repeat event}',
      autoClose: true,
      width: 400,
      items: {
        frequencyField: true,
        daysButtonField: true,
        monthDaysRadioField: true,
        monthDaysButtonField: true,
        monthsButtonField: true,
        positionAndDayRadioField: true,
        stopRecurrenceField: true,
        countField: true,
        endDateField: true,
        intervalField: true,
        positionsCombo: true,
        daysCombo: true
      },
      namedItems: {
        frequencyField: {
          type: 'recurrencefrequencycombo',
          name: 'frequency',
          localeClass: this,
          label: 'L{Frequency}',
          weight: 10,
          onChange: 'up.onFrequencyFieldChange'
        },
        intervalField: {
          type: 'numberfield',
          weight: 15,
          name: 'interval',
          localeClass: this,
          label: 'L{Every}',
          labels: [{
            align: 'end',
            reference: 'intervalUnit',
            style: {
              width: '50em'
            }
          }],
          min: 1,
          allowBlank: false
        },
        daysButtonField: {
          type: 'recurrencedaysbuttongroup',
          weight: 20,
          name: 'days',
          forFrequency: 'WEEKLY'
        },

        monthDaysRadioField: {
          type: 'checkbox',
          weight: 30,
          toggleGroup: 'radio',
          forFrequency: 'MONTHLY',
          localeClass: this,
          label: 'L{Each}',
          checked: true,
          onChange: 'up.onMonthDaysRadioFieldChange'
        },
        monthDaysButtonField: {
          type: 'recurrencemonthdaysbuttongroup',
          weight: 40,
          name: 'monthDays',
          forFrequency: 'MONTHLY'
        },
        monthsButtonField: {
          type: 'recurrencemonthsbuttongroup',
          weight: 50,
          name: 'months',
          forFrequency: 'YEARLY'
        },

        positionAndDayRadioField: {
          type: 'checkbox',
          weight: 60,
          toggleGroup: 'radio',
          forFrequency: 'MONTHLY|YEARLY',
          localeClass: this,
          label: 'L{On the}',
          onChange: 'up.onPositionAndDayRadioFieldChange'
        },
        positionsCombo: {
          type: 'recurrencepositionscombo',
          weight: 80,
          name: 'positions',
          forFrequency: 'MONTHLY|YEARLY'
        },
        daysCombo: {
          type: 'recurrencedayscombo',
          weight: 90,
          name: 'days',
          forFrequency: 'MONTHLY|YEARLY',
          flex: 1
        },
        stopRecurrenceField: {
          type: 'recurrencestopconditioncombo',
          weight: 100,
          localeClass: this,
          label: 'L{End repeat}',
          onChange: 'up.onStopRecurrenceFieldChange'
        },
        countField: {
          type: 'numberfield',
          weight: 110,
          name: 'count',
          min: 2,
          localeClass: this,
          allowBlank: false,
          disabled: true,
          label: ' ',
          labels: [{
            align: 'end',
            reference: 'countUnit',
            label: 'L{time(s)}'
          }]
        },
        endDateField: {
          type: 'datefield',
          weight: 120,
          name: 'endDate',
          hidden: true,
          disabled: true,
          label: ' ',
          allowBlank: false
        }
      },
      bbar: [{
        type: 'widget',
        cls: 'b-label-filler'
      }, {
        type: 'button',
        color: 'b-green',
        ref: 'saveButton',
        localeClass: this,
        text: 'L{Save}',
        onClick: 'up.onSaveClick'
      }, {
        type: 'button',
        color: 'b-gray',
        ref: 'cancelButton',
        localeClass: this,
        text: 'L{Cancel}',
        onClick: 'up.onCancelClick'
      }]
    };
  }


  get record() {
    return super.record;
  }

  set record(record) {
    super.record = record;
    const me = this,
      event = record.timeSpan,
      startDate = event && event.startDate,
      {
        daysButtonField,
        monthDaysButtonField,
        monthsButtonField,
        monthDaysRadioField,
        positionAndDayRadioField,
        stopRecurrenceField
      } = me.widgetMap;

    if (startDate) {

      if (!record.days || !record.days.length) {
        daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];
      }

      if (!record.monthDays || !record.monthDays.length) {
        monthDaysButtonField.value = startDate.getDate();
      }

      if (!record.months || !record.months.length) {
        monthsButtonField.value = startDate.getMonth() + 1;
      }
    }

    if (record.days && record.positions) {
      positionAndDayRadioField.check();

      if (!me.isPainted) {
        monthDaysRadioField.uncheck();
      }
    } else {
      monthDaysRadioField.check();

      if (!me.isPainted) {
        positionAndDayRadioField.uncheck();
      }
    }

    stopRecurrenceField.recurrence = record;
  }

  onSaveClick() {
    const me = this;

    if (me.saveHandler) {
      me.saveHandler.call(me.thisObj || me, me, me.record);
    } else {
      me.updateRecord();
      me.close();
    }
  }

  onCancelClick() {
    const me = this;

    if (me.cancelHandler) {
      me.cancelHandler.call(me.thisObj || me, me, me.record);
    } else {
      me.close();
    }
  }


  updateRecord(recurrence) {

    const values = this.getValues(w => w.name in recurrence && !w.disabled);
    recurrence.set(values);
  }

  toggleStopFields() {
    const me = this,
      {
        countField,
        endDateField
      } = me.widgetMap;

    switch (me.widgetMap.stopRecurrenceField.value) {
      case 'count':
        countField.show();
        countField.enable();
        endDateField.hide();
        endDateField.disable();
        break;

      case 'date':
        countField.hide();
        countField.disable();
        endDateField.show();
        endDateField.enable();
        break;

      default:
        countField.hide();
        endDateField.hide();
        countField.disable();
        endDateField.disable();
    }
  }

  onMonthDaysRadioFieldChange({
                                checked
                              }) {
    const {
      monthDaysButtonField
    } = this.widgetMap;
    monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);
  }

  onPositionAndDayRadioFieldChange({
                                     checked
                                   }) {
    const {
      daysCombo,
      positionsCombo
    } = this.widgetMap;

    daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);
  }

  onStopRecurrenceFieldChange() {
    this.toggleStopFields();
  }

  isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {
    return !widget.forFrequency || widget.forFrequency.indexOf(frequency) > -1;
  }

  onFrequencyFieldChange({
                           value,
                           valid
                         }) {
    const me = this,
      items = me.queryAll(w => 'forFrequency' in w);

    if (valid && value) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i];

        if (me.isWidgetAvailableForFrequency(item, value)) {
          item.show();
          item.enable();
        } else {
          item.hide();
          item.disable();
        }
      }


      me.widgetMap.intervalField.intervalUnit.innerHTML = me.L(`${value}intervalUnit`);
      me.toggleFieldsState();
    }
  }

  toggleFieldsState() {
    const me = this,
      {
        widgetMap
      } = this;
    me.onMonthDaysRadioFieldChange({
      checked: widgetMap.monthDaysRadioField.checked
    });
    me.onPositionAndDayRadioFieldChange({
      checked: widgetMap.positionAndDayRadioField.checked
    });
    me.onStopRecurrenceFieldChange();
  }

  updateLocalization() {

    const {
      countField,
      intervalField,
      frequencyField
    } = this.widgetMap;
    countField.countUnit.innerHTML = this.L('time(s)');
    intervalField.intervalUnit.innerHTML = this.L(`${frequencyField.value}intervalUnit`);
    super.updateLocalization();
  }

}

RecurrenceEditor._$name = 'RecurrenceEditor';
BryntumWidgetAdapterRegister.register('recurrenceeditor', RecurrenceEditor);


var RecurringEventEdit = (Target => class RecurringEventEdit extends (Target || Base) {
  static get $name() {
    return 'RecurringEventEdit';
  }

  static get defaultConfig() {
    return {
      recurringEventsItems: [

        {
          type: 'recurrencecombo',
          label: 'L{Repeat}',
          ref: 'recurrenceCombo'
        },

        {
          type: 'recurrencelegendbutton',
          ref: 'editRecurrenceButton',
          name: 'recurrenceRule',
          flex: '1'
        }],


      showRecurringUI: null
    };
  }

  insertExtraWidgetsIntoDefaultWidgets(editorConfig) {

    this.processEditorConfig(editorConfig);
    super.insertExtraWidgetsIntoDefaultWidgets(editorConfig);
  }

  processEditorConfig(editorConfig) {
    const {
      items
    } = editorConfig;

    const extraItemsIndex = items.findIndex(item => item.type === 'extraItems');

    if (extraItemsIndex < 0) {
      items.push(...this.recurringEventsItems);
    } else {
      items.splice(extraItemsIndex, 0, ...this.recurringEventsItems);
    }
  }

  construct(scheduler, config) {
    const me = this;
    super.construct(scheduler, config);
    me.scheduler.on({
      beforeEventDelete: me.onRecurrableEventBeforeDelete,
      beforeEventSave: me.onRecurrableEventBeforeSave,
      thisObj: me
    });
  }

  doDestroy() {
    this._recurrenceConfirmation && this.recurrenceConfirmation.destroy();
    this._recurrenceEditor && this.recurrenceEditor.destroy();
    super.doDestroy();
  }

  get isRecurringEnabled() {
    return Boolean(this.scheduler.features.recurringEvents && !this.scheduler.features.recurringEvents.disabled);
  }

  onEditorConstructed(editor) {
    const me = this;
    editor.on('hide', me.onRecurringEventEditorHide, me);
    me.editRecurrenceButton && me.editRecurrenceButton.on('click', me.onEditRecurrenceClick, me);
    me.recurrenceCombo.on('change', me.onRecurrenceComboChange.bind(me));
  }

  internalShowEditor() {
    this.toggleRecurringFieldsVisibility(this.isRecurringEnabled && this.showRecurringUI !== false);
  }

  toggleRecurringFieldsVisibility(show = true) {
    const methodName = show ? 'show' : 'hide';
    this.editRecurrenceButton && this.editRecurrenceButton[methodName]();
    this.recurrenceCombo && this.recurrenceCombo[methodName]();
  }

  onRecurringEventEditorHide({
                               source
                             }) {
    const {
      recurrenceEditor,
      recurrenceConfirmation
    } = this;

    if (recurrenceEditor && recurrenceEditor.isVisible) {
      recurrenceEditor.hide();
    }

    if (recurrenceConfirmation && recurrenceConfirmation.isVisible) {
      recurrenceConfirmation.hide();
    }
  }


  makeRecurrence(rule) {
    const event = this.eventRecord,
      eventCopy = event.copy();
    let recurrence = event.recurrence;

    if (!rule && recurrence) {
      recurrence = recurrence.copy();
    } else {
      recurrence = new event.recurrenceModel({
        rule
      });
    }

    recurrence.timeSpan = eventCopy;

    eventCopy.setStartDate(this.values.startDate);
    recurrence.suspendTimeSpanNotifying();
    return recurrence;
  }

  onRecurrableEventBeforeSave({
                                eventRecord,
                                context
                              }) {
    const me = this;

    if (eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence)) {
      me.recurrenceConfirmation.confirm({
        actionType: 'update',
        eventRecord,

        changerFn() {
          context.finalize(true);
        },

        cancelFn() {
          context.finalize(false);
        }

      });

      context.async = true;
      return false;
    }
  }

  showDisplayConfirmationOnEventDelete(eventRecord) {
    return this.isEditing && this.eventRecord === eventRecord && eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);
  }

  onRecurrableEventBeforeDelete({
                                  eventRecords,
                                  context
                                }) {
    const [eventRecord] = eventRecords;

    if (this.showDisplayConfirmationOnEventDelete(eventRecord)) {
      this.recurrenceConfirmation.confirm({
        actionType: 'delete',
        eventRecord,

        changerFn() {
          context.finalize(true);
        },

        cancelFn() {
          context.finalize(false);
        }

      });
      return false;
    }
  }

  set recurrenceConfirmation(recurrenceConfirmation) {
    this._recurrenceConfirmation = recurrenceConfirmation;
  }

  get recurrenceConfirmation() {
    const me = this;
    let recurrenceConfirmation = me._recurrenceConfirmation;

    if (!recurrenceConfirmation || !recurrenceConfirmation.$name) {
      recurrenceConfirmation = WidgetHelper.createWidget(Object.assign({
        type: 'recurrenceconfirmation',
        owner: me.getEditor()
      }, recurrenceConfirmation));
      me._recurrenceConfirmation = recurrenceConfirmation;
    }

    return recurrenceConfirmation;
  }

  set recurrenceEditor(recurrenceEditor) {
    this._recurrenceEditor = recurrenceEditor;
  }

  get recurrenceEditor() {
    const me = this;
    let recurrenceEditor = me._recurrenceEditor;

    if (!recurrenceEditor || !recurrenceEditor.$name) {
      recurrenceEditor = WidgetHelper.createWidget(Object.assign({
        type: 'recurrenceeditor',
        autoShow: false,
        owner: me.getEditor(),
        scrollAction: 'realign',
        clippedBy: [me.scheduler.timeAxisSubGridElement, me.scheduler.bodyContainer],
        constrainTo: window,
        anchor: true,
        saveHandler: me.recurrenceEditorSaveHandler,
        thisObj: me
      }, recurrenceEditor));
      me._recurrenceEditor = recurrenceEditor;
    }

    return recurrenceEditor;
  }

  showRecurrenceEditor() {
    const me = this,
      {
        recurrenceEditor,
        eventRecord
      } = me;

    if (recurrenceEditor && eventRecord && eventRecord.supportsRecurring) {

      if (!me.recurrence) {
        me.recurrence = me.makeRecurrence();
      }

      me.recurrence.timeSpan.setStartDate(me.values.startDate);

      recurrenceEditor.record = me.recurrence;
      recurrenceEditor.showBy(me.recurrenceCombo.element);
    }
  }

  onEditRecurrenceClick() {
    this.showRecurrenceEditor();
  }

  loadRecurrenceData(recurrence) {
    this.recurrence = recurrence;
    this.updateRecurrenceFields(recurrence);
  }

  updateRecurrenceFields(recurrence) {
    const me = this;

    if (me.recurrenceCombo) {
      me.recurrenceCombo.recurrence = recurrence;
    }

    if (me.editRecurrenceButton) {
      me.editRecurrenceButton.recurrence = recurrence;
      me.editRecurrenceButton.value = recurrence ? recurrence.rule : null;

      if (recurrence && me.isRecurringEnabled && me.showRecurringUI !== false) {
        me.editRecurrenceButton.show();
      } else {
        me.editRecurrenceButton.hide();
      }
    }
  }

  onRecurrenceComboChange({
                            source,
                            value,
                            userAction
                          }) {
    const me = this;

    if (value == source.customValue) {

      if (userAction) {
        me.showRecurrenceEditor();
      }
    } else {
      me.loadRecurrenceData(value ? me.makeRecurrence(`FREQ=${value}`) : null);
    }
  }

  recurrenceEditorSaveHandler(editor, recurrence) {

    editor.updateRecord(recurrence);

    this.updateRecurrenceFields(recurrence);
    editor.close();
  }

  onDatesChange(...args) {
    super.onDatesChange(...args);
    const me = this,
      {
        editRecurrenceButton
      } = me;

    if (!me.loadingRecord && editRecurrenceButton) {
      const {
        startDate
      } = me.values;
      if (startDate) editRecurrenceButton.eventStartDate = startDate;
    }
  }

  internalLoadRecord(eventRecord, resourceRecord) {
    if (this.recurrenceCombo && eventRecord && eventRecord.supportsRecurring) {
      this.loadRecurrenceData(eventRecord.recurrence ? this.makeRecurrence() : null);
    }
  }

});


class EventEdit extends RecurringEventEdit(EditBase) {

  static get $name() {
    return 'EventEdit';
  }

  static get defaultConfig() {
    return {

      triggerEvent: 'eventdblclick',


      showResourceField: true,


      resourceFieldConfig: null,


      typeField: 'eventType',


      eventRecord: null,


      readOnly: null,


      editorConfig: {
        title: 'L{Edit Event}',
        localeClass: this,
        closable: true,
        items: [

          {
            type: 'text',
            localeClass: this,
            label: 'L{Name}',
            clearable: true,
            name: 'name',
            ref: 'nameField'
          },

          {
            type: 'combo',
            localeClass: this,
            label: 'L{Resource}',
            name: 'resource',
            ref: 'resourceField',
            editable: true,
            valueField: 'id',
            displayField: 'name'
          },

          {
            type: 'date',
            cls: 'b-inline',
            clearable: false,
            required: true,
            localeClass: this,
            label: 'L{Start}',
            name: 'startDate',
            ref: 'startDateField',
            flex: '1 0 60%'
          },

          {
            type: 'time',
            clearable: false,
            required: true,
            name: 'startDate',
            ref: 'startTimeField',
            cls: 'b-match-label',
            flex: '1 0 40%'
          },

          {
            type: 'date',
            cls: 'b-inline',
            clearable: false,
            required: true,
            localeClass: this,
            label: 'L{End}',
            name: 'endDate',
            ref: 'endDateField',
            flex: '1 0 60%'
          },

          {
            type: 'time',
            clearable: false,
            required: true,
            name: 'endDate',
            ref: 'endTimeField',
            cls: 'b-match-label',
            flex: '1 0 40%'
          }, {

            type: 'extraItems'
          }],
        bbar: [{
          type: 'widget',
          cls: 'b-label-filler'
        },

          {
            color: 'b-green',
            localeClass: this,
            text: 'L{Save}',
            ref: 'saveButton'
          },

          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Delete}',
            ref: 'deleteButton'
          },

          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Cancel}',
            ref: 'cancelButton'
          }]
      }
    };
  }

  static get pluginConfig() {
    return {
      chain: ['getEventMenuItems', 'onEventEnterKey'],
      assign: ['editEvent']
    };
  }


  construct(scheduler, config) {
    const me = this;
    me.scheduler = scheduler;
    me.eventStore = scheduler.eventStore;
    me.resourceStore = scheduler.resourceStore;
    super.construct(scheduler, config);
  }


  get readOnly() {
    return this.editor ? this.editor.readOnly : this._readOnly;
  }

  set readOnly(readOnly) {
    this._readOnly = readOnly;

    if (this.editor) {
      this.editor.readOnly = readOnly;
    }
  }


  getEditor() {
    const me = this;
    let {
      editor
    } = me;

    if (editor) {
      return editor;
    }

    editor = me.editor = new EventEditor(me.getEditorConfig());

    if (editor.items.length === 0) {
      console.warn('Event Editor configured without any `items`');
    }

    editor.on({
      beforehide: me.resetEditingContext,
      keydown: me.onPopupKeyDown,
      thisObj: me
    });


    Object.values(editor.widgetMap).forEach(widget => {
      const ref = widget.ref || widget.id;

      if (ref && !me[ref]) {
        me[ref] = widget;

        switch (widget.name) {
          case 'startDate':
          case 'endDate':
            widget.on('change', me.onDatesChange, me);
            break;
        }
      }
    });

    me.onEditorConstructed && me.onEditorConstructed(editor);
    me.eventTypeField && me.eventTypeField.on('change', me.onEventTypeChange, me);
    me.saveButton && me.saveButton.on('click', me.onSaveClick, me);
    me.deleteButton && me.deleteButton.on('click', me.onDeleteClick, me);
    me.cancelButton && me.cancelButton.on('click', me.onCancelClick, me);
    return me.editor;
  }

  getEditorConfig() {
    const me = this,
      {
        autoClose,
        cls,
        readOnly
      } = me;
    return ObjectHelper.assign({
      eventEditFeature: me,
      align: 'b-t',
      id: `${me.scheduler.id}-event-editor`,
      autoShow: false,
      anchor: true,
      scrollAction: 'realign',
      clippedBy: [me.scheduler.timeAxisSubGridElement, me.scheduler.bodyContainer],
      constrainTo: window,
      autoClose,
      readOnly,
      cls
    }, me.editorConfig);
  }

  internalShowEditor(eventRecord, resourceRecord, element = null) {
    const me = this,
      scheduler = me.scheduler,

      eventElement = element || DomHelper.down(scheduler.getElementFromEventRecord(eventRecord, resourceRecord), scheduler.eventInnerSelector);


    if (eventElement || !eventRecord.isPartOfStore(scheduler.eventStore)) {

      if (scheduler.trigger('beforeEventEdit', {
        eventEdit: me,
        eventRecord,
        resourceRecord,
        eventElement
      }) === false) {
        scheduler.element.classList.remove('b-eventeditor-editing');
        me.phantomEventElement && me.phantomEventElement.remove();
        me.phantomEventElement = null;
        return;
      }

      me.resourceRecord = resourceRecord;
      const editor = me.getEditor(eventRecord);
      super.internalShowEditor && super.internalShowEditor(eventRecord, resourceRecord, element);

      if (me.typeField) {
        me.toggleEventType(eventRecord.get(me.typeField));
      }


      scheduler.trigger('beforeEventEditShow', {
        eventEdit: me,
        eventRecord,
        resourceRecord,
        eventElement,
        editor
      });

      me.isEditing = true;
      me.loadRecord(eventRecord, resourceRecord);

      if (eventElement) {
        eventElement.classList.add('b-editing');
        editor.showBy({
          target: eventElement,
          anchor: true
        });
      } else {
        editor.showBy({
          target: scheduler.element,
          anchor: false,
          align: 'c-c'
        });
      }

      const timeResolution = scheduler.timeAxisViewModel.timeResolution;

      if (timeResolution.unit === 'hour' || timeResolution.unit === 'minute') {
        me.startTimeField.step = me.endTimeField.step = `${timeResolution.increment}${timeResolution.unit}`;
      }
    }
  }


  editEvent(eventRecord, resourceRecord, element = null) {
    const me = this,
      scheduler = me.scheduler,
      isNewRecord = scheduler.eventStore.indexOf(eventRecord) < 0;

    if (me.isEditing) {

      me.resetEditingContext();
    }

    if (scheduler.readOnly || me.disabled) {
      return;
    }


    scheduler.element.classList.add('b-eventeditor-editing');

    if (!resourceRecord) {
      if (eventRecord.resource) {
        resourceRecord = eventRecord.resource;
      } else if (eventRecord.resourceId) {
        resourceRecord = scheduler.resourceStore.getById(eventRecord.resourceId);
      }
    }

    if (isNewRecord) {

      this.phantomEventElement = element;
    }


    if (element || isNewRecord) {
      me.internalShowEditor(eventRecord, resourceRecord, element);
    } else {


      scheduler.scrollResourceEventIntoView(resourceRecord, eventRecord, null, {
        animate: true,
        edgeOffset: 0,
        extendTimeAxis: false
      }).then(() => me.internalShowEditor(eventRecord, resourceRecord), () => scheduler.element.classList.remove('b-eventeditor-editing'));
    }
  }


  loadRecord(eventRecord, resourceRecord) {
    this.loadingRecord = true;
    this.internalLoadRecord(eventRecord, resourceRecord);
    this.loadingRecord = false;
  }

  internalLoadRecord(eventRecord, resourceRecord) {
    const me = this,
      {
        eventStore
      } = me.client;
    me.eventRecord = eventRecord;
    me.resourceRecord = resourceRecord;
    me.editor.record = eventRecord;

    if (me.resourceField) {
      const resources = eventStore.getResourcesForEvent(eventRecord);

      if (!eventStore.storage.includes(eventRecord, true) && me.resourceRecord) {
        me.resourceField.value = me.resourceRecord[me.resourceField.valueField];
      } else if (me.scheduler.assignmentStore) {
        me.resourceField.value = resources.map(resource => resource[me.resourceField.valueField]);
      }
    }

    super.internalLoadRecord(eventRecord, resourceRecord);
  }

  toggleEventType(eventType) {

    this.editor.element.dataset.eventType = eventType || '';

    this.editor.eachWidget(widget => widget.dataset && widget.dataset.eventType && (widget.hidden = widget.dataset.eventType !== eventType));
  }


  get values() {
    const values = super.values;

    if (!this.scheduler.assignmentStore && values.resource) {
      values.resourceId = values.resource.id;
      delete values.resource;
    }

    return values;
  }

  finalizeEventSave(eventRecord, resourceRecords, resolve, reject) {
    const me = this,
      {
        scheduler,
        eventStore
      } = me;
    me.onBeforeSave(eventRecord);
    eventRecord.beginBatch();
    me.updateRecord(eventRecord);
    eventRecord.endBatch();

    if (eventStore && !eventRecord.stores.length) {

      if (scheduler.trigger('beforeEventAdd', {
        eventRecord,
        resourceRecords,
        resources: resourceRecords
      }) !== false) {


        if (scheduler.isInTimeAxis(eventRecord)) {
          if (me.phantomEventElement) {
            const eventTpl = scheduler.generateTplData(eventRecord, resourceRecords[0]);

            if (eventTpl) {
              DomHelper.syncClassList(me.phantomEventElement, eventTpl.wrapperCls);
              DomHelper.createElement({
                tag: 'div',
                parent: me.phantomEventElement,
                className: eventTpl.cls.toString()
              });

              me.phantomEventElement.classList.add('b-sch-dragcreator-proxy');
              me.phantomEventElement.id = eventTpl.id;
              me.phantomEventElement.dataset.syncId = eventRecord.id;
              scheduler.isHorizontal && scheduler.currentOrientation.releaseTimeSpanDiv(me.phantomEventElement, true);
              me.phantomEventElement = null;


              eventRecord.instanceMeta(scheduler).fromDragProxy = true;
            }
          }
        } else {
          me.phantomEventElement.remove();
        }


        me.eventStore.add(eventRecord);
        me.eventStore.assignEventToResource(eventRecord, resourceRecords);

        if (!me.eventStore.includes(eventRecord)) {

          const proxyElement = scheduler.element.querySelector('.b-sch-dragcreator-proxy');

          if (proxyElement) {
            scheduler.currentOrientation.availableDivs.remove(proxyElement);
            proxyElement.remove();
          }
        }
      } else {
        resolve(false);
        return;
      }
    } else if (scheduler.assignmentStore) {
      me.eventStore.assignEventToResource(eventRecord, resourceRecords, true);
    }


    scheduler.trigger('afterEventSave', {
      eventRecord
    });
    me.onAfterSave(eventRecord);
    resolve(eventRecord);
  }


  save() {
    return new Promise((resolve, reject) => {
      const me = this,
        {
          scheduler,
          eventRecord
        } = me;

      if (!eventRecord || !me.isValid) {
        resolve(false);
        return;
      }

      const {
          eventStore,
          values
        } = me,
        resourceRecords = me.resourceField && me.resourceField.records || [me.resourceRecord],
        resourceRecord = resourceRecords[0];

      if (!me.scheduler.allowOverlap && eventStore) {
        const abort = resourceRecords.some(resource => {
          return !eventStore.isDateRangeAvailable(values.startDate, values.endDate, eventRecord, resource);
        });

        if (abort) {
          resolve(false);
          return;
        }
      }

      const context = {
        finalize(saveEvent) {
          try {
            if (saveEvent !== false) {
              me.finalizeEventSave(eventRecord, resourceRecords, resolve, reject);
            } else {
              resolve(false);
            }
          } catch (e) {
            reject(e);
          }
        }

      };


      if (scheduler.trigger('beforeEventSave', {
        eventRecord,
        resourceRecords,
        resourceRecord,
        values,
        context
      }) !== false) {
        context.finalize();
      } else if (!context.async) {
        resolve();
      }
    });
  }


  deleteEvent() {
    return new Promise((resolve, reject) => {
      const me = this,
        {
          eventRecord,
          editor
        } = me;
      me.scheduler.removeRecords([eventRecord], removeRecord => {


        if (removeRecord && editor.containsFocus) {
          editor.revertFocus();
        }

        resolve(removeRecord);
      });
    });
  }


  get resourceStore() {
    return this._resourceStore;
  }

  set resourceStore(store) {
    this._resourceStore = store;

    if (this.resourceField) {
      this.resourceField.store = store;
    }
  }


  onActivateEditor({
                     eventRecord,
                     resourceRecord,
                     eventElement
                   }) {
    this.editEvent(eventRecord, resourceRecord, eventElement);
  }

  onDragCreateEnd({
                    newEventRecord,
                    resourceRecord,
                    proxyElement
                  }) {
    const me = this;

    if (!me.disabled) {

      me.scheduler.onEventCreated(newEventRecord);

      const phantomEventElement = proxyElement.cloneNode(true);
      phantomEventElement.removeAttribute('id');
      proxyElement.parentElement.appendChild(phantomEventElement);
      me.editEvent(newEventRecord, resourceRecord, phantomEventElement);
    }
  }

  onEventEnterKey({
                    assignmentRecord,
                    eventRecord
                  }) {
    if (assignmentRecord) {
      this.editEvent(eventRecord, assignmentRecord.resource);
    } else if (eventRecord) {
      this.editEvent(eventRecord, eventRecord.resource);
    }
  }

  onEventTypeChange({
                      value
                    }) {
    this.toggleEventType(value);
  }


  getEventMenuItems({
                      eventRecord,
                      resourceRecord,
                      items
                    }) {
    if (!this.scheduler.readOnly) {
      items.editEvent = {
        text: this.L('Edit Event'),
        icon: 'b-icon b-icon-edit',
        weight: -200,
        onItem: () => {
          this.editEvent(eventRecord, resourceRecord);
        }
      };
    }
  }

}

EventEdit._$name = 'EventEdit';
GridFeatureManager.registerFeature(EventEdit, true, 'Scheduler');


class EventFilter extends InstancePlugin {

  static get $name() {
    return 'EventFilter';
  }

  static get pluginConfig() {
    return {
      chain: ['getHeaderMenuItems']
    };
  }

  construct(scheduler, config) {
    super.construct(scheduler, config);
    this.scheduler = scheduler;
  }


  getHeaderMenuItems(column, items) {
    const me = this;
    if (column.type !== 'timeAxis') return;
    items.push({
      text: me.L('filterEvents'),
      icon: 'b-fw-icon b-icon-filter',
      disabled: me.disabled,
      menu: {
        type: 'popup',
        items: [{
          type: 'textfield',
          cls: 'b-eventfilter b-last-row',
          clearable: true,
          keyStrokeChangeDelay: 300,
          label: me.L('byName'),
          width: 200,
          listeners: {
            change: me.onEventFilterChange,
            thisObj: me
          }
        }],

        onBeforeShow({
                       source: menu
                     }) {
          const [filterByName] = menu.items,
            filter = me.scheduler.eventStore.filters.getBy('property', 'name');
          filterByName.value = filter && filter.value;
        }

      }
    });
  }

  onEventFilterChange({
                        value
                      }) {
    const me = this;

    if (value !== '') {
      me.scheduler.eventStore.filter('name', value);
    } else {
      me.scheduler.eventStore.removeFilter('name');
    }
  }

}

EventFilter.featureClass = 'b-event-filter';
EventFilter._$name = 'EventFilter';
GridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);


const tipAlign = {
  top: 'b-t',
  right: 'b100-t100',
  bottom: 't-b',
  left: 'b0-t0'
};


class ResizeBase extends InstancePlugin {

  static get defaultConfig() {
    return {

      showTooltip: true,


      showExactResizePosition: false,


      validatorFn: () => {
      },


      validatorFnThisObj: null,


      tip: null,
      tipTemplate: data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }


  render() {
    const me = this;
    me.resize && me.resize.destroy();
    me.resize = me.createResizeHelper();

    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        scheduler: me.client
      });
    }
  }

  doDestroy() {
    const me = this;
    me.tip && me.tip.destroy();
    me.clockTemplate && me.clockTemplate.destroy();
    me.resize && me.resize.destroy();
    super.doDestroy();
  }


  isElementResizable(element, event) {
    const {
        client,
        resize
      } = this,
      timespanRecord = client.resolveTimeSpanRecord(element);

    if (client.readOnly) {
      return false;
    }

    let resizable = timespanRecord && timespanRecord.isResizable;

    element = DomHelper.up(event.target, client.eventSelector);


    const handleHoldingElement = element ? element.firstElementChild : element,
      handleEl = event.target.closest('[class$="-handle"]');

    if (!resizable || handleEl && handleEl !== handleHoldingElement) {
      return false;
    }

    const startsOutside = element.classList.contains('b-sch-event-startsoutside'),
      endsOutside = element.classList.contains('b-sch-event-endsoutside');

    if (resizable === true) {
      if (startsOutside && endsOutside) {
        return false;
      } else if (startsOutside) {
        resizable = 'end';
      } else if (endsOutside) {
        resizable = 'start';
      } else {
        return resize.overStartHandle(event, element) || resize.overEndHandle(event, element);
      }
    }

    if (startsOutside && resizable === 'start' || endsOutside && resizable === 'end') {
      return false;
    }

    if (resize.overStartHandle(event, element) && resizable === 'start' || resize.overEndHandle(event, element) && resizable === 'end') {
      return true;
    }

    return false;
  }

  onBeforeResizeStart({
                        element,
                        event
                      }) {
    const {
        client
      } = this,
      name = client.scheduledEventName,
      timespanRecord = client.resolveTimeSpanRecord(element);

    if (this.disabled) {
      return false;
    }

    return client.trigger(`before${client.capitalizedEventName}Resize`, {
      [name + 'Record']: timespanRecord,
      event
    }) !== false;
  }

  onResizeStart({
                  context,
                  event
                }) {
    const me = this,
      client = me.client,
      timespanRecord = client.resolveTimeSpanRecord(context.element),
      name = client.scheduledEventName;
    client.element.classList.add('b-resizing-event');

    me.setupProductResizeContext(context, event);

    if (me.showTooltip) {
      if (me.tip) {
        me.tip.align = tipAlign[context.edge];
        me.tip.showBy(me.getTooltipTarget());
      } else {
        me.tip = new Tooltip({
          id: `${client.id}-event-resize-tip`,
          autoShow: true,
          axisLock: true,
          trackMouse: false,
          updateContentOnMouseMove: true,
          getHtml: me.getTipHtml.bind(me),
          align: tipAlign[context.edge],
          hideDelay: 0
        });
        me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
      }
    }

    timespanRecord.instanceMeta(client).retainElement = true;

    client.trigger(`${name}ResizeStart`, {
      [`${name}Record`]: timespanRecord,
      event
    });
  }

  updateDateIndicator() {
    const {
        edge,
        startDate,
        endDate
      } = this.resize.context,
      {
        element
      } = this.tip;

    if (startDate || endDate) {
      if (edge === 'right' || edge === 'bottom') {
        this.clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);
      } else {
        this.clockTemplate.updateDateIndicator(element, startDate);
      }
    }
  }

  getTooltipTarget() {
    const me = this,
      target = Rectangle.from(me.resize.context.element, null, true);

    if (me.resize.direction === 'horizontal') {

      if (me.resize.context.edge === 'right') {
        target.x = target.right - 1;
      }

      target.width = me.tip.anchorSize[0] / 2;
    } else {

      if (me.resize.context.edge === 'bottom') {
        target.y = target.bottom - 1;
      }

      target.height = me.tip.anchorSize[1] / 2;
    }

    return {
      target
    };
  }

  onResizing({
               context,
               event
             }) {
    const me = this,
      {
        client
      } = me,
      depFeature = client.features.dependencies,
      timespanRecord = me.getTimespanRecord(context),
      name = client.scheduledEventName,
      {
        element,
        edge
      } = context,
      xy = DomHelper.getTranslateXY(element);
    let start, end;

    if (edge === 'top' || edge === 'left') {
      end = timespanRecord.endDate;

      if (client.snapRelativeToEventStartDate) {
        start = client.getDateFromXY(xy, null, true);
        start = client.timeAxis.roundDate(start, timespanRecord.startDate);
      } else {
        start = client.getDateFromXY(xy, 'round', true);
      }
    } else {
      xy[0] += element.offsetWidth;
      xy[1] += element.offsetHeight;
      start = timespanRecord && timespanRecord.startDate;

      if (client.snapRelativeToEventStartDate) {
        end = client.getDateFromXY(xy, null, true);
        end = client.timeAxis.roundDate(end, timespanRecord.endDate);
      } else {
        end = client.getDateFromXY(xy, 'round', true);
      }
    }

    start = start || context.startDate;
    end = end || context.endDate;

    if (context.dateConstraints) {
      start = DateHelper.constrain(start, context.dateConstraints.start, context.dateConstraints.end);
      end = DateHelper.constrain(end, context.dateConstraints.start, context.dateConstraints.end);
    }

    if (me.showExactResizePosition || client.timeAxisViewModel.snap) {
      const exactSize = edge === 'top' || edge === 'left' ? client.timeAxisViewModel.getDistanceBetweenDates(start, timespanRecord.endDate) : client.timeAxisViewModel.getDistanceBetweenDates(timespanRecord.startDate, end);

      switch (edge) {
        case 'top':
          DomHelper.setTranslateY(element, context.elementStartY + context.elementWidth - exactSize);
          element.style.height = exactSize + 'px';
          break;

        case 'right':
          element.style.width = exactSize + 'px';
          break;

        case 'bottom':
          element.style.height = exactSize + 'px';
          break;

        case 'left':
          DomHelper.setTranslateX(element, context.elementStartX + context.elementWidth - exactSize);
          element.style.width = exactSize + 'px';
          break;
      }
    }

    const dateChanged = context.endDate - end !== 0 || context.startDate - start !== 0;
    context.endDate = end;
    context.startDate = start;

    if (dateChanged) {
      context.valid = me.checkValidity(context, event);
    }

    client.trigger(`${name}PartialResize`, {
      [`${name}Record`]: timespanRecord,
      startDate: start,
      endDate: end,
      element,
      context
    });

    if (depFeature) {
      depFeature.updateDependenciesForTimeSpan(timespanRecord, element);
    }

    if (me.showTooltip) {
      me.tip.alignTo(me.getTooltipTarget());
    }
  }

  checkValidity(context, event) {
    let valid = context.startDate && context.endDate > context.startDate && this.validatorFn.call(this.validatorFnThisObj || this, context, event);

    if (valid && typeof valid !== 'boolean') {
      context.message = valid.message || '';
      valid = valid.valid;
    }

    return valid !== false;
  }

  onFinishResize({
                   source: drag,
                   context,
                   event
                 }) {
    const me = this,
      timespanRecord = me.getTimespanRecord(context),
      oldStart = timespanRecord.startDate,
      oldEnd = timespanRecord.endDate,
      start = context.startDate || oldStart,
      end = context.endDate || oldEnd,
      client = me.client;
    let modified = false;

    timespanRecord.instanceMeta(client).retainElement = false;
    const old = context.finalize;

    context.finalize = (...params) => {


      context.async && me.finalize(...params);
      old.call(context, params);
    };

    context.valid = start && end && end - start > 0 && (
      start - oldStart !== 0 || end - oldEnd !== 0) &&
      context.valid !== false;

    if (context.valid) {


      client.trigger(`before${client.scheduledEventName}ResizeFinalize`, {
        context,
        event
      });
      modified = true;
    }

    if (!context.async) {
      me.finalize(modified);
    }
  }

  onCancelResize({
                   context
                 }) {
    const timespanRecord = this.getTimespanRecord(context);

    if (timespanRecord) {
      timespanRecord.instanceMeta(this.client).retainElement = false;
    }

    this.finalize(false);
  }

  finalize(updateRecord) {
    const me = this,
      {
        client
      } = me,
      context = me.resize.context,
      timespanRecord = me.getTimespanRecord(context),
      name = client.scheduledEventName;
    let wasChanged = false;

    if (me.tip) {
      me.tip.hide();
    }

    if (context.started) {
      if (updateRecord) {

        wasChanged = me.internalUpdateRecord(context, timespanRecord);
      }

      if (!updateRecord || !wasChanged) {
        const dependencies = client.features.dependencies;
        me.resize.abortResize(null, true);


        if (dependencies) {
          dependencies.scheduleDraw(true);
        }
      }
    }

    client.element.classList.remove('b-resizing-event');

    client.trigger(`${name}ResizeEnd`, {
      changed: wasChanged,
      [`${name}Record`]: timespanRecord || client.resolveEventRecord(context.element)
    });
  }


  getTipHtml({
               tip
             }) {
    const me = this;
    let {
      startDate,
      endDate,
      valid,
      message
    } = me.resize.context;

    if (!startDate || !endDate) {
      return tip.html;
    }

    if (message === undefined) message = '';
    endDate = me.client.getDisplayEndDate(endDate, startDate);
    const startText = me.client.getFormattedDate(startDate),
      endText = me.client.getFormattedDate(endDate);
    return me.tipTemplate({
      valid,
      startDate,
      endDate,
      startText,
      endText,
      message,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: me.clockTemplate.template({
        date: endDate,
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })
    });
  }


  getRowRecord(context) {
    throw new Error('Implement in subclass');
  }

  getTimespanRecord(context) {
    throw new Error('Implement in subclass');
  }

  setupProductResizeContext(context, event) {
    throw new Error('Implement in subclass');
  }

  get store() {
    throw new Error('Implement in subclass');
  }

}

ResizeBase._$name = 'ResizeBase';


class EventResize extends ResizeBase {


  static get $name() {
    return 'EventResize';
  }

  createResizeHelper() {
    const me = this,
      client = me.client;
    return new ResizeHelper({
      direction: client.isVertical ? 'vertical' : 'horizontal',
      name: me.constructor.$name,

      isElementResizable: (el, event) => me.isElementResizable(el, event),
      targetSelector: client.eventSelector,
      handleContainerSelector: client.eventInnerSelector,
      resizingCls: 'b-sch-event-wrap-resizing',
      allowResize: me.isElementResizable.bind(me),
      outerElement: client.timeAxisSubGridElement,

      scrollManager: client.scrollManager,
      dragThreshold: 0,
      dynamicHandleSize: true,
      reservedSpace: 5,
      scroller: client.timeAxisSubGrid.scrollable,

      listeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onFinishResize,
        cancel: me.onCancelResize,
        thisObj: me
      }
    });
  }

  get store() {
    return this.client.eventStore;
  }

  getTimespanRecord(context) {
    return context.eventRecord;
  }

  getRowRecord(context) {
    return context.resourceRecord;
  }

  setupProductResizeContext(context, event) {
    const scheduler = this.client,
      eventRecord = scheduler.resolveEventRecord(context.element),
      resourceRecord = scheduler.resolveResourceRecord(context.element);
    Object.assign(context, {
      eventRecord,
      resourceRecord,
      dateConstraints: scheduler.getDateConstraints(resourceRecord, eventRecord)
    });
  }

  onResizeStart({
                  context,
                  event
                }) {
    super.onResizeStart({
      context,
      event
    });

    if (this.client.features.dependencies) {
      this.client.features.dependencies.hideTerminals(context.element);
    }

    context.element.querySelector('.b-sch-event').classList.add('b-sch-event-resizing');
  }

  checkValidity(context, event) {
    return (this.client.allowOverlap || this.client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)) && super.checkValidity(context, event);
  }

  onFinishResize({
                   source,
                   context,
                   event
                 }) {
    super.onFinishResize({
      source,
      context,
      event
    });

    if (this.client.features.dependencies) {
      this.client.features.dependencies.showTerminals(context.eventRecord, context.element);
    }
  }

  internalUpdateRecord(context, timespanRecord) {
    const {
        store
      } = this,
      {
        generation
      } = timespanRecord;

    if (context.edge === 'left' || context.edge === 'top') {
      timespanRecord.setStartDate(context.startDate, false, store.skipWeekendsDuringDragDrop);
    } else {
      timespanRecord.setEndDate(context.endDate, false, store.skipWeekendsDuringDragDrop);
    }

    if (timespanRecord.generation !== generation) {
      return true;
    }

    this.client.repaintEventsForResource(context.resourceRecord);
    return false;
  }

  finalize(updateRecord) {
    this.resize.context.element.querySelector('.b-sch-event').classList.remove('b-sch-event-resizing');
    super.finalize(updateRecord);
  }

}

EventResize._$name = 'EventResize';
GridFeatureManager.registerFeature(EventResize, true, 'Scheduler');


class TooltipBase extends InstancePlugin {

  static get defaultConfig() {
    return {

      autoUpdate: false,
      template: null,
      cls: null,
      align: {
        align: 'b-t'
      },
      clockTemplate: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }


  construct(client, config) {
    const me = this;

    config = me.processConfig(config);
    super.construct(client, config);

    if (!me.forSelector) {
      me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy)`;
    }

    me.clockTemplate = new ClockTemplate({
      scheduler: client
    });
    client.on({
      [`before${client.scheduledEventName}drag`]: () => {
        me.tooltip && me.tooltip.hide();
      }
    });
  }


  processConfig(config) {
    if (typeof config === 'function') {
      return {
        template: config
      };
    }

    return config;
  }

  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }

  doDestroy() {
    this.clockTemplate && this.clockTemplate.destroy();
    this.tooltip && this.tooltip.destroy();
    super.doDestroy();
  }

  doDisable(disable) {
    if (this.tooltip) {
      this.tooltip.disabled = disable;
    }

    super.doDisable(disable);
  }

  render() {
    const me = this,
      client = me.client,
      ignoreSelector = ['.b-dragselecting', '.b-eventeditor-editing', '.b-resizing-event', '.b-dragcreating', `.b-dragging-${client.scheduledEventName}`, '.b-creating-dependency', '.b-dragproxy'].map(cls => `:not(${cls})`).join('');

    if (me.tooltip) {
      me.tooltip.destroy();
    }


    me.tooltip = new Tooltip(Object.assign({
      axisLock: 'flexible',
      id: me.tipId || `${me.client.id}-event-tip`,
      cls: me.tipCls,
      forSelector: `.b-timelinebase${ignoreSelector} .b-grid-body-container:not(.b-scrolling) ${me.forSelector}`,
      scrollAction: 'realign',
      clippedBy: [client.timeAxisSubGridElement, client.bodyContainer],
      forElement: client.timeAxisSubGridElement,
      showOnHover: true,
      hoverDelay: 0,
      hideDelay: 100,
      anchorToTarget: true,
      allowOver: Boolean(me.config.items || me.config.tools),
      getHtml: me.getTipHtml.bind(me),
      disabled: me.disabled
    }, me.config));
    me.tooltip.on('innerhtmlupdate', me.updateDateIndicator, me);
  }

  updateDateIndicator() {
    const me = this,
      client = me.client,
      tip = me.tooltip,
      timeSpanRecord = tip.activeTarget && client.resolveTimeSpanRecord(tip.activeTarget),
      endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');
    if (!timeSpanRecord) return;
    me.clockTemplate.updateDateIndicator(tip.element, timeSpanRecord.startDate);
    endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, timeSpanRecord.endDate);
  }

  resolveTimeSpanRecord(forElement) {
    return this.client.resolveTimeSpanRecord(forElement);
  }

  getTipHtml({
               tip,
               activeTarget
             }) {
    const me = this,
      client = me.client,
      recordProp = me.recordType || `${client.scheduledEventName}Record`,
      timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);


    if (timeSpanRecord) {
      const {
          startDate,
          endDate
        } = timeSpanRecord,
        startText = client.getFormattedDate(startDate),
        endDateValue = client.getDisplayEndDate(endDate, startDate),
        endText = client.getFormattedDate(endDateValue);
      tip.eventRecord = timeSpanRecord;
      tip.title = timeSpanRecord.name;
      return me.template({
        tip,

        [`${recordProp}`]: timeSpanRecord,
        startDate,
        endDate,
        startText,
        endText,
        startClockHtml: me.clockTemplate.template({
          date: startDate,
          text: startText,
          cls: 'b-sch-tooltip-startdate'
        }),
        endClockHtml: timeSpanRecord.isMilestone ? '' : me.clockTemplate.template({
          date: endDateValue,
          text: endText,
          cls: 'b-sch-tooltip-enddate'
        })
      });
    } else {
      tip.hide();
      return '';
    }
  }

}

TooltipBase._$name = 'TooltipBase';


class EventTooltip extends TooltipBase {

  static get $name() {
    return 'EventTooltip';
  }

  static get defaultConfig() {
    return {

      template: data => `
                ${data.eventRecord.name ? `<div class="b-sch-event-title">${data.eventRecord.name}</div>` : ''}
                ${data.startClockHtml}
                ${data.endClockHtml}`,
      cls: 'b-sch-event-tooltip'
    };
  }

  construct(client, config) {
    const me = this;
    super.construct(client, config);

    if (typeof me.align === 'string') {
      me.align = {
        align: me.align
      };
    }
  }

  render() {
    const me = this,
      dependencies = me.client.features.dependencies;
    super.render();

    if (dependencies) {
      const configuredOffset = me.align.offset;
      me.tooltip.on('beforeshow', ({
                                     source: tooltip
                                   }) => {

        if (!dependencies.disabled) {
          tooltip.align.offset = [0, 10];
        } else {
          tooltip.align.offset = configuredOffset;
        }
      });
    }
  }

}

EventTooltip._$name = 'EventTooltip';
GridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');


class HeaderContextMenu extends InstancePlugin {
  static get $name() {
    return 'HeaderContextMenu';
  }

  static get defaultConfig() {
    return {

      extraItems: null,


      processItems: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['getHeaderMenuItems']
    };
  }

  construct(scheduler, config) {
    super.construct(scheduler, config);
    this.scheduler = scheduler;
  }


  getHeaderMenuItems(column, items) {
    const me = this,
      {
        scheduler,
        processItems
      } = me,
      {
        timeAxis
      } = scheduler,
      dateStep = {
        magnitude: timeAxis.shiftIncrement,
        unit: timeAxis.shiftUnit
      };

    if (column.type !== 'timeAxis') {
      return;
    }

    items.push({
      text: me.L('pickZoomLevel'),
      icon: 'b-fw-icon b-icon-search-plus',
      disabled: !scheduler.presets.count || me.disabled,
      menu: {
        type: 'popup',
        items: [{
          type: 'slider',
          showValue: false,
          listeners: {
            input: me.onZoomSliderChange,
            thisObj: me
          },

          minWidth: 130
        }],

        onBeforeShow({
                       source: menu
                     }) {
          const [zoom] = menu.items;
          zoom.min = scheduler.minZoomLevel;
          zoom.max = scheduler.maxZoomLevel;
          zoom.value = scheduler.zoomLevel;
        }

      }
    });
    me.startDateField = new DateField({
      label: me.L('startText'),
      labelWidth: '6em',
      required: true,
      step: dateStep,
      listeners: {
        change: me.onRangeDateFieldChange,
        thisObj: me
      }
    });
    me.endDateField = new DateField({
      label: me.L('endText'),
      labelWidth: '6em',
      required: true,
      step: dateStep,
      listeners: {
        change: me.onRangeDateFieldChange,
        thisObj: me
      }
    });
    items.push({
      text: me.L('activeDateRange'),
      icon: 'b-fw-icon b-icon-calendar',
      disabled: me.disabled,
      menu: {
        type: 'popup',
        width: '20em',
        items: [me.startDateField, me.endDateField, {
          type: 'button',
          cls: 'b-left-nav-btn',
          icon: 'b-icon b-icon-prev',
          color: 'b-blue b-raised',
          flex: 1,
          margin: 0,
          listeners: {
            click: me.onLeftShiftBtnClick,
            thisObj: me
          }
        }, {
          type: 'button',
          cls: 'b-today-nav-btn',
          color: 'b-blue b-raised',
          text: me.L('todayText'),
          flex: 4,
          margin: '0 8',
          listeners: {
            click: me.onTodayBtnClick,
            thisObj: me
          }
        }, {
          type: 'button',
          cls: 'b-right-nav-btn',
          icon: 'b-icon b-icon-next',
          color: 'b-blue b-raised',
          flex: 1,
          listeners: {
            click: me.onRightShiftBtnClick,
            thisObj: me
          }
        }],
        onBeforeShow: () => me.initDates()
      }
    });

    if (me.extraItems) {
      items.push.apply(items, me.extraItems);
    }

    if (processItems) {
      processItems({
        items
      });
    }
  }

  onZoomSliderChange({
                       value
                     }) {
    const menu = this.client.features.contextMenu.currentMenu;


    menu.scrollAction = 'realign';
    this.scheduler.zoomLevel = value;
    menu.setTimeout({
      fn: () => menu.scrollAction = 'hide',
      delay: 100,
      cancelOutstanding: true
    });
  }

  initDates() {
    const me = this;
    me.startDateField.suspendEvents();
    me.endDateField.suspendEvents();


    me.startDateField.value = me.startDateFieldInitialValue = me.scheduler.startDate;
    me.endDateField.value = me.endDateFieldInitialValue = me.scheduler.endDate;
    me.startDateField.resumeEvents();
    me.endDateField.resumeEvents();
  }

  onRangeDateFieldChange({
                           source
                         }) {
    const me = this,
      startDateChanged = source === me.startDateField,
      {
        client
      } = me,
      {
        timeResolution
      } = client,
      {
        scrollable
      } = client.timeAxisSubGrid,
      startDate = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value,
      viewportStartDate = client.getDateFromX(scrollable.x);
    let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;


    if (startDateChanged) {
      me.startDateFieldInitialValue = null;
    } else {
      me.endDateFieldInitialValue = null;
    }


    if (!(endDate - startDate)) {
      endDate = DateHelper.add(endDate, timeResolution.increment, timeResolution.unit);
    } else if (endDate < startDate) {
      endDate = DateHelper.add(startDate, timeResolution.increment, timeResolution.unit);
    }

    me.scheduler.timeAxis.setTimeSpan(startDate, endDate);

    scrollable.x = client.getCoordinateFromDate(viewportStartDate, true);
    me.initDates();
  }

  onLeftShiftBtnClick() {
    const me = this;
    me.scheduler.timeAxis.shiftPrevious();
    me.initDates();
  }

  onTodayBtnClick() {
    const me = this,
      today = DateHelper.clearTime(new Date());
    me.scheduler.timeAxis.setTimeSpan(today, DateHelper.add(today, 1, 'day'));
    me.initDates();
  }

  onRightShiftBtnClick() {
    const me = this;
    me.scheduler.timeAxis.shiftNext();
    me.initDates();
  }

}

HeaderContextMenu.featureClass = '';
HeaderContextMenu._$name = 'HeaderContextMenu';
GridFeatureManager.registerFeature(HeaderContextMenu, true, ['Scheduler', 'Gantt']);


class HeaderZoom extends InstancePlugin {
  static get $name() {
    return 'HeaderZoom';
  }

  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
    };
  }

  onElementMouseDown(event) {
    const me = this,
      scheduler = me.client;

    if (event.touches || event.button !== 0 || me.disabled) {
      return;
    }

    if (event.target.matches('.b-sch-header-timeaxis-cell')) {
      const headerEl = scheduler.subGrids.normal.header.headersElement;
      me.startX = event.clientX;
      me.element = DomHelper.createElement({
        parent: headerEl,
        tag: 'div',
        className: 'b-headerzoom-rect'
      });
      me.headerElementRect = Rectangle.from(headerEl);
    }
  }

  onElementMouseMove(event) {
    const me = this;


    if (event.buttons === 0 && !BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted)) {
      me.onElementMouseUp(event);
      return;
    }

    if (typeof me.startX === 'number') {
      const x = Math.max(event.clientX, me.headerElementRect.left),
        left = Math.min(me.startX, x),
        width = Math.abs(me.startX - x),
        rect = new Rectangle(left - me.headerElementRect.x + me.client.scrollLeft, 0, width, me.headerElementRect.height);
      DomHelper.setTranslateX(me.element, rect.left);
      me.element.style.width = rect.width + 'px';
    }
  }

  onElementMouseUp(event) {
    const me = this;

    if (typeof me.startX === 'number') {
      const timeline = me.client,
        rect = Rectangle.from(me.element),
        startDate = timeline.getDateFromCoordinate(rect.left, 'round', false),
        endDate = timeline.getDateFromCoordinate(rect.right, 'round', false);
      me.element && me.element.remove();
      me.startX = null;
      me.client.zoomToSpan({
        startDate,
        endDate
      });
    }
  }

}

HeaderZoom._$name = 'HeaderZoom';
GridFeatureManager.registerFeature(HeaderZoom, false, 'Scheduler');


class AbstractTimeRanges extends Delayable(InstancePlugin) {

  static get defaultConfig() {
    return {

      rangeCls: 'b-sch-range',

      lineCls: 'b-sch-line',


      store: {
        modelClass: TimeSpan
      },


      enableResizing: false,


      showTooltip: true,


      showHeaderElements: true,
      dragTipTemplate: data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    <div class="b-sch-tip-name">${data.name || ''}</div>
                    ${data.startClockHtml}
                    ${data.endClockHtml || ''}
                </div>
            `,
      baseCls: 'b-sch-timerange',

      cls: ''
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onPaint', 'getHeaderMenuItems']
    };
  }


  construct(client, config) {
    const me = this;
    super.construct(client, config);


    me.cls = me.cls || `b-timerange-${me.constructor.$name}`;
    me.baseSelector = `.${me.baseCls}.${me.cls}`;

    if (me.enableResizing) {
      me.showHeaderElements = true;
    }
  }

  doDestroy() {
    const me = this;
    me.storeDetacher && me.storeDetacher();
    me.timeAxisViewModelDetacher && me.timeAxisViewModelDetacher();
    me.timeAxisDetacher && me.timeAxisDetacher();
    me.clockTemplate && me.clockTemplate.destroy();
    me.tip && me.tip.destroy();
    me.drag && me.drag.destroy();
    me.resize && me.resize.destroy();
    super.doDestroy();
  }

  doDisable(disable) {
    if (this.client.isPainted) {
      this.renderRanges();
    }

    super.doDisable(disable);
  }


  onPaint() {
    const me = this;

    if (!me.isPainted) {
      me.timeAxisViewModel = me.client.timeAxisViewModel;
      me.timeAxisViewModelDetacher = me.timeAxisViewModel.on({
        reconfigure: me.onTimeAxisViewModelUpdate,
        update: me.onTimeAxisViewModelUpdate,
        thisObj: me
      });
      me.timeAxisDetacher = me.client.timeAxis.on({
        includeChange: me.onTimeAxisViewModelUpdate,
        thisObj: me
      });

      if (me.enableResizing && !me.client.hideHeaders) {
        me.drag = new DragHelper({
          name: 'rangeDrag',
          mode: me.client.isVertical ? 'translateY' : 'translateX',
          constrain: true,
          outerElement: me.headerContainerElement,
          targetSelector: `${me.baseSelector}`,
          isElementDraggable: (el, event) => !me.client.readOnly && me.isElementDraggable(el, event),
          transitionDuration: me.client.transitionDuration,
          listeners: {
            dragstart: me.onDragStart,
            drag: me.onDrag,
            drop: me.onDrop,
            abort: me.onInvalidDrop,
            thisObj: me
          }
        });
        me.resize = new ResizeHelper({
          direction: me.client.mode,
          targetSelector: `${me.baseSelector}.b-sch-range`,
          outerElement: me.headerContainerElement,
          isElementResizable: el => !el.closest('.b-dragging'),
          listeners: {
            resizestart: me.onResizeStart,
            resizing: me.onResizeDrag,
            resize: me.onResize,
            cancel: me.onInvalidResize,
            thisObj: me
          }
        });
      }

      me.renderRanges();
    }
  }

  renderRanges() {
    const me = this,
      element = me.client.foregroundCanvas;

    if (element) {
      const {
        headerContainerElement,
        store
      } = me;

      DomHelper.removeEachSelector(element, me.baseSelector);

      if (headerContainerElement) {
        DomHelper.removeEachSelector(headerContainerElement, me.baseSelector);
      }

      if (!me.disabled) {

        for (const range of store) {
          me.renderRange(range, true);
        }
      }
    }
  }

  renderRange(range, injectIntoDom) {
    const me = this,
      client = me.client;

    if (range.duration && client.timeAxis.timeSpanInAxis(range.startDate, range.endDate) || range.startDate && client.timeAxis.dateInAxis(range.startDate)) {
      const startPos = client.getCoordinateFromDate(DateHelper.max(range.startDate, client.timeAxis.startDate), {
          respectExclusion: true
        }),
        endPos = range.duration && client.getCoordinateFromDate(DateHelper.min(range.endDate, client.timeAxis.endDate), {
          respectExclusion: true,
          isEnd: true
        }),
        labelTpl = `<label>${range.name || '&nbsp;'}</label>`,
        config = {
          className: `${me.baseCls} ${me.cls} ${endPos ? me.rangeCls : me.lineCls} ${range.cls || ''}`,
          dataset: {
            id: range.id
          },
          style: client.isVertical ? `transform: translateY(${startPos}px); ${endPos ? `height:${endPos - startPos}px` : ''};` : `transform: translateX(${startPos}px); ${endPos ? `width:${endPos - startPos}px` : ''};`,
          retainElement: true

        },
        bodyElement = DomHelper.createElement(Object.assign({}, config, {
          parent: injectIntoDom && client.foregroundCanvas,
          style: config.style + (range.style || ''),
          html: me.showHeaderElements ? '' : labelTpl
        }));
      let headerElement;

      if (me.showHeaderElements) {
        headerElement = DomHelper.createElement(Object.assign({
          parent: injectIntoDom && me.headerContainerElement,
          html: range.name ? labelTpl : ''
        }, config));
      }

      const result = {
        bodyElement,
        headerElement
      };

      if (injectIntoDom) {

        me.rotateLabel(result);
      }

      return result;
    }
  }

  rotateLabel({
                bodyElement
              }) {
    const label = bodyElement.firstChild;

    if (!label) {
      return;
    }

    label.classList.remove('b-vertical');
    const rotate = this.client.isVertical ? label.offsetHeight < bodyElement.offsetHeight : label.offsetWidth > bodyElement.offsetWidth;

    label.classList[rotate ? 'add' : 'remove']('b-vertical');
  }

  getElementsByRecord(idOrRecord) {
    const id = typeof idOrRecord !== 'object' ? idOrRecord : idOrRecord.id,
      bodyElement = this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${id}"]`),
      headerElement = this.headerContainerElement.querySelector(`${this.baseSelector}[data-id="${id}"]`);
    return bodyElement ? {
      bodyElement,
      headerElement
    } : null;
  }

  getBodyElementByRecord(idOrRecord) {
    const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord.id;
    return this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${id}"]`);
  }

  getRecordByElement(el) {
    return this.store.getById(el.dataset.id);
  }

  get headerContainerElement() {
    const {
      isVertical,
      timeView,
      timeAxisColumn
    } = this.client;
    let element = null;

    if (isVertical && timeView.element) {
      element = timeView.element.parentElement;
    } else if (!isVertical) {
      element = timeAxisColumn.element;
    }

    return element;
  }


  get showHeaderElements() {
    return this._showHeaderElements;
  }

  set showHeaderElements(show) {
    this._showHeaderElements = show;
    if (!this.client.isPainted) return;

    if (show) {
      this.client.element.classList.add('b-sch-timeranges-with-headerelements');
    } else {
      this.client.element.classList.remove('b-sch-timeranges-with-headerelements');
    }

    this.renderRanges();
  }


  getHeaderMenuItems(column, items) {
    return [];
  }


  get store() {
    return this._store;
  }

  set store(store) {
    const me = this;
    me._store = Store.getStore(store, Store);
    let renderRanges = false;

    if (me.storeDetacher) {
      me.storeDetacher();

      renderRanges = true;
    }

    me.storeDetacher = me._store.on({
      change: me.onStoreChanged,
      refresh: me.onStoreChanged,
      thisObj: me
    });

    renderRanges && this.renderRanges();
  }


  onTimeAxisViewModelUpdate() {
    this.renderRanges();
  }

  onStoreChanged(event) {
    const me = this;

    if (me.isConfiguring || event.type === 'refresh' && event.action !== 'batch') {
      return;
    }

    if (event.action === 'update') {
      const id = event.changes.hasOwnProperty('id') ? event.changes.id.oldValue : event.record.id,
        existingElements = me.getElementsByRecord(id),
        redrawnElements = me.renderRange(event.record, !existingElements);

      if (existingElements && !redrawnElements) {
        existingElements.bodyElement.remove();
        existingElements.headerElement && existingElements.headerElement.remove();
      }

      if (!existingElements || !redrawnElements) return;
      me.client.runWithTransition(() => {
        DomHelper.sync(redrawnElements.bodyElement, existingElements.bodyElement);

        if (me.showHeaderElements) {
          DomHelper.sync(redrawnElements.headerElement, existingElements.headerElement);
        }

        me.rotateLabel(existingElements);
      });
    } else {
      me.renderRanges();
    }
  }


  showTip(context) {
    const me = this;

    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        scheduler: me.client
      });
      me.tip = new Tooltip({
        id: `${me.client.id}-time-range-tip`,
        cls: 'b-interaction-tooltip',
        align: 'b-t',
        autoShow: true,
        updateContentOnMouseMove: true,
        forElement: context.element,
        getHtml: () => me.getTipHtml(context.record, context.element)
      });
    }
  }

  isElementDraggable(el) {
    el = el.closest(this.baseSelector + ':not(.b-resizing)');
    return el && !el.classList.contains('b-over-resize-handle');
  }

  onDragStart({
                context
              }) {
    const me = this,
      record = me.getRecordByElement(context.element.closest(me.baseSelector)),
      rangeBodyEl = me.getBodyElementByRecord(record),
      drag = me.drag;
    Object.assign(context, {
      record,
      rangeBodyEl,
      originRangeX: DomHelper.getTranslateX(rangeBodyEl),
      originRangeY: DomHelper.getTranslateY(rangeBodyEl)
    });

    if (me.client.isVertical) {
      drag.minY = 0;

      drag.maxY = me.timeAxisViewModel.totalSize - context.rangeBodyEl.offsetHeight;

      drag.minX = 0;
      drag.maxX = Number.MAX_SAFE_INTEGER;
    } else {
      drag.minX = 0;

      drag.maxX = me.timeAxisViewModel.totalSize - context.rangeBodyEl.offsetWidth;

      drag.minY = 0;
      drag.maxY = Number.MAX_SAFE_INTEGER;
    }

    me.client.element.classList.add('b-dragging-timerange');
    me.showTip(context);
  }

  onDrag({
           context
         }) {

    if (this.client.isVertical) {
      DomHelper.setTranslateY(context.rangeBodyEl, DomHelper.getTranslateY(context.element));
    } else {
      DomHelper.setTranslateX(context.rangeBodyEl, DomHelper.getTranslateX(context.element));
    }
  }

  onDrop({
           context
         }) {
    if (!context.valid) {
      return this.onInvalidDrop({
        context
      });
    }

    const me = this,
      record = context.record,
      box = context.rangeBodyEl.getBoundingClientRect(),
      newStart = me.client.getDateFromCoordinate(me.client.isVertical ? box.top : box.left, 'round', false),
      wasModified = record.startDate - newStart !== 0;

    if (wasModified) {
      record.setStartDate(newStart);
    } else {
      me.onInvalidDrop();
    }

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }

    me.client.element.classList.remove('b-dragging-timerange');
  }

  onInvalidDrop() {
    const me = this;
    me.drag.reset();
    me.renderRanges();
    me.client.element.classList.remove('b-dragging-timerange');

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }


  onResizeStart({
                  context
                }) {
    const me = this,
      record = me.getRecordByElement(context.element.closest(me.baseSelector)),
      rangeBodyEl = me.getBodyElementByRecord(record);
    Object.assign(context, {
      record,
      rangeBodyEl
    });
    me.showTip(context);
  }

  onResizeDrag({
                 context
               }) {
    const me = this;

    if (me.client.isVertical) {
      if (context.edge === 'top') {
        DomHelper.setTranslateY(context.rangeBodyEl, context.newY);
      }

      context.rangeBodyEl.style.height = context.newHeight + 'px';
    } else {
      if (context.edge === 'left') {
        DomHelper.setTranslateX(context.rangeBodyEl, context.newX);
      }

      context.rangeBodyEl.style.width = context.newWidth + 'px';
    }
  }

  onResize({
             context
           }) {
    if (!context.valid) return this.onInvalidDrop({
      context
    });
    const me = this,
      {
        client
      } = me,
      record = context.record,
      box = context.element.getBoundingClientRect(),
      startPos = client.isVertical ? box.top : box.left,
      endPos = client.isVertical ? box.bottom : box.right,
      newStart = client.getDateFromCoordinate(startPos, 'round', false),
      isStart = context.edge === 'left' || context.edge === 'top',
      newEnd = client.getDateFromCoordinate(endPos, 'round', false),
      wasModified = isStart && record.startDate - newStart !== 0 || newEnd && record.endDate - newEnd !== 0;

    if (wasModified && newEnd > newStart) {
      if (isStart) {

        record.setStartDate(newStart, false);
      } else {
        record.setEndDate(newEnd, false);
      }
    } else {
      me.onInvalidResize();
    }

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }

  onInvalidResize() {
    const me = this;
    me.resize.reset();
    me.renderRanges();

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }


  getTipHtml(record, element) {
    const me = this,
      {
        client
      } = me,
      box = element.getBoundingClientRect(),
      startPos = client.isVertical ? box.top : box.left,
      endPos = client.isVertical ? box.bottom : box.right,
      startDate = client.getDateFromCoordinate(startPos, 'round', false),
      endDate = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),
      startText = client.getFormattedDate(startDate),
      endText = endDate && client.getFormattedEndDate(endDate, startDate);
    return me.dragTipTemplate({
      name: record.name || '',
      startDate: startDate,
      endDate: endDate,
      startText: startText,
      endText: endText,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: endText && me.clockTemplate.template({
        date: endDate,
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })
    });
  }

}

AbstractTimeRanges._$name = 'AbstractTimeRanges';


class NonWorkingTime extends AbstractTimeRanges {

  static get $name() {
    return 'NonWorkingTime';
  }

  static get defaultConfig() {
    return {

      highlightWeekends: true,
      showHeaderElements: true,
      cls: 'b-sch-nonworkingtime'
    };
  }


  construct(client, config) {
    const me = this;
    super.construct(client, config);

    if (!me.calendar || !client.calendar) {
      me.calendar = new Calendar();
    }

    me.bindCalendar(me.calendar);
  }

  doDestroy() {
    this.bindCalendar(null);
    super.doDestroy();
  }


  bindCalendar(calendar) {
    const me = this;
    if (me.calendarDetacher) me.calendarDetacher();

    if (calendar) {
      me.calendarDetacher = calendar.on({
        change: me.renderRanges,
        thisObj: me,
        delay: 1
      });
    }

    me.calendar = calendar;
    me.renderRanges();
  }


  renderRanges() {
    const me = this;

    if (me.store && !me.store.isDestroyed) {
      const shouldPaint = DateHelper.as(me.client.timeAxis.unit, 1, 'week') >= 1;
      me.store.removeAll(true);

      if (me.calendar && me.highlightWeekends && shouldPaint) {
        me.store.add(me.calendar.getHolidaysRanges(me.client.timeAxis.startDate, me.client.timeAxis.endDate, true), true);
      }
    }

    super.renderRanges();
  }

}

NonWorkingTime._$name = 'NonWorkingTime';
GridFeatureManager.registerFeature(NonWorkingTime, false, 'Scheduler');


class Pan extends InstancePlugin {

  static get $name() {
    return 'Pan';
  }

  static get defaultConfig() {
    return {

      vertical: true
    };
  }

  construct(timeline, config) {
    this.timeline = timeline;

    if (timeline.features.eventDragCreate && !timeline.features.eventDragCreate.disabled) {
      throw new Error('Cannot combine Pan and eventDragCreate features');
    }

    const targetSelectors = ['.b-grid-cell', '.b-timeline-subgrid'];
    this.targetSelector = targetSelectors.join(',');
    super.construct(timeline, config);
  }


  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
    };
  }

  onElementMouseDown(event) {
    const me = this,
      timeline = me.timeline,
      dragFeature = Object.values(timeline.features).find(feature => feature instanceof DragBase),
      enablePanOnEvents = timeline.readOnly || !dragFeature || dragFeature.disabled;

    if (event.touches || event.button !== 0 || me.disabled) {
      return;
    }

    if (event.target.matches(me.targetSelector) || enablePanOnEvents && event.target.closest(timeline.eventSelector)) {
      me.mouseX = event.clientX;
      me.mouseY = event.clientY;
    }
  }

  onElementMouseMove(event) {
    const me = this;


    if (event.buttons === 0 && !BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted)) {
      me.onElementMouseUp();
      return;
    }

    if (typeof me.mouseX === 'number') {
      const xScroller = me.timeline.subGrids.normal.scrollable,
        yScroller = me.timeline.scrollable,
        x = event.clientX,
        y = event.clientY;
      event.preventDefault();

      if (me.vertical) {
        yScroller.scrollBy(0, me.mouseY - y);
      }

      xScroller.scrollBy(me.mouseX - x);
      me.mouseX = x;
      me.mouseY = y;
    }
  }

  onElementMouseUp(event) {
    this.mouseX = this.mouseY = null;
  }

}

Pan._$name = 'Pan';
GridFeatureManager.registerFeature(Pan, false, ['Scheduler', 'Gantt']);


class ResourceTimeRangeModel extends TimeSpan {

  static get fields() {
    return [

      'resourceId',

      'timeRangeColor'];
  }

  static get relationConfig() {
    return [

      {
        relationName: 'resource',
        fieldName: 'resourceId',
        store: 'resourceStore',
        collectionName: 'timeRanges',
        nullFieldOnRemove: true
      }];
  }


  get isResourceTimeRange() {
    return true;
  }

  get resources() {
    return [this.resource];
  }

}

ResourceTimeRangeModel._$name = 'ResourceTimeRangeModel';


class ResourceTimeRangeStore extends AjaxStore {
  static get defaultConfig() {
    return {

      loadPriority: 500,


      syncPriority: 500,


      resourceStore: null,
      modelClass: ResourceTimeRangeModel,
      storeId: 'resourceTimeRanges'
    };
  }

  set resourceStore(store) {
    this._resourceStore = store;

    if (!this.isConfiguring) {
      this.initRelations(true);
    }
  }

  get resourceStore() {
    return this._resourceStore;
  }

  getResourcesForEvent(resourceTimeRange) {
    return [resourceTimeRange.resource];
  }

}

ResourceTimeRangeStore._$name = 'ResourceTimeRangeStore';


class ResourceTimeRanges extends InstancePlugin {

  static get $name() {
    return 'ResourceTimeRanges';
  }

  static get defaultConfig() {
    return {
      idPrefix: 'resourcetimerange',
      rangeCls: 'b-sch-resourcetimerange',


      store: false,


      resourceTimeRanges: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis']
    };
  }

  noFeatureElementsInAxis() {
    const {
      timeAxis
    } = this.scheduler;
    return !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));
  }


  construct(scheduler, config) {
    const me = this;
    me.scheduler = scheduler;
    super.construct(scheduler, config);

    Object.defineProperty(scheduler, 'resourceTimeRanges', {
      get: () => me.store.records,
      set: resourceTimeRanges => me.store.data = resourceTimeRanges
    });
  }

  doDisable(disable) {
    if (this.client.isPainted) {
      this.client.refresh();
    }

    super.doDisable(disable);
  }


  set store(store) {
    const me = this,
      {
        scheduler
      } = me;
    me._store = store = store || new ResourceTimeRangeStore();

    if (!scheduler.resourceTimeRangeStore) {
      scheduler.resourceTimeRangeStore = store;
    }

    if (scheduler.resourceTimeRanges) {
      store.add(scheduler.resourceTimeRanges);
      delete scheduler.resourceTimeRanges;
    }

    if (!store.resourceStore) {
      store.resourceStore = scheduler.resourceStore;
    }

    me.storeDetacher && me.storeDetacher();
    me.storeDetacher = me.store.on({
      change: me.onStoreChange,
      thisObj: me
    });
  }

  get store() {
    return this._store;
  }


  getEventsToRender(resource, events) {
    if (resource.timeRanges && resource.timeRanges.length && !this.disabled) {
      events.push(...resource.timeRanges);
    }

    return events;
  }


  onEventDataGenerated(renderData) {
    const me = this,
      record = renderData.event || renderData.eventRecord;

    if (record.isResourceTimeRange) {
      if (me.scheduler.isVertical) {
        renderData.width = me.scheduler.resourceColumnWidth;
      } else {
        renderData.top = 0;

        renderData.id = `${me.scheduler.id}-${me.idPrefix}-${record.id}`;
      }

      renderData.fillSize = true;

      renderData.wrapperCls[me.rangeCls] = 1;
      renderData.wrapperCls[`b-sch-color-${record.timeRangeColor}`] = record.timeRangeColor;

      renderData.body = document.createDocumentFragment();
      renderData.body.textContent = record.name;

      renderData.eventId = `${me.idPrefix}-${record.id}`;
      renderData.eventContent = record.name;
    }
  }

  onStoreChange(event) {
    this.scheduler.onInternalEventStoreChange(event);
  }

}

ResourceTimeRanges.featureClass = '';
ResourceTimeRanges._$name = 'ResourceTimeRanges';
GridFeatureManager.registerFeature(ResourceTimeRanges, false, 'Scheduler');


class SimpleEventEdit extends InstancePlugin {


  static get $name() {
    return 'SimpleEventEdit';
  }

  static get defaultConfig() {
    return {

      triggerEvent: 'eventdblclick',


      eventRecord: null,


      field: 'name',


      editorConfig: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onEventEnterKey'],
      assign: ['editEvent']
    };
  }


  construct(scheduler, config) {
    const me = this;
    me.scheduler = scheduler;
    me.eventStore = scheduler.eventStore;
    scheduler.eventEdit = me;
    super.construct(scheduler, config);
    me.clientListenersDetacher = scheduler.on({
      [me.triggerEvent]: ({
                            eventRecord,
                            eventElement
                          }) => me.editEvent(eventRecord, eventRecord.resource, eventElement),
      dragcreateend: me.onDragCreateEnd,
      thisObj: me
    });
  }

  doDestroy() {
    this.clientListenersDetacher();
    this.editor && this.editor.destroy();
    super.doDestroy();
  }


  editEvent(eventRecord, resourceRecord, element) {
    const me = this,
      scheduler = me.scheduler;

    if (scheduler.readOnly || me.disabled) {
      return;
    }


    element = DomHelper.down(element, scheduler.eventInnerSelector) || element;
    eventRecord = eventRecord instanceof AssignmentModel ? eventRecord.event : eventRecord;
    me.resource = resourceRecord;
    me.event = eventRecord;
    me.element = element;
    scheduler.element.classList.add('b-eventeditor-editing');

    if (!me.editor) {


      me.editor = new Editor(Object.assign({
        owner: me.scheduler.timeAxisSubGrid,
        appendTo: me.scheduler.timeAxisSubGridElement,
        scrollAction: 'realign',
        cls: 'b-simpleeventeditor',
        listeners: {
          complete: me.onEditorComplete,
          cancel: me.onEditorCancel,
          thisObj: me
        }
      }, me.editorConfig));
      me.relayEvents(me.editor, ['beforestart', 'start', 'beforecomplete', 'complete', 'beforecancel', 'cancel']);
    }

    me.editor.startEdit({
      target: element,
      record: eventRecord,
      field: me.field
    });

    me.scheduler.navigator.disabled = true;
  }

  onEditorComplete() {
    const me = this;

    if (me.event.stores.length === 0) {
      me.eventStore.add(me.editor.record);
      me.event.assign(me.resource);
    }

    if (me.element && me.element.classList.contains('b-sch-dragcreator-proxy')) {
      me.element.remove();
    }

    me.reset();
  }

  onEditorCancel() {
    if (this.event.stores.length === 0) {
      this.element.remove();
    }

    this.reset();
  }

  reset() {
    this.scheduler.element.classList.remove('b-eventeditor-editing');

    this.scheduler.navigator.disabled = false;
  }


  onEventEnterKey({
                    assignmentRecord,
                    eventRecord
                  }) {
    const element = assignmentRecord ? this.scheduler.getElementFromAssignmentRecord(assignmentRecord) : this.scheduler.getElementFromEventRecord(eventRecord),
      resourceRecord = (assignmentRecord || eventRecord).resource;
    this.editEvent(eventRecord, resourceRecord, element);
  }

  onDragCreateEnd({
                    newEventRecord,
                    resourceRecord,
                    proxyElement
                  }) {
    const me = this;

    me.scheduler.onEventCreated(newEventRecord);

    const phantomEventElement = proxyElement.cloneNode(true);
    phantomEventElement.removeAttribute('id');
    proxyElement.parentElement.appendChild(phantomEventElement);
    me.element = phantomEventElement;
    me.editEvent(newEventRecord, resourceRecord, phantomEventElement);
  }

}

SimpleEventEdit._$name = 'SimpleEventEdit';
GridFeatureManager.registerFeature(SimpleEventEdit, false, 'Scheduler');


class TimeRanges extends AbstractTimeRanges {

  static get $name() {
    return 'TimeRanges';
  }

  static get defaultConfig() {
    return {

      store: {
        modelClass: TimeSpan,
        storeId: 'timeRanges'
      },
      updateCurrentTimeLineInterval: 10000,


      currentDateFormat: 'HH:mm',


      timeRanges: null,


      showCurrentTimeLine: false
    };
  }


  construct(client, config) {
    const me = this;
    super.construct(client, config);

    if (!client._timeRangesExposed) {

      Object.defineProperty(client, 'timeRanges', {
        get: () => me.store.records,
        set: timeRanges => me.store.data = timeRanges
      });
      client._timeRangesExposed = true;
    }
  }

  startConfigure(config) {
    const {
      client
    } = this;

    if (client.project) {
      const store = client.project.timeRangeStore;

      if (store) {
        config.store = store;
      }
    }
  }


  initCurrentTimeLine() {
    const me = this,
      now = new Date();

    if (me.currentTimeLine || !me.showCurrentTimeLine) {
      return;
    }

    me.currentTimeLine = new me.store.modelClass({
      'id': 'currentTime',
      cls: 'b-sch-current-time',
      startDate: now,
      name: DateHelper.format(now, me.currentDateFormat)
    });
    me.updateCurrentTimeLine = me.updateCurrentTimeLine.bind(me);
    me.currentTimeInterval = me.setInterval(me.updateCurrentTimeLine, me.updateCurrentTimeLineInterval);

    if (me.client.isPainted) {
      me.renderRanges();
    }
  }

  updateCurrentTimeLine() {
    const me = this;
    me.currentTimeLine.startDate = new Date();
    me.currentTimeLine.name = DateHelper.format(me.currentTimeLine.startDate, me.currentDateFormat);
    me.onStoreChanged({
      action: 'update',
      record: me.currentTimeLine,
      changes: {}
    });
  }

  hideCurrentTimeLine() {
    const me = this;

    if (!me.currentTimeLine) {
      return;
    }

    me.clearInterval(me.currentTimeInterval);
    me.currentTimeLine = null;

    if (me.client.isPainted) {
      me.renderRanges();
    }
  }

  renderRanges() {
    const me = this;
    super.renderRanges();

    if (me.showCurrentTimeLine && !me.disabled) {
      me.renderRange(me.currentTimeLine, true);
    }
  }


  get showCurrentTimeLine() {
    return this._showCurrentTimeLine;
  }

  set showCurrentTimeLine(show) {
    this._showCurrentTimeLine = show;

    if (show) {
      this.initCurrentTimeLine();
    } else {
      this.hideCurrentTimeLine();
    }
  }


  getHeaderMenuItems(column, items) {
    const me = this;

    if (!items.some(item => item.isCurrentTimeline) && column.type === 'timeAxis') {
      items.push({
        isCurrentTimeline: true,
        text: me.L('showCurrentTimeLine'),
        checked: me.showCurrentTimeLine,
        onToggle: ({
                     checked
                   }) => {
          me.showCurrentTimeLine = checked;
        }
      });
    }
  }


  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;

    if (this.client.isPainted) {
      this.renderRanges();
    }
  }


  get store() {
    return this._store;
  }

  set store(store) {
    const me = this,
      client = me.client;

    if (!store.storeId) {
      store.storeId = 'timeRanges';
    }

    super.store = store;


    if (client.timeRanges && !client._timeRangesExposed) {
      me._store.add(client.timeRanges);

      delete client.timeRanges;
    }

    if (me.timeRanges) {
      me._store.add(me.timeRanges);

      delete me.timeRanges;
    }
  }

}

TimeRanges._$name = 'TimeRanges';
GridFeatureManager.registerFeature(TimeRanges, false, ['Scheduler', 'Gantt']);


var DependencyCreation = (Target => class DependencyCreation extends (Target || Base) {

  static get defaultConfig() {
    return {

      showCreationTooltip: true,


      creationTooltip: null,


      terminalCls: 'b-sch-terminal',


      terminalSides: ['left', 'top', 'right', 'bottom'],


      allowCreate: true
    };
  }


  construct(view, config) {
    super.construct(view, config);
    const me = this;
    me.view = view;
    me.eventName = view.scheduledEventName;
    me.view.on('readOnly', () => me.updateCreateListeners());
    me.updateCreateListeners();
  }

  doDestroy() {
    const me = this;
    me.detachListeners('view');
    me.creationData = null;
    me.mouseDetacher && me.mouseDetacher();
    me.creationTooltip && me.creationTooltip.destroy();
    super.doDestroy();
  }

  updateCreateListeners() {
    const me = this;

    if (!me.view) {
      return;
    }

    me.detachListeners('view');

    if (me.isCreateAllowed) {
      me.view.on({
        name: 'view',
        [`${me.eventName}mouseenter`]: 'onTimeSpanMouseEnter',
        [`${me.eventName}mouseleave`]: 'onTimeSpanMouseLeave',
        thisObj: me
      });
    }
  }

  set allowCreate(value) {
    this._allowCreate = value;
    this.updateCreateListeners();
  }

  get allowCreate() {
    return this._allowCreate;
  }

  get isCreateAllowed() {
    return this.allowCreate && !this.view.readOnly && !this.disabled;
  }


  onTimeSpanMouseEnter(event) {
    const record = event[`${this.eventName}Record`],
      element = event[`${this.eventName}Element`];
    this.showTerminals(record, DomHelper.down(element, event.source.eventInnerSelector));
  }


  onTimeSpanMouseLeave(event) {
    const me = this,
      element = event[`${me.eventName}Element`];

    if (!me.creationData || !DomHelper.isDescendant(element, me.creationData.sourceTerminal.parentElement)) {
      me.hideTerminals(element);
    }
  }


  onTerminalMouseOut(event) {
    const me = this,
      el = DomHelper.up(event.target, me.view.eventSelector);

    if (el && !DomHelper.isDescendant(el, me.showingTerminalsFor) && (!me.creationData || el !== me.creationData.sourceTerminal.parentElement)) {
      me.hideTerminals(el);
      me.view.unhover(event);
    }
  }


  onTerminalMouseDown(event) {
    const me = this;

    if (event.button === 0 && !me.creationData) {
      const view = me.view,
        timeAxisSubGridElement = view.timeAxisSubGridElement,
        terminal = event.target,
        element = terminal.parentElement.closest(view.eventSelector),
        viewBounds = Rectangle.from(view.element, document.body);
      event.preventDefault();
      event.stopPropagation();
      me.creationData = {
        source: view.resolveTimeSpanRecord(element),
        sourceTerminal: terminal,
        startPoint: Rectangle.from(terminal, timeAxisSubGridElement).center,
        startX: event.pageX - viewBounds.x + view.scrollLeft,
        startY: event.pageY - viewBounds.y + view.scrollTop,
        valid: false
      };

      if (view.resolveResourceRecord) {
        me.creationData.sourceResource = view.resolveResourceRecord(element);
      }

      me.mouseDetacher = EventHelper.on({
        mouseup: {
          element: document.body,
          handler: 'onMouseUp'
        },
        mousemove: {
          element: timeAxisSubGridElement,
          handler: 'onMouseMove'
        },
        thisObj: me
      });
    }
  }


  onMouseMove(event) {
    const me = this,
      {
        view,
        creationData: data
      } = me,
      viewBounds = Rectangle.from(view.element, document.body),
      deltaX = event.pageX - viewBounds.x + view.scrollLeft - data.startX,
      deltaY = event.pageY - viewBounds.y + view.scrollTop - data.startY,
      length = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,
      angle = Math.atan2(deltaY, deltaX);
    let {
      connector
    } = me;

    if (!connector) {
      if (this.onRequestDragCreate() === false) {
        return;
      }

      connector = me.connector;
    }

    connector.style.width = `${length}px`;
    connector.style.transform = `rotate(${angle}rad)`;
    me.lastMouseMoveEvent = event;
  }

  onRequestDragCreate() {
    const me = this,
      {
        view,
        creationData: data
      } = me;


    if (view.trigger('beforeDependencyCreateDrag', {
      data
    }) === false) {
      me.abort();
      return false;
    }

    view.element.classList.add('b-creating-dependency');
    me.connector = me.createConnector(data.startPoint.x, data.startPoint.y);


    view.trigger('dependencyCreateDragStart', {
      data
    });

    if (me.showCreationTooltip) {
      me.creationTooltip = me.creationTooltip || me.createDragTooltip();
      me.creationTooltip.disabled = false;
      me.creationTooltip.show();
    }

    view.scrollManager.startMonitoring({
      element: view.timeAxisSubGridElement,
      callback: () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent),
      thisObj: me
    });
  }

  onOverTargetTerminal(event) {
    const me = this,
      {
        target
      } = event,
      {
        view,
        creationData: data
      } = me;
    const {
      connector
    } = me;

    if (!(data.valid instanceof Promise)) {
      if (target !== data.sourceTerminal) {
        if (target !== data.targetTerminal) {
          data.targetTerminal = target;
          data.target = view.resolveTimeSpanRecord(target);

          if (view.resolveResourceRecord) {
            data.targetResource = view.resolveResourceRecord(target);
          }

          const fromSide = data.sourceTerminal.dataset.side,
            toSide = data.targetTerminal.dataset.side,
            updateValidity = valid => {
              if (!me.isDestroyed) {
                data.valid = valid;
                target.classList.add(valid ? 'b-valid' : 'b-invalid');
                connector.classList.add(valid ? 'b-valid' : 'b-invalid');


                view.trigger('dependencyValidationComplete', {
                  data
                });
              }
            };

          let type;


          switch (true) {
            case fromSide === 'left' && toSide === 'left':
              type = DependencyBaseModel.Type.StartToStart;
              break;

            case fromSide === 'left' && toSide === 'right':
              type = DependencyBaseModel.Type.StartToEnd;
              break;

            case fromSide === 'right' && toSide === 'left':
              type = DependencyBaseModel.Type.EndToStart;
              break;

            case fromSide === 'right' && toSide === 'right':
              type = DependencyBaseModel.Type.EndToEnd;
              break;
          }


          view.trigger('dependencyValidationStart', {
            data
          });
          data.valid = me.dataApi.isValidDependencyToCreate({
            type,
            sourceEvent: data.source,
            targetEvent: data.target,
            dependencyStore: me.dependencyStore
          });

          if (data.valid instanceof Promise) {
            data.valid.then(updateValidity);
          } else {
            updateValidity(data.valid);
          }
        }
      } else {
        connector.classList.remove('b-valid');
        connector.classList.remove('b-invalid');
      }
    }
  }


  onMouseUp(event) {
    const me = this,
      data = me.creationData,
      target = event.target;
    me.abort();

    const doDependencyDrop = async () => {
      data.targetTerminal = event.target;
      const result = me.createDependency(data);

      if (result instanceof Promise) {
        await result;
      }


      me.view.trigger('dependencyCreateDrop', {
        data
      });
    };

    const doAfterDependencyDrop = data => {

      me.view.trigger('afterDependencyCreateDrop', {
        data
      });
    };

    if (data.valid && target.matches(`.${me.terminalCls}`)) {
      if (data.valid instanceof Promise) {
        data.valid.then(valid => {
          data.valid = valid;

          if (valid) {
            doDependencyDrop().then(() => doAfterDependencyDrop(data));
          } else {
            doAfterDependencyDrop(data);
          }
        });
      } else {
        doDependencyDrop().then(() => doAfterDependencyDrop(data));
      }
    } else {
      data.valid = false;
      doAfterDependencyDrop(data);
    }
  }


  abort() {
    const me = this,
      {
        view,
        creationData
      } = me;

    if (creationData) {
      const {
        source,
        sourceResource,
        target,
        targetResource
      } = creationData;

      if (source) {
        const el = view.getElementFromEventRecord(source, sourceResource);

        if (el) {
          me.hideTerminals(el);
        }
      }

      if (target) {
        const el = view.getElementFromEventRecord(target, targetResource);

        if (el) {
          me.hideTerminals(el);
        }
      }
    }

    if (me.creationTooltip) {
      me.creationTooltip.disabled = true;
    }

    me.creationData = me.lastMouseMoveEvent = null;
    me.mouseDetacher && me.mouseDetacher();
    me.removeConnector();
  }


  createConnector(x, y) {
    const me = this,
      view = me.view;
    me.connector = DomHelper.createElement({
      parent: view.timeAxisSubGridElement,
      className: `${me.baseCls}-connector`,
      style: `left:${x}px;top:${y}px`
    });
    view.element.classList.add('b-creating-dependency');
    return me.connector;
  }

  createDragTooltip() {
    const me = this,
      view = me.view;
    return me.creationTooltip = new Tooltip(Object.assign({
      id: `${view.id}-dependency-drag-tip`,
      cls: 'b-sch-dependency-creation-tooltip',
      loadingMsg: '',
      autoShow: true,
      anchorToTarget: false,

      forSelector: '.b-sch-terminal',
      forElement: view.timeAxisSubGridElement,
      trackMouse: true,

      constrainTo: null,
      getHtml: ({
                  tip,
                  event
                }) => {
        if (me.creationData) {
          event && me.onOverTargetTerminal(event);
          return me.generateTooltipContent(tip, me.creationData);
        }
      },
      header: {
        dock: 'right'
      },
      listeners: {
        pointerout: ({
                       source: tip
                     }) => {
          const data = me.creationData;
          data.target = data.targetTerminal = null;
          data.valid = false;
          tip.html = tip.getHtml({
            tip
          });
          return false;
        },
        beforeShow: ({
                       source: tip
                     }) => {

          tip.html = tip.getHtml({
            tip
          });
        }
      }
    }, me.creationTooltip || {}));
  }


  removeConnector(callback) {
    const me = this,
      {
        connector,
        view
      } = me;

    if (connector) {
      connector.classList.add('b-removing');
      connector.style.width = '0';
      me.setTimeout(() => {
        connector.remove();
        me.connector = null;

        if (callback) {
          callback.call(me);
        }
      }, 200);
    }

    view.element.classList.remove('b-creating-dependency');
    me.creationTooltip && me.creationTooltip.hide();
    view.scrollManager.stopMonitoring(view.timeAxisSubGridElement);
  }


  showTerminals(timeSpanRecord, element) {
    const me = this;

    if (!me.isCreateAllowed) {
      return;
    }

    const cls = me.terminalCls,
      terminalsVisibleCls = `${cls}s-visible`;

    element = DomHelper.down(element, me.view.eventInnerSelector);


    if (!element.classList.contains(terminalsVisibleCls) && !this.view.element.classList.contains('b-resizing-event') && !me.view.readOnly) {

      me.terminalSides.forEach(side => {
        const terminal = DomHelper.createElement({
          parent: element,
          className: `${cls} ${cls}-${side}`,
          dataset: {
            side,
            feature: true
          }
        });
        terminal.detacher = EventHelper.on({
          element: terminal,
          mouseout: 'onTerminalMouseOut',
          mousedown: {
            handler: 'onTerminalMouseDown',
            capture: true
          },
          thisObj: me
        });
      });
      element.classList.add(terminalsVisibleCls);
      timeSpanRecord.cls.add(terminalsVisibleCls);
      me.showingTerminalsFor = element;
    }
  }


  hideTerminals(eventElement) {

    const me = this,
      eventParams = me.client.getTimeSpanMouseEventParams(eventElement),
      timeSpanRecord = eventParams[`${this.eventName}Record`],
      terminalsVisibleCls = `${me.terminalCls}s-visible`;
    DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, terminal => {
      terminal.detacher && terminal.detacher();
      terminal.remove();
    });
    DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);
    timeSpanRecord.cls.remove(terminalsVisibleCls);
    me.showingTerminalsFor = null;
  }


  createDependency(data) {
    const source = data.source,
      target = data.target,
      fromSide = data.sourceTerminal.dataset.side,
      toSide = data.targetTerminal.dataset.side,
      type = (fromSide === 'left' ? 0 : 2) + (toSide === 'right' ? 1 : 0);
    return this.dataApi.createDependency({
      sourceEvent: source,
      targetEvent: target,
      dependencyStore: this.dependencyStore,
      type,
      fromSide,
      toSide
    });
  }


  generateTooltipContent(tip, data) {
    const me = this,
      {
        valid
      } = data;
    Object.assign(data, {
      fromText: data.source.name,
      toText: data.target ? data.target.name : '',
      fromSide: data.sourceTerminal.dataset.side,
      toSide: data.targetTerminal ? data.targetTerminal.dataset.side : ''
    });
    let tipTitleIconClsSuffix, tipTitleText;

    if (valid instanceof Promise) {
      tip.element.classList.remove('b-invalid');
      tip.element.classList.add('b-checking');
      tipTitleIconClsSuffix = 'checking';
      tipTitleText = me.L('Checking');
      return new Promise(resolve => valid.then(valid => {
        data.valid = valid;

        if (!tip.isDestroyed) {
          resolve(me.generateTooltipContent(tip, data));
        }
      }));
    } else if (valid === true) {
      tip.element.classList.remove('b-invalid');
      tip.element.classList.remove('b-checking');
      tipTitleIconClsSuffix = 'valid';
      tipTitleText = me.L('valid');
    } else {
      tip.element.classList.remove('b-checking');
      tip.element.classList.add('b-invalid');
      tipTitleIconClsSuffix = 'invalid';
      tipTitleText = me.L('invalid');
    }

    tip.titleElement.innerHTML = `<i class="b-icon b-icon-${tipTitleIconClsSuffix}"></i>${tipTitleText}`;
    return `<table class="b-sch-dependency-creation-tooltip">
                        <tr><td>${me.L('from')}: </td><td>${data.fromText}</td><td><div class="b-sch-box b-${data.fromSide}"></div></td></tr>
                        <tr><td>${me.L('to')}: </td><td>${data.toText}</td><td><div class="b-sch-box b-${data.toSide}"></div></td></tr>
                    </table>`;
  }

});


class RectangularPathFinder extends Base {
  static get defaultConfig() {
    return {

      startSide: 'right',


      startArrowSize: 0,


      startArrowMargin: 12,


      startShift: 0,


      endSide: 'left',


      endArrowSize: 0,


      endArrowMargin: 12,


      endShift: 0,


      verticalMargin: 2,


      horizontalMargin: 5,


      otherBoxes: null
    };
  }


  findPath(lineDef, noPathFallbackFn) {
    let me = this,
      lineDefFull,
      startBox,
      endBox,
      startShift,
      endShift,
      startSide,
      endSide,
      startArrowSize,
      endArrowSize,
      startArrowMargin,
      endArrowMargin,
      horizontalMargin,
      verticalMargin,
      startHorizontalMargin,
      startVerticalMargin,
      endHorizontalMargin,
      endVerticalMargin,
      otherHorizontalMargin,
      otherVerticalMargin,
      otherBoxes,
      connStartPoint,
      connEndPoint,
      pathStartPoint,
      pathEndPoint,
      gridStartPoint,
      gridEndPoint,
      startGridBox,
      endGridBox,
      grid,
      path,
      tryNum;

    if (noPathFallbackFn && !Array.isArray(noPathFallbackFn)) {
      noPathFallbackFn = [noPathFallbackFn];
    }

    for (tryNum = 0; lineDef && !path;) {
      lineDefFull = Object.assign(me.config, lineDef);
      startBox = lineDefFull.startBox;
      endBox = lineDefFull.endBox;
      startShift = lineDefFull.startShift;
      endShift = lineDefFull.endShift;
      startSide = lineDefFull.startSide;
      endSide = lineDefFull.endSide;
      startArrowSize = lineDefFull.startArrowSize;
      endArrowSize = lineDefFull.endArrowSize;
      startArrowMargin = lineDefFull.startArrowMargin;
      endArrowMargin = lineDefFull.endArrowMargin;
      horizontalMargin = lineDefFull.horizontalMargin;
      verticalMargin = lineDefFull.verticalMargin;
      startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin;
      startVerticalMargin = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin;
      endHorizontalMargin = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin;
      endVerticalMargin = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin;
      otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin') ? lineDefFull.otherHorizontalMargin : horizontalMargin;
      otherVerticalMargin = lineDefFull.hasOwnProperty('otherVerticalMargin') ? lineDefFull.otherVerticalMargin : verticalMargin;
      otherBoxes = lineDefFull.otherBoxes;
      startSide = me.normalizeSide(startSide);
      endSide = me.normalizeSide(endSide);
      connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
      connEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);
      startGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide, startArrowSize, startArrowMargin, startHorizontalMargin, startVerticalMargin);
      endGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide, endArrowSize, endArrowMargin, endHorizontalMargin, endVerticalMargin);
      otherBoxes = otherBoxes && otherBoxes.map(box => me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, 0, otherHorizontalMargin, otherVerticalMargin));
      pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
      pathEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
      grid = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
      gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
      gridEndPoint = me.convertDecartPointToGridPoint(grid, pathEndPoint);
      path = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);


      for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {
        lineDef = noPathFallbackFn[tryNum](lineDefFull);
      }
    }

    if (path) {
      path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide);
      path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide);
      path = me.optimizePath(path);
    }

    return path;
  }

  getConnectionCoordinatesFromBoxSideShift(box, side, shift) {
    let coords;

    switch (side) {
      case 'left':
        coords = {
          x: box.start,
          y: (box.top + box.bottom) / 2 + shift
        };
        break;

      case 'right':
        coords = {
          x: box.end,
          y: (box.top + box.bottom) / 2 + shift
        };
        break;

      case 'top':
        coords = {
          x: (box.start + box.end) / 2 + shift,
          y: box.top
        };
        break;

      case 'bottom':
        coords = {
          x: (box.start + box.end) / 2 + shift,
          y: box.bottom
        };
        break;
    }

    return coords;
  }

  calcGridBaseBoxFromBoxAndDrawParams(box, side, arrowSize, arrowMargin, horizontalMargin, verticalMargin) {
    let gridBox;

    switch (side) {
      case 'left':
        gridBox = {
          start: box.start - Math.max(arrowSize + arrowMargin, horizontalMargin),
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
        break;

      case 'right':
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + Math.max(arrowSize + arrowMargin, horizontalMargin),
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
        break;

      case 'top':
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - Math.max(arrowSize + arrowMargin, verticalMargin),
          bottom: box.bottom + verticalMargin
        };
        break;

      case 'bottom':
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + Math.max(arrowSize + arrowMargin, verticalMargin)
        };
        break;

      default:
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
    }

    return gridBox;
  }

  buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
    let xs,
      ys,
      y,
      x,
      ix,
      iy,
      xslen,
      yslen,
      ib,
      blen,
      box,
      permitted,
      point,
      points = {},
      linearPoints = [];
    xs = [startGridBox.start, startSide === 'left' || startSide === 'right' ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x, startGridBox.end, endGridBox.start, endSide === 'left' || endSide === 'right' ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x, endGridBox.end];
    ys = [startGridBox.top, startSide === 'top' || startSide === 'bottom' ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y, startGridBox.bottom, endGridBox.top, endSide === 'top' || endSide === 'bottom' ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y, endGridBox.bottom];

    if (otherGridBoxes) {
      otherGridBoxes.forEach(box => {
        xs.push(box.start, (box.start + box.end) / 2, box.end);
        ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);
      });
    }

    xs = [...new Set(xs.sort((a, b) => a - b))];
    ys = [...new Set(ys.sort((a, b) => a - b))];


    for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {
      points[iy] = points[iy] || {};
      y = ys[iy];

      for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {
        x = xs[ix];
        permitted = (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) && (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom);

        if (otherGridBoxes) {
          for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
            box = otherGridBoxes[ib];
            permitted = x <= box.start || x >= box.end || y <= box.top || y >= box.bottom ||
              x === pathStartPoint.x && y === pathStartPoint.y || x === pathEndPoint.x && y === pathEndPoint.y;
          }
        }

        point = {
          distance: Math.pow(2, 53) - 1,

          permitted: permitted,
          x: x,
          y: y,
          ix: ix,
          iy: iy
        };
        points[iy][ix] = point;
        linearPoints.push(point);
      }
    }

    return {
      width: xs.length,
      height: ys.length,
      xs: xs,
      ys: ys,
      points: points,
      linearPoints: linearPoints
    };
  }

  convertDecartPointToGridPoint(grid, point) {
    let x = grid.xs.indexOf(point.x),
      y = grid.ys.indexOf(point.y);
    return grid.points[y][x];
  }

  findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
    let me = this,
      path = false;

    if (gridStartPoint.permitted && gridEndPoint.permitted) {
      grid = me.waveForward(grid, gridStartPoint, 0);
      path = me.collectPath(grid, gridEndPoint, endSide);
    }

    return path;
  }

  getGridPointNeighbors(grid, gridPoint, predicateFn) {
    let ix = gridPoint.ix,
      iy = gridPoint.iy,
      result = [],
      neighbor;


    if (iy < grid.height - 1) {
      neighbor = grid.points[iy + 1][ix];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }

    if (iy > 0) {
      neighbor = grid.points[iy - 1][ix];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }

    if (ix < grid.width - 1) {
      neighbor = grid.points[iy][ix + 1];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }

    if (ix > 0) {
      neighbor = grid.points[iy][ix - 1];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }

    return result;
  }

  waveForward(grid, gridStartPoint, distance) {
    const me = this;


    WalkHelper.preWalkUnordered(
      [gridStartPoint, distance],


      ([point, distance]) => me.getGridPointNeighbors(grid, point, neighborPoint => neighborPoint.permitted && neighborPoint.distance > distance + 1).map(neighborPoint => [neighborPoint, distance + 1]
      ),
      ([point, distance]) => point.distance = distance
    );
    return grid;
  }

  collectPath(grid, gridEndPoint, endSide) {
    let me = this,
      pathFound = true,
      neighbors,
      lowestDistanceNeighbor,
      xDiff,
      yDiff,
      path = [];

    while (pathFound && gridEndPoint.distance) {
      neighbors = me.getGridPointNeighbors(grid, gridEndPoint, point => point.permitted && point.distance == gridEndPoint.distance - 1);
      pathFound = neighbors.length > 0;

      if (pathFound) {

        neighbors = neighbors.sort((a, b) => {
          let xDiff, yDiff;
          xDiff = a.ix - gridEndPoint.ix;
          yDiff = a.iy - gridEndPoint.iy;
          let resultA = (endSide === 'left' || endSide === 'right') && yDiff === 0 || (endSide === 'top' || endSide === 'bottom') && xDiff === 0 ? -1 : 1;
          xDiff = b.ix - gridEndPoint.ix;
          yDiff = b.iy - gridEndPoint.iy;
          let resultB = (endSide === 'left' || endSide === 'right') && yDiff === 0 || (endSide === 'top' || endSide === 'bottom') && xDiff === 0 ? -1 : 1;
          if (resultA > resultB) return 1;
          if (resultA < resultB) return -1;

          if (resultA === resultB) return a.y > b.y ? -1 : 1;
        });
        lowestDistanceNeighbor = neighbors[0];
        path.push({
          x1: lowestDistanceNeighbor.x,
          y1: lowestDistanceNeighbor.y,
          x2: gridEndPoint.x,
          y2: gridEndPoint.y
        });

        xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
        yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;

        switch (true) {
          case !yDiff && xDiff > 0:
            endSide = 'left';
            break;

          case !yDiff && xDiff < 0:
            endSide = 'right';
            break;

          case !xDiff && yDiff > 0:
            endSide = 'top';
            break;

          case !xDiff && yDiff < 0:
            endSide = 'bottom';
            break;
        }

        gridEndPoint = lowestDistanceNeighbor;
      }
    }

    return pathFound && path.reverse() || false;
  }

  prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide) {
    let prependSegment, firstSegment;

    if (path.length > 0) {
      firstSegment = path[0];
      prependSegment = {
        x2: firstSegment.x1,
        y2: firstSegment.y1
      };

      switch (startSide) {
        case 'left':
          prependSegment.x1 = connStartPoint.x - startArrowSize;
          prependSegment.y1 = firstSegment.y1;
          break;

        case 'right':
          prependSegment.x1 = connStartPoint.x + startArrowSize;
          prependSegment.y1 = firstSegment.y1;
          break;

        case 'top':
          prependSegment.x1 = firstSegment.x1;
          prependSegment.y1 = connStartPoint.y - startArrowSize;
          break;

        case 'bottom':
          prependSegment.x1 = firstSegment.x1;
          prependSegment.y1 = connStartPoint.y + startArrowSize;
          break;
      }

      path.unshift(prependSegment);
    }

    return path;
  }

  appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide) {
    let appendSegment, lastSegment;

    if (path.length > 0) {
      lastSegment = path[path.length - 1];
      appendSegment = {
        x1: lastSegment.x2,
        y1: lastSegment.y2
      };

      switch (endSide) {
        case 'left':
          appendSegment.x2 = connEndPoint.x - endArrowSize;
          appendSegment.y2 = lastSegment.y2;
          break;

        case 'right':
          appendSegment.x2 = connEndPoint.x + endArrowSize;
          appendSegment.y2 = lastSegment.y2;
          break;

        case 'top':
          appendSegment.x2 = lastSegment.x2;
          appendSegment.y2 = connEndPoint.y - endArrowSize;
          break;

        case 'bottom':
          appendSegment.x2 = lastSegment.x2;
          appendSegment.y2 = connEndPoint.y + endArrowSize;
          break;
      }

      path.push(appendSegment);
    }

    return path;
  }

  optimizePath(path) {
    let optPath = [],
      prevSegment,
      curSegment;

    if (path.length > 0) {
      prevSegment = path.shift();
      optPath.push(prevSegment);

      while (path.length > 0) {
        curSegment = path.shift();

        if (prevSegment.x1 == curSegment.x1 && prevSegment.y1 == curSegment.y1 && prevSegment.x2 == curSegment.x2 && prevSegment.y2 == curSegment.y2) {
          prevSegment = curSegment;
        } else if (prevSegment.y1 - prevSegment.y2 === 0 && curSegment.y1 - curSegment.y2 === 0) {
          prevSegment.x2 = curSegment.x2;
        } else if (prevSegment.x1 - prevSegment.x2 === 0 && curSegment.x1 - curSegment.x2 === 0) {
          prevSegment.y2 = curSegment.y2;
        } else {
          optPath.push(curSegment);
          prevSegment = curSegment;
        }
      }
    }

    return optPath;
  }

  normalizeSide(side) {
    return RectangularPathFinder.sideToSide[side] || side;
  }

  static get sideToSide() {
    return {
      'l': 'left',
      'r': 'right',
      't': 'top',
      'b': 'bottom'
    };
  }

}

RectangularPathFinder._$name = 'RectangularPathFinder';


const fromBoxSide = ['left', 'left', 'right', 'right'],
  toBoxSide = ['left', 'right', 'left', 'right'];


class Dependencies extends base(InstancePlugin).mixes(DependencyCreation, SchedulerFeatureDataLayer, Delayable, DataAPI) {


  static get $name() {
    return 'Dependencies';
  }

  static get defaultConfig() {
    return {

      pathFinderConfig: null,


      overCls: 'b-sch-dependency-over',


      baseCls: 'b-sch-dependency',


      store: null,


      dependencies: null,
      highlightDependenciesOnEventHover: false,


      showTooltip: true,


      tooltip: null,
      bufferSize: 50,
      cacheGridSize: {
        x: 500,
        index: 25
      },
      drawnDependencies: [],
      drawnLines: [],
      dependenciesToRefresh: new Map(),
      storeClass: DependencyStore
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render', 'renderContents', 'onElementClick', 'onElementDblClick', 'onElementMouseOver', 'onElementMouseOut'],
      assign: ['getElementForDependency', 'getDependencyForElement']
    };
  }


  construct(scheduler, config = {}) {
    const me = this;

    if (scheduler.isVertical) {
      throw new Error('Dependencies feature is not supported in vertical mode');
    }


    me.doScheduleDraw = me.createOnFrame('draw', [], me, true);
    super.construct(scheduler, config);
    me.pathFinder = new RectangularPathFinder(me.pathFinderConfig);
    delete me.pathFinderConfig;
    me.lineDefAdjusters = me.createLineDefAdjusters();
  }

  doDestroy() {
    this.tooltip && this.tooltip.destroy();
    super.doDestroy();
  }

  doDisable(disable) {
    this.updateCreateListeners();

    if (this.client.isPainted) {
      this.draw();
    }

    super.doDisable(disable);
  }


  exposeSchedulerDependenciesProperty() {
    const me = this;

    if (me.dependenciesPropertyExposed) {
      delete me.client.dependencies;
    }

    Object.defineProperty(me.client, 'dependencies', {
      configurable: true,
      get: () => me.dependencyStore.records,
      set: dependencies => me.dependencyStore.data = dependencies
    });
    me.dependenciesPropertyExposed = true;
  }

  get rowStore() {
    return this.resourceStore;
  }

  get scheduler() {
    return this.client;
  }

  getResourceStoreListenersConfig() {
    return {
      refresh: this.onRowStoreRefresh
    };
  }

  obtainDependencyStore(scheduler, config) {
    let store = config && config.store || super.obtainDependencyStore(scheduler, config);

    if (store === true || !store) {
      store = new this.storeClass();
    }

    return store;
  }

  getDependencyStoreListenersConfig() {
    return {
      change: this.onDependencyChange
    };
  }

  onDependencyStoreChange(newStore, oldStore) {
    const me = this,
      scheduler = me.client;

    me.resetGridCache();
    me.resetBoundsCache();
    scheduler.dependencyStore = newStore;

    if (newStore) {
      if (!me.dependenciesPropertyExposed && scheduler.dependencies) {
        newStore.data = scheduler.dependencies;
        delete scheduler.dependencies;
      }

      if (me.dependencies) {
        newStore.data = me.dependencies;
        delete me.dependencies;
      }


      newStore.metaMapId = scheduler.id;


      newStore.eventStore = scheduler.eventStore;

      me.exposeSchedulerDependenciesProperty();
    }
  }

  getAssignmentStoreListenersConfig() {
    return {
      change: this.onAssignmentChange,
      refresh: this.onAssignmentRefresh
    };
  }

  getEventStoreListenersConfig() {
    return {
      change: this.onEventChange
    };
  }

  createMarkers() {
    const me = this,
      svg = me.client.svgCanvas,
      endMarker = me.endMarker = me.initMarkerElement('arrowEnd', '8', 'M0,0 L0,6 L9,3 z');

    if (BrowserHelper.isEdge || BrowserHelper.isIE11) {
      const startMarker = me.startMarker = me.initMarkerElement('arrowStart', '1', 'M0,3 L9,6 L9,0 z');
      svg.appendChild(startMarker);
    } else {
      endMarker.setAttribute('orient', 'auto-start-reverse');
    }

    svg.appendChild(endMarker);
  }

  initMarkerElement(id, refX, arrowPath) {
    return DomHelper.createElement({
      id,
      tag: 'marker',
      ns: 'http://www.w3.org/2000/svg',
      markerHeight: 9,
      markerWidth: 9,
      refX,
      refY: 3,
      viewBox: '0 0 9 6',
      orient: 'auto',
      markerUnits: 'userSpaceOnUse',
      children: [{
        tag: 'path',
        ns: 'http://www.w3.org/2000/svg',
        d: arrowPath
      }]
    });
  }


  createLineDefAdjusters() {
    const scheduler = this.client;

    function shrinkArrowMargins(lineDef) {
      let adjusted = false;

      if (lineDef.startArrowMargin > scheduler.barMargin || lineDef.endArrowMargin > scheduler.barMargin) {
        lineDef.startArrowMargin = lineDef.endArrowMargin = scheduler.barMargin;
        adjusted = true;
      }

      return adjusted ? lineDef : adjusted;
    }

    function resetArrowMargins(lineDef) {
      let adjusted = false;

      if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {
        lineDef.startArrowMargin = lineDef.endArrowMargin = 0;
        adjusted = true;
      }

      return adjusted ? lineDef : adjusted;
    }


    return [shrinkArrowMargins, resetArrowMargins


    ];
  }


  getElementForDependency(dependency, assignmentData = null) {
    let selector = `[depId="${dependency.id}"]`;

    if (assignmentData) {
      selector += `[fromId="${assignmentData.from.id}"][toId="${assignmentData.to.id}"]`;
    }

    return this.client.svgCanvas.querySelector(selector);
  }

  getDependencyForElement(element) {
    const id = typeof element === 'string' ? element : element.getAttribute('depId');

    return this.dependencyStore.getById(id);
  }


  onToggleNode() {

    this.dependencyGridCache = null;

    this.scheduleDraw(true);
  }

  onViewportResize() {
    this.scheduleDraw(true);
  }


  onTranslateRow({
                   row
                 }) {


    if (row.lastTop >= 0 && row.top !== row.lastTop) {
      this.scheduleDraw(true);
    }
  }


  onChangeTotalHeight() {


    this.scheduleDraw(true);
  }


  onHorizontalScroll({
                       subGrid
                     }) {

    if (this.isDrawn && subGrid === this.client.timeAxisSubGrid) {
      this.scheduleDraw(false);
    }
  }


  onVerticalScroll() {

    if (this.isDrawn) {

      this.scheduleDraw(false);
    }
  }

  onRowsRefresh() {
    this.scheduleDraw(true);
  }


  onRowsRerender() {
    this.scheduleDraw(true);
  }


  onRowStoreRefresh({
                      action
                    }) {
    switch (action) {
      case 'sort':
      case 'filter':
      case 'batch':


        this.dependencyGridCache = null;
        this.scheduleDraw(true);
    }
  }


  onDependencyChange({
                       action,
                       record,
                       records
                     }) {
    const me = this;

    if (!me.client.isPainted || me.disabled) {
      return;
    }

    switch (action) {
      case 'dataset':
        me.dependencyGridCache = {};


      case 'add':


        const cache = me._dependencyGridCache;
        records.forEach(dependency => {


          cache && me.addToGridCache(dependency);
        });

        if (!cache) {
          me._thisIsAUsedExpression(me.dependencyGridCache);
        }

        me.scheduleDraw();
        return;

      case 'update':

        return me.scheduleRefreshDependency(record);

      case 'remove':

        records.forEach(dependency => {
          me.releaseDependency(dependency, true);
          me.removeFromCache(dependency);
        });
        me.client.trigger('dependenciesDrawn');
        return;


      case 'removeall':
      case 'filter':
        me.dependencyGridCache = null;

        break;
    }

    me.scheduleDraw(true);
  }


  onEventChange({
                  action,
                  record
                }) {
    switch (action) {
      case 'filter':

        this.scheduleDraw(true);
        break;

      case 'update':
        if (!record.isEvent) {
          this.drawForTimeSpan(record, true);
        } else {


          const eventRecords = [record];

          record.resources.forEach(resourceRecord => eventRecords.push(...resourceRecord.events));
          new Set(eventRecords).forEach(eventRecord => this.drawForTimeSpan(eventRecord, true));
        }

        break;

      case 'removeall':
        this.resetGridCache();
        this.scheduleDraw(true);
        break;
    }


  }

  onAssignmentRefresh({
                        action
                      }) {
    if (action === 'dataset') {

      this.resetGridCache();
      this.scheduleDraw(true);
    }
  }

  onAssignmentChange({
                       action,
                       record,
                       records
                     }) {
    const me = this;

    if (record) {
      records = [record];
    }

    if (action === 'add' || action === 'remove' || action === 'update') {
      records.forEach(assignment => {
        const dependencies = this.dataApi.getAssignmentDependencies({
          assignment,
          dependencyStore: this.dependencyStore
        });
        dependencies.forEach(dependency => {

          if (action === 'add') {
            me.scheduleRefreshDependency(dependency);
          } else if (action === 'remove') {
            let assignments;

            if (this.dataApi.isDependencySourceAssignment({
              dependency,
              assignment
            })) {

              assignments = this.dataApi.getDependencyTargetAssignments({
                dependency,
                assignmentStore: this.assignmentStore
              }).map(to => ({
                from: assignment,
                to
              }));
            } else {

              assignments = this.dataApi.getDependencySourceAssignments({
                dependency,
                assignmentStore: this.assignmentStore
              }).map(from => ({
                from,
                to: assignment
              }));
            }

            assignments.forEach(assignmentData => {
              me.releaseDependency(dependency, assignmentData);
              me.removeFromCache(dependency, assignmentData);
            });
          } else if (action === 'update') {
            this.dataApi.getDependencyAssignmentsAsFromToArray({
              dependency,
              assignmentStore: this.assignmentStore
            }).filter(a => a.from === record || a.to === record).forEach(assignmentData => {
              this.scheduleRefreshDependency(dependency, assignmentData);
            });
          }
        });
      });
    }
  }

  onElementClick(event) {
    const me = this;

    if (event.target.matches('.' + me.baseCls)) {
      const dependency = DomDataStore.get(event.target).dependency,
        eventName = event.type === 'click' ? 'Click' : 'DblClick';


      me.client.trigger(`dependency${eventName}`, {
        dependency,
        event
      });
    }
  }

  onElementDblClick(event) {
    return this.onElementClick(event);
  }

  onElementMouseOver(event) {
    const me = this;

    if (event.target.matches('.' + me.baseCls)) {
      const dependency = DomDataStore.get(event.target).dependency;


      me.client.trigger('dependencyMouseOver', {
        dependency,
        event
      });
      if (me.overCls) me.highlight(dependency, me.overCls);
    }
  }

  onElementMouseOut(event) {
    const me = this;

    if (event.target.matches('.' + me.baseCls)) {
      const dependency = DomDataStore.get(event.target).dependency;


      me.client.trigger('dependencyMouseOut', {
        dependency,
        event
      });
      if (me.overCls && !dependency.meta.removed) me.unhighlight(dependency);
    }
  }


  highlight(dependency, cls = this.overCls) {
    const element = this.getElementForDependency(dependency);
    element && element.classList.add(cls);
    dependency.highlight(cls);
  }

  unhighlight(dependency, cls = this.overCls) {
    const element = this.getElementForDependency(dependency);
    element && element.classList.remove(cls);
    dependency.unhighlight(cls);
  }

  highlightEventDependencies(timespan) {
    timespan.allDependencies.forEach(dep => this.highlight(dep));
  }

  unhighlightEventDependencies(timespan) {
    timespan.allDependencies.forEach(dep => this.unhighlight(dep));
  }


  isDependencyVisible(dependency, assignmentData = null) {
    const me = this,
      {
        dataApi,
        resourceStore,
        eventStore
      } = me,
      from = dataApi.getDependencySourceEvent({
        dependency
      }),
      to = dataApi.getDependencyTargetEvent({
        dependency
      });

    if (!(from && to)) {
      return false;
    }

    let fromResource, toResource;

    if (assignmentData) {
      fromResource = dataApi.getAssignmentResource({
        assignment: assignmentData.from,
        resourceStore
      });
      toResource = dataApi.getAssignmentResource({
        assignment: assignmentData.to,
        resourceStore
      });

      if (eventStore.isFiltered && (eventStore.indexOf(from) === -1 || eventStore.indexOf(to) === -1)) {
        return false;
      }
    } else {
      fromResource = dataApi.getEventResource({
        event: from,
        resourceStore
      });
      toResource = dataApi.getEventResource({
        event: to,
        resourceStore
      });
    }

    return from instanceof Model &&
      fromResource instanceof ResourceModel && toResource instanceof ResourceModel && !fromResource.instanceMeta(resourceStore).hidden && !toResource.instanceMeta(resourceStore).hidden;
  }

  getBox(dependency, source, assignmentData = null) {
    const eventRecord = this.getTimeSpanRecordFromDependency(dependency, source);
    let resource;

    if (assignmentData) {
      resource = this.dataApi.getAssignmentResource({
        assignment: assignmentData[source ? 'from' : 'to'],
        resourceStore: this.resourceStore
      });
    } else {
      resource = this.dataApi.getEventResource({
        event: eventRecord,
        resourceStore: this.resoureStore
      });
    }

    return this.client.getResourceEventBox(eventRecord, resource, true);
  }

  getRowRecordFromDependency(dependency, source, assignmentData) {
    let rowRecord;

    if (assignmentData) {
      rowRecord = this.dataApi.getAssignmentResource({
        assignment: assignmentData[source ? 'from' : 'to'],
        resourceStore: this.resourceStore
      });
    } else {
      rowRecord = this.dataApi.getEventResource({
        event: this.getTimeSpanRecordFromDependency(dependency, source),
        resourceStore: this.resourceStore
      });
    }

    return rowRecord;
  }

  getTimeSpanRecordFromDependency(dependency, source = true) {
    return dependency[`${source ? 'source' : 'target'}Event`];
  }

  getMetaId(assignmentData = null) {
    return assignmentData ? `${this.client.id}-ass${assignmentData.from.id}-ass${assignmentData.to.id}` : this.client.id;
  }

  getDependencyBounds(dependency, assignmentData = null) {
    const me = this,
      scheduler = me.client,
      ddr = dependency.getDateRange();

    if (!scheduler.rowManager.rowCount || !me.isDependencyVisible(dependency, assignmentData)) {
      return null;
    }

    if (!(ddr && DateHelper.intersectSpans(ddr.start, ddr.end, scheduler.startDate, scheduler.endDate))) {
      return null;
    }

    const metaId = me.getMetaId(assignmentData),
      instanceMeta = dependency.instanceMeta(metaId),
      startBox = me.getBox(dependency, true, assignmentData),
      endBox = me.getBox(dependency, false, assignmentData);

    if (!startBox || !endBox) {
      return null;
    }


    if (me._resetBoundsCache || !instanceMeta.bounds || !instanceMeta.bounds.layout) {
      const from = me.getTimeSpanRecordFromDependency(dependency, true),
        to = me.getTimeSpanRecordFromDependency(dependency, false),
        startRectangle = startBox instanceof Rectangle ? startBox : new Rectangle(startBox.start, startBox.top, startBox.end - startBox.start, startBox.bottom - startBox.top),
        endRectangle = endBox instanceof Rectangle ? endBox : new Rectangle(endBox.start, endBox.top, endBox.end - endBox.start, endBox.bottom - endBox.top),
        bounds = Rectangle.union(startRectangle, endRectangle);

      if (!scheduler.isGantt) {
        [[from, startRectangle, startBox], [to, endRectangle, endBox]].map(([record, rectangle, eventBox]) => {


          if (scheduler.milestoneLayoutMode === 'default' && record.isMilestone) {
            if (!scheduler.milestoneWidth && eventBox.eventEl && record.iconCls) {
              scheduler.milestoneWidth = eventBox.eventEl.firstElementChild.offsetWidth;
            }


            const milestoneWidth = scheduler.milestoneWidth || rectangle.height;
            rectangle.left -= milestoneWidth / 2;
            rectangle.right += milestoneWidth / 2;
          }
        });
      }

      instanceMeta.bounds = {
        bounds,
        startRectangle,
        endRectangle,


        layout: startBox.layout && endBox.layout
      };
    }

    return dependency.instanceMeta(metaId).bounds;
  }

  get dependencyGridCache() {
    const me = this;

    if (!me._dependencyGridCache) {
      me._dependencyGridCache = {};
      me.dependencyStore.forEach(dependency => me.addToGridCache(dependency));
    }

    return me._dependencyGridCache;
  }

  getIteratableDependencyAssignments(dependency) {
    return this.assignmentStore ? this.dataApi.getDependencyAssignmentsAsFromToArray({
      dependency,
      assignmentStore: this.assignmentStore
    }) : [null];
  }

  addToGridCache(dependency) {
    const me = this,
      {
        dependencyGridCache,
        cacheGridSize,
        rowStore
      } = me,
      assignmentDataArray = me.getIteratableDependencyAssignments(dependency);
    assignmentDataArray.forEach(assignmentData => {
      const dependencyBounds = me.getDependencyBounds(dependency, assignmentData);

      if (dependencyBounds) {
        const metaId = me.getMetaId(assignmentData),
          meta = dependency.instanceMeta(metaId),
          metaGridCache = meta.gridCache = [],

          fromIndex = rowStore.indexOf(me.getRowRecordFromDependency(dependency, true, assignmentData)),
          toIndex = rowStore.indexOf(me.getRowRecordFromDependency(dependency, false, assignmentData)),
          topIndex = Math.min(fromIndex, toIndex),
          bottomIndex = Math.max(fromIndex, toIndex),

          box = dependencyBounds.bounds,
          boxLeft = Math.floor(Math.max(box.x, 0) / cacheGridSize.x),
          boxRight = Math.floor(box.right / cacheGridSize.x),
          boxTop = Math.floor(topIndex / cacheGridSize.index),
          boxBottom = Math.floor(bottomIndex / cacheGridSize.index);
        let cacheX, cacheY, x, y;

        for (x = boxLeft; x <= boxRight; x++) {
          cacheX = dependencyGridCache[x] || (dependencyGridCache[x] = {});

          for (y = boxTop; y <= boxBottom; y++) {
            cacheY = cacheX[y] || (cacheX[y] = []);

            if (!cacheY.find(i => i.dependency.id === dependency.id && i.assignmentData === assignmentData && i.metaId === metaId)) {
              cacheY.push({
                dependency,
                assignmentData,
                metaId
              });
            }

            metaGridCache.push([x, y]);
          }
        }
      }
    });
  }

  removeFromCache(dependency, assignmentData = null) {
    const me = this;
    let assignments;

    if (assignmentData) {
      assignments = [assignmentData];
    } else {
      assignments = this.getIteratableDependencyAssignments(dependency);
    }

    assignments.forEach(assignmentData => {
      const metaId = me.getMetaId(assignmentData),
        meta = dependency.instanceMeta(metaId);
      meta.gridCache && me._dependencyGridCache && meta.gridCache.forEach(([x, y]) => {
        if (me._dependencyGridCache.hasOwnProperty(x) && me._dependencyGridCache[x].hasOwnProperty(y)) {
          const entries = me._dependencyGridCache[x][y],
            index = entries.findIndex(d => d.dependency === dependency && (d.assignmentData === assignmentData || d.assignmentData.from === assignmentData.from && d.assignmentData.to === assignmentData.to));

          if (index > -1) {
            entries.splice(index, 1);
          }
        }
      });
      meta.bounds = null;
      meta.gridCache = null;
    });
  }

  set dependencyGridCache(cache) {
    this._dependencyGridCache = cache;
  }


  resetBoundsCache() {


    this._resetBoundsCache = true;
  }

  resetGridCache() {
    this.dependencyGridCache = null;
  }


  prepareLineDef(dependency, dependencyDrawData, assignmentData = null) {
    const me = this,
      source = me.getTimeSpanRecordFromDependency(dependency, true),
      target = me.getTimeSpanRecordFromDependency(dependency, false),
      type = dependency.type;
    let startSide = dependency.fromSide,
      endSide = dependency.toSide;

    if (!startSide) {
      switch (true) {
        case type === DependencyModel.Type.StartToEnd:
          startSide = me.getConnectorStartSide(source);
          break;

        case type === DependencyModel.Type.StartToStart:
          startSide = me.getConnectorStartSide(source);
          break;

        case type === DependencyModel.Type.EndToStart:
          startSide = me.getConnectorEndSide(source);
          break;

        case type === DependencyModel.Type.EndToEnd:
          startSide = me.getConnectorEndSide(source);
          break;

        default:
          throw new Error('Invalid dependency type: ' + type);
      }
    }

    if (!endSide) {
      switch (true) {
        case type === DependencyModel.Type.StartToEnd:
          endSide = me.getConnectorEndSide(target);
          break;

        case type === DependencyModel.Type.StartToStart:
          endSide = me.getConnectorStartSide(target);
          break;

        case type === DependencyModel.Type.EndToStart:
          endSide = me.getConnectorStartSide(target);
          break;

        case type === DependencyModel.Type.EndToEnd:
          endSide = me.getConnectorEndSide(target);
          break;

        default:
          throw new Error('Invalid dependency type: ' + type);
      }
    }

    const {
      startRectangle,
      endRectangle
    } = dependencyDrawData;
    return {
      startBox: {
        start: startRectangle.x,
        end: startRectangle.right,
        top: startRectangle.y,
        bottom: startRectangle.bottom
      },
      endBox: {
        start: endRectangle.x,
        end: endRectangle.right,
        top: endRectangle.y,
        bottom: endRectangle.bottom
      },
      startSide: startSide,
      endSide: endSide
    };
  }

  drawLine(canvas, dependency, points, assignmentData = null, cache = true) {
    const scheduler = this.client,
      metaId = this.getMetaId(assignmentData);

    let line = dependency.instanceMeta(metaId).lineElement;

    if (!line || !cache) {
      line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');

      if (cache) {
        dependency.instanceMeta(metaId).lineElement = line;
      }

      line.setAttribute('depId', dependency.id);

      if (assignmentData) {
        line.setAttribute('fromId', assignmentData.from.id);
        line.setAttribute('toId', assignmentData.to.id);
      }

      canvas.appendChild(line);
    }


    line.classList.length && line.classList.remove.apply(line.classList, line.getAttribute('class').split(' '));
    line.classList.add(this.baseCls);

    if (dependency.cls) {
      line.classList.add(dependency.cls);
    }

    if (dependency.bidirectional) {
      line.classList.add('b-sch-bidirectional-line');
    }

    if (dependency.highlighted) {
      line.classList.add(...dependency.highlighted.split(' '));
    }

    if (BrowserHelper.isIE11) {
      const ddr = dependency.getDateRange(true),
        viewStart = scheduler.startDate;

      if (ddr.start < viewStart) {
        line.classList.add('b-no-start-marker');
      }

      if (ddr.end < viewStart) {
        line.classList.add('b-no-end-marker');
      }
    }

    line.setAttribute('points', !points ? '' : points.map((p, i) => i !== points.length - 1 ? `${p.x1},${p.y1}` : `${p.x1},${p.y1} ${p.x2},${p.y2}`).join(' '));
    DomDataStore.set(line, {
      dependency
    });
    return line;
  }


  refreshDependency(dependency) {
    const me = this,
      assignments = me.getIteratableDependencyAssignments(dependency);

    me.releaseDependency(dependency, assignments[0] !== null);

    me.removeFromCache(dependency);

    me.addToGridCache(dependency);

    assignments.forEach(assignmentData => me.drawDependency(dependency, null, assignmentData));
  }


  refreshDependencyAssignment(dependency, assignmentData) {
    const me = this;

    me.releaseDependency(dependency, assignmentData);

    me.removeFromCache(dependency, assignmentData);
    me.addToGridCache(dependency);

    me.drawDependency(dependency, null, assignmentData);
  }


  scheduleRefreshDependency(dependency, assignmentData = null) {
    const map = this.dependenciesToRefresh;

    if (!assignmentData) {
      map.set(dependency, true);
    } else if (map.has(dependency)) {
      if (map.get(dependency) !== true) {
        map.get(dependency).add(assignmentData);
      }
    } else {
      map.set(dependency, new Set([assignmentData]));
    }

    if (map.size === 1) {
      this.requestAnimationFrame(() => {
        this.refreshDependencyOnFrame();
      });
    }
  }


  refreshDependencyOnFrame() {
    const me = this,
      map = me.dependenciesToRefresh;

    if (me.client.isPainted) {

      map.forEach((assignments, dependency) => {
        if (assignments === true) {
          const assignments = me.getIteratableDependencyAssignments(dependency);

          me.releaseDependency(dependency, assignments[0] !== null);

          me.removeFromCache(dependency);
        } else {
          assignments.forEach(assignment => {

            me.releaseDependency(dependency, assignment);

            me.removeFromCache(dependency, assignment);
          });
        }
      });

      map.forEach((assignments, dependency) => {

        me.addToGridCache(dependency);
      });

      map.forEach((assignments, dependency) => {
        if (assignments === true) {
          assignments = me.getIteratableDependencyAssignments(dependency);
        }

        assignments.forEach(assignmentData => {
          me.drawDependency(dependency, null, assignmentData);
        });
      });
      map.clear();
      me.client.trigger('dependenciesDrawn', {
        partial: true
      });
    }
  }


  drawDependency(dependency, drawData = null, assignmentData = null, canvas = this.client.svgCanvas, cache = true) {
    const me = this,
      {
        drawnDependencies,
        oldDrawnDependencies
      } = me,

      dependencyDrawData = drawData || me.getDependencyBounds(dependency, assignmentData),
      lookup = d => d.dependency === dependency && (d.assignmentData === assignmentData || d.assignmentData && d.assignmentData.from === assignmentData.from && d.assignmentData.to === assignmentData.to);

    if (!me.disabled && dependencyDrawData) {

      const lineDef = me.prepareLineDef(dependency, dependencyDrawData),
        lines = me.pathFinder.findPath(lineDef, me.lineDefAdjusters);
      me.drawLine(canvas, dependency, lines, assignmentData, cache);


      if (cache && !drawnDependencies.some(lookup)) {
        drawnDependencies.push({
          dependency,
          assignmentData
        });
      }
    }

    const oldIndex = oldDrawnDependencies && oldDrawnDependencies.findIndex(lookup);

    if (oldIndex >= 0) {
      oldDrawnDependencies.splice(oldIndex, 1);
    }
  }


  drawForTimeSpan(timeSpanRecord, async = false) {
    const me = this;


    if (me.client.isAnimating) {
      me.client.on({
        transitionend() {
          me.drawForTimeSpan(timeSpanRecord, true);
        },

        once: true
      });
    } else {
      me.dependencyStore.getTimeSpanDependencies(timeSpanRecord).forEach(dependency => {
        if (async) {
          me.scheduleRefreshDependency(dependency);
        } else {
          me.refreshDependency(dependency);
        }
      });
    }
  }


  drawForEvent(eventRecord) {
    this.drawForTimeSpan(eventRecord);
  }


  updateDependenciesForTimeSpan(timeSpanRecord, element) {
    const me = this,
      eventRecord = timeSpanRecord.isAssignment ? timeSpanRecord.event : timeSpanRecord,
      deps = me.dependencyStore.getTimeSpanDependencies(eventRecord),
      metaId = me.getMetaId(),
      scheduler = me.client,
      originalTaskRect = Rectangle.from(element, scheduler.timeAxisSubGridElement);
    let bounds;
    deps.forEach(dep => {
      const assignments = this.getIteratableDependencyAssignments(dep);
      assignments.forEach(assignmentData => {
        const taskRect = originalTaskRect.clone();
        let startRectangle, endRectangle, box;


        if (assignmentData && assignmentData.from !== timeSpanRecord && assignmentData.to !== timeSpanRecord) {
          return;
        }

        if (!me.isDependencyVisible(dep, assignmentData)) {
          return;
        }

        if (me.getTimeSpanRecordFromDependency(dep, true) === eventRecord) {
          startRectangle = taskRect;

          if (bounds = dep.instanceMeta(metaId).bounds) {
            endRectangle = bounds.endRectangle;
          } else {
            box = me.getBox(dep, false, assignmentData);

            if (box) {

              endRectangle = box instanceof Rectangle ? box : new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
            }
          }
        } else {

          if (bounds = dep.instanceMeta(metaId).bounds) {
            startRectangle = bounds.startRectangle;
          } else {
            box = me.getBox(dep, true, assignmentData);

            if (box) {

              startRectangle = box instanceof Rectangle ? box : new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
            }
          }

          endRectangle = taskRect;
        }

        if (startRectangle && endRectangle) {
          me.drawDependency(dep, {
            startRectangle,
            endRectangle
          }, assignmentData);
        }
      });
    });
  }

  scheduleDraw(relayout = false) {
    const me = this;

    if (me.disabled) {
      return;
    }


    if (relayout) {
      me.resetBoundsCache();
    }


    if (me.client.isAnimating) {
      if (!me.clientTransitionRemover) {
        me.clientTransitionRemover = me.client.on({
          transitionend() {
            me.clientTransitionRemover();
            me.clientTransitionRemover = null;
            me.draw();
          },

          once: true
        });
      }
    } else {
      me.doScheduleDraw();
    }
  }


  draw(reLayout = false) {
    const me = this,
      scheduler = me.client;

    if (!me.oldDrawnDependencies && !me.dependencyStore.count || !scheduler.isPainted) {
      return;
    }

    if (scheduler.isAnimating) {
      scheduler.on({
        transitionend() {
          me.scheduleDraw(true);
        },

        once: true
      });
      return;
    }

    const viewBox = scheduler.timeAxisSubGrid.viewRectangle;

    if (reLayout) {
      me.resetBoundsCache();
    }


    if (!viewBox.width || !viewBox.height) {
      return;
    }

    me.oldDrawnDependencies = me.drawnDependencies;
    me.drawnDependencies = [];

    viewBox.inflate(me.bufferSize);

    if (!me.disabled && me.rowStore.count && scheduler.rowManager.rowCount) {
      const consideredDependencies = {},
        {
          dependencyGridCache,
          cacheGridSize
        } = me,
        viewLeft = Math.floor(Math.max(viewBox.left, 0) / cacheGridSize.x),
        viewRight = Math.floor(viewBox.right / cacheGridSize.x),
        topIndex = Math.floor(scheduler.rowManager.topRow.dataIndex / cacheGridSize.index),
        bottomIndex = Math.floor(scheduler.rowManager.bottomRow.dataIndex / cacheGridSize.index),
        dependenciesToDraw = [];
      let x, rowIndex, i;

      for (x = viewLeft; x <= viewRight; x++) {
        for (rowIndex = topIndex; rowIndex <= bottomIndex; rowIndex++) {
          const cacheX = dependencyGridCache[x],
            deps = cacheX && cacheX[rowIndex];

          for (i = 0; deps && i < deps.length; i++) {
            const {
                dependency,
                assignmentData,
                metaId
              } = deps[i],

              flagId = dependency.id + '-' + metaId;

            if (!consideredDependencies[flagId]) {

              const bounds = me.getDependencyBounds(dependency, assignmentData);

              if (bounds && bounds.bounds.intersect(viewBox, true, true) || scheduler.ignoreViewBox) {
                dependenciesToDraw.push([dependency, bounds, assignmentData]);
              }

              consideredDependencies[flagId] = true;
            }
          }
        }
      }

      dependenciesToDraw.forEach(([dependency, bounds, assignmentData]) => {
        me.drawDependency(dependency, bounds, assignmentData);
      });
    }

    me._resetBoundsCache = false;

    me.oldDrawnDependencies.forEach(data => me.releaseDependency(data.dependency, data.assignmentData));
    scheduler.trigger('dependenciesDrawn');
    this.isDrawn = true;
  }


  releaseDependency(dependency, assignmentData = null) {

    if (assignmentData === true) {
      Object.keys(dependency.meta.map || {}).filter(key => key.startsWith(this.client.id)).forEach(key => {
        const data = dependency.meta.map[key];

        if (data.lineElement) {
          data.lineElement.remove();
          data.lineElement = null;
        }
      });
    } else {
      const metaId = this.getMetaId(assignmentData),
        lineElement = dependency.instanceMeta(metaId).lineElement;

      if (lineElement) {
        dependency.instanceMeta(metaId).lineElement = null;

        lineElement.remove();
      }
    }
  }

  render() {
    const me = this,
      scheduler = me.client;

    if (me.showTooltip) {
      me.tooltip = me.createTooltip();
    }

    scheduler.timeAxis.on({
      endreconfigure: me.resetGridCache,
      thisObj: me
    });
    scheduler.rowManager.on({
      refresh: me.onRowsRefresh,

      changetotalheight: me.onChangeTotalHeight,

      thisObj: me
    });

    scheduler.on({
      horizontalscroll: me.onHorizontalScroll,
      svgcanvascreated: me.createMarkers,
      togglenode: me.onToggleNode,
      scroll: me.onVerticalScroll,

      timelineviewportresize: me.onViewportResize,
      thisObj: me
    });

    if (me.highlightDependenciesOnEventHover) {
      scheduler.on(scheduler.scheduledEventName + 'MouseEnter', params => me.highlightEventDependencies(params.eventRecord || params.taskRecord));
      scheduler.on(scheduler.scheduledEventName + 'MouseLeave', params => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord));
    }

    me.draw();
  }

  renderContents() {
    this.draw();
  }


  getConnectorStartSide(timeSpanRecord) {
    return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);
  }


  getConnectorEndSide(timeSpanRecord) {
    return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);
  }


  createTooltip() {
    const me = this,
      scheduler = me.client;
    return new Tooltip(Object.assign({
      align: 'b-t',
      id: `${scheduler.id}-dependency-tip`,

      forSelector: `.b-timelinebase:not(.b-eventeditor-editing):not(.b-resizing-event):not(.b-dragcreating):not(.b-dragging-event):not(.b-creating-dependency) .${me.baseCls}`,
      clippedBy: [scheduler.timeAxisSubGridElement, scheduler.bodyContainer],
      forElement: scheduler.timeAxisSubGridElement,
      showOnHover: true,
      hoverDelay: 0,
      hideDelay: 0,
      anchorToTarget: false,
      textContent: false,

      trackMouse: false,
      getHtml: me.getHoverTipHtml.bind(me)
    }, me.tooltip || {}));
  }


  getHoverTipHtml({
                    activeTarget
                  }) {
    const me = this,
      dependency = me.getDependencyForElement(activeTarget),
      fromEvent = me.dataApi.getDependencySourceEvent({
        dependency,
        eventStore: this.eventStore
      }),
      toEvent = me.dataApi.getDependencyTargetEvent({
        dependency,
        eventStore: this.eventStore
      });
    return TemplateHelper.tpl`
             <table class="b-sch-dependency-tooltip">
                <tr>
                    <td>${me.L('from')}: </td>
                    <td>${fromEvent.name}</td>
                    <td>
                        <div class="b-sch-box b-${fromBoxSide[dependency.type]}"></div>
                    </td>
                </tr>
                <tr>
                    <td>${me.L('to')}: </td>
                    <td>${toEvent.name}</td>
                    <td><div class="b-sch-box b-${toBoxSide[dependency.type]}"></div></td>
                </tr>
            </table>
        `;
  }

}

Dependencies._$name = 'Dependencies';
GridFeatureManager.registerFeature(Dependencies, false, 'Scheduler');


if (document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
  (function (view) {
    if (!('Element' in view)) return;

    var classListProp = 'classList',
      protoProp = 'prototype',
      elemCtrProto = view.Element[protoProp],
      objCtr = Object,
      strTrim = String[protoProp].trim || function () {
        return this.replace(/^\s+|\s+$/g, '');
      },
      arrIndexOf = Array[protoProp].indexOf || function (item) {
        for (var i = 0, len = this.length; i < len; i++) {
          if (i in this && this[i] === item) {
            return i;
          }
        }

        return -1;
      },

      DOMEx = function (type, message) {
        this.name = type;
        this.code = DOMException[type];

        this.message = message;
      },
      checkTokenAndGetIndex = function (classList, token) {
        if (token === '') {
          throw new DOMEx('SYNTAX_ERR', 'The token must not be empty.');
        }

        if (/\s/.test(token)) {
          throw new DOMEx('INVALID_CHARACTER_ERR', 'The token must not contain space characters.');
        }

        return arrIndexOf.call(classList, token);
      },
      ClassList = function (elem) {
        var trimmedClasses = strTrim.call(elem.getAttribute('class') || ''),
          classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [];

        for (var i = 0, len = classes.length; i < len; i++) {
          this.push(classes[i]);
        }

        this._updateClassName = function () {
          elem.setAttribute('class', this.toString());
        };
      },
      classListProto = ClassList[protoProp] = [],
      classListGetter = function () {
        return new ClassList(this);
      };


    DOMEx[protoProp] = Error[protoProp];

    classListProto.item = function (i) {
      return this[i] || null;
    };

    classListProto.contains = function (token) {
      return ~checkTokenAndGetIndex(this, token + '');
    };

    classListProto.add = function () {
      var tokens = arguments,
        i = 0,
        l = tokens.length,
        token,
        updated = false;

      do {
        token = tokens[i] + '';

        if (!~checkTokenAndGetIndex(this, token)) {
          this.push(token);
          updated = true;
        }
      } while (++i < l);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.remove = function () {
      var tokens = arguments,
        i = 0,
        l = tokens.length,
        token,
        updated = false,
        index;

      do {
        token = tokens[i] + '';
        index = checkTokenAndGetIndex(this, token);

        while (~index) {
          this.splice(index, 1);
          updated = true;
          index = checkTokenAndGetIndex(this, token);
        }
      } while (++i < l);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.toggle = function (token, force) {
      var result = this.contains(token),
        method = result ? force !== true && 'remove' : force !== false && 'add';

      if (method) {
        this[method](token);
      }

      if (force === true || force === false) {
        return force;
      } else {
        return !result;
      }
    };

    classListProto.replace = function (token, replacementToken) {
      var index = checkTokenAndGetIndex(token + '');

      if (~index) {
        this.splice(index, 1, replacementToken);

        this._updateClassName();
      }
    };

    classListProto.toString = function () {
      return this.join(' ');
    };

    if (objCtr.defineProperty) {
      var classListPropDesc = {
        get: classListGetter,
        enumerable: true,
        configurable: true
      };

      try {
        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
      } catch (ex) {


        if (ex.number === undefined || ex.number === -0x7FF5EC54) {
          classListPropDesc.enumerable = false;
          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
        }
      }
    } else if (objCtr[protoProp].__defineGetter__) {
      elemCtrProto.__defineGetter__(classListProp, classListGetter);
    }
  })(window);
}


(function () {
  var testElement = document.createElement('_');
  testElement.classList.add('c1', 'c2');


  if (!testElement.classList.contains('c2')) {
    var createMethod = function (method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function (token) {

        for (var i = 0, len = arguments.length; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };

    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle('c3', false);


  if (testElement.classList.contains('c3')) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function (token, force) {

      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };
  }

  if (!('replace' in document.createElement('_').classList)) {
    DOMTokenList.prototype.replace = function (token, replacementToken) {

      var tokens = this.toString().split(' '),
        index = tokens.indexOf(token + '');

      if (~index) {
        tokens = tokens.slice(index);
        this.remove.apply(this, tokens);
        this.add(replacementToken);
        this.add.apply(this, tokens.slice(1));
      }
    };
  }

  testElement = null;
})();

const ScheduleRange = {
  completeview: 'completeview',

  currentview: 'currentview',
  daterange: 'daterange'
};

class ScheduleRangeCombo extends LocalizableCombo {
  static get $name() {
    return 'ScheduleRangeCombo';
  }

  static get defaultConfig() {
    return {
      editable: false
    };
  }

  buildLocalizedItems() {
    const me = this;
    return Object.entries(ScheduleRange).map(([id, text]) => ({
      id,
      text: me.L(text)
    }));
  }

}

ScheduleRangeCombo._$name = 'ScheduleRangeCombo';
BryntumWidgetAdapterRegister.register(ScheduleRangeCombo.$name.toLowerCase(), ScheduleRangeCombo);


function isLastLevel(level, levels) {
  return level === levels.length - 1;
}

function isLastCell(level, cell) {
  return cell === level.cells[level.cells.length - 1];
}


class TimeAxisBase extends Widget {

  static get defaultConfig() {
    return {

      compactCellWidthThreshold: 15,

      model: null,
      cls: null,


      sizeProperty: null,


      positionProperty: null,


      wrapText: null
    };
  }

  static get properties() {
    return {
      startDate: null,
      endDate: null,
      levels: [],
      size: null
    };
  }

  set range(range) {
    this.startDate = range.startDate;
    this.endDate = range.endDate;
    this.refresh();
    this.trigger('rangeChange', {
      startDate: range.startDate,
      endDate: range.endDate
    });
  }


  buildCells() {
    const me = this,
      {
        sizeProperty
      } = me,
      featureHeaderConfigs = [],
      cellConfigs = me.levels.map((level, i) => ({
        className: {
          'b-sch-header-row': 1,
          [`b-sch-header-row-${level.position}`]: 1,
          'b-sch-header-row-main': i === me.model.viewPreset.mainHeaderLevel,
          'b-lowest': isLastLevel(i, me.levels)
        },
        syncOptions: {


          releaseThreshold: 5,
          syncIdField: 'tickIndex'
        },
        dataset: {
          headerFeature: `headerRow${i}`,
          headerPosition: level.position
        },

        children: level.cells.filter(cell => cell.start < me.endDate && cell.end > me.startDate).map(cell => ({
          className: {
            'b-sch-header-timeaxis-cell': 1,
            [cell.headerCellCls]: cell.headerCellCls,
            [`b-align-${cell.align}`]: cell.align,
            'b-last': isLastCell(level, cell)
          },
          dataset: {
            tickIndex: cell.index,

            ...(window.DEBUG && {
              date: cell.start.getTime()
            })
          },
          style: {

            [me.positionProperty]: cell.coord,
            [sizeProperty]: cell.width,
            [`min-${sizeProperty}`]: cell.width
          },
          children: me.wrapText ? [{
            className: 'b-sch-header-text',
            html: cell.value
          }] : null,
          html: me.wrapText ? null : cell.value
        }))
      }));

    me.client && me.client.getHeaderDomConfigs(featureHeaderConfigs);
    cellConfigs.push(...featureHeaderConfigs);

    return {
      className: `b-widget ${me.cls}`,
      syncOptions: {

        releaseThreshold: 0
      },
      style: {
        [sizeProperty]: me.size
      },
      children: cellConfigs
    };
  }

  render(targetElement) {
    super.render(targetElement);
    this.refresh(true);
  }


  refresh(rebuild = !this.levels.length) {
    const me = this,
      {
        columnConfig
      } = me.model,
      {
        levels
      } = me,
      oldLevelsCount = levels.length;

    if (rebuild) {
      levels.length = 0;
      columnConfig.forEach((cells, position) => levels[position] = {
        position,
        cells
      });
      me.size = levels[0].cells.reduce((sum, cell) => sum += cell.width, 0);

      const parentEl = me.element.parentElement;

      if (parentEl) {
        parentEl.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);
        parentEl.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);
      }
    }

    if (!me.startDate || !me.endDate) {
      return;
    }

    DomSync.sync({
      domConfig: me.buildCells(),
      targetElement: me.element,
      syncIdField: 'headerFeature'
    });
    me.trigger('refresh');
  }


  get widgetClass() {
  }

}

TimeAxisBase._$name = 'TimeAxisBase';


class HorizontalTimeAxis extends TimeAxisBase {
  static get $name() {
    return 'HorizontalTimeAxis';
  }

  static get defaultConfig() {
    return {
      cls: 'b-horizontaltimeaxis',
      sizeProperty: 'width',
      positionProperty: 'left',
      wrapText: false
    };
  }

  construct() {
    super.construct(...arguments);
    this.model.on({
      update: this.onModelUpdate,
      thisObj: this
    });
  }

  get width() {
    return this.size;
  }

  onModelUpdate() {

    if (this.model.availableSpace !== this.width) {
      this.refresh(true);
    }
  }

}

HorizontalTimeAxis._$name = 'HorizontalTimeAxis';


class ResourceHeader extends Widget {

  static get $name() {
    return 'ResourceHeader';
  }

  static get defaultConfig() {
    return {

      resourceStore: null,


      columnWidth: 150,


      headerRenderer: null,


      fillWidth: true,


      fitWidth: false,

      imagePath: null,

      imageExtension: null,

      defaultImageName: null
    };
  }

  static get properties() {
    return {
      firstResource: -1,
      lastResource: -1
    };
  }


  construct(config) {
    super.construct(config);
    const me = this;

    if (me.imagePath != null) {

      EventHelper.on({
        element: me.element,
        delegate: '.b-resource-image',
        capture: true,
        error: event => me.setDefaultResourceImage(event.target),
        thisObj: me
      });

      me.element.classList.add('b-has-images');
    }

    EventHelper.on({
      element: me.element,
      delegate: '.b-resourceheader-cell',
      capture: true,
      click: 'onResourceMouseEvent',
      dblclick: 'onResourceMouseEvent',
      contextmenu: 'onResourceMouseEvent',
      thisObj: me
    });
  }


  set resourceStore(store) {
    const me = this;

    if (store !== me._resourceStore) {
      me.resourceStoreDetacher && me.resourceStoreDetacher();
      me._resourceStore = store;
      me.resourceStoreDetacher = store.on({
        change: 'onResourceStoreDataChange',
        thisObj: me
      });

      if (store.count) {
        me.onResourceStoreDataChange({});
      }
    }
  }

  get resourceStore() {
    return this._resourceStore;
  }

  onResourceStoreDataChange({
                              action
                            }) {
    const me = this,
      width = me.resourceStore.count * me.columnWidth;

    if (width !== me.width) {
      me.element.style.width = width + 'px';

      me.column.set('width', width, me.column.grid.isConfiguring);
    }

    if (action === 'removeall') {

      me.element.innerHTML = '';
    }

    if (action === 'remove' || action === 'add' || action === 'filter') {
      me.refreshWidths();
    }
  }


  get columnWidth() {
    return this._columnWidth;
  }

  set columnWidth(width) {
    const me = this;

    if (width !== me._columnWidth) {
      const oldWidth = me._columnWidth;
      me._columnWidth = width;

      if (!me.refreshingWidths) {
        me._originalColumnWidth = width;
        me.refreshWidths();
      }

      if (!me.isConfiguring) {
        me.refresh();

        me.trigger('columnWidthChange', {
          width: me._columnWidth,
          oldWidth
        });
      }
    }
  }


  get fillWidth() {
    return this._fillWidth;
  }

  set fillWidth(fill) {
    this._fillWidth = fill;
    this.refreshWidths();
  }


  get fitWidth() {
    return this._fitWidth;
  }

  set fitWidth(fit) {
    this._fitWidth = fit;
    this.refreshWidths();
  }

  setDefaultResourceImage(target) {
    if (this.defaultImageName) {
      const defaultURL = this.getImageURL(this.defaultImageName);

      if (target.src && !target.src.endsWith(defaultURL.replace(/^[./]*/gm, ''))) {
        target.src = defaultURL;
      }
    }
  }

  getImageURL(imageName) {
    return StringHelper.joinPaths([this.imagePath || '', imageName || '']);
  }

  get imagePath() {
    return this._imagePath;
  }

  set imagePath(path) {
    this._imagePath = path;
    this.refresh();
  }


  get availableWidth() {
    return this._availableWidth;
  }

  set availableWidth(width) {
    this._availableWidth = width;
    this.refreshWidths();
  }

  refreshWidths() {
    const me = this,
      {
        availableWidth,
        _originalColumnWidth
      } = me,
      count = me.resourceStore && me.resourceStore.count;

    if (!availableWidth || !count) {
      return;
    }

    me.refreshingWidths = true;
    const
      fit = me.fitWidth || me.fillWidth && _originalColumnWidth * count < availableWidth,
      useWidth = fit ? Math.floor(availableWidth / count) : _originalColumnWidth,
      shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;
    DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0, me);
    me.columnWidth = useWidth;
    me.refreshingWidths = false;
  }


  set range(range) {
    const me = this;
    me.firstResource = range.firstResource;
    me.lastResource = range.lastResource;
    me.refresh();
  }


  refresh() {
    const me = this,
      {
        firstResource,
        lastResource
      } = me;

    if (me.column.grid.isConfiguring || firstResource === -1 || lastResource === -1 || lastResource >= me.resourceStore.count) {
      return;
    }

    const configs = [];

    for (let i = firstResource; i <= lastResource; i++) {
      const resourceRecord = me.resourceStore.getAt(i),
        elementConfig = {

          className: new DomClassList({
            'b-resourceheader-cell': 1
          }),
          dataset: {
            resourceId: resourceRecord.id
          },
          style: {
            left: i * me.columnWidth,
            width: me.columnWidth
          },
          children: []
        };

      if (me.headerRenderer) {
        const value = me.headerRenderer({
          elementConfig,
          resourceRecord
        });

        if (value != null) {
          elementConfig.html = value;
        }
      } else {
        let imageUrl;

        if (resourceRecord.imageUrl) {
          imageUrl = resourceRecord.imageUrl;
        } else {
          if (me.imagePath != null) {
            const imageName = resourceRecord.image || resourceRecord.name && resourceRecord.name.toLowerCase() + me.imageExtension || me.defaultImageName;
            imageUrl = me.getImageURL(imageName);
          }
        }

        if (imageUrl != null) {
          elementConfig.children.push({
            tag: 'img',
            className: 'b-resource-image',
            src: imageUrl
          });
        }

        if (resourceRecord.iconCls) {
          elementConfig.children.push({
            tag: 'i',
            className: resourceRecord.iconCls
          });
        }

        elementConfig.children.push({
          tag: 'span',
          className: 'b-resource-name',
          html: resourceRecord.name
        });
      }

      configs.push(elementConfig);
    }

    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: configs
      },
      targetElement: me.element,
      syncIdField: 'resourceId'


    });
  }

  onResourceMouseEvent(event) {
    const resourceCell = event.target.closest('.b-resourceheader-cell'),
      resourceRecord = this.resourceStore.getById(resourceCell.dataset.resourceId);
    this.trigger('resourceHeader' + StringHelper.capitalizeFirstLetter(event.type), {
      resourceRecord,
      event
    });
  }

}

ResourceHeader._$name = 'ResourceHeader';


class TimeAxisColumn extends Events(Column) {


  construct() {
    const me = this;
    super.construct(...arguments);
    me.initialRender = true;
    me.thisObj = me;
    me.timeAxisViewModel = me.timeline.timeAxisViewModel;


    me.mode = me.mode;
    me.grid.on({
      paint: 'onTimelinePaint',
      thisObj: me,
      once: true
    });
    me.timeAxisViewModel.on({
      update: me.onViewModelUpdate,
      thisObj: me
    });
  }

  static get autoExposeFields() {
    return true;
  }


  static get fields() {
    return ['mode'];
  }

  static get defaults() {
    return {

      draggable: false,


      groupable: false,


      hideable: false,


      showColumnPicker: false,


      filterable: false,


      sortable: false,


      resizable: false,


      searchable: false,


      editor: false,


      enableCellContextMenu: false,


      tooltipRenderer: false,


      cls: 'b-sch-timeaxiscolumn',

      needWidth: true,
      mode: null,
      region: 'normal',
      exportable: false
    };
  }

  static get type() {
    return 'timeAxis';
  }

  doDestroy() {
    this.resourceColumns && this.resourceColumns.destroy();
    super.doDestroy();
  }

  set mode(mode) {
    const me = this,
      {
        timeline
      } = me;
    me.set('mode', mode);

    if (mode === 'horizontal') {
      me.timeAxisView = new HorizontalTimeAxis({
        model: me.timeAxisViewModel,
        compactCellWidthThreshold: me.compactCellWidthThreshold,
        owner: me.grid,
        client: me.grid
      });
    } else if (mode === 'vertical') {

      me.resourceColumns = new ResourceHeader(ObjectHelper.assign({
        column: me,
        resourceStore: timeline.resourceStore,
        imagePath: timeline.resourceImagePath,
        imageExtension: timeline.resourceImageExtension,
        defaultImageName: timeline.defaultResourceImageName
      }, timeline.resourceColumns || {}));
      me.relayEvents(me.resourceColumns, ['resourceheaderclick', 'resourceheaderdblclick', 'resourceheadercontextmenu']);
    }
  }

  get mode() {
    return this.get('mode');
  }


  onViewModelUpdate({
                      source: viewModel
                    }) {
    const me = this;

    if (me.mode === 'horizontal') {

      me.refreshHeader(true);
      me.width = viewModel.totalSize;
      me.timeline.refresh();
    } else if (me.mode === 'vertical') {

      me.timeline.refreshRows();
    }
  }


  onTimelinePaint({
                    firstPaint
                  }) {
    const me = this;

    if (!me.subGrid.insertRowsBefore) {
      return;
    }

    if (firstPaint) {
      me.subGridElement.classList.add('b-timeline-subgrid');

      if (me.element) {
        EventHelper.on({
          element: me.element,
          thisObj: me,
          click: 'onContainerElementClick',
          dblclick: 'onContainerElementClick',
          contextmenu: 'onContainerElementClick'
        });
      }

      if (me.mode === 'vertical') {
        me.refreshHeader();
      }
    }
  }


  refreshHeader(internal) {
    const me = this,
      {
        element
      } = me;

    if (element) {
      if (me.mode === 'horizontal') {

        !internal && me.timeAxisViewModel.update(null, true);

        if (!me.timeAxisView.rendered) {

          element.innerHTML = '';
          me.timeAxisView.render(element);
        } else {

          me.timeAxisView.refresh(true);
        }
      } else if (me.mode === 'vertical') {
        if (!me.resourceColumns.currentElement) {

          element.innerHTML = '';
          me.resourceColumns.render(element);
        }

      }
    }
  }

  renderer(renderData) {
    return this.timeline.currentOrientation.renderer(renderData);
  }


  onContainerElementClick(event) {
    const target = DomHelper.up(event.target, '.b-sch-header-timeaxis-cell');

    if (target) {
      const index = target.dataset.tickIndex,
        position = target.parentElement.dataset.headerPosition,
        columnConfig = this.timeAxisViewModel.columnConfig[position][index];

      const contextMenu = this.grid.features.contextMenu;

      if (!contextMenu || event.type !== contextMenu.triggerEvent) {
        this.trigger('timeAxisHeader' + StringHelper.capitalizeFirstLetter(event.type), {
          startDate: columnConfig.start,
          endDate: columnConfig.end,
          event
        });
      }
    }
  }

}

ColumnStore.registerColumnType(TimeAxisColumn);
TimeAxisColumn._$name = 'TimeAxisColumn';


class SchedulerExportDialog extends ExportDialog {
  static get $name() {
    return 'SchedulerExportDialog';
  }

  onLocaleChange() {
    const labelWidth = this.L('labelWidth');
    this.width = this.L('width');
    this.items.forEach(widget => {
      if (widget instanceof Field) {
        widget.labelWidth = labelWidth;
      } else if (widget.ref === 'rangeFieldsContainer') {
        widget.items[0].width = labelWidth;
      }
    });
  }

  buildDialogItems(config) {
    const me = this,
      {
        client
      } = config,
      items = super.buildDialogItems(config),
      labelWidth = me.L('labelWidth');
    me.columnsStore = client.columns.chain(record => record.isLeaf && !(record instanceof TimeAxisColumn));
    const columnsField = items.find(item => item.ref === 'columnsField');
    columnsField.store = me.columnsStore;
    columnsField.value = me.columnsStore.allRecords;
    items.splice(1, 0, {
      labelWidth,
      type: 'schedulerangecombo',
      ref: 'scheduleRangeField',
      label: 'L{Schedule range}',
      localeClass: me,
      value: ScheduleRange.completeview,

      onChange({
                 value
               }) {
        const hidden = value !== ScheduleRange.daterange,
          widgetMap = this.owner.widgetMap;
        widgetMap.rangeStartField.hidden = widgetMap.rangeEndField.hidden = hidden;
      }

    }, {
      type: 'container',
      ref: 'rangeFieldsContainer',
      flex: '1 0 100%',
      items: [{

        type: 'widget',
        width: labelWidth
      }, {
        type: 'datefield',
        ref: 'rangeStartField',
        label: 'L{Export from}',
        hidden: true,
        flex: '1 0 25%',
        localeClass: me,
        value: config.client.startDate
      }, {
        type: 'datefield',
        ref: 'rangeEndField',
        label: 'L{Export to}',
        hidden: true,
        flex: '1 0 25%',
        localeClass: me,
        value: config.client.endDate
      }]
    });
    return items;
  }

}

SchedulerExportDialog._$name = 'SchedulerExportDialog';

const immediatePromise$5 = Promise.resolve();
var SchedulerExporterMixin = (base => class SchedulerExporterMixin extends base {
  async scrollRowIntoView(client, index) {
    const {
        rowManager,
        scrollable
      } = client,
      oldY = scrollable.y;

    if (index < client.store.count) {

      scrollable.scrollTo(null, rowManager.calculateTop(index));


      if (scrollable.y !== oldY) {


        if (!rowManager.getRow(index)) {
          return new Promise(resolve => {
            const detacher = rowManager.on({
              renderRow({
                          recordIndex
                        }) {
                if (recordIndex === index) {
                  detacher();
                  resolve();
                }
              }

            });
          });
        }
      }
    }

    return immediatePromise$5;
  }

  async scrollToDate(client, date) {
    let scrollFired = false;
    const promises = [];


    const detacher = client.timeAxisSubGrid.scrollable.on({
      scrollstart({
                    x
                  }) {
        if (x != null) {
          scrollFired = true;
        }
      }

    });


    promises.push(client.scrollToDate(date, {
      block: 'start'
    }));
    detacher();

    if (scrollFired) {

      promises.push(new Promise(resolve => {
        client.timeView.on({
          refresh() {
            resolve();
          },

          once: true
        });
      }));
    }

    await Promise.all(promises);
  }

  async prepareComponent(config) {
    const me = this,
      {
        client
      } = config;

    switch (config.scheduleRange) {
      case ScheduleRange.completeview:
        config.rangeStart = client.startDate;
        config.rangeEnd = client.endDate;
        break;

      case ScheduleRange.currentview:
        const {
          startDate,
          endDate
        } = client.getVisibleDateRange();
        config.rangeStart = startDate;
        config.rangeEnd = endDate;
        break;
    }

    client.setTimeSpan(config.rangeStart, config.rangeEnd);
    await super.prepareComponent(config);
    const {
        exportMeta
      } = me,
      fgCanvasEl = me.element.querySelector('.b-sch-foreground-canvas'),
      timeAxisEl = me.element.querySelector('.b-horizontaltimeaxis');

    if (config.scheduleRange !== ScheduleRange.completeview) {

      exportMeta.totalWidth -= exportMeta.subGrids.normal.width;
      exportMeta.totalWidth += exportMeta.subGrids.normal.width = client.timeAxisViewModel.getDistanceBetweenDates(config.rangeStart, config.rangeEnd);

      exportMeta.subGrids.normal.scrollLeft = client.getCoordinateFromDate(config.rangeStart);
    }

    exportMeta.timeAxisHeaders = [];
    exportMeta.timeAxisPlaceholders = [];
    exportMeta.headersColleted = false;
    DomHelper.forEachSelector(timeAxisEl, '.b-sch-header-row', headerRow => {
      exportMeta.timeAxisPlaceholders.push(me.createPlaceholder(headerRow));
      exportMeta.timeAxisHeaders.push(new Map());
    });

    exportMeta.subGrids.normal.eventsPlaceholder = me.createPlaceholder(fgCanvasEl, false);
    DomHelper.removeEachSelector(fgCanvasEl, '.b-sch-event-wrap');
    exportMeta.eventsBoxes = new Map();
    exportMeta.client = client;

    if (client.features.dependencies && !client.features.dependencies.disabled) {
      const svgCanvasEl = me.element.querySelector(`[id="${client.svgCanvas.getAttribute('id')}"]`);

      if (exportMeta.dependenciesPlaceholder = svgCanvasEl) {
        DomHelper.removeEachSelector(svgCanvasEl, '.b-sch-dependency');
      }
    }

    if (!DateHelper.betweenLesser(config.rangeStart, client.startDate, client.endDate)) {
      await me.scrollToDate(client, config.rangeStart);
    }

    const horizontalPages = Math.ceil(exportMeta.totalWidth / exportMeta.pageWidth),
      totalPages = horizontalPages * exportMeta.verticalPages;
    exportMeta.horizontalPages = horizontalPages;
    exportMeta.totalPages = totalPages;
  }

  async onRowsCollected(rows, config) {
    await super.onRowsCollected(rows);
    const me = this,
      {
        client
      } = config,
      {
        timeView
      } = client,
      {
        pageRangeStart,
        pageRangeEnd
      } = me.getCurrentPageDateRange(config);
    let rangeProcessed = false;
    await me.scrollToDate(client, pageRangeStart);


    while (!rangeProcessed) {
      me.collectHeaders(config);
      me.collectEvents(rows, config);

      if (DateHelper.timeSpanContains(timeView.startDate, timeView.endDate, pageRangeStart, pageRangeEnd)) {
        rangeProcessed = true;
      } else if (timeView.endDate.getTime() >= pageRangeEnd.getTime()) {
        rangeProcessed = true;
      } else {
        const endDate = timeView.endDate;
        await me.scrollToDate(client, timeView.endDate);


        if (endDate.getTime() === timeView.endDate.getTime()) {
          throw new Error('Could not scroll to date');
        }
      }
    }

    await me.scrollToDate(client, config.rangeStart);
  }

  getCurrentPageDateRange({
                            rangeStart,
                            rangeEnd,
                            client
                          }) {
    const me = this,
      {
        exportMeta
      } = me,
      {
        horizontalPages,
        horizontalPosition,
        pageWidth,
        subGrids
      } = exportMeta;
    let pageRangeStart, pageRangeEnd;

    if (horizontalPages > 1) {
      const pageStartX = horizontalPosition * pageWidth,
        pageEndX = (horizontalPosition + 1) * pageWidth,


        normalGridX = subGrids.locked.width;

      if (pageEndX <= normalGridX) {
        pageRangeEnd = pageRangeStart = null;
      } else {
        pageRangeStart = client.getDateFromCoordinate(Math.max(pageStartX - normalGridX, 0));

        pageRangeEnd = client.getDateFromCoordinate((pageEndX - normalGridX) * 1.2) || rangeEnd;
      }
    } else {
      pageRangeStart = rangeStart;
      pageRangeEnd = rangeEnd;
    }

    return {
      pageRangeStart,
      pageRangeEnd
    };
  }

  prepareExportElement() {
    const {
        element,
        exportMeta
      } = this,
      {
        id,
        headerId,
        footerId,
        scrollLeft
      } = exportMeta.subGrids.normal;
    const el = element.querySelector(`[id="${id}"]`);
    ['.b-sch-background-canvas', '.b-sch-foreground-canvas'].forEach(selector => {
      const canvasEl = el.querySelector(selector);

      if (canvasEl) {

        if (exportMeta.lastExportedRowBottom) {
          canvasEl.style.height = `${exportMeta.lastExportedRowBottom}px`;
        } else {
          canvasEl.style.height = '';
        }

        if (scrollLeft) {
          canvasEl.style.marginLeft = `-${scrollLeft}px`;
        }
      }
    });

    if (scrollLeft) {
      [headerId, footerId].forEach(id => {
        const el = element.querySelector(`[id="${id}"] .b-widget-scroller`);

        if (el) {
          el.style.marginLeft = `-${scrollLeft}px`;
        }
      });
    }

    return super.prepareExportElement();
  }

  collectRow(row) {
    const me = this,
      {
        subGrids
      } = me.exportMeta;
    Object.entries(row.elements).forEach(([key, value]) => {
      const rowConfig = [value.outerHTML, row.top, row.offsetHeight];

      if (key === 'normal') {
        rowConfig.push(new Map());
      }

      subGrids[key].rows.push(rowConfig);
    });
  }

  collectHeaders(config) {
    const me = this,
      {
        client
      } = config,
      {
        exportMeta
      } = me;

    if (!exportMeta.headersCollected) {
      const timeAxisEl = client.timeView.element,
        timeAxisHeaders = exportMeta.timeAxisHeaders;
      DomHelper.forEachSelector(timeAxisEl, '.b-sch-header-row', (headerRow, index, headerRows) => {
        const headersMap = timeAxisHeaders[index];
        DomHelper.forEachSelector(headerRow, '.b-sch-header-timeaxis-cell', el => {
          if (!headersMap.has(el.dataset.tickIndex)) {
            headersMap.set(el.dataset.tickIndex, el.outerHTML);
          }
        });

        if (index === headerRows.length - 1 && headersMap.has(String(client.timeAxis.count - 1))) {
          exportMeta.headersCollected = true;
        }
      });
    }
  }

  collectEvents(rows, config) {
    const me = this,
      addedRows = rows.length,
      {
        client
      } = config,
      normalRows = me.exportMeta.subGrids.normal.rows;
    rows.forEach((row, index) => {
      const rowConfig = normalRows[normalRows.length - addedRows + index],
        resource = client.store.getAt(row.dataIndex),
        eventsMap = rowConfig[3];
      resource.events && resource.events.forEach(event => {
        if (event.isScheduled) {
          let el = client.getElementFromEventRecord(event, resource);

          if (el && (el = el.parentElement) && !eventsMap.has(event.id)) {
            eventsMap.set(event.id, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);
          }
        }
      });
    });
  }

  buildPageHtml() {
    const me = this,
      {
        subGrids,
        timeAxisHeaders,
        timeAxisPlaceholders
      } = me.exportMeta;

    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
                                       placeHolder,
                                       eventsPlaceholder,
                                       rows
                                     }) => {
      const placeHolderText = placeHolder.outerHTML,

        {
          resources,
          events
        } = me.positionRows(rows);
      html = html.replace(placeHolderText, resources.join(''));

      if (eventsPlaceholder) {
        html = html.replace(eventsPlaceholder.outerHTML, events.join(''));
      }
    });
    timeAxisHeaders.forEach((headers, index) => {
      html = html.replace(timeAxisPlaceholders[index].outerHTML, Array.from(headers.values()).join(''));
    });
    html = me.buildDependenciesHtml(html);
    return html;
  }

  getDependenciesOuterHTML() {
    const {
      dependenciesPlaceholder
    } = this.exportMeta;
    let result;

    if (BrowserHelper.isIE11) {
      const wrapper = document.createElement('div'),
        tmpEl = dependenciesPlaceholder.cloneNode(true);
      wrapper.appendChild(tmpEl);
      result = wrapper.innerHTML;
    } else {
      result = dependenciesPlaceholder.outerHTML;
    }

    return result;
  }

  renderDependencies() {
    const me = this,
      {
        client,
        dependenciesPlaceholder,
        eventsBoxes
      } = me.exportMeta,
      {
        dependencies
      } = client,
      dependencyFeature = client.features.dependencies,
      eventsInView = Array.from(eventsBoxes.keys());
    dependencies.filter(r => eventsInView.includes(String(r.from)) || eventsInView.includes(String(r.to))).forEach(dependency => {
      let fromBox = eventsBoxes.get(String(dependency.from)),
        toBox = eventsBoxes.get(String(dependency.to));
      const {
        sourceEvent,
        targetEvent
      } = dependency;


      if (!fromBox) {
        if (sourceEvent) {
          const box = dependencyFeature.getBox(dependency, true);

          if (box) {
            fromBox = box instanceof Rectangle ? box : new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
          }
        }
      }

      if (!toBox) {
        if (targetEvent) {
          const box = dependencyFeature.getBox(dependency, false);

          if (box) {
            toBox = box instanceof Rectangle ? box : new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
          }
        }
      }

      const drawData = {
        startRectangle: fromBox && fromBox.clone(),
        endRectangle: toBox && toBox.clone()
      };

      if (fromBox && toBox) {
        dependencyFeature.drawDependency(dependency, drawData, null, dependenciesPlaceholder, false);
      }
    });
    const result = me.getDependenciesOuterHTML();
    DomHelper.removeEachSelector(dependenciesPlaceholder, '.b-sch-dependency');
    return result;
  }

  buildDependenciesHtml(html) {
    const {
      dependenciesPlaceholder
    } = this.exportMeta;

    if (dependenciesPlaceholder) {
      const placeholder = this.getDependenciesOuterHTML();
      html = html.replace(placeholder, this.renderDependencies());
    }

    return html;
  }

});

class MultiPageExporter$1 extends SchedulerExporterMixin(MultiPageExporter) {
  async stateNextPage(config) {
    await super.stateNextPage(config);
    this.exportMeta.eventsBoxes.clear();
  }

  positionRows(rows) {
    const resources = [],
      events = [];


    rows.forEach(([html, top, height, eventsHtml]) => {
      resources.push(html);
      eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box]]) => {
        events.push(html);

        this.exportMeta.eventsBoxes.set(String(key), box);
      });
    });
    return {
      resources,
      events
    };
  }

}

MultiPageExporter$1._$name = 'MultiPageExporter';

class SinglePageExporter$1 extends SchedulerExporterMixin(SinglePageExporter) {

  collectDependencies() {
  }

  positionRows(rows) {
    let currentTop = 0,
      resources = [],
      events = [],
      translateRe = /translate\((\d+.?\d*)px, (\d+.?\d*)px\)/;


    rows.forEach(([html, top, height, eventsHtml]) => {
      resources.push(html.replace(translateRe, `translate($1px, ${currentTop}px)`));
      const rowTopDelta = currentTop - top;
      eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box]]) => {

        box.translate(0, rowTopDelta);

        this.exportMeta.eventsBoxes.set(String(key), box);
        events.push(html.replace(translateRe, `translate($1px, ${box.y}px)`));
      });
      currentTop += height;
    });
    return {
      resources,
      events
    };
  }

}

SinglePageExporter$1._$name = 'SinglePageExporter';


class PdfExport$1 extends PdfExport {
  static get $name() {
    return 'PdfExport';
  }

  static get defaultConfig() {
    return {
      exporters: [SinglePageExporter$1, MultiPageExporter$1],


      scheduleRange: 'completeview',


      rangeStart: null,


      rangeEnd: null
    };
  }

  showExportDialog() {
    const me = this;

    if (!me.exportDialog) {
      me.exportDialog = new SchedulerExportDialog({
        client: me.client,
        exporters: me.exporters,
        listeners: {
          export: me.onExportDialogExport,
          thisObj: me
        }
      });
    }

    me.exportDialog.show();
  }

  buildExportConfig(config) {
    config = super.buildExportConfig(config);
    const {
      scheduleRange,
      rangeStart,
      rangeEnd
    } = this;

    if (config.columns && !config.columns.find(col => col.type === 'timeAxis')) {
      config.columns.push(config.client.timeAxisColumn.id);
    }

    return ObjectHelper.assign({
      scheduleRange,
      rangeStart,
      rangeEnd
    }, config);
  }

}

PdfExport$1._$name = 'PdfExport';
GridFeatureManager.registerFeature(PdfExport$1, false, 'Scheduler');


class Header$1 extends Header {
  static get $name() {
    return 'SchedulerHeader';
  }

  refreshContent() {

    if (this.headersElement && this.headersElement.childNodes.length === 0) {
      super.refreshContent();
    }
  }

}

Header$1._$name = 'Header';


class TimeAxisViewModel extends Events() {


  static get defaultConfig() {
    return {

      timeAxis: null,


      availableSpace: null,


      tickSize: 100,


      snap: false,


      forceFit: false,
      headers: null,
      calendar: null,
      mode: 'horizontal',


      suppressFit: false,

      columnConfig: [],

      viewPreset: null,

      columnLinesFor: null,

      eventStore: null,
      originalTickSize: null,
      headersDatesCache: []
    };
  }


  construct(config) {
    const me = this;

    me.unitToPixelsCache = {};
    super.construct(config);
    const viewPreset = me.timeAxis.viewPreset || me.viewPreset;

    if (viewPreset) {
      if (viewPreset instanceof ViewPreset) {
        me.consumeViewPreset(viewPreset);
      } else {
        const preset = pm.getPreset(viewPreset);
        preset && me.consumeViewPreset(preset);
      }
    }

    me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);
    me.configured = true;
  }

  doDestroy() {
    this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
  }


  get columnConfig() {
    return this._columnConfig;
  }

  set columnConfig(config) {
    this._columnConfig = config;
  }

  get headers() {
    return this._headers;
  }

  set headers(headers) {
    if (headers && headers.length && headers[headers.length - 1].cellGenerator) {
      throw new Error('`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.');
    }

    this._headers = headers;
  }

  get isTimeAxisViewModel() {
    return true;
  }


  get isHorizontal() {
    return this.mode !== 'vertical';
  }


  get isVertical() {
    return this.mode === 'vertical';
  }


  set forceFit(value) {
    if (value !== this._forceFit) {
      this._forceFit = value;
      this.update();
    }
  }


  reconfigure(config) {

    const me = this;
    me.headers = null;

    me.setConfig(config);
    me.trigger('reconfigure');
  }

  onTimeAxisReconfigure({
                          source: timeAxis,
                          suppressRefresh
                        }) {
    if (this.viewPreset !== timeAxis.viewPreset) {
      this.consumeViewPreset(timeAxis.viewPreset);
    }

    if (!suppressRefresh) {
      this.update();
    }
  }


  update(availableSpace, silent = false, forceUpdate = false) {
    const me = this,
      {
        timeAxis,
        headers
      } = me;

    if (me.isConfiguring || me._availableSpace === availableSpace) {
      if (forceUpdate) {
        me.trigger('update');
      }

      return;
    }

    me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);

    if (typeof me.availableSpace !== 'number') {
      throw new Error('Invalid available space provided to TimeAxisModel');
    }

    me.columnConfig = [];


    const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);

    if (typeof tickSize !== 'number' || tickSize <= 0) {
      throw new Error('Invalid timeAxis tick size');
    }

    me.unitToPixelsCache = {};

    me._totalSize = null;

    for (let pos = 0, {
      length
    } = headers; pos < length; pos++) {
      const header = headers[pos];

      if (header.cellGenerator) {
        const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);
        me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);
      } else {
        me.columnConfig[pos] = me.createHeaderRow(pos, header);
      }
    }

    if (!silent) {
      me.trigger('update');
    }
  }


  getDistanceBetweenDates(start, end) {
    return Math.round(this.getPositionFromDate(end) - this.getPositionFromDate(start));
  }


  getDistanceForDuration(durationMs) {
    const me = this,
      tick = this.timeAxis.getAt(0),
      pxPerMs = me.tickSize / (tick.endDate - tick.startDate);
    return pxPerMs * durationMs;
  }


  getPositionFromDate(date, options = {}) {
    const me = this,
      tick = me.getScaledTick(date, options);

    if (tick === -1) {
      return -1;
    }

    return Math.round(me.tickSize * (tick - me.timeAxis.visibleTickStart));
  }

  getScaledTick(date, {
    respectExclusion,
    snapToNextIncluded,
    isEnd,
    min,
    max
  }) {
    const {
        timeAxis
      } = this,
      {
        include,
        unit,
        weekStartDay
      } = timeAxis;
    let tick = timeAxis.getTickFromDate(date);

    if (tick !== -1 && respectExclusion && include) {
      let tickChanged = false;


      if (include.hour && DateHelper.compareUnits(unit, 'hour') > 0 && unit !== 'day') {
        const {
            from,
            to,
            lengthFactor,
            center
          } = include.hour,

          originalHours = date.getHours(),

          croppedHours = Math.min(Math.max(originalHours, from), to);


        if (!snapToNextIncluded && croppedHours !== originalHours) {
          return -1;
        }

        const
          fractionalHours = croppedHours + date.getMinutes() / 60,

          hoursFromCenter = center - fractionalHours,

          newHours = center - hoursFromCenter * lengthFactor;

        date = DateHelper.add(date, newHours - originalHours, 'h');
        tickChanged = true;
      }

      if (include.day && DateHelper.compareUnits(unit, 'day') > 0) {
        const {
          from,
          to,
          lengthFactor,
          center
        } = include.day;

        let checkDay = date.getDay();

        if (isEnd && date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0 && date.getMilliseconds() === 0) {
          if (--checkDay < 0) {
            checkDay = 6;
          }
        }

        let addDays = 0;

        if (checkDay < from || checkDay >= to) {

          if (snapToNextIncluded) {

            if (isEnd) {
              addDays = (to - checkDay - 8) % 7;
            } else {
              addDays = (from - checkDay + 7) % 7;
            }

            date = DateHelper.add(date, addDays, 'd');
            date = DateHelper.startOf(date, 'd', false);

            if (max && date.getTime() >= max || min && date.getTime() <= min) {
              return -1;
            }
          } else {

            return -1;
          }
        }

        const
          fixedCenter = date.getDay() === 0 ? 0 : center,

          fractionalDay = date.getDay() + date.getHours() / 24,


          daysFromCenter = fixedCenter - fractionalDay,

          newDay = fixedCenter - daysFromCenter * lengthFactor;

        date = DateHelper.add(date, newDay - fractionalDay + weekStartDay, 'd');
        tickChanged = true;
      }

      if (tickChanged) {


        date = DateHelper.constrain(date, timeAxis.startDate, timeAxis.endDate);

        tick = timeAxis.getTickFromDate(date);
      }
    }

    return tick;
  }


  getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {
    const me = this,
      timeAxis = me.timeAxis,
      tick = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;

    if (tick < 0 || tick > timeAxis.count) {
      if (allowOutOfRange) {

        if (tick < 0) {
          return DateHelper.add(timeAxis.startDate, tick, timeAxis.unit);
        }

        return DateHelper.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);
      }

      return null;
    }

    return timeAxis.getDateFromTick(tick, roundingMethod);
  }

  getScaledPosition(position) {
    const {
      include,
      unit,
      weekStartDay
    } = this.timeAxis;

    if (include) {
      const dayWidth = this.getSingleUnitInPixels('day');

      if (include.day && DateHelper.compareUnits(unit, 'day') > 0) {
        const {
            from,
            lengthFactor
          } = include.day,

          positionInWeek = position % (dayWidth * 7),

          weekStartPosition = position - positionInWeek;

        position = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;
      }


      if (include.hour && DateHelper.compareUnits(unit, 'hour') > 0 && unit !== 'day') {
        const {
            from,
            lengthFactorExcl
          } = include.hour,
          hourWidth = this.getSingleUnitInPixels('hour'),

          positionInDay = position % dayWidth,

          dayStartPosition = position - positionInDay;

        position = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;
      }
    }

    return position;
  }


  getSingleUnitInPixels(unit) {
    const me = this;
    return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DateHelper.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);
  }


  get snapPixelAmount() {
    if (this.snap) {
      const {
        resolution
      } = this.timeAxis;
      return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
    } else {
      return 1;
    }
  }


  get tickSize() {
    return this._tickSize;
  }

  set tickSize(size) {
    this.setTickSize(size, false);
  }

  setTickSize(size, suppressEvent) {
    this._tickSize = this.originalTickSize = size;
    this.update(undefined, suppressEvent);
  }

  get timeResolution() {
    return this.timeAxis.resolution;
  }


  calculateTickSize(proposedSize) {
    const me = this,
      {
        forceFit,
        timeAxis
      } = me,
      timelineUnit = timeAxis.unit;
    let size = 0,
      ratio = 1;

    if (me.snap) {
      const resolution = timeAxis.resolution;
      ratio = DateHelper.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
    }


    if (!me.suppressFit) {
      const ticks = timeAxis.visibleTickTimeSpan,

        fittingSize = Math[forceFit ? 'floor' : 'round'](me.availableSpace / ticks);
      size = forceFit || proposedSize < fittingSize ? fittingSize : proposedSize;

      if (ratio > 0 && (!forceFit || ratio < 1)) {

        const method = forceFit ? 'floor' : 'round';
        size = Math.round(Math.max(1, Math[method](ratio * size)) / ratio);
      }
    } else {
      size = proposedSize;
    }

    return size;
  }


  get totalSize() {
    return this._totalSize || (this._totalSize = Math.round(this.tickSize * this.timeAxis.visibleTickTimeSpan));
  }


  get availableSpace() {
    return this._availableSpace;
  }

  set availableSpace(space) {
    const me = this;


    me._availableSpace = Math.max(0, space);

    if (me._availableSpace > 0) {
      const newTickSize = me.calculateTickSize(me.originalTickSize);

      if (newTickSize > 0 && newTickSize !== me.tickSize) {
        me.update();
      }
    }
  }


  getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {
    const me = this,
      ticks = [],
      linesForLevel = useLowestHeader ? me.lowestHeader : level,
      majorLevel = me.majorHeaderLevel,
      levelUnit = me.headers && me.headers[level].unit,
      majorUnit = majorLevel != null && me.headers && me.headers[majorLevel].unit,
      validMajor = majorLevel != null && DateHelper.doesUnitsAlign(majorUnit, levelUnit),
      hasGenerator = !!(me.headers && me.headers[linesForLevel].cellGenerator);

    if (hasGenerator) {
      const cells = me.columnConfig[linesForLevel];

      for (let i = 1, l = cells.length; i < l; i++) {
        ticks.push({
          date: cells[i].startDate
        });
      }
    } else {
      me.forEachInterval(linesForLevel, (start, end) => {
        ticks.push({
          date: getEnd ? end : start,

          isMajor: majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)
        });
      });
    }

    return ticks;
  }

  get forceFit() {
    return this._forceFit;
  }


  fitToAvailableSpace(suppressEvent) {
    const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);
    this.setTickSize(proposedSize, suppressEvent);
  }

  get snap() {
    return this._snap;
  }


  set snap(value) {
    if (value !== this._snap) {
      this._snap = value;
      if (this.configured) this.update();
    }
  }


  createHeaderRow(position, headerRowConfig, headerCells) {
    const me = this,
      cells = [],
      align = headerRowConfig.align,
      today = DateHelper.clearTime(new Date()),
      headerCellCls = headerRowConfig.headerCellCls || '',
      createCellContext = (start, end, i, data) => {
        let value = DateHelper.format(start, headerRowConfig.dateFormat);
        const cellData = {
          align,
          start,
          end,
          value: data ? data.header : value,
          headerCellCls,
          width: this.getDistanceBetweenDates(start, end),
          index: i
        };

        if (cellData.width === 0) {
          return;
        }

        cellData.coord = size;
        size += cellData.width;
        me.headersDatesCache[position][start.getTime()] = 1;

        if (headerRowConfig.renderer) {
          value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i, me.eventStore);
          cellData.value = value == null ? '' : value;
        }

        if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {
          cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();

          if (me.calendar && me.calendar.isWeekend(start)) {
            cellData.headerCellCls += ' b-sch-dayheadercell-nonworking';
          }

          if (DateHelper.clearTime(start, true) - today === 0) {
            cellData.headerCellCls += ' b-sch-dayheadercell-today';
          }
        }

        cells.push(cellData);
      };

    let size = 0;
    me.headersDatesCache[position] = {};

    if (headerCells) {
      headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, cellData));
    } else {
      me.forEachInterval(position, createCellContext);
    }

    return cells;
  }

  get mainHeader() {
    return 'mainHeaderLevel' in this ? this.headers[this.mainHeaderLevel] : this.bottomHeader;
  }

  get bottomHeader() {
    return this.headers[this.headers.length - 1];
  }

  get lowestHeader() {
    return this.headers.length - 1;
  }


  get majorHeaderLevel() {
    const {
      headers
    } = this;

    if (headers) {
      return Math.max(headers.length - 2, 0);
    }

    return null;
  }


  isMajorTick(date) {
    const nextLevel = this.majorHeaderLevel;


    return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;
  }


  forEachInterval(position, iteratorFn, thisObj = this) {
    const {
      headers
    } = this;

    if (headers) {

      if (position === headers.length - 1) {
        this.timeAxis.forEach((r, index) => iteratorFn.call(thisObj, r.startDate, r.endDate, index));
      } else {
        const header = headers[position];
        this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);
      }
    }
  }


  forEachMainInterval(iteratorFn, thisObj) {
    this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);
  }


  consumeViewPreset(preset) {
    const me = this;

    me.headers = null;

    me._thisIsAUsedExpression(me.tickSize);


    me.viewPreset = preset;
    Object.assign(me, {
      headers: preset.headers,
      columnLinesFor: preset.columnLinesFor,
      mainHeaderLevel: preset.mainHeaderLevel,
      _tickSize: me.isHorizontal ? preset.tickWidth : preset.tickHeight
    });
    me.originalTickSize = me.tickSize;
  }


}

TimeAxisViewModel._$name = 'TimeAxisViewModel';

const tempDate = new Date();


var TimelineDateMapper = (Target => class TimelineDateMapper extends (Target || Base) {


  getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false) {
    if (!local) {
      coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);
    }

    return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);
  }


  getDateFromX(x, roundingMethod, local = true) {
    return this.getDateFromCoordinate(x, roundingMethod, local);
  }


  getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {
    return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);
  }


  getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {
    return this.getDateFromXY([e.x, e.y], roundingMethod, false, allowOutOfRange);
  }


  getStartEndDatesFromRectangle(rect, roundingMethod, duration) {
    const me = this,
      {
        isHorizontal
      } = me,
      timeSpanEnd = isHorizontal ? me.timeAxisSubGrid.width : me.timeAxisSubGrid.height,
      startPos = isHorizontal ? rect.x : rect.top,
      endPos = isHorizontal ? rect.right : rect.bottom;
    let start, end;

    if (startPos >= 0 && endPos < timeSpanEnd) {
      start = me.getDateFromCoordinate(startPos, null, true);
      end = me.getDateFromCoordinate(endPos, null, true);
    } else if (startPos < 0) {
      end = me.getDateFromCoordinate(endPos, roundingMethod, true);
      start = DateHelper.add(end, -duration, 'ms');
    } else {
      start = me.getDateFromCoordinate(startPos, roundingMethod, true);
      end = DateHelper.add(start, duration, 'ms');
    }

    return {
      start,
      end
    };
  }


  get displayDateFormat() {
    return this._displayDateFormat;
  }

  set displayDateFormat(format) {
    this._displayDateFormat = format;

    this.trigger('displayDateFormatChange', {
      format
    });
  }


  getFormattedDate(date) {
    return DateHelper.format(date, this.displayDateFormat);
  }


  getDisplayEndDate(endDate, startDate) {
    if (
      endDate.getHours() === 0 && endDate.getMinutes() === 0 && (
      !startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) &&
      !DateHelper.formatContainsHourInfo(this.displayDateFormat)) {

      endDate = DateHelper.add(endDate, -1, 'day');
    }

    return endDate;
  }


  getFormattedEndDate(endDate, startDate) {
    return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));
  }


  getCoordinateFromDate(date, options = true) {
    const me = this,
      {
        timeAxisViewModel
      } = me,
      {
        isContinuous,
        startMS,
        endMS,
        startDate,
        unit
      } = me.timeAxis,
      dateMS = date.valueOf();

    if (options === true) {
      options = {
        local: true
      };
    } else if (!options) {
      options = {
        local: false
      };
    } else if (!('local' in options)) {
      options.local = true;
    }

    let pos;


    if (!(date instanceof Date)) {
      tempDate.setTime(date);
      date = tempDate;
    }

    if (isContinuous && date.getTimezoneOffset() === startDate.getTimezoneOffset() && DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1) {
      if (dateMS < startMS || dateMS > endMS) {
        return -1;
      }

      pos = Math.round((dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize);
    } else {
      pos = timeAxisViewModel.getPositionFromDate(date, options);
    }

    if (!options.local) {
      pos = me.currentOrientation.translateToPageCoordinate(pos);
    }

    return pos;
  }


  getTimeSpanDistance(startDate, endDate) {
    return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
  }


  get viewportCenterDate() {
    const me = this,
      timeAxis = me.timeAxis,
      subGrid = me.timeAxisSubGrid,
      scroller = subGrid.scrollable,
      centerX = scroller.x + subGrid.width / 2,
      centerY = scroller.y + subGrid.height / 2;

    if (timeAxis.isContinuous) {


      const scrollCenter = me.isHorizontal ? centerX / scroller.scrollWidth : centerY / scroller.scrollHeight,
        centerMilli = timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * scrollCenter;
      return new Date(centerMilli);
    } else {
      const xy = me.isHorizontal ? [centerX, 0] : [0, centerY];
      return me.getDateFromXY(xy, null, true);
    }
  }

  get viewportCenterDateCached() {
    return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);
  }


  get timeResolution() {
    return this.timeAxis.resolution;
  }

  set timeResolution(resolution) {
    this.timeAxis.resolution = typeof resolution === 'number' ? {
      increment: resolution,
      unit: this.timeAxis.resolution.unit
    } : resolution;
  }


  set snap(enabled) {

    if (!this.isConfiguring) {
      this.timeAxisViewModel.snap = enabled;
    } else {
      this._snap = enabled;
    }
  }

  get snap() {

    if (this.isConfiguring) {
      return this._snap;
    }

    return this.timeAxisViewModel.snap;
  }

  onSchedulerHorizontalScroll({
                                subGrid,
                                scrollLeft
                              }) {

    if (!this.scrollingToCenter) {
      this.cachedCenterDate = null;
    }
  }


  get widgetClass() {
  }

});


const eventNameMap = {
  mousedown: 'MouseDown',
  mouseup: 'MouseUp',
  click: 'Click',
  dblclick: 'DblClick',
  contextmenu: 'ContextMenu',
  mouseover: 'MouseOver',
  mouseout: 'MouseOut'
};


var TimelineDomEvents = (Target => class TimelineDomEvents extends (Target || Base) {

  static get defaultConfig() {
    return {

      scheduledBarEvents: {
        mousedown: 'handleScheduledBarEvent',
        mouseup: 'handleScheduledBarEvent',
        click: 'handleScheduledBarEvent',
        dblclick: 'handleScheduledBarEvent',
        contextmenu: 'handleScheduledBarEvent',
        mouseover: 'handleScheduledBarEvent',
        mouseout: 'handleScheduledBarEvent'
      },

      schedulerEvents: {
        click: 'handleScheduleEvent',
        dblclick: 'handleScheduleEvent',
        contextmenu: 'handleScheduleEvent',
        mousemove: 'handleScheduleEvent'
      }
    };
  }


  initDomEvents() {
    const me = this;

    me.scheduledBarEvents.element = me.schedulerEvents.element = me.timeAxisSubGridElement;
    me.scheduledBarEvents.thisObj = me.schedulerEvents.thisObj = me;

    EventHelper.on(me.scheduledBarEvents);
    EventHelper.on(me.schedulerEvents);
  }


  getTimeSpanMouseEventParams(eventElement, event) {
    throw new Error('Implement in subclass');
  }

  getScheduleMouseEventParams(cellData, event) {
    throw new Error('Implement in subclass');
  }


  handleScheduledBarEvent(event) {
    const me = this,
      eventElement = DomHelper.up(event.target, me.eventInnerSelector),
      eventName = eventNameMap[event.type] || StringHelper.capitalizeFirstLetter(event.type);

    if (eventElement) {
      me.trigger(me.scheduledEventName + eventName, me.getTimeSpanMouseEventParams(eventElement, event));
    }
  }


  handleScheduleEvent(event) {
    const me = this,
      eventElement = DomHelper.up(event.target, me.eventSelector),
      cellElement = !eventElement && DomHelper.up(event.target, '.' + me.timeCellCls),
      eventName = eventNameMap[event.type] || StringHelper.capitalizeFirstLetter(event.type);

    if (cellElement) {
      const clickedDate = me.getDateFromDomEvent(event, 'floor'),
        cellData = DomDataStore.get(cellElement),
        index = cellData.row.dataIndex,
        tickIndex = me.timeAxis.getTickFromDate(clickedDate),
        tick = me.timeAxis.getAt(Math.floor(tickIndex));

      if (tick) {
        me.trigger('schedule' + eventName, Object.assign({
          date: clickedDate,
          tickStartDate: tick.startDate,
          tickEndDate: tick.endDate,
          row: cellData.row,
          index,
          event
        }, me.getScheduleMouseEventParams(cellData, event)));
      }
    }
  }


  onElementMouseOver(event) {
    super.onElementMouseOver(event);
    const me = this,
      target = event.target;

    if (target.closest(me.eventInnerSelector)) {
      const eventElement = target.closest(me.eventSelector);
      eventElement.classList.add(me.overScheduledEventClass);

      if (eventElement !== me.hoveredEventNode && !me.preventOverCls) {
        me.hoveredEventNode = eventElement;
        const params = me.getTimeSpanMouseEventParams(eventElement, event);

        if (params) {


          me.trigger(me.scheduledEventName + 'MouseEnter', params);
        }
      }
    } else {
      me.hoveredEventNode = null;
    }
  }


  onElementMouseOut(event) {
    super.onElementMouseOut(event);
    const me = this;

    if (event.target.closest(me.eventInnerSelector) && me.resolveTimeSpanRecord(event.target) && me.hoveredEventNode) {

      if (event.relatedTarget && DomHelper.isDescendant(event.target.closest(me.eventInnerSelector), event.relatedTarget)) return;
      me.unhover(event);
    }
  }

  unhover(event) {
    const me = this,
      eventElement = me.hoveredEventNode;

    if (eventElement) {
      eventElement.classList.remove(me.overScheduledEventClass);
      me.trigger(me.scheduledEventName + 'MouseLeave', me.getTimeSpanMouseEventParams(eventElement, event));
      me.hoveredEventNode = null;
    }
  }


  get widgetClass() {
  }

});


var TimelineViewPresets = (Target => class TimelineViewPresets extends (Target || Base) {

  static get defaultConfig() {
    return {

      viewPreset: 'weekAndDayLetter',


      displayDateFormat: null,


      presets: true
    };
  }


  set presets(presets) {
    if (presets === true) {
      presets = pm.allRecords;
    }

    this._presets = new PresetStore({
      data: presets
    });
  }

  get presets() {
    return this._presets;
  }


  get viewPreset() {
    return this._viewPreset;
  }

  set viewPreset(preset) {

    if (!(preset instanceof ViewPreset) && preset.name && !preset.base) {
      VersionHelper.deprecate('Scheduler', '4.0.0', 'ViewPreset name config replaced by base config. See https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
      preset.base = preset.name;
    }

    if (!this._viewPreset || !this._viewPreset.equals(preset)) {
      this.setViewPreset(preset);
    }
  }

  normalizePreset(preset) {
    const me = this,
      input = preset,
      {
        presets
      } = me;

    if (!(preset instanceof ViewPreset)) {


      if (typeof preset === 'object') {

        if (preset.base) {

          const base = presets.getById(preset.base) || pm.getById(preset.base);

          if (!base) {
            throw new Error(`ViewPreset base '${preset.base}' does not exist`);
          }


          preset = ObjectHelper.merge(ObjectHelper.clone(base.data), pm.createRecord(preset).data);
        }


        if (preset.id) {
          preset = presets.createRecord(preset);
        } else {
          preset = presets.createRecord(ObjectHelper.assign({}, preset));
          preset.id = preset.generateId(presets);
        }
      } else {
        if (typeof preset === 'number') {
          preset = presets.getAt(preset);
        } else {
          preset = presets.getById(preset) || pm.getById(preset);
        }
      }

      if (!preset) {
        throw new Error(`Invalid ViewPreset requested: ${input}`);
      }
    }


    return presets.add(preset)[0];
  }


  setViewPreset(preset, startDate, endDate, initial, options = {}) {
    const me = this,
      {
        isHorizontal,
        _timeAxis: timeAxis

      } = me,
      event = {
        startDate,
        endDate,
        from: me.viewPreset
      };

    preset = event.to = event.preset = me.normalizePreset(preset);

    if (!Object.keys(options).length && me._viewPreset && (me._viewPreset === preset || me._viewPreset.equals(preset))) {
      return;
    }

    initial = initial || me.isConfiguring;
    let centerDate = options.centerDate;


    if (initial || me.trigger('beforePresetChange', event) !== false && me.trigger('beforeZoomChange', event) !== false) {
      me._viewPreset = preset;

      me._viewPresetChanging = true;

      me.displayDateFormat = me.config.displayDateFormat || preset.displayDateFormat;

      if (timeAxis) {

        me.suspendRefresh();

        if (!(initial && timeAxis.isConfigured)) {
          const timeAxisCfg = {
            weekStartDay: me.weekStartDay,
            startTime: me.startTime,
            endTime: me.endTime
          };

          if (initial) {
            if (timeAxis.count === 0 || startDate) {
              timeAxisCfg.startDate = startDate || new Date();
              timeAxisCfg.endDate = endDate;
            }
          } else {

            if (startDate) {
              timeAxisCfg.startDate = startDate;
              timeAxisCfg.endDate = endDate;

              if (!centerDate && endDate) {


                centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
              }

            } else {
              timeAxisCfg.startDate = timeAxis.startDate;
              timeAxisCfg.endDate = endDate || timeAxis.endDate;

              if (!centerDate) {


                centerDate = me.viewportCenterDate;
              }
            }
          }

          timeAxis.isConfigured = false;
          timeAxis.viewPreset = preset;
          timeAxis.reconfigure(timeAxisCfg, true);
          me.timeAxisViewModel.reconfigure({
            viewPreset: me.viewPreset,
            headers: preset.headers,

            columnLinesFor: preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,

            rowHeightHorizontal: me.readRowHeightFromPreset ? preset.rowHeight : me.rowHeight,
            tickSize: isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60
          });

          me.resumeRefresh();
        }


        me.refresh();

        if (!options.notScroll && me.isPainted) {

          if (centerDate) {

            me.cachedCenterDate = centerDate;


            event.centerDate = centerDate;
            let x = null;


            x = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - me.timeAxisSubGrid.width / 2), 0);
            me.viewPresetActiveScroll = {
              left: x
            };


            me.scrollingToCenter = true;
            me.scrollHorizontallyTo(x, false);

            me.setTimeout(() => {
              me.scrollingToCenter = false;
            }, 100);

          } else {


            me.scrollHorizontallyTo(0, false);


          }
        }
      }


      me.trigger('presetChange', event);
      me.trigger('zoomChange', event);
    }

    me._viewPresetChanging = false;
  }


  get widgetClass() {
  }

});


var TimelineZoomable = (Target => class TimelineZoomable extends (Target || Base) {
  static get defaultConfig() {
    return {

      zoomOnMouseWheel: true,


      zoomOnTimeAxisDoubleClick: true,
      preventScrollZoom: null,


      minZoomLevel: null,


      maxZoomLevel: null,


      visibleZoomFactor: 5,


      zoomKeepsOriginalTimespan: null
    };
  }

  construct(config) {
    const me = this;
    super.construct(config);

    if (me.zoomOnMouseWheel) {
      EventHelper.on({
        element: me.timeAxisSubGridElement,
        wheel: 'onWheel',
        thisObj: me,
        capture: true,
        passive: false
      });
    }

    if (me.zoomOnTimeAxisDoubleClick) {
      me.on('timeaxisheaderdblclick', ({
                                         startDate,
                                         endDate
                                       }) => {
        if (!me.isVertical) {
          me.zoomToSpan({
            startDate,
            endDate
          });
        }
      });
    }
  }

  get maxZoomLevel() {
    return this._maxZoomLevel || this.presets.count - 1;
  }


  set maxZoomLevel(level) {
    if (typeof level !== 'number') {
      level = this.presets.count - 1;
    }

    if (level < 0 || level >= this.presets.count) {
      throw new Error('Invalid range for `setMinZoomLevel`');
    }

    this._maxZoomLevel = level;
  }

  get minZoomLevel() {
    return this._minZoomLevel || 0;
  }


  set minZoomLevel(level) {
    if (typeof level !== 'number') {
      level = 0;
    }

    if (level < 0 || level >= this.presets.count) {
      throw new Error('Invalid range for `minZoomLevel`');
    }

    this._minZoomLevel = level;
  }


  get zoomLevel() {
    return this.presets.indexOf(this.viewPreset);
  }

  set zoomLevel(level) {
    this.zoomToLevel(level);
  }


  getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {
    const {
        bottomHeader
      } = preset,
      width = this.isHorizontal ? preset.tickWidth : preset.tickHeight;


    return Math.round((DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) / (

      ignoreActualWidth ? width : preset.actualWidth || width));
  }


  zoomTo(config) {
    const me = this;

    if (typeof config === 'object') {
      if (config.preset) {
        me.zoomToLevel(config.preset, config);
      } else if (config.level != null) {
        me.zoomToLevel(config.level, config);
      } else {
        me.zoomToSpan(config);
      }
    } else {
      me.zoomToLevel(config);
    }
  }


  zoomToLevel(preset, options = {}) {

    if (typeof preset === 'number') {
      preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);
    }

    const me = this,
      {
        config
      } = me,
      tickSizeProp = me.isVertical ? 'tickHeight' : 'tickWidth',
      newPreset = me.normalizePreset(preset),
      configuredTickSize = newPreset[tickSizeProp],
      startDate = options.startDate,
      endDate = options.endDate;
    let span = startDate && endDate ? {
      startDate,
      endDate
    } : null;
    const centerDate = options.centerDate || (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached),
      timeAxisSubGridWidth = me.timeAxisSubGrid.width;

    if (timeAxisSubGridWidth === 0) {
      return null;
    }

    if (!span) {


      if (config.startDate && config.endDate && config.viewPreset && newPreset.equals(me.normalizePreset(config.viewPreset))) {
        span = {
          startDate: config.startDate,
          endDate: config.endDate
        };
      } else {
        span = me.calculateOptimalDateRange(centerDate, timeAxisSubGridWidth, newPreset);
      }
    }

    if ('width' in options) {
      newPreset.setData(tickSizeProp, options.width);
    }

    me.isZooming = true;
    me.setViewPreset(newPreset, span.startDate || me.startDate, span.endDate || me.endDate, false, {
      centerDate: centerDate
    });


    newPreset.actualWidth = me.timeAxisViewModel.tickSize;
    me.isZooming = false;

    newPreset.setData(tickSizeProp, configuredTickSize);
  }


  zoomToFit(options) {
    const eventStore = this.eventStore,
      span = eventStore.getTotalTimeSpan();
    options = Object.assign({
      leftMargin: 0,
      rightMargin: 0
    }, options, span);

    if (options.startDate && options.endDate) {
      this.zoomToSpan(options);
    }
  }


  zoomToSpan(config = {}) {
    if (config.leftMargin || config.rightMargin) {
      config.adjustStart = 0;
      config.adjustEnd = 0;
    }

    if (!config.leftMargin) config.leftMargin = 0;
    if (!config.rightMargin) config.rightMargin = 0;
    if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');
    const me = this,

      needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;
    let {
      startDate,
      endDate
    } = config;

    if (needToAdjust) {
      startDate = DateHelper.add(startDate, -config.adjustStart, me.timeAxis.mainUnit);
      endDate = DateHelper.add(endDate, config.adjustEnd, me.timeAxis.mainUnit);
    }

    if (startDate <= endDate) {

      const {
          availableSpace
        } = me.timeAxisViewModel,
        presets = me.presets.allRecords,
        diffMS = endDate - startDate || 1;


      let currLevel = Math.floor(me.zoomLevel),
        inc,
        range;

      if (currLevel === -1) currLevel = 0;
      let msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true),


        candidateLevel = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1),
        zoomLevel,
        levelToZoom = null;

      while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {

        zoomLevel = presets[candidateLevel];
        msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
        const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;

        if (inc === -1) {

          if (spanWidth <= availableSpace) {
            levelToZoom = candidateLevel;

            break;
          }

        } else {


          if (spanWidth <= availableSpace) {

            if (currLevel !== candidateLevel - inc) {

              levelToZoom = candidateLevel;
            }
          } else {


            break;
          }
        }

        candidateLevel += inc;
      }

      levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;

      zoomLevel = presets[levelToZoom];
      const unitToZoom = zoomLevel.bottomHeader.unit;

      if (config.leftMargin || config.rightMargin) {

        startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);
        endDate = new Date(endDate.getTime() + msPerPixel * config.rightMargin);
      }

      const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;

      if (tickCount === 0) {
        return null;
      }

      const customWidth = Math.floor(availableSpace / tickCount),
        centerDate = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);

      if (needToAdjust) {
        range = {
          startDate,
          endDate
        };
      } else {
        range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);
      }

      return me.zoomToLevel(levelToZoom, Object.assign(range, {
        width: customWidth,
        centerDate
      }));
    }

    return null;
  }


  zoomIn(levels = 1) {
    const currentZoomLevelIndex = this.zoomLevel;
    if (currentZoomLevelIndex >= this.presets.count - 1) return null;
    return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
  }


  zoomOut(levels = 1) {
    const currentZoomLevelIndex = this.zoomLevel;
    if (currentZoomLevelIndex <= 0) return null;
    return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
  }


  zoomInFull() {
    return this.zoomToLevel(this.maxZoomLevel);
  }


  zoomOutFull() {
    return this.zoomToLevel(this.minZoomLevel);
  }


  calculateOptimalDateRange(centerDate, panelSize, viewPreset, userProvidedSpan) {


    if (userProvidedSpan) return userProvidedSpan;
    const me = this,
      {
        timeAxis
      } = me,
      {
        bottomHeader
      } = viewPreset,
      tickWidth = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;

    if (me.zoomKeepsOriginalTimespan) {
      return {
        startDate: timeAxis.startDate,
        endDate: timeAxis.endDate
      };
    }

    const unit = bottomHeader.unit,
      difference = Math.ceil(panelSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2),
      startDate = DateHelper.add(centerDate, -difference, unit),
      endDate = DateHelper.add(centerDate, difference, unit);
    return {
      startDate: timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),
      endDate: timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)
    };
  }

  onWheel(event) {
    const me = this;

    if (event.ctrlKey) {
      event.preventDefault();

      if (!me.preventScrollZoom) {
        if (event.deltaY > 0) {
          me.zoomOut();
        } else if (event.deltaY < 0) {
          me.zoomIn();
        }

        me.preventScrollZoom = true;
        me.setTimeout(() => me.preventScrollZoom = false, 30);
      }
    }
  }


  setTimeSpan(startDate, endDate) {
    this.timeAxis.setTimeSpan(startDate, endDate);
  }


  shift(amount, unit) {
    this.timeAxis.shift(amount, unit);
  }


  shiftNext(amount) {
    this.timeAxis.shiftNext(amount);
  }


  shiftPrevious(amount) {
    this.timeAxis.shiftPrevious(amount);
  }


  get widgetClass() {
  }

});


var TimelineEventRendering = (Target => class TimelineEventRendering extends (Target || Base) {

  static get defaultConfig() {
    return {

      barMargin: 10,
      resourceMargin: null,


      managedEventSizing: true,


      generatedIdCls: 'b-sch-dirty-new',


      dirtyCls: 'b-sch-dirty',


      committingCls: 'b-sch-committing',


      endsOutsideViewCls: 'b-sch-event-endsoutside',


      startsOutsideViewCls: 'b-sch-event-startsoutside',


      fixedEventCls: 'b-sch-event-fixed',


      eventStyle: 'plain',


      eventColor: 'green'
    };
  }


  get barMargin() {
    return this._barMargin;
  }

  set barMargin(margin) {
    const me = this;
    ObjectHelper.assertNumber(margin, 'barMargin');

    if (me.isHorizontal && me.rowHeight) {
      margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
    }

    if (me._barMargin !== margin) {
      me._barMargin = margin;

      if (me.rendered) {
        me.currentOrientation.onBeforeRowHeightChange();
        me.refreshWithTransition();
      }
    }
  }

  get resourceMargin() {
    return this._resourceMargin == null ? this.barMargin : this._resourceMargin;
  }

  set resourceMargin(margin) {
    const me = this;
    ObjectHelper.assertNumber(margin, 'resourceMargin');

    if (me.isHorizontal && me.rowHeight) {
      margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
    }

    if (me._resourceMargin !== margin) {
      me._resourceMargin = margin;

      if (me.rendered) {
        me.currentOrientation.onBeforeRowHeightChange();
        me.refreshWithTransition();
      }
    }
  }


  set tickWidth(width) {
    this.tickSize = width;
  }

  get tickWidth() {
    return this.tickSize;
  }


  set tickSize(width) {
    ObjectHelper.assertNumber(width, 'tickSize');
    this.timeAxisViewModel.tickSize = width;
  }

  get tickSize() {
    return this.timeAxisViewModel.tickSize;
  }


  static get eventColors() {
    return ['red', 'pink', 'purple', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'lime', 'yellow', 'orange', 'gray'];
  }


  static get eventStyles() {
    return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal'];
  }


  get widgetClass() {
  }

});


var TimelineScroll = (Target => class TimelineScroll extends (Target || Base) {


  scrollToDate(date, options = {}) {
    const me = this,
      scroller = me.timeAxisSubGrid.scrollable,
      scrollerViewport = scroller.viewport,
      localCoordinate = me.getCoordinateFromDate(date, true),
      target = me.isHorizontal ? new Rectangle(me.getCoordinateFromDate(date, false), scrollerViewport.y, me.timeAxisViewModel.tickSize, scrollerViewport.height) : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);
    return me.scrollToCoordinate(localCoordinate, target, date, options);
  }


  scrollToNow(options = {}) {
    return this.scrollToDate(new Date(), options);
  }


  scrollToCoordinate(localCoordinate, target, date, options = {}) {
    const me = this;


    if (localCoordinate < 0) {

      const halfVisibleSpan = (me.timeAxis.endDate - me.timeAxis.startDate) / 2,
        newStartDate = new Date(date.getTime() - halfVisibleSpan),
        newEndDate = new Date(date.getTime() + halfVisibleSpan);


      if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {
        me.setTimeSpan(newStartDate, newEndDate);
        return me.scrollToDate(date, options);
      }

      return;
    }

    return me.timeAxisSubGrid.scrollable.scrollIntoView(target, options);
  }


  set scrollLeft(left) {
    this.timeAxisSubGrid.scrollable.x = left;
  }


  set scrollTop(top) {
    this.scrollable.y = top;
  }

  get scrollLeft() {
    return this.timeAxisSubGrid.scrollable.x;
  }

  get scrollTop() {
    return this.scrollable.y;
  }


  scrollHorizontallyTo(coordinate, options = true) {
    return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);
  }


  scrollVerticallyTo(y, options = true) {
    return this.scrollable.scrollTo(null, y, options);
  }


  scrollTo(x, options = true) {
    return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);
  }


  get widgetClass() {
  }

});

const timeAxisColumnConfigs = ['viewPreset', 'eventBarTextField', 'eventRenderer', 'eventRendererThisObj', 'eventBodyTemplate'],
  exitTransition = {
    fn: 'exitTransition',
    delay: 0,
    cancelOutstanding: true
  };


class TimelineBase extends base(GridBase).mixes(TimelineDateMapper, TimelineDomEvents, TimelineEventRendering, TimelineScroll, TimelineViewPresets, TimelineZoomable) {

  static get $name() {
    return 'TimelineBase';
  }

  static get defaultConfig() {
    return {


      workingTime: null,


      timeAxis: null,


      timeAxisViewModel: null,


      autoAdjustTimeAxis: true,


      startDate: null,


      endDate: null,


      snap: false,


      snapRelativeToEventStartDate: false,


      forceFit: false,


      eventCls: null,


      getDateConstraints: null,


      timeCellCls: null,
      timeCellSelector: null,
      scheduledEventName: null,


      createEventOnDblClick: true,


      overScheduledEventClass: null,

      preventOverCls: false,

      hoveredEventNode: null,

      useBackgroundCanvas: false,


      enableEventAnimations: !BrowserHelper.isIE11,
      disableGridRowModelWarning: true,

      animateRemovingRows: false,


      partner: null,
      schedulerRegion: 'normal',
      transitionDuration: 200,

      animationTimeout: null,


      milestoneLayoutMode: 'default',


      defaultRegion: 'locked'
    };
  }


  construct(config = {}) {
    const me = this,
      region = config.schedulerRegion || 'normal',

      {
        subGridConfigs = {}
      } = config;
    config.subGridConfigs = subGridConfigs;
    subGridConfigs[region] = subGridConfigs[region] || {};
    subGridConfigs[region].headerClass = Header$1;

    if (!('flex' in subGridConfigs[region] || 'width' in subGridConfigs[region])) {
      subGridConfigs[region].flex = 1;
    }

    if (config.startDate) {
      config.startDate = DateHelper.parse(config.startDate);
    }

    if (config.endDate) {
      config.endDate = DateHelper.parse(config.endDate);
    }

    super.construct(config);

    me.onSchedulerViewportResize = me.throttle(me.onSchedulerViewportResize, 250);
    me.initDomEvents();
    me.currentOrientation.init();
    me.rowManager.on('refresh', () => {
      me.forceLayout = false;
    });
  }

  doDestroy() {
    const me = this,
      {
        currentOrientation
      } = this;

    if (currentOrientation) {
      currentOrientation.destroy();
    }

    if (me.partneredWith) {
      me.partneredWith.forEach(p => {
        me.removePartner(p);
      });
      me.partneredWith.destroy();
    }

    super.doDestroy();
  }

  startConfigure(config) {
    super.startConfigure(config);


    this._thisIsAUsedExpression(this.partner);
  }

  onPaint({
            firstPaint
          }) {


    if (firstPaint) {


      const {
          timeAxisSubGrid
        } = this,
        availableSpace = this.isVertical ? BrowserHelper.isIE11 ? timeAxisSubGrid.element.parentElement.offsetHeight : timeAxisSubGrid.height : timeAxisSubGrid.width;
      this.timeAxisViewModel.update(availableSpace, false, true);
    }

    super.onPaint([...arguments]);
  }

  initSubGrids() {
    super.initSubGrids();
    const me = this,
      timeAxisSubGrid = me.timeAxisSubGrid = me.subGrids[me.timeAxisColumn.region];

    timeAxisSubGrid.sealedColumns = true;
    timeAxisSubGrid.on({
      resize: me.onTimeAxisSubGridResize,
      thisObj: me
    });
  }

  onSchedulerHorizontalScroll(subGrid, scrollLeft) {

    this.currentOrientation.updateFromHorizontalScroll(scrollLeft);
    super.onSchedulerHorizontalScroll(subGrid, scrollLeft);
  }


  initScroll() {
    let me = this,
      frameCount = 0;
    super.initScroll();

    if (BrowserHelper.isMobileSafari) {
      me.scrollable.element.style.transform = 'translate3d(0, 0, 0)';
    }

    me.on('horizontalscroll', ({
                                 subGrid,
                                 scrollLeft
                               }) => {
      if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying) {
        me.onSchedulerHorizontalScroll(subGrid, scrollLeft);
      }

      frameCount++;
    });

    if (me.testPerformance === 'horizontal') {
      me.setTimeout(() => {
        let start = performance.now(),

          scrollSpeed = 5,
          direction = 1;
        let scrollInterval = me.setInterval(() => {
          scrollSpeed = scrollSpeed + 5;
          me.scrollLeft += (10 + Math.floor(scrollSpeed)) * direction;

          if (direction === 1 && me.scrollLeft > 5500) {
            direction = -1;
            scrollSpeed = 5;
          }

          if (direction === -1 && me.scrollLeft <= 0) {
            let done = performance.now(),

              elapsed = done - start;
            let timePerFrame = elapsed / frameCount,
              fps = 1000 / timePerFrame;
            fps = Math.round(fps * 10) / 10;
            clearInterval(scrollInterval);
            console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');
          }
        }, 0);
      }, 500);
    }
  }


  get hasVisibleEvents() {
    return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some(t => this.timeAxis.isTimeSpanInAxis(t));
  }


  noFeatureElementsInAxis() {
  }


  get capitalizedEventName() {
    if (!this._capitalizedEventName) {
      this._capitalizedEventName = StringHelper.capitalizeFirstLetter(this.scheduledEventName);
    }

    return this._capitalizedEventName;
  }

  set partner(partner) {
    const me = this,
      partneredWith = me.partneredWith || (me.partneredWith = new Collection());
    me._partner = partner;

    if (!partneredWith.includes(partner)) {

      partneredWith.add(partner);
      (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);
      partner.on({
        presetchange: 'onPartnerPresetChange',
        thisObj: me
      });
      me.on({
        presetchange: 'onPartnerPresetChange',
        thisObj: partner
      });
      me.setConfig({
        viewPreset: partner.viewPreset,
        timeAxis: partner.timeAxis,
        timeAxisViewModel: partner.timeAxisViewModel
      });

      me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {
        me.scrollable.addPartner(partner.scrollable, 'x');
      }, me);
    }
  }

  removePartner(partner) {
    const me = this,
      partneredWith = me.partneredWith;

    if (partneredWith && partneredWith.includes(partner)) {
      partneredWith.remove(partner);
      partner.partneredWith.remove(me);
      partner.scrollable.removePartner(me.scrollable);
      partner.un({
        presetchange: 'onPartnerPresetChange',
        thisObj: me
      });
      me.un({
        presetchange: 'onPartnerPresetChange',
        thisObj: partner
      });
    }
  }

  onPartnerPresetChange({
                          preset,
                          startDate,
                          endDate,
                          centerDate
                        }) {
    if (!this._viewPresetChanging && this.viewPreset !== preset) {

      this.setViewPreset(preset, startDate, endDate, false, {
        centerDate
      });
    }
  }

  get partner() {
    return this._partner;
  }

  get timeAxisColumn() {
    return this.columns && this._timeAxisColumn;
  }

  get columns() {


    return super.columns;
  }

  set columns(columns) {
    const me = this;
    let timeAxisColumnIndex, timeAxisColumnConfig, timeAxisColumn, value;

    if (columns) {
      const isArray = Array.isArray(columns);
      let cols = columns;

      if (!isArray) {
        cols = columns.data;
      }

      timeAxisColumnIndex = cols && cols.length;
      cols.forEach((col, index) => {
        if (col.type === 'timeAxis') {
          timeAxisColumnIndex = index;
          timeAxisColumnConfig = col;
        }
      });


      if (me.isVertical) {
        me._horizontalColumns = columns;
        cols = [{
          type: 'verticalTimeAxis',
          locked: true,
          timeline: me
        },
          cols[timeAxisColumnIndex]];
        timeAxisColumnIndex = 1;
      } else {

        cols = cols.slice();
      }

      timeAxisColumnConfig = cols[timeAxisColumnIndex] = Object.assign({
        type: 'timeAxis',
        locked: false,
        timeline: me,
        cellCls: me.timeCellCls,
        mode: me.mode
      }, timeAxisColumnConfig);

      timeAxisColumnConfigs.forEach(configName => {
        value = me[configName];

        if (value != null) {
          timeAxisColumnConfig[configName] = value;
        }
      });

      if (isArray) {
        columns = cols;
      } else {
        columns.data = cols;
      }
    }

    super.columns = columns;

    if (columns) {
      timeAxisColumn = me._timeAxisColumn = me.columns.getAt(timeAxisColumnIndex);

      if (me.isVertical) {
        me.verticalTimeAxisColumn = me.columns.getAt(timeAxisColumnIndex - 1);
      }

      timeAxisColumn.relayAll(me);
    }
  }

  get timeView() {
    const me = this;


    return me.columns && me.isVertical ? me.verticalTimeAxisColumn && me.verticalTimeAxisColumn.view : me.timeAxisColumn && me.timeAxisColumn.timeAxisView;
  }

  set eventCls(eventCls) {
    const me = this;
    me._eventCls = eventCls;

    if (!me.eventSelector) {
      me.eventSelector = `.${eventCls}-wrap`;
      me.unreleasedEventSelector = `${me.eventSelector}:not(.b-sch-released)`;
    }

    if (!me.eventInnerSelector) {
      me.eventInnerSelector = '.' + eventCls;
    }
  }

  get eventCls() {
    return this._eventCls;
  }

  set timeAxisViewModel(timeAxisViewModel) {
    const me = this,
      tavmListeners = {
        update: 'onTimeAxisViewModelUpdate',
        prio: 100,
        thisObj: me
      };

    if (me.partner && !timeAxisViewModel) {
      return;
    }

    if (timeAxisViewModel && timeAxisViewModel.isTimeAxisViewModel) {
      timeAxisViewModel.on(tavmListeners);
    } else {
      timeAxisViewModel = Object.assign({
        mode: me._mode,
        snap: me.snap,
        forceFit: me.forceFit,
        timeAxis: me.timeAxis,
        listeners: tavmListeners
      }, timeAxisViewModel);
      timeAxisViewModel = new TimeAxisViewModel(timeAxisViewModel);
    }

    me._timeAxisViewModel = timeAxisViewModel;
  }


  get timeAxisViewModel() {
    if (!this._timeAxisViewModel) {
      this.timeAxisViewModel = null;
    }

    return this._timeAxisViewModel;
  }

  set timeAxis(timeAxis) {
    const me = this;

    if (me.partner && !timeAxis) {
      return;
    }

    me.timeAxisDetacher && me.timeAxisDetacher();

    if (!(timeAxis && timeAxis.isTimeAxis)) {
      timeAxis = ObjectHelper.assign({
        viewPreset: me.viewPreset,
        autoAdjust: me.autoAdjustTimeAxis,
        mode: 'plain',
        weekStartDay: me.weekStartDay
      }, timeAxis);

      if (me.startDate) {
        timeAxis.startDate = me.startDate;
      }

      if (me.endDate) {
        timeAxis.endDate = me.endDate;
      }

      if (me.workingTime) {
        me.applyWorkingTime(timeAxis);
      }

      timeAxis = new TimeAxis(timeAxis);
    }

    me.timeAxisDetacher = timeAxis.on({
      thisObj: me,

      reconfigure({
                    config
                  }) {

        me.trigger('timeAxisChange', {
          config
        });
      }

    });
    me._timeAxis = timeAxis;
  }

  get timeAxis() {
    if (!this._timeAxis) {
      this.timeAxis = null;
    }

    return this._timeAxis;
  }


  set workingTime(config) {
    this._workingTime = config;

    if (!this.isConfiguring) {
      this.applyWorkingTime(this.timeAxis);
    }
  }

  get workingTime() {
    return this._workingTime;
  }


  applyWorkingTime(timeAxis) {
    const me = this,
      config = me._workingTime;

    if (config) {
      let hour = null;

      if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {
        hour = {
          from: config.fromHour,
          to: config.toHour
        };
      }

      let day = null;

      if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {
        day = {
          from: config.fromDay,
          to: config.toDay
        };
      }

      if (hour || day) {
        timeAxis.include = {
          hour,
          day
        };
      } else {

        timeAxis.include = null;
      }
    } else {

      timeAxis.include = null;
    }

    if (me.isPainted) {

      me.timeAxisColumn.refreshHeader();

      if (me.features.columnLines) {
        me.features.columnLines.drawLines();
      }

      me.refreshWithTransition();
    }
  }


  set startDate(date) {
    this.setStartDate(date);
  }


  setStartDate(date, keepDuration = true) {
    const me = this,
      ta = me._timeAxis || {},
      {
        startDate,
        endDate,
        mainUnit
      } = ta;

    if (typeof date === 'string') {
      date = DateHelper.parse(date);
    }

    if (me._timeAxis && endDate) {
      if (date) {
        let calcEndDate = endDate;

        if (keepDuration && startDate) {
          const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
          calcEndDate = DateHelper.add(date, diff, mainUnit);
        }

        ta.setTimeSpan(date, calcEndDate);
      }
    } else {
      me._tempStartDate = date;
    }
  }

  get startDate() {
    const me = this;

    if (me._timeAxis) {
      return me._timeAxis.startDate;
    }

    return me._tempStartDate || new Date();
  }


  set endDate(date) {
    this.setEndDate(date);
  }


  setEndDate(date, keepDuration = false) {
    const me = this,
      ta = me._timeAxis || {},
      {
        startDate,
        endDate,
        mainUnit
      } = ta;

    if (typeof date === 'string') {
      date = DateHelper.parse(date);
    }

    if (me._timeAxis && startDate) {
      if (date) {
        let calcStartDate = startDate;

        if (keepDuration && endDate) {
          const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
          calcStartDate = DateHelper.add(date, -diff, mainUnit);
        }

        ta.setTimeSpan(calcStartDate, date);
      }
    } else {
      me._tempEndDate = date;
    }
  }

  get endDate() {
    const me = this;

    if (me._timeAxis) {
      return me._timeAxis.endDate;
    }

    return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);
  }

  get features() {
    return super.features;
  }

  set features(features) {
    features = features === true ? {} : features;

    if (!('regionResize' in features)) {
      features.regionResize = true;
    }

    super.features = features;
  }

  get eventStyle() {
    return this._eventStyle;
  }

  set eventStyle(style) {
    const me = this;
    me._eventStyle = style;

    if (me.isPainted) {
      me.refreshWithTransition();
    }
  }

  get eventColor() {
    return this._eventColor;
  }

  set eventColor(color) {
    const me = this;
    me._eventColor = color;

    if (me.isPainted) {
      me.refreshWithTransition();
    }
  }


  onLocaleChange() {


    super.onLocaleChange();
    this.timeAxisColumn.refreshHeader();
  }


  onInternalResize(element, width, height, oldWidth, oldHeight) {

    const oldSchedulerBodyRect = this._bodyRectangle;
    super.onInternalResize(element, width, height, oldWidth, oldHeight);

    if (oldSchedulerBodyRect && height !== oldHeight) {
      this.onSchedulerViewportResize(oldSchedulerBodyRect.width, this.bodyContainer.offsetHeight, oldSchedulerBodyRect.width, oldSchedulerBodyRect.height);
    }
  }


  onTimeAxisSubGridResize({
                            width,
                            height,
                            oldWidth,
                            oldHeight
                          }) {

    if (this.isPainted && width !== oldWidth) {
      const schedulerBodyRect = this._bodyRectangle;
      this.onSchedulerViewportResize(width, schedulerBodyRect.height, oldWidth, schedulerBodyRect.height);
    }
  }

  onSchedulerViewportResize(width, height, oldWidth, oldHeight) {
    if (this.isPainted) {
      const me = this,
        subGrid = me.timeAxisSubGrid;
      me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);


      if (me._lastOverflow == null || me._lastOverflow === subGrid.overflowingHorizontally) {


        me.setTimeout(() => {
          me.timeAxisViewModel.availableSpace = me.isHorizontal ? subGrid.width : subGrid.height;
        }, 0);
        me.partneredWith && !me.isSyncingFromPartner && me.partneredWith.forEach(p => {
          if (!p.isSyncingFromPartner) {
            p.isSyncingFromPartner = true;
            me.eachSubGrid(subGrid => {
              const partnerSubGrid = p.subGrids[subGrid.region];

              if (partnerSubGrid.width !== subGrid.width) {
                if (subGrid.collapsed) {
                  partnerSubGrid.collapse();
                } else {
                  if (partnerSubGrid.collapsed) {
                    partnerSubGrid.expand();
                  }

                  if (subGrid.flex) {

                    if (subGrid.flex !== partnerSubGrid.flex) {
                      partnerSubGrid.flex = subGrid.flex;
                    }
                  } else {
                    partnerSubGrid.width = subGrid.width;
                  }
                }
              }
            });
            p.isSyncingFromPartner = false;
          }
        });
      }


      me.trigger('timelineViewportResize', {
        width,
        height,
        oldWidth,
        oldHeight
      });
      me._lastOverflow = subGrid.overflowingHorizontally;
    }
  }

  onTimeAxisViewModelUpdate() {
    this.updateCanvasSize();

    if (this.isHorizontal) {


      this.callEachSubGrid('refreshFakeScroll');
      this.refreshVirtualScrollbars();
    }

    this.currentOrientation.onTimeAxisViewModelUpdate();
  }


  get currentOrientation() {
    throw new Error('Implement in subclass');
  }

  get isHorizontal() {
    return true;
  }


  get backgroundCanvas() {
    return this._backgroundCanvas;
  }

  get foregroundCanvas() {
    return this._foregroundCanvas;
  }

  get svgCanvas() {
    const me = this;

    if (!me._svgCanvas) {
      const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('id', IdHelper.generateId('svg'));

      svg.retainElement = true;
      me.foregroundCanvas.appendChild(svg);
      me.trigger('svgCanvasCreated');
    }

    return me._svgCanvas;
  }


  get timeAxisSubGridElement() {
    return this.timeAxisColumn && this.timeAxisColumn.subGridElement;
  }

  updateCanvasSize() {
    const me = this;

    if (me.isHorizontal) {
      if (me.backgroundCanvas) {
        me.backgroundCanvas.style.width = `${me.timeAxisViewModel.totalSize}px`;
      }

      me.foregroundCanvas.style.width = `${me.timeAxisViewModel.totalSize}px`;
    } else {
      if (me.backgroundCanvas) {
        me.backgroundCanvas.style.width = DomHelper.setLength(me.timeAxisColumn.width);
      }

      me.foregroundCanvas.style.width = DomHelper.setLength(me.timeAxisColumn.width);
    }
  }


  getHeaderDomConfigs(configs) {
  }


  getForegroundDomConfigs(configs) {
  }


  refresh(forceLayout = true, refreshMoreFn = null) {
    const me = this;

    if (me.isPainted && !me.refreshSuspended) {
      if (me.hasVisibleEvents) {
        me.refreshRows(false, forceLayout);

        if (refreshMoreFn) {
          refreshMoreFn();
        }
      } else {
        me.rowManager.trigger('refresh');
      }
    }
  }

  render() {
    const me = this,
      schedulerEl = me.timeAxisSubGridElement;

    if (me.useBackgroundCanvas) {
      me._backgroundCanvas = DomHelper.createElement({
        className: 'b-sch-background-canvas',
        parent: schedulerEl,
        nextSibling: schedulerEl.firstElementChild
      });
    }

    const fgCanvas = me._foregroundCanvas = DomHelper.createElement({
      className: 'b-sch-foreground-canvas',
      style: `font-size:${me.rowHeight - me.resourceMargin * 2}px`,
      parent: schedulerEl
    });
    me.timeAxisSubGrid.insertRowsBefore = fgCanvas;
    super.render(...arguments);
  }

  refreshRows(returnToTop = false, reLayoutEvents = true) {
    const me = this;

    if (me.isConfiguring) {
      return;
    }

    me.currentOrientation.refreshRows(reLayoutEvents);
    super.refreshRows(returnToTop);
  }


  getDateConstraints() {
  }

  runWithTransition(fn, duration) {
    const me = this;

    if (me.isVisible) {

      if (duration == null || duration === true) {
        duration = me.transitionDuration;
      }

      if (duration && me.enableEventAnimations) {
        me.isAnimating = true;


        exitTransition.delay = duration;
        me.setTimeout(exitTransition);
      }
    }

    fn();
  }

  exitTransition() {
    this.isAnimating = false;
    this.trigger('transitionend');
  }


  refreshWithTransition(forceLayout) {
    this.runWithTransition(() => this.refresh(forceLayout));
  }


  getVisibleDateRange() {
    return this.currentOrientation.getVisibleDateRange();
  }

}

VersionHelper.setVersion('scheduler', '3.1.3');
TimelineBase._$name = 'TimelineBase';


const locale$3 =   locale_zh.locale$3

for (let i in locale$2) {
  locale$3[i] = locale$2[i];
}
LocaleManagerSingelton.registerLocale('En', {
  desc: 'English',
  locale: locale$3
});


var SchedulerDom = (Target => class SchedulerDom extends (Target || Base) {


  getElementFromAssignmentRecord(assignmentRecord) {
    return this.currentOrientation.getElementFromEventRecord(assignmentRecord.event, assignmentRecord.resource);
  }


  getElementFromEventRecord(eventRecord, resourceRecord) {
    return this.currentOrientation.getElementFromEventRecord(eventRecord, resourceRecord);
  }


  getElementsFromEventRecord(eventRecord, resourceRecord) {
    return this.currentOrientation.getElementsFromEventRecord(eventRecord, resourceRecord);
  }


  getEventIdFromDomNodeId(id) {
    const eventId = id.substring(this.eventPrefix.length).split('-')[0];


    return eventId && eventId.replace(/\._\./g, '-');
  }


  getEventRecordFromDomId(id) {
    id = this.getEventIdFromDomNodeId(id);
    return this.eventStore.getById(id);
  }


  getResourceIdFromDomNodeId(id) {
    const resourceId = id.substring(this.eventPrefix.length).split('-')[1];


    return resourceId && resourceId.replace(/\._\./g, '-');
  }


  getResourceRecordFromDomId(id) {
    id = this.getResourceIdFromDomNodeId(id);
    return this.resourceStore.getById(id);
  }


  resolveResourceRecord(elementOrEvent, xy) {
    return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);
  }


  resolveEventRecord(element) {
    element = DomHelper.up(element, this.eventSelector);

    if (element) {
      if (element.dataset.eventId) {
        return this.eventStore.getById(element.dataset.eventId);
      }

      if (element.dataset.assignmentId) {
        return this.assignmentStore.getById(element.dataset.assignmentId).event;
      }
    }

    return null;
  }

  resolveTimeSpanRecord(element) {
    return this.resolveEventRecord(element);
  }


  resolveAssignmentRecord(element) {
    const {
      assignmentStore
    } = this.eventStore;
    let assignment = null;

    if (assignmentStore) {
      const eventElement = DomHelper.up(element, this.eventSelector),
        event = this.resolveEventRecord(eventElement),
        resource = this.resolveResourceRecord(eventElement);

      if (event && resource) {
        assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
      }
    }

    return assignment;
  }


  isRowVisible(resourceRecord) {

    return this.store.indexOf(resourceRecord) >= 0;
  }


  getMilestoneLabelWidth(eventRecord) {
    const me = this,
      mode = me.milestoneLayoutMode;

    if (mode === 'measure') {
      const element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({
        className: 'b-sch-event-wrap b-milestone-wrap b-measure',
        children: [{
          className: 'b-sch-event b-milestone',
          html: `<label></label>`
        }],
        parent: me.foregroundCanvas
      }));
      element.firstElementChild.firstElementChild.innerHTML = eventRecord.name;
      return element.offsetWidth;
    }

    if (mode === 'estimate') {
      return Math.max(eventRecord.name.length * me.milestoneCharWidth, me.milestoneMinWidth);
    }

    if (mode === 'data') {
      return Math.max(eventRecord.milestoneWidth, me.milestoneMinWidth);
    }

    return 0;
  }

  set milestoneLayoutMode(mode) {
    const me = this;
    me._milestoneLayoutMode = mode;
    me.element.classList[mode !== 'default' ? 'add' : 'remove']('b-sch-layout-milestones');
    me.refresh();
  }

  get milestoneLayoutMode() {
    return this._milestoneLayoutMode;
  }

  set milestoneAlign(align) {
    this._milestoneAlign = align;
    this.refresh();
  }

  get milestoneAlign() {
    return this._milestoneAlign;
  }

  set milestoneCharWidth(width) {
    this._milestoneCharWidth = width;
    this.refresh();
  }

  get milestoneCharWidth() {
    return this._milestoneCharWidth;
  }


  get widgetClass() {
  }

});


var SchedulerDomEvents = (Target => class SchedulerDomEvents extends (Target || Base) {


  getTimeSpanMouseEventParams(eventElement, event) {
    return {
      eventRecord: this.resolveEventRecord(eventElement),
      resourceRecord: this.resolveResourceRecord(eventElement),
      assignmentRecord: this.resolveAssignmentRecord(eventElement),
      eventElement,
      event
    };
  }

  getScheduleMouseEventParams(cellData, event) {
    const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);
    return {
      resourceRecord
    };
  }


  onElementKeyDown(event) {
    super.onElementKeyDown(event);
    const me = this;

    if (me.selectedEvents.length) {
      me.trigger(me.scheduledEventName + 'KeyDown', {
        eventRecord: me.selectedEvents
      });
    }
  }


  onElementKeyUp(event) {
    super.onElementKeyUp(event);
    const me = this;

    if (me.selectedEvents.length) {
      me.trigger(me.scheduledEventName + 'KeyUp', {
        eventRecord: me.selectedEvents
      });
    }
  }


  get widgetClass() {
  }

});


var SchedulerDragResize = (Target => class SchedulerDragResize extends (Target || Base) {
  construct(config) {
    const me = this;
    super.construct(config);

    if (me.hasFeature('eventDragCreate')) {
      me.on({
        dragcreateend: me.internalOnDragCreateEnd,
        thisObj: me
      });
    }
  }

  internalOnDragCreateEnd({
                            newEventRecord: eventRecord,
                            resourceRecord
                          }) {
    const me = this;

    if (!me.hasFeature('eventEdit') || me.features.eventEdit.disabled) {
      const resources = resourceRecord ? [resourceRecord] : [];

      if (me.trigger('beforeEventAdd', {
        eventRecord,
        resources,
        resourceRecords: resources
      }) !== false) {
        me.onEventCreated(eventRecord);
        me.eventStore.add(eventRecord);
        eventRecord.assign(resourceRecord);
      }
    }
  }

  get eventEditor() {
    return this._eventEditor;
  }

  set eventEditor(editor) {
    this._eventEditor = editor;
  }


  get widgetClass() {
  }

});


class HorizontalLayout extends Base {
  static get defaultConfig() {
    return {
      nbrOfBandsByResource: {},
      bandIndexToPxConvertFn: null,
      bandIndexToPxConvertThisObj: null
    };
  }

  clearCache(resource) {
    if (resource) {
      delete this.nbrOfBandsByResource[resource.id];
    } else {
      this.nbrOfBandsByResource = {};
    }
  }


  getNumberOfBands(resource, resourceEventsOrFn) {
    const nbrOfBandsByResource = this.nbrOfBandsByResource;

    if (nbrOfBandsByResource.hasOwnProperty(resource.id)) {
      return nbrOfBandsByResource[resource.id];
    }

    const resourceEvents = typeof resourceEventsOrFn === 'function' ? resourceEventsOrFn() : resourceEventsOrFn,
      eventsData = resourceEvents.map(event => ({
        start: event.startDate,
        end: event.endDate,
        event: event
      }));
    return this.applyLayout(eventsData, resource);
  }

  applyLayout(events, resource) {
    const rowEvents = events.slice(),

      newNbrBands = this.layoutEventsInBands(rowEvents);
    return this.nbrOfBandsByResource[resource.id] = newNbrBands;
  }

}

HorizontalLayout._$name = 'HorizontalLayout';


class HorizontalLayoutStack extends HorizontalLayout {

  layoutEventsInBands(events) {
    let verticalPosition = 0;

    do {
      let eventIndex = 0,
        event = events[0];

      while (event) {

        event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, verticalPosition, event.event);

        events.splice(eventIndex, 1);
        eventIndex = this.findClosestSuccessor(event, events);
        event = events[eventIndex];
      }

      verticalPosition++;
    } while (events.length > 0);

    return verticalPosition;
  }

  findClosestSuccessor(eventRenderData, events) {
    let minGap = Infinity,
      closest,
      eventEnd = eventRenderData.endMs,
      gap,
      isMilestone = eventRenderData.event.duration === 0,
      evt;

    for (let i = 0, l = events.length; i < l; i++) {
      evt = events[i];
      gap = evt.startMs - eventEnd;

      if (gap >= 0 && gap < minGap && (
        gap > 0 || evt.endMs - evt.startMs > 0 || !isMilestone)) {
        closest = i;
        minGap = gap;
      }
    }

    return closest;
  }

}

HorizontalLayoutStack._$name = 'HorizontalLayoutStack';


var PackMixin = (Target => class PackMixin extends (Target || Base) {
  static get defaultConfig() {
    return {
      coordProp: 'top',
      sizeProp: 'height'
    };
  }

  applyLayout(events, applyClusterFn) {
    const me = this,
      {
        coordProp,
        sizeProp
      } = me;
    let slot, firstInCluster, cluster, j;

    for (let i = 0, l = events.length; i < l; i++) {
      firstInCluster = events[i];
      slot = me.findStartSlot(events, firstInCluster);
      cluster = me.getCluster(events, i);

      if (cluster.length > 1) {
        firstInCluster[coordProp] = slot.start;
        firstInCluster[sizeProp] = slot.end - slot.start;

        j = 1;

        while (j < cluster.length - 1 && cluster[j + 1].start - firstInCluster.start === 0) {
          j++;
        }

        const nextSlot = me.findStartSlot(events, cluster[j]);

        if (nextSlot && nextSlot.start < 0.8) {
          cluster.length = j;
        }
      }

      const clusterSize = cluster.length,
        slotSize = (slot.end - slot.start) / clusterSize;

      for (j = 0; j < clusterSize; j++) {
        applyClusterFn(cluster[j], j, slot, slotSize);
      }

      i += clusterSize - 1;
    }
  }

  findStartSlot(events, event) {
    const {
        sizeProp,
        coordProp
      } = this,
      priorOverlappers = this.getPriorOverlappingEvents(events, event);
    let i;

    if (priorOverlappers.length === 0) {
      return {
        start: 0,
        end: 1
      };
    }

    for (i = 0; i < priorOverlappers.length; i++) {
      if (i === 0 && priorOverlappers[0][coordProp] > 0) {
        return {
          start: 0,
          end: priorOverlappers[0][coordProp]
        };
      } else if (priorOverlappers[i][coordProp] + priorOverlappers[i][sizeProp] < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][coordProp] : 1)) {
        return {
          start: priorOverlappers[i][coordProp] + priorOverlappers[i][sizeProp],
          end: i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][coordProp] : 1
        };
      }
    }

    return false;
  }

  getPriorOverlappingEvents(events, event) {
    const start = event.start,
      end = event.end,
      overlappers = [];

    for (let i = 0, l = events.indexOf(event); i < l; i++) {
      if (DateHelper.intersectSpans(start, end, events[i].start, events[i].end)) {
        overlappers.push(events[i]);
      }
    }

    overlappers.sort(this.sortOverlappers.bind(this));
    return overlappers;
  }

  sortOverlappers(e1, e2) {
    return e1[this.coordProp] < e2[this.coordProp] ? -1 : 1;
  }

  getCluster(events, startIndex) {
    const startEvent = events[startIndex];

    if (startIndex >= events.length - 1) {
      return [startEvent];
    }

    const evts = [startEvent],
      l = events.length;
    let {
        start,
        end
      } = startEvent,
      i = startIndex + 1;

    while (i < l && DateHelper.intersectSpans(start, end, events[i].start, events[i].end)) {
      evts.push(events[i]);
      start = DateHelper.max(start, events[i].start);
      end = DateHelper.min(events[i].end, end);
      i++;
    }

    return evts;
  }

});


class HorizontalLayoutPack extends PackMixin(HorizontalLayout) {

  applyLayout(events) {
    super.applyLayout(events, (event, j, slot, slotSize) => {
      event.height = slotSize;
      event.top = slot.start + j * slotSize;
    });
    events.forEach(event => {
      Object.assign(event, this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, event.top, event.height, null, event.event));
    });
  }

}

HorizontalLayoutPack._$name = 'HorizontalLayoutPack';


const hyphenRe = /-/g;


var SchedulerEventRendering = (Target => class SchedulerEventRendering extends (Target || Base) {

  static get defaultConfig() {
    return {

      eventRenderer: null,


      eventRendererThisObj: null,
      eventPrefix: '',


      eventLayout: 'stack',


      horizontalLayoutPackClass: HorizontalLayoutPack,


      horizontalLayoutStackClass: HorizontalLayoutStack,


      horizontalEventSorterFn: null,


      eventBarTextField: 'name',


      eventBodyTemplate: null,
      eventPositionMode: 'translate',
      eventScrollMode: 'move',


      fillTicks: false,


      useInitialAnimation: true,


      resourceColumns: null,


      resourceImagePath: null,


      defaultResourceImageName: 'none.png',


      resourceImageExtension: '.jpg',


      resourceMargin: null,

      isFirstRender: true
    };
  }


  get eventPrefix() {
    return this._eventPrefix;
  }

  set eventPrefix(eventPrefix) {
    this._eventPrefix = eventPrefix || this.id + '-';
  }


  get layouts() {
    const me = this;

    if (!me._eventLayout) {
      me._eventLayout = {};

      if (me.horizontalLayoutPackClass) {
        me._eventLayout.horizontalPack = new me.horizontalLayoutPackClass(Object.assign(
          {
            scheduler: me,
            timeAxisViewModel: me.timeAxisViewModel,
            bandIndexToPxConvertFn: me.horizontal.layoutEventVerticallyPack,
            bandIndexToPxConvertThisObj: me.horizontal
          }));
      }

      if (me.horizontalLayoutStackClass) {
        me._eventLayout.horizontalStack = new me.horizontalLayoutStackClass(Object.assign(
          {
            scheduler: me,
            timeAxisViewModel: me.timeAxisViewModel,
            bandIndexToPxConvertFn: me.horizontal.layoutEventVerticallyStack,
            bandIndexToPxConvertThisObj: me.horizontal
          }));
      }
    }

    return me._eventLayout;
  }


  get eventLayout() {
    return this._overlapMode;
  }

  set eventLayout(eventLayout) {
    const me = this;

    if (eventLayout != me._overlapMode) {
      me.element.classList.remove(`b-eventlayout-${me._overlapMode}`);
      me._overlapMode = eventLayout;
      me.runWithTransition(() => {
        me.element.classList.add(`b-eventlayout-${me._overlapMode}`);
        me.refresh();
      });
    }
  }


  get fillTicks() {
    return this._fillTicks;
  }

  set fillTicks(fill) {
    const me = this;

    if (fill != me._fillTicks) {
      me._fillTicks = fill;
      me.refreshWithTransition();
    }
  }


  get currentEventLayout() {
    const me = this;
    if (!me.isHorizontal) return null;

    switch (me.eventLayout) {
      case 'stack':
        return me.layouts.horizontalStack;

      case 'pack':
        return me.layouts.horizontalPack;

      default:
        return null;
    }
  }

  get useInitialAnimation() {
    return this._useInitialAnimation;
  }

  set useInitialAnimation(name) {
    const me = this;

    if (me._useInitialAnimation) {
      me.element.classList.remove(`b-initial-${me._useInitialAnimation}`);
    }

    me._useInitialAnimation = name === true ? 'fade-in' : name;

    if (name) {
      me.element.classList.add(`b-initial-${me._useInitialAnimation}`);
    }
  }

  set isFirstRender(value) {
    const me = this;
    me._isFirstRender = value;

    if (!me._firstRenderDone && value) {
      me._firstRenderDone = me.createOnFrame(() => {
        me._isFirstRender = false;
        me._firstRenderDone = null;
      });
    }
  }

  get isFirstRender() {
    return this._isFirstRender;
  }

  set horizontalEventSorterFn(fn) {

    this._horizontalEventSorterFn = fn ? (a, b) => fn(a.event, b.event) : fn;

    if (this.rendered) {
      this.refreshWithTransition();
    }
  }

  get horizontalEventSorterFn() {
    return this._horizontalEventSorterFn;
  }


  set resourceColumns(config) {
    this._resourceColumns = config;
  }


  get resourceColumns() {
    return this.timeAxisColumn && this.timeAxisColumn.resourceColumns || this._resourceColumns;
  }


  get resourceColumnWidth() {
    return this.resourceColumns ? this.resourceColumns.columnWidth : null;
  }


  getEventsToRender(resource, events) {
    return events;
  }


  repaintEventsForResource(resourceRecord
  ) {
    const me = this;

    if (me.isHorizontal) {
      me.currentOrientation.cache.clearRow(resourceRecord.id);
      const row = me.getRowFor(resourceRecord);

      if (row) {

        row.render();
      }
    }


  }


  repaintEvent(eventRecord) {
    const resources = this.eventStore.getResourcesForEvent(eventRecord);
    resources.forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));
  }


  generateTplData(eventRecord, resourceRecord, includeOutside = {
    viewport: true
  }) {
    const me = this,


      renderData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside);
    let eventContent = '';

    if (renderData) {
      let resizable = eventRecord.isResizable;

      if (renderData.startsOutsideView) {
        if (resizable === true) resizable = 'end'; else if (resizable === 'start') resizable = false;
      }

      if (renderData.endsOutsideView) {
        if (resizable === true) resizable = 'start'; else if (resizable === 'end') resizable = false;
      }


      const clsList = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.cls.clone(),
        wrapperClsList = eventRecord.isResourceTimeRange ? eventRecord.cls.clone() : new DomClassList();
      Object.assign(clsList, {
        [resourceRecord.cls]: resourceRecord.cls,
        [me.generatedIdCls]: eventRecord.hasGeneratedId,
        [me.dirtyCls]: eventRecord.isPersistable && eventRecord.modifications,
        [me.committingCls]: eventRecord.isCommitting,
        [me.endsOutsideViewCls]: renderData.endsOutsideView,
        [me.startsOutsideViewCls]: renderData.startsOutsideView,
        'b-clipped-start': renderData.clippedStart,
        'b-clipped-end': renderData.clippedEnd
      });
      Object.assign(wrapperClsList, {
        [`${me.eventCls}-parent`]: resourceRecord.isParent
      });

      if (eventRecord.isEvent || eventRecord.isTask) {
        Object.assign(clsList, {
          [me.eventCls]: 1,
          'b-milestone': eventRecord.isMilestone,
          'b-sch-event-narrow': renderData.width < 10,
          [me.fixedEventCls]: eventRecord.isDraggable === false,
          [`b-sch-event-resizable-${resizable}`]: Boolean(me.features.eventResize),
          [me.eventSelectedCls]: me.isEventSelected(eventRecord),
          'b-recurring': eventRecord.isRecurring,
          'b-occurrence': eventRecord.isOccurrence
        });
        renderData.eventId = eventRecord.id;

        renderData.id = me.getEventRenderId(eventRecord, resourceRecord);


        if ('id' in eventRecord.meta.modified) {
          renderData.oldId = me.getEventRenderId(eventRecord.meta.modified.id, resourceRecord);
        }

        Object.assign(wrapperClsList, {
          [`${me.eventCls}-wrap`]: 1,
          'b-milestone-wrap': eventRecord.isMilestone
        });
        const eventStyle = eventRecord.eventStyle || resourceRecord.eventStyle || me.eventStyle,
          eventColor = eventRecord.eventColor || resourceRecord.eventColor || me.eventColor;
        renderData.eventColor = eventColor;
        renderData.eventStyle = eventStyle;


        if (me.assignmentStore && eventRecord.assignments) {
          renderData.assignment = eventRecord.assignments.find(a => a.resourceId === resourceRecord.id);
        }
      }

      renderData.wrapperCls = wrapperClsList;
      renderData.cls = clsList;
      renderData.iconCls = new DomClassList(eventRecord.get(me.eventBarIconClsField) || eventRecord.iconCls);

      if (eventRecord.isResourceTimeRange) {
        renderData.style = '';
        renderData.wrapperStyle = eventRecord.style || '';
      } else {
        renderData.style = eventRecord.style || '';
      }

      renderData.resource = resourceRecord;
      renderData.resourceId = renderData.rowId;

      if (eventRecord.isEvent || eventRecord.isTask) {
        if (me.eventRenderer) {

          const value = me.eventRenderer.call(me.eventRendererThisObj || me, {
            eventRecord,
            resourceRecord,
            assignmentRecord: renderData.assignment,
            tplData: renderData
          });

          if (typeof renderData.cls === 'string') {
            renderData.cls = new DomClassList(renderData.cls);
          }

          if (typeof renderData.wrapperCls === 'string') {
            renderData.wrapperCls = new DomClassList(renderData.wrapperCls);
          }

          if (typeof renderData.iconCls === 'string') {
            renderData.iconCls = new DomClassList(renderData.iconCls);
          }

          eventContent = me.eventBodyTemplate && me.eventBodyTemplate(value) || (value == null ? '' : String(value));
        } else if (me.eventBodyTemplate) {

          eventContent = me.eventBodyTemplate(eventRecord);
        } else if (me.eventBarTextField) {

          eventContent = eventRecord.data[me.eventBarTextField] || '';
        }

        if (!me.eventBodyTemplate) {

          if (eventRecord.isMilestone && eventContent) {
            eventContent = `<label>${eventContent}</label>`;
          }

          if (renderData.iconCls && renderData.iconCls.length) {
            eventContent = `<i class="${renderData.iconCls}"></i>${eventContent}`;
          }
        }

        renderData.wrapperCls[`b-sch-style-${renderData.eventStyle}`] = renderData.eventStyle;

        if (renderData.eventColor && renderData.eventColor.startsWith('#')) {
          renderData.style = `background-color:${renderData.eventColor};` + renderData.style;
        } else {
          renderData.wrapperCls[`b-sch-color-${renderData.eventColor}`] = renderData.eventColor;
        }
      }

      renderData.cls['b-sch-event-withicon'] = renderData.iconCls.length;

      if (eventContent.includes('<')) {

        renderData.body = DomHelper.createElementFromTemplate(eventContent, {
          fragment: true
        });
      } else {
        renderData.body = document.createDocumentFragment();
        renderData.body.textContent = eventContent;
      }

      renderData.eventContent = eventContent;

      me.onEventDataGenerated(renderData);
    }

    return renderData;
  }


  onEventDataGenerated(eventData) {
  }


  getEventRenderId(eventRecord, resourceRecord) {

    const eventId = eventRecord instanceof TimeSpan ? eventRecord.id : eventRecord,
      eventIdWithoutDash = eventId.toString().replace(hyphenRe, '._.'),
      resourceId = resourceRecord instanceof ResourceModel ? resourceRecord.id : resourceRecord,
      resourceIdWithoutDash = resourceId.toString().replace(hyphenRe, '._.');
    return this.eventPrefix + `${eventIdWithoutDash}-${resourceIdWithoutDash}-x`;
  }


  restartInitialAnimation(initialAnimation) {
    const me = this;
    me.useInitialAnimation = initialAnimation;
    me._firstRenderDone = null;
    me.isFirstRender = true;
    me.refresh();
  }


  get widgetClass() {
  }

});


const MAX_VALUE = Math.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,
  checkResources = {
    add: 1,
    update: 1,
    remove: 1,
    filter: 1
  };


var SchedulerStores = (Target => class SchedulerStores extends (Target || Base) {

  static get defaultConfig() {
    return {

      events: null,


      eventStore: null,


      resources: null,


      resourceStore: null,


      assignments: null,


      assignmentStore: null,


      dependencies: null,


      dependencyStore: null,


      timeRanges: null,


      resourceTimeRanges: null,


      store: null,


      startParamName: 'startDate',


      endParamName: 'endDate',


      passStartEndParameters: false,


      removeUnassignedEvent: true
    };
  }


  onStoreDataChange({
                      source: store,
                      action
                    }) {
    this.currentOrientation.clearEvents();
    super.onStoreDataChange(...arguments);

    if (action === 'dataset') {
      this.calculateAllRowHeights();
    }
  }

  refreshFromRowOnStoreAdd(row, {
    isExpand
  }) {
    const args = arguments;
    this.runWithTransition(() => super.refreshFromRowOnStoreAdd(row, ...args), !isExpand);
  }

  onStoreAdd({
               source: store,
               records,
               isChild,
               isExpandAll
             }) {
    const me = this,
      {
        rowManager
      } = me;


    if (isExpandAll || isChild && !records[0].ancestorsExpanded(store)) {
      return;
    }

    rowManager.calculateRowCount(false, true, true);
    const endIndex = Math.max(rowManager.topIndex + rowManager.rowCount, Math.min(rowManager.visibleRowCount, store.count));

    records = records.sort((lhs, rhs) => {
      return store.indexOf(lhs) - store.indexOf(rhs);
    });
    let firstUpdatedIndex = store.indexOf(records[0]);

    if (firstUpdatedIndex < endIndex) {


      firstUpdatedIndex = Math.max(firstUpdatedIndex, rowManager.topIndex);

      for (let i = firstUpdatedIndex; i < endIndex; i++) {
        me.currentOrientation.onRowRecordUpdate({
          record: store.getAt(i)
        });
      }
    } else {

      rowManager.estimateTotalHeight();
    }

    super.onStoreAdd(...arguments);
  }


  onStoreUpdateRecord() {

    this.currentOrientation.onRowRecordUpdate(...arguments);
    super.onStoreUpdateRecord(...arguments);
  }

  onStoreRemove() {
    this.currentOrientation.onRowRecordRemove(...arguments);
    super.onStoreRemove(...arguments);
  }

  onStoreRemoveAll() {
    this.currentOrientation.clearEvents();
    super.onStoreRemoveAll();
  }


  doDestroy() {
    super.doDestroy();
    const me = this;

    if (me.destroyStores) {
      me.constructor.destroy(me.assignmentStore, me.resourceStore, me.dependencyStore, me.eventStore);
    }
  }


  get store() {
    const me = this;


    me._thisIsAUsedExpression(me.resources);

    if (!me._store && me.isVertical) {

      me._store = new Store({
        data: [{
          id: 'verticalTimeAxisRow'
        }]
      });
    }

    return super.store;
  }

  set store(store) {
    super.store = store;
  }


  get resources() {
    const resourceStore = this.resourceStore;
    return resourceStore && resourceStore.records;
  }

  set resources(resources) {
    this.resourceStore.data = resources;
  }


  get resourceStore() {
    const me = this;


    if (!me._resourceStore) {
      if (!me.crudManager || !me.crudManager.resourceStore) {
        me.resourceStore = new ResourceStore();
      }
    }

    return me._resourceStore;
  }

  set resourceStore(newResourceStore) {
    const me = this,
      oldResourceStore = me._resourceStore;

    if (newResourceStore === oldResourceStore) {
      return;
    }

    if (!(newResourceStore instanceof ResourceStore)) {
      newResourceStore = new ResourceStore(newResourceStore);
    }

    if (oldResourceStore) {
      const isBackingRowStore = oldResourceStore === me.store;
      me._resourceStore = newResourceStore;

      if (newResourceStore && me.isHorizontal) {
        if (isBackingRowStore) {
          me.store = me.resourceStore;
          me.store.metaMapId = me.id;
        } else {
          me.refresh();
        }
      }
    } else {
      me._resourceStore = newResourceStore;
    }

    if (newResourceStore) {

      if (me.isVertical) {
        newResourceStore.on({
          load: () => me.unmaskBody(),
          thisObj: me
        });
      }

      me.trigger('resourceStoreChange', {
        newResourceStore,
        oldResourceStore
      });
    }

    if (me.isHorizontal && !me._store) {
      me.store = newResourceStore;
    }
  }

  getResourceStoreListenerConfig() {
    return {};
  }


  get events() {
    return this._eventStore.records;
  }

  set events(events) {
    this.eventStore.data = events;
  }


  get eventStore() {
    const me = this;


    if (!me._eventStore) {
      if (!me.crudManager || !me.crudManager.eventStore) {
        me.eventStore = new EventStore({
          resourceStore: me.resourceStore
        });
      }
    }

    return this._eventStore;
  }

  set eventStore(newEventStore) {
    const me = this,
      oldEventStore = me._eventStore;
    let triggerLoad = false;

    if (newEventStore === oldEventStore) {
      return;
    }

    const resourceStore = me.resourceStore;

    if (oldEventStore) {
      const oldEventStore = me.eventStore,
        {
          assignmentStore,
          dependencyStore
        } = me;

      if (newEventStore === oldEventStore) {
        return;
      }

      me.eventStoreDetacher && me.eventStoreDetacher();
      me._eventStore = newEventStore;
      me.timeAxisViewModel.eventStore = newEventStore;

      if (newEventStore) {
        if (resourceStore && !newEventStore.resourceStore) {
          newEventStore.resourceStore = resourceStore;
        }

        if (assignmentStore && !newEventStore.assignmentStore) {
          newEventStore.assignmentStore = assignmentStore;
        }

        if (dependencyStore && !newEventStore.dependencyStore) {
          newEventStore.dependencyStore = dependencyStore;
        }

        me.trigger('eventStoreChange', {
          newEventStore,
          oldEventStore
        });
        me.refresh();
      }
    } else {
      if (newEventStore.isEventStore) {
        if (resourceStore && newEventStore.resourceStore !== resourceStore) {


          if (newEventStore.resourceStore) {
            throw new Error(`eventStore ${newEventStore.id} is already linked to resourceStore ${newEventStore.resourceStore.id}`);
          }

          newEventStore.resourceStore = resourceStore;
        }
      } else {
        triggerLoad = newEventStore.autoLoad;
        newEventStore.autoLoad = false;
        newEventStore = new EventStore(Object.assign({
          resourceStore: me.resourceStore
        }, newEventStore));
      }

      me._eventStore = newEventStore;
    }

    if (newEventStore) {
      const listenerCfg = this.getEventStoreListenerConfig();

      if (me.passStartEndParameters) {
        listenerCfg.beforeload = me.applyStartEndParameters;
      }

      me.eventStoreDetacher && me.eventStoreDetacher();


      me.eventStoreDetacher = newEventStore.on(listenerCfg);

      if (newEventStore.assignmentStore) {
        me.assignmentStore = newEventStore.assignmentStore;
      }

      if (triggerLoad) {
        newEventStore.load().catch(() => {
        });
      }
    }

    if (me.eventStore.count > 0) {
      me.eventsRendered = true;
    }
  }

  getEventStoreListenerConfig() {
    return {
      thisObj: this,
      detachable: true,


      change: 'onInternalEventStoreChange',
      clearchanges: 'onEventClearChanges',
      beforecommit: 'onEventBeforeCommit',
      commit: 'onEventCommit',
      beforeRemove: 'onEventStoreBeforeRemove',
      refresh: 'onEventStoreRefresh',
      exception: 'onEventException',
      idchange: 'onEventIdChange'


    };
  }


  get assignments() {
    return this.assignmentStore && this.assignmentStore.records;
  }

  set assignments(assignments) {


    if (!this.assignmentStore) {
      this.eventStore.assignmentStore = this.assignmentStore = new AssignmentStore();
    }

    this.assignmentStore.data = assignments;
  }


  get assignmentStore() {
    const me = this,
      eventStore = me.eventStore,
      crudManager = me.crudManager;
    return crudManager && crudManager.assignmentStore || eventStore && eventStore.assignmentStore;
  }

  set assignmentStore(newAssignmentStore) {
    const me = this,
      oldAssignmentStore = me.assignmentStore;

    if (me.eventStore.assignmentStore !== newAssignmentStore) {
      me.eventStore.assignmentStore = newAssignmentStore;
    }

    me.assignmentStoreDetacher && me.assignmentStoreDetacher();

    if (newAssignmentStore) {

      me.assignmentStoreDetacher = newAssignmentStore.on(me.getAssignmentStoreListenerConfig());
      me.trigger('assignmentStoreChange', {
        newAssignmentStore,
        oldAssignmentStore
      });
      me.refresh();
    }
  }

  getAssignmentStoreListenerConfig() {
    const me = this;
    return {
      thisObj: me,

      refresh: me.onAssignmentRefresh,
      update: me.onAssignmentUpdate,
      add: me.onAssignmentAdd,
      beforeRemove: {
        fn: me.onBeforeAssignmentRemove,


        prio: -1000
      },
      remove: me.onAssignmentRemove,
      filter: me.onAssignmentFilter,
      removeall: me.onAssignmentRemoveAll
    };
  }


  get dependencyStore() {
    const me = this,
      eventStore = me.eventStore,
      crudManager = me.crudManager;
    return crudManager && crudManager.dependencyStore || eventStore && eventStore.dependencyStore || me._dependencyStore;
  }

  set dependencyStore(newDependencyStore) {
    const me = this;

    if (!me.isConfigured) {
      me._dependencyStore = newDependencyStore;
    } else {
      const oldDependencyStore = me.dependencyStore;
      me.eventStore.dependencyStore = newDependencyStore;

      if (newDependencyStore) {
        me.trigger('dependencyStoreChange', {
          newDependencyStore,
          oldDependencyStore
        });
        me.refresh();
      }
    }
  }

  getDependencyStoreListenerConfig() {
    return {};
  }


  onEventIdChange(params) {
    this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);
  }


  onInternalEventStoreChange(params) {
    const me = this;

    if (!me._mode) {
      return;
    }

    if (me.isVertical) {
      me.currentOrientation.onEventStoreChange(params);
    } else {

      const layout = me.currentOrientation,

        eventStore = params.source,
        {
          rowManager,
          resourceStore
        } = me,
        {
          action,
          changes,
          isCollapse
        } = params,
        events = params.records || (params.record ? [params.record] : null),
        resources = [];
      let rows = new Set(),
        useTransition = false,
        len,
        i;

      if (!me.isPainted) {

        if (params.action === 'dataset') {

          this.calculateAllRowHeights(true);
        }

        return;
      }

      if (isCollapse || action === 'update' && events.length && events[0].meta.removingResource) {
        return;
      }


      const skipRows = action === 'filter' && me.hasFeature('resourceTimeRanges');

      if (!skipRows && checkResources[action] && events) {

        if (changes && 'resourceId' in changes && changes.resourceId.oldValue != null) {
          const prevResource = resourceStore.getById(changes.resourceId.oldValue),
            prevRow = prevResource && rowManager.getRowFor(prevResource);


          if (prevRow) {
            resources.push(prevResource);
            rows.add(prevRow);
          }
        }

        for (i = 0, len = events.length; i < len; i++) {
          resources.push(...eventStore.getResourcesForEvent(events[i]).filter(resource => {


            if (resource && me.resourceStore.isAvailable(resource.id)) {
              const row = rowManager.getRowFor(resource);

              if (row) {
                rows.add(row);
                return true;
              }
            }

            return false;
          }));
        }

        if (resources.length) {

          if (rows.size > 1) {
            rows = new Set([...rows].sort((a, b) => a.dataIndex - b.dataIndex));
          } else if (!rows.size) {
            return;
          }
        } else if (!(action === 'filter' && !events.length)) {
          rowManager.estimateTotalHeight();
          return;
        }

        params.resources = resources;
      }

      switch (action) {
        case 'dataset':
          layout.onEventDataset();
          break;

        case 'add':
          layout.onEventAdd(params);
          useTransition = true;
          break;

        case 'update':
          layout.onEventUpdate(params);
          useTransition = true;
          break;

        case 'remove':
          layout.onEventRemove(params);
          useTransition = true;
          break;

        case 'removeall':
          layout.onEventRemoveAll();
          useTransition = true;
          break;

        case 'filter':
          layout.onEventFilter(params);

          rows.clear();
          useTransition = true;
          break;

        case 'clearchanges':
          layout.onEventClearChanges(params);
          break;
      }

      me.runWithTransition(() => {
        if (rows.size) {

          rowManager.renderRows(rows);
        } else {

          rowManager.renderFromRow();
        }
      }, useTransition);
    }
  }


  onEventStoreRefresh({
                        action
                      }) {
    if (action === 'batch' && this.rowManager.rowCount) {
      this.currentOrientation.onEventDataset && this.currentOrientation.onEventDataset();

      this.refresh();
    }
  }


  onEventStoreBeforeRemove({
                             records
                           }) {
    const me = this;

    if (me.activeEvent && records.includes(me.activeEvent)) {
      let moveTo;


      if (GlobalEvents.lastInteractionType === 'key') {
        for (let i = 0, l = records.length; i < l && (!moveTo || records.includes(moveTo)); i++) {
          if (me.eventStore.getResourcesForEvent(records[i]).length) {
            const event = records[i],
              from = event.assignments && event.assignments.length ? event.assignments[0] : event;
            moveTo = me.getNext(from, true) || me.getPrevious(from, true);
          }
        }
      }


      if (moveTo) {
        me.navigateTo(moveTo);
      } else {
        DomHelper.focusWithoutScrolling(me.focusElement);
      }
    }
  }


  onEventCommit({
                  changes
                }) {
    let resourcesToRepaint = [...changes.added, ...changes.modified].map(eventRecord => this.eventStore.getResourcesForEvent(eventRecord));

    resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);

    new Set(resourcesToRepaint).forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));
  }


  onEventBeforeCommit({
                        changes
                      }) {


    [...changes.added, ...changes.modified].forEach(eventRecord => this.getElementsFromEventRecord(eventRecord).forEach(element => element.classList.add(this.committingCls)));
  }

  onEventException({
                     action
                   }) {
    if (action === 'commit') {
      const {
        changes
      } = this.eventStore;
      [...changes.added, ...changes.modified, ...changes.removed].forEach(eventRecord => this.repaintEvent(eventRecord));
    }
  }


  onEventClearChanges() {
    this.refresh();
  }


  onAssignmentRefresh(event) {
    if (this.isHorizontal && (event.action === 'dataset' || event.action === 'batch')) {
      this.refresh();
    }
  }


  onAssignmentAdd({
                    records
                  }) {
    if (this.isHorizontal) {
      records.forEach(assignment => {
        const resource = assignment.resource;
        resource && this.repaintEventsForResource(resource);
      });
    }
  }


  onAssignmentUpdate({
                       record,
                       changes
                     }) {
    if (this.isHorizontal) {

      const {
          rowManager
        } = this,
        layoutCache = this.currentOrientation.cache,
        oldResourceId = 'resourceId' in changes && changes.resourceId.oldValue,
        newResourceId = record.resourceId;
      let row,
        fromRow = MAX_VALUE;

      if (oldResourceId != null && (row = rowManager.getRowFor(oldResourceId))) {
        layoutCache.clearRow(oldResourceId);
        fromRow = Math.min(fromRow, row.index);
      }

      if (newResourceId && (row = rowManager.getRowFor(newResourceId))) {
        layoutCache.clearRow(newResourceId);
        fromRow = Math.min(fromRow, row.index);
      }

      if (fromRow !== MAX_VALUE) {
        rowManager.renderFromRow(rowManager.rows[fromRow]);
      }
    }
  }

  onBeforeAssignmentRemove({
                             source,
                             records,
                             doRemoveLastEvent
                           }) {

    if (source.isRemovingEvent) {
      return;
    }

    const me = this,
      events = records.reduce((result, assignment) => {
        const event = assignment.event;

        if (event && !event.placeHolder && !result.includes(event)) {
          result.push(event);
        }

        return result;
      }, []);
    let moveTo;

    if (me.activeEvent && events.includes(me.activeEvent)) {


      if (GlobalEvents.lastInteractionType === 'key') {

        for (let i = 0, l = records.length; i < l && (!moveTo || records.includes(moveTo)); i++) {
          if (me.eventStore.getResourcesForEvent(records[i].event).length) {
            const event = records[i],
              from = event.assignments && event.assignments.length ? event.assignments[0] : event;
            moveTo = me.getNext(from) || me.getPrevious(from);
          }
        }
      }


      if (moveTo) {
        me.navigateTo(moveTo);
      } else {
        DomHelper.focusWithoutScrolling(me.focusElement);
      }
    }

    if (me.removeUnassignedEvent && !me.isRemoving && doRemoveLastEvent !== false && (!source.stm || !source.stm.isRestoring)) {

      const toRemove = events.reduce((result, eventRecord) => {
        let assignmentCount = eventRecord.assignments ? eventRecord.assignments.length : 0;
        assignmentCount -= records.filter(r => r.event === eventRecord).length;

        if (!assignmentCount) {
          result.push(eventRecord);
        }

        return result;
      }, []);

      me.eventStore.remove(toRemove);
    }
  }


  onAssignmentRemove({
                       records
                     }) {
    if (this.isHorizontal) {
      records.forEach(assignment => {
        const resource = assignment.resource;
        resource && this.repaintEventsForResource(resource);
      });
    }
  }


  onAssignmentRemoveAll() {
    if (this.isHorizontal) {
      this.refresh();
    }
  }


  onAssignmentFilter() {
    if (this.isHorizontal) {
      this.refresh();
    }
  }


  applyStartEndParameters({
                            source: eventStore,
                            params
                          }) {
    const me = this,
      dateFormat = eventStore.modelClass.fieldMap.startDate.dateFormat;
    params[me.startParamName] = DateHelper.format(me.startDate, dateFormat);
    params[me.endParamName] = DateHelper.format(me.endDate, dateFormat);
  }


  get widgetClass() {
  }

});


const immediatePromise$6 = new Promise(resolve => resolve()),
  defaultScrollOptions$3 = {
    block: 'nearest',
    edgeOffset: 20
  },
  unrenderedScrollOptions = {
    highlight: false,
    focus: false
  };


var SchedulerScroll = (Target => class SchedulerScroll extends (Target || Base) {


  scrollEventIntoView(eventRec, options = defaultScrollOptions$3) {
    const me = this,
      resources = eventRec.resources || [eventRec];

    if (resources.length > 1) {
      throw new Error('scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.');
    }

    if (!resources.length) {
      console.warn('You have asked to scroll to an event which is not assigned to a resource');
      return immediatePromise$6;
    }

    return me.scrollResourceEventIntoView(resources[0], eventRec, null, options);
  }


  scrollResourceEventIntoView(resourceRec, eventRec, index, options = defaultScrollOptions$3) {
    const me = this,
      eventStart = eventRec.startDate,
      eventEnd = eventRec.endDate,
      eventIsOutside = eventStart < me.timeAxis.startDate | (eventEnd > me.timeAxis.endDate) << 1;
    let el;

    if (options.edgeOffset == null) {
      options.edgeOffset = 20;
    }


    if (eventIsOutside && options.extendTimeAxis !== false) {
      let currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate,
        startAnchorPoint,
        endAnchorPoint;

      if (eventIsOutside === 3) {
        me.timeAxis.setTimeSpan(new Date(eventStart.valueOf() - currentTimeSpanRange / 2), new Date(eventEnd.getTime() + currentTimeSpanRange / 2));
      } else {
        startAnchorPoint = eventIsOutside & 1 ? me.getCoordinateFromDate(eventRec.endDate) : me.getCoordinateFromDate(eventRec.startDate);

        if (eventIsOutside & 1) {
          me.timeAxis.setTimeSpan(new Date(eventStart), new Date(eventStart.valueOf() + currentTimeSpanRange));
        } else {
          me.timeAxis.setTimeSpan(new Date(eventEnd.valueOf() - currentTimeSpanRange), new Date(eventEnd));
        }

        endAnchorPoint = eventIsOutside & 1 ? me.getCoordinateFromDate(eventRec.endDate) : me.getCoordinateFromDate(eventRec.startDate);
        me.timeAxisSubGrid.scrollable.scrollBy(endAnchorPoint - startAnchorPoint);
      }
    }

    el = me.getElementFromEventRecord(eventRec, resourceRec);

    if (el) {

      if (!DomHelper.isFocusable(el)) {
        el = el.parentNode;
      }

      const scroller = me.timeAxisSubGrid.scrollable;


      me.timeAxisSubGrid.forceScrollUpdate = true;

      return scroller.scrollIntoView(el, options);
    } else if (eventIsOutside && options.extendTimeAxis === false) {
      console.warn('You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled');
      return immediatePromise$6;
    } else if (!me.eventStore.isAvailable(eventRec)) {
      console.warn('You have asked to scroll to an event which is not available');
      return immediatePromise$6;
    } else {

      return me.scrollUnrenderedEventIntoView(resourceRec, eventRec, options);
    }
  }


  scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions$3) {


    return new Promise(resolve => {
      const me = this,


        modifiedOptions = Object.assign({
          edgeOffset: 20
        }, options, unrenderedScrollOptions),
        scroller = me.timeAxisSubGrid.scrollable,
        box = me.getResourceEventBox(eventRec, resourceRec),

        scrollerViewport = scroller.viewport;

      if (!scrollerViewport) {
        resolve();
        return;
      }

      const targetRect = new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top).translate(scrollerViewport.x - scroller.x, scrollerViewport.y - scroller.y),
        delta = scroller.getDeltaTo(targetRect, modifiedOptions)[me.isHorizontal ? 'xDelta' : 'yDelta'],
        onEventPaint = ({
                          scheduler,
                          eventRecord,
                          resourceRecord,
                          element,
                          targetElement
                        }) => {
          if (eventRecord === eventRec) {

            const el = element || targetElement;
            detatcher();

            initialScrollPromise.then(() => {


              if (delta > 0) {
                scroller.scrollIntoView(el, {
                  edgeOffset: options.edgeOffset
                });
              }

              options.highlight && DomHelper.highlight(el);
              options.focus && el.focus();
              resolve();
            });
          }
        },

        detatcher = me.on({
          renderEvent: onEventPaint,

          eventrepaint: onEventPaint,
          eventpaint: onEventPaint
        }),
        initialScrollPromise = scroller.scrollIntoView(targetRect, modifiedOptions);
    });
  }


  scrollResourceIntoView(resourceRecord, options = defaultScrollOptions$3) {
    if (this.isVertical) {
      return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);
    } else {
      return this.scrollRowIntoView(resourceRecord, options);
    }
  }


  get widgetClass() {
  }

});


var SchedulerRegions = (Target => class SchedulerRegions extends (Target || Base) {


  getScheduleRegion(resourceRecord, eventRecord, local = true) {
    return this.currentOrientation.getScheduleRegion(resourceRecord, eventRecord, local);
  }


  getResourceRegion(resourceRecord, startDate, endDate) {
    return this.currentOrientation.getRowRegion(resourceRecord, startDate, endDate);
  }


  getResourceEventBox(eventRecord, resourceRecord, includeOutside = false) {

    const me = this,

      cached = me.currentOrientation.getResourceEventBox(eventRecord.id, resourceRecord.id);

    if (cached) {
      return cached;
    }

    const viewStartDate = me.timeAxis.startDate,
      viewEndDate = me.timeAxis.endDate,
      eventStartDate = eventRecord.startDate,
      eventEndDate = eventRecord.endDate;


    let result = null,
      eventLayout,
      rowEventsLayoutData,
      eventRecordData,
      rowElement,
      rowTop,
      eventElements,
      eventElement,
      eventElOffsets,
      eventElBox;


    if (eventStartDate && eventEndDate && (includeOutside || DateHelper.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate)) && this.isRowVisible(resourceRecord)) {
      rowElement = me.getRowFor(resourceRecord);

      if (rowElement) {


        if (me.managedEventSizing) {
          eventLayout = me.currentEventLayout;

          rowEventsLayoutData = me.eventStore.getEventsForResource(resourceRecord).reduce((result, event) => {
            const eventBox = me[me.mode].getTimeSpanRenderData(event, resourceRecord, includeOutside);

            if (eventBox) {
              result.push(eventBox);
            }

            return result;
          }, []);


          eventLayout && eventLayout.applyLayout(rowEventsLayoutData, resourceRecord);

          eventRecordData = rowEventsLayoutData.find(eventData => eventData.event == eventRecord);

          if (eventRecordData) {


            rowTop = me.getRecordCoords(resourceRecord, true).y;

            result = {
              layout: true,
              start: eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right,

              end: (eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right) + eventRecordData.width,
              top: rowTop + eventRecordData.top,
              bottom: rowTop + eventRecordData.top + eventRecordData.height
            };
          }
        } else {
          eventElements = me.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);

          if (eventElements.length) {
            eventElement = eventElements[0];

            eventElOffsets = eventElement.getOffsetsTo(me.getEl());
            eventElBox = eventElement.getBox();
            result = {
              layout: true,
              start: eventElOffsets[0],
              end: eventElOffsets[0] + eventElBox.width,
              top: eventElOffsets[1],
              bottom: eventElOffsets[1] + eventElBox.height
            };
          }
        }
      } else {
        result = {
          layout: false,
          start: me.getCoordinateFromDate(Math.max(eventRecord.startDateMS, me.timeAxis.startMS)),
          end: me.getCoordinateFromDate(Math.min(eventRecord.endDateMS, me.timeAxis.endMS))

        };

        const recordCoords = me.rowManager.getRecordCoords(resourceRecord, true);

        result.top = recordCoords.y + me.barMargin;
        result.height = Math.max(me.rowManager.rowHeight - 2 * me.barMargin, 1);
        result.bottom = result.top + result.height;
      }

      if (result) {
        result = me.adjustItemBox(eventRecord, result);
      }
    }

    return result;
  }


  getItemBox(event, includeOutside = false) {
    return event.resources.map(resource => this.getResourceEventBox(event, resource, includeOutside));
  }


  adjustItemBox(eventRecord, eventRecordBox) {
    const viewStartMS = this.timeAxis.startMS,
      viewEndMS = this.timeAxis.endMS,
      eventStartMS = eventRecord.startDateMS,
      eventEndMS = eventRecord.endDateMS,
      width = this.timeAxisViewModel.totalSize,
      OUTSIDE_VIEW_OFFSET = 40;


    if (viewStartMS > eventStartMS) eventRecordBox.start = -OUTSIDE_VIEW_OFFSET;
    if (viewStartMS > eventEndMS) eventRecordBox.end = -OUTSIDE_VIEW_OFFSET;
    if (viewEndMS < eventStartMS) eventRecordBox.start = width + OUTSIDE_VIEW_OFFSET;
    if (viewEndMS < eventEndMS) eventRecordBox.end = width + OUTSIDE_VIEW_OFFSET;
    return eventRecordBox;
  }


  get widgetClass() {
  }

});


const copyProperties = ['eventLayout', 'barMargin', 'mode', 'tickSize', 'zoomLevel', 'eventColor', 'eventStyle', 'fillTicks', 'startDate', 'endDate'];


var SchedulerState = (Target => class SchedulerState extends (Target || Base) {

  getState() {
    return ObjectHelper.copyProperties(super.getState(), this, copyProperties);
  }


  applyState(state) {
    ObjectHelper.copyProperties(this, state, copyProperties);
    super.applyState(state);
  }


  get widgetClass() {
  }

});


var EventSelection = (Target => class EventSelection extends (Target || Base) {

  static get defaultConfig() {
    return {

      multiEventSelect: false,


      eventSelectionDisabled: false,


      eventSelectedCls: 'b-sch-event-selected',


      triggerSelectionChangeOnRemove: false,


      maintainSelectionOnDatasetChange: true,


      eventAssignHighlightCls: 'b-sch-event-assign-selected',


      selectedCollection: {}
    };
  }


  afterConstruct() {
    super.afterConstruct();
    this.navigator.on({
      navigate: 'onEventNavigate',
      thisObj: this
    });
  }


  set selectedCollection(selectedCollection) {
    if (!(selectedCollection instanceof Collection)) {
      selectedCollection = new Collection(selectedCollection);
    }

    this._selectedCollection = selectedCollection;

    selectedCollection.on({
      change: 'onSelectedCollectionChange',
      thisObj: this
    });
  }

  get selectedCollection() {
    return this._selectedCollection;
  }


  get selectedEvents() {
    return this.selectedCollection.values;
  }

  set selectedEvents(events) {

    this.selectedCollection.splice(0, this.selectedCollection.count, events || []);
  }


  isEventSelected(event) {
    return this.selectedCollection.includes(event);
  }


  selectEvent(event, preserveSelection = false) {


    if (!this.isEventSelected(event)) {
      preserveSelection ? this.selectedCollection.add(event) : this.selectedEvents = event;
    }
  }


  deselectEvent(event, preserveSelection = false) {
    if (this.isEventSelected(event)) {
      this.selectedCollection.remove(event);
    }
  }


  selectEvents(events) {
    this.selectedCollection.add(events);
  }


  deselectEvents(events) {
    this.selectedCollection.remove(events);
  }


  clearEventSelection() {
    this.selectedEvents = [];
  }


  onSelectedCollectionChange({
                               added,
                               removed
                             }) {
    const me = this,
      selection = me.selectedEvents,
      selected = added || [],
      deselected = removed || [];

    function updateSelection(record, select) {
      const resourceRecord = record.isTask ? record : record.resource,
        eventRecord = record.isAssignment ? record.event : record;

      if (eventRecord) {
        const element = me.getElementFromEventRecord(eventRecord, resourceRecord);
        me.currentOrientation.toggleCls(eventRecord, resourceRecord, me.eventSelectedCls, select);

        if (record.isAssignment) {
          me.getElementsFromEventRecord(eventRecord).forEach(el => {
            if (el !== element) {
              el.classList[select ? 'add' : 'remove'](me.eventAssignHighlightCls);
            }
          });
        }
      }
    }

    selected.forEach(record => updateSelection(record, true));
    deselected.forEach(record => updateSelection(record, false));

    if (!me.silent) {
      me.trigger('eventSelectionChange', {
        action: selection.length > 0 ? selected.length > 0 && deselected.length > 0 ? 'update' : selected.length > 0 ? 'select' : 'deselect' : 'clear',
        selection,
        selected,
        deselected
      });
    }
  }


  onInternalEventStoreChange({
                               action,
                               records: events,
                               source: eventStore
                             }) {
    super.onInternalEventStoreChange(...arguments);
    const me = this;
    me.silent = !me.triggerSelectionChangeOnRemove;

    if (action === 'remove') {
      me.deselectEvents(events);
    } else if (action === 'dataset') {
      if (!me.maintainSelectionOnDatasetChange) {
        me.clearEventSelection();
      } else {
        me.selectedEvents = me.selectedEvents.filter(event => eventStore.includes(event));
      }
    }

    me.silent = false;
  }


  onAssignmentRemove({
                       records: assignments
                     }) {
    super.onAssignmentRemove(...arguments);
    const me = this;
    me.silent = !me.triggerSelectionChangeOnRemove;
    me.deselectEvents(assignments);
    me.silent = false;
  }


  onEventSelectionClick(event, clickedRecord) {
    const me = this;


    if (me.isEventSelected(clickedRecord)) {
      event.ctrlKey && me.deselectEvent(clickedRecord, me.multiEventSelect);
    } else {
      me.selectEvent(clickedRecord, event.ctrlKey && me.multiEventSelect);
    }
  }


  onEventNavigate({
                    event,
                    item
                  }) {
    if (!this.eventSelectionDisabled) {
      const me = this,
        record = item && (item.nodeType === 1 ? me.assignmentStore ? me.resolveAssignmentRecord(item) : me.resolveEventRecord(item) : item);

      if (record) {
        me.onEventSelectionClick(event, record);
      } else {
        me.clearEventSelection();
      }
    }
  }


  get widgetClass() {
  }

});


const sortByStartDate = (l, r) => l.startDate - r.startDate,
  preventDefault = e => e.preventDefault();


var EventNavigation = (Target => class EventNavigation extends Delayable(Target || Base) {

  static get defaultConfig() {
    return {

      navigator: null,


      focusCls: 'b-active',


      enableDeleteKey: true,

      onDeleteKeyBuffer: 500,
      navigatePreviousBuffer: 200,
      navigateNextBuffer: 200,
      testConfig: {
        onDeleteKeyBuffer: 1
      }
    };
  }


  construct(config) {
    const me = this;
    me.isInTimeAxis = me.isInTimeAxis.bind(me);
    super.construct(config);
    const onDeleteKey = me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me),
      navigatorConfig = ObjectHelper.merge({
        ownerCmp: me,
        target: me.timeAxisSubGridElement,
        processEvent: me.processEvent,
        itemSelector: `.${me.eventCls}-wrap`,
        focusCls: me.focusCls,
        navigatePrevious: me.throttle(me.navigatePrevious, me.navigatePreviousBuffer, me, null, preventDefault),
        navigateNext: me.throttle(me.navigateNext, me.navigateNextBuffer, me, null, preventDefault),
        allowCtrlKey: true,
        scrollSilently: true,
        keys: {
          Space: 'onEventSpaceKey',
          Enter: 'onEventEnterKey',
          Delete: onDeleteKey,
          Backspace: onDeleteKey
        }
      }, me.navigator);
    me.navigator = new Navigator(navigatorConfig);
  }

  doDestroy() {
    this.navigator.destroy();
    super.doDestroy();
  }

  isInTimeAxis(record) {


    return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);
  }


  accessibleFocusCell(cellSelector, options) {
    const me = this;
    cellSelector = me.normalizeCellContext(cellSelector);

    if (cellSelector.columnId === me.timeAxisColumn.id) ; else {
      return super.focusCell(cellSelector, options);
    }
  }

  getPrevious(eventOrAssignmentRecord, isDelete) {
    const me = this,
      resourceStore = me.resourceStore,
      isAssignment = eventOrAssignmentRecord.isAssignment;

    if (eventOrAssignmentRecord.isTask) {
      return me.eventStore.getAt(me.eventStore.indexOf(eventOrAssignmentRecord) - 1);
    }

    let resourceRecord = eventOrAssignmentRecord.resource || me.eventStore.getResourcesForEvent(eventOrAssignmentRecord)[0],
      resourceEvents = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate),
      eventRecord = isAssignment ? eventOrAssignmentRecord.event : eventOrAssignmentRecord,
      previousEvent = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];

    if (!previousEvent) {


      for (let rowIdx = resourceStore.indexOf(resourceRecord) - 1; (!previousEvent || isDelete && previousEvent === eventRecord) && rowIdx >= 0; rowIdx--) {
        resourceRecord = resourceStore.getAt(rowIdx);
        let events = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate);
        previousEvent = events.length && events[events.length - 1];
      }
    }

    return isAssignment ? me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord) : previousEvent;
  }

  navigatePrevious(keyEvent) {
    const me = this,
      previousEvent = me.getPrevious(keyEvent.assignmentRecord || keyEvent.eventRecord);
    keyEvent.preventDefault();

    if (previousEvent) {
      if (!keyEvent.ctrlKey) {
        me.clearEventSelection();
      }

      me.navigateTo(previousEvent, keyEvent);
    }
  }

  getNext(eventOrAssignmentRecord, isDelete) {
    const me = this,
      resourceStore = me.resourceStore,
      isAssignment = eventOrAssignmentRecord.isAssignment;

    if (eventOrAssignmentRecord.isTask) {
      return me.eventStore.getAt(me.eventStore.indexOf(eventOrAssignmentRecord) + 1);
    }

    let resourceRecord = isAssignment ? eventOrAssignmentRecord.resource : eventOrAssignmentRecord.resources[0],

      resourceEvents = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate),
      eventRecord = isAssignment ? eventOrAssignmentRecord.event : eventOrAssignmentRecord,
      nextEvent = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];

    if (!nextEvent) {


      for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || isDelete && nextEvent === eventRecord) && rowIdx < resourceStore.count; rowIdx++) {
        resourceRecord = resourceStore.getAt(rowIdx);
        nextEvent = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate)[0];
      }
    }

    return isAssignment ? me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord) : nextEvent;
  }

  navigateNext(keyEvent) {
    const me = this,
      nextEvent = me.getNext(keyEvent.assignmentRecord || keyEvent.eventRecord);
    keyEvent.preventDefault();

    if (nextEvent) {
      if (!keyEvent.ctrlKey) {
        me.clearEventSelection();
      }

      me.navigateTo(nextEvent, keyEvent);
    }
  }

  navigateTo(targetEvent, uiEvent = {}) {
    const me = this;

    if (targetEvent) {

      me.navigator.disabled = true;
      const resource = targetEvent.resource;
      me.scrollResourceEventIntoView(resource, targetEvent.isAssignment ? targetEvent.event : targetEvent, null, {
        animate: 100
      }).then(() => {

        if (!me.isDestroyed) {
          me.navigator.disabled = false;
          me.activeEvent = targetEvent;
          me.navigator.trigger('navigate', {
            event: uiEvent,
            item: DomHelper.up(me.getElementFromEventRecord(targetEvent, resource), me.navigator.itemSelector)
          });
        }
      });
    }
  }

  set activeEvent(eventOrAssignmentRec) {
    const eventEl = this.getElementFromEventRecord(eventOrAssignmentRec.isAssignment ? eventOrAssignmentRec.event : eventOrAssignmentRec, eventOrAssignmentRec.resource);
    this.navigator.activeItem = eventEl.parentNode;
  }

  get activeEvent() {
    const {
      activeItem
    } = this.navigator;

    if (activeItem) {
      return this.resolveEventRecord(activeItem);
    }
  }

  get previousActiveEvent() {
    const {
      previousActiveItem
    } = this.navigator;

    if (previousActiveItem) {
      return this.resolveEventRecord(previousActiveItem);
    }
  }

  processEvent(keyEvent) {
    const me = this,
      eventElement = DomHelper.up(keyEvent.target, me.eventSelector);

    if (!me.navigator.disabled && eventElement) {
      keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);
      keyEvent.eventRecord = me.resolveEventRecord(eventElement);
      keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);
    }

    return keyEvent;
  }

  onDeleteKey(keyEvent) {
    const record = keyEvent.assignmentRecord || keyEvent.eventRecord;

    if (!this.readOnly && this.enableDeleteKey && record) {
      this.removeRecords([record]);
    }
  }


  removeRecords(eventRecords, callback = null) {
    if (!this.readOnly && eventRecords.length) {
      const context = {
        finalize(removeRecord = true) {
          if (callback) {
            callback(removeRecord);
          }

          if (removeRecord !== false) {
            eventRecords.forEach(r => r.remove());
          }
        }

      };


      if (this.trigger('beforeEventDelete', {
        eventRecords,
        context
      }) !== false) {
        context.finalize();
        return true;
      }
    }

    return false;
  }

  onEventSpaceKey(keyEvent) {
  }

  onEventEnterKey(keyEvent) {
  }

  get isActionableLocation() {


    if (!this.navigator.activeItem) {
      return super.isActionableLocation;
    }
  }


  get widgetClass() {
  }

});


const emptyObject$3 = {},
  elRange = document.createRange(),
  MAX_WIDTH = 9999999;

function isEventElAvailable(element) {
  return !(element.classList.contains('b-dragging') || element.classList.contains('b-resizing'));
}


class BaseHorizontalMapper extends Delayable(Base) {

  construct(view) {
    const me = this;
    me.view = view;
    me.innerElCls = `${view.eventCls}`;
    me.availableDivs = new Bag();
    me.reservedIds = {};
    me.divCount = 0;
  }

  init() {
    const me = this;
    me.view.rowManager.on({
      beforetranslaterow: me.onBeforeTranslateRow,
      translaterow: me.onTranslateRow,
      beforerowheight: me.onBeforeRowHeightChange,
      thisObj: me
    });
    me.view.on({
      beforetogglenode: me.onBeforeToggleNode,
      beforetoggleallnodes: me.onBeforeToggleAllNodes,
      thisObj: me
    });
  }


  get column() {
    return this.view.timeAxisColumn;
  }

  get timeAxis() {
    return this.view.timeAxis;
  }

  get timeAxisViewModel() {
    return this.view.timeAxisViewModel;
  }

  translateToPageCoordinate(x) {
    const element = this.column.subGridElement;
    return x + element.getBoundingClientRect().left - element.scrollLeft;
  }


  refreshRows(reLayoutEvents) {
    if (reLayoutEvents) {
      this.cache.clear(this.refreshFromRerender);
      this.view.refreshFromRerender = false;
    }
  }


  onDragAbort(context) {
    if (this.view.currentOrientation.availableDivs.includes(context.element)) {
      context.element.classList.add('b-sch-released');
    }
  }

  onLocaleChange() {

    this.cache.clear();
  }


  calculateMS(timespanRecord) {
    throw new Error('Implement in subclass');
  }


  getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {
    const me = this,
      {
        timeAxis
      } = me,
      includeOutsideTimeAxis = includeOutside === true || includeOutside.timeAxis,
      includeOutsideViewport = includeOutside === true || includeOutside.viewport;


    if (includeOutsideTimeAxis || timeAxis.isTimeSpanInAxis(timeSpan)) {
      const view = me.view,
        row = view.getRowById(rowRecord);

      if (row || includeOutsideViewport) {

        const scrollTop = view.scrollable.y,
          viewportTop = Math.max(scrollTop - 50, 0),
          viewportBottom = Math.min(scrollTop + view._bodyRectangle.height + 50, view.virtualScrollHeight);


        if (includeOutsideViewport || row.top < viewportBottom && row.top + (row.height || row.lastHeight) >= viewportTop) {
          const pxPerMinute = me.timeAxisViewModel.getSingleUnitInPixels('minute'),
            timespanStart = timeSpan.startDate,
            timespanEnd = timeSpan.endDate || timespanStart,

            viewStartMS = timeAxis.startMS,
            viewEndMS = timeAxis.endMS,
            {
              startMS,
              endMS,
              durationMS
            } = me.calculateMS(timeSpan),


            startsOutsideView = startMS < viewStartMS | (startMS > viewEndMS) << 1,


            endsOutsideView = endMS > viewEndMS | (endMS <= viewStartMS) << 1,
            durationMinutes = durationMS / (1000 * 60),
            width = endsOutsideView ? pxPerMinute * durationMinutes : null;

          let endX = view.getCoordinateFromDate(endMS, {
              local: true,
              respectExclusion: true,
              isEnd: true
            }),
            startX,
            clippedStart = false,
            clippedEnd = false;

          if (startsOutsideView) {
            startX = (startMS - viewStartMS) / (1000 * 60) * pxPerMinute;
          } else {

            startX = view.getCoordinateFromDate(startMS, {
              local: true,
              respectExclusion: true,
              isEnd: false,
              snapToNextIncluded: endX !== -1
            });
            clippedStart = startX === -1;
          }

          if (endsOutsideView) {
            endX = startX + width;
          } else {
            clippedEnd = endX === -1;
          }

          if (clippedEnd && !clippedStart) {


            endX = view.getCoordinateFromDate(endMS, {
              local: true,
              respectExclusion: true,
              isEnd: true,
              snapToNextIncluded: true
            });
          }


          if (width > MAX_WIDTH) {

            if (startsOutsideView === 1) {

              if (endsOutsideView === 1) {
                startX = -100;
                endX = view.timeAxisColumn.width + 100;
              } else {
                startX = endX - MAX_WIDTH;
              }
            } else if (endsOutsideView === 1) {
              endX = startX + MAX_WIDTH;
            }
          }

          if (clippedStart && clippedEnd) {

            startX = view.getCoordinateFromDate(startMS, {
              local: true,
              respectExclusion: true,
              isEnd: false,
              snapToNextIncluded: true,
              max: endMS
            });
            endX = view.getCoordinateFromDate(endMS, {
              local: true,
              respectExclusion: true,
              isEnd: true,
              snapToNextIncluded: true,
              min: startMS
            });

            if (startX === endX) {

              timeSpan.instanceMeta(view).excluded = true;

              return null;
            }
          }

          const data = {
            [me.view.scheduledEventName]: timeSpan,
            left: Math.min(startX, endX),
            width: Math.abs(endX - startX),
            start: timespanStart,
            end: timespanEnd,
            startMs: startMS,
            endMs: endMS,
            rowId: rowRecord.id,
            startsOutsideView,
            endsOutsideView,
            clippedStart,
            clippedEnd,
            row
          };

          if (me.view.fillTicks) {
            data.dataStartMs = data.start.getTime();
            data.dataEndMs = data.end.getTime();
          }

          data.top = Math.max(0, view.resourceMargin);

          if (view.managedEventSizing) {

            data.height = Math.max(view.rowManager.rowHeight - 2 * view.resourceMargin, 1);
          }

          return data;
        }
      }
    }
  }

  onTranslateRow({
                   source: row
                 }) {
  }

  onBeforeRowHeightChange(event) {
    const view = this.view,
      newHeight = event ? event.height : view.rowHeight;
    this.cache.clear();

    if (view.foregroundCanvas) {
      view.element.classList.add('b-notransition');
      view.foregroundCanvas.style.fontSize = `${newHeight - view.resourceMargin * 2}px`;


      this._thisIsAUsedExpression(window.getComputedStyle(view.foregroundCanvas).fontSize);

      view.element.classList.remove('b-notransition');
    }

    view.milestoneWidth = null;
  }

  onBeforeTranslateRow({
                         row
                       }) {


    this.cache.clearRow(row.id);
  }

  onViewportResize() {

    this.lastUpdateScrollPos = null;

    this.update();
  }


  positionTimeSpan(el, x, y) {
    const mode = this.view.eventPositionMode || 'translate';

    switch (mode) {
      case 'position':
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        return;

      case 'translate':
        el.style.transform = `translate(${x}px,${y}px)`;
        return;

      case 'translate3d':
        el.style.transform = `translate3d(${x}px,${y}px,0)`;
    }
  }

  getTimeSpanDiv(timeSpanData) {
    const me = this,
      {
        availableDivs
      } = me,
      {
        id,
        oldId
      } = timeSpanData;

    if (me.view.eventScrollMode === 'move') {
      let wrapperElement;


      if (id) {
        wrapperElement = availableDivs.get(id) || availableDivs.get(oldId);
      }

      if (wrapperElement && !isEventElAvailable(wrapperElement)) {
        wrapperElement = null;
      }


      if (!wrapperElement) {
        wrapperElement = availableDivs.find(isEventElAvailable);
      }

      if (wrapperElement) {
        availableDivs.remove(wrapperElement);
        wrapperElement.classList.remove('b-sch-released');
      }

      return wrapperElement;
    }

    return null;
  }

  releaseTimeSpanDiv(div, remainVisible = false) {
    const me = this,
      divStyle = div.style;


    if (!remainVisible && div === document.activeElement) {
      me.view.focusElement.focus();
    }

    if (me.view.eventScrollMode === 'move') {
      me.availableDivs.add(div);

      if (!remainVisible && isEventElAvailable(div)) {
        div.classList.add('b-sch-released');
      }
    } else {
      if (!remainVisible) {
        divStyle.opacity = 0;
        divStyle.pointerEvents = 'none';
        me.setTimeout(() => {
          div.remove();
          divStyle.opacity = 1;
          divStyle.pointerEvents = '';
        }, 200);
      }
    }
  }

  updateElementId(element, newId) {
    const {
      availableDivs
    } = this;


    if (availableDivs.includes(element)) {
      availableDivs.changeId(element, newId);

      availableDivs.items.delete(element);
      availableDivs.items.add(element);
    }
  }

  triggerPaint(data, element) {
    throw new Error('Implement in subclass');
  }


  addTemporaryDragElement(eventRecord) {
    const {
        scheduler
      } = this,
      tplData = scheduler.generateTplData(eventRecord, eventRecord.resource, {
        timeAxis: true,
        viewport: true
      });
    tplData.top = tplData.row ? tplData.top + tplData.row.top : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;
    const result = this.renderTimeSpan(tplData, {}, null, true);

    this.scheduler.currentOrientation.availableDivs.add(result);
    return result;
  }


  renderTimeSpan(data, cache, renderedTimeSpan, forceNewElement = false) {
    const me = this,
      view = me.view,
      {
        cls,
        id
      } = data;
    let wrapperElement = cache && cache.div,
      changedDiv = false,
      trigger = false,
      isRepaint = false,
      innerElement;


    if (!forceNewElement && !wrapperElement && (wrapperElement = me.getTimeSpanDiv(data))) {

      changedDiv = wrapperElement.id !== id;
    }

    const isDragCreateProxy = wrapperElement && wrapperElement.classList.contains('b-sch-dragcreator-proxy');

    if (!wrapperElement || changedDiv) {


      if (changedDiv) {


        innerElement = wrapperElement.innerElement || wrapperElement.firstElementChild;
        innerElement.innerHTML = '';
        innerElement.style.cssText = '';

        if (innerElement.nextSibling) {
          elRange.setStartAfter(innerElement);
          elRange.setEndAfter(wrapperElement.lastChild);
          elRange.deleteContents();
        }
      } else {
        [wrapperElement, innerElement] = DomHelper.createElement({
          tabIndex: 0,

          children: [{
            className: `${me.innerElCls}`
          }]
        }, true);

        wrapperElement.innerElement = innerElement;
      }

      wrapperElement.id = id;

      if (data[view.scheduledEventName + 'Id']) {
        wrapperElement.dataset[view.scheduledEventName + 'Id'] = data[view.scheduledEventName + 'Id'];
      }

      DomHelper.syncClassList(wrapperElement, data.wrapperCls);

      if (wrapperElement.parentNode !== view.foregroundCanvas) {
        view.foregroundCanvas.appendChild(wrapperElement);
      }

      DomHelper.syncClassList(innerElement, cls);

      if (data.style || data.internalStyle) {
        innerElement.style.cssText = (data.internalStyle || '') + (data.style || '');
      }

      if (data.body) {

        innerElement.appendChild(data.body.cloneNode(true));
      }

      wrapperElement.style.cssText = `width:${data.width}px;height:${data.height}px;${data.wrapperStyle || ''}`;
      me.positionTimeSpan(wrapperElement, data.left, data.top);
      trigger = true;
    } else {

      const old = renderedTimeSpan && cache.div ? renderedTimeSpan : emptyObject$3;
      innerElement = wrapperElement.querySelector(`.${me.innerElCls}`) || wrapperElement.firstElementChild;


      DomHelper.syncClassList(wrapperElement, data.wrapperCls);
      DomHelper.syncClassList(innerElement, data.cls);

      if (data.style) {
        innerElement.style.cssText = data.style;
      } else {
        innerElement.style.cssText = '';
      }

      if (data.body) {
        const oldInnerHTML = innerElement.innerHTML,

          featureEls = innerElement.featureEls;

        if (featureEls) {
          featureEls.forEach(featureEl => data.body.appendChild(featureEl));
        }

        innerElement.innerHTML = '';

        innerElement.appendChild(data.body.cloneNode(true));

        trigger = innerElement.innerHTML !== oldInnerHTML;
      }

      if (document.activeElement && document.activeElement.id === data.id) {
        wrapperElement.classList.add(view.focusCls);
      }

      isRepaint = true;

      if (data.wrapperStyle) {
        wrapperElement.style.cssText += data.wrapperStyle;
      }

      if (old.left !== data.left || old.top !== data.top || data.style) {
        me.positionTimeSpan(wrapperElement, data.left, data.top);
        trigger = true;
      }

      if (old.width !== data.width || data.style) {
        wrapperElement.style.width = `${data.width}px`;
        trigger = true;
      }

      if (old.height !== data.height || data.style) {
        wrapperElement.style.height = `${data.height}px`;
        trigger = true;
      }
    }

    cache.div = wrapperElement;
    cache.eventEl = innerElement;

    if (trigger) {

      if (isRepaint && isDragCreateProxy) {
        isRepaint = false;
        wrapperElement.classList.remove('b-sch-dragcreator-proxy');
      }

      me.triggerPaint(data, wrapperElement, isRepaint);
    }

    return wrapperElement;
  }


  cacheTimeSpanElement(timeSpanRecord, resourceRecord, element) {
    const me = this,
      {
        availableDivs,
        view
      } = me,
      timeSpanRecordId = view.getEventRenderId(timeSpanRecord, resourceRecord);

    if (!availableDivs.includes(timeSpanRecordId)) {
      if (element) {
        element.id = timeSpanRecordId;
        view.foregroundCanvas.appendChild(element);
      } else {
        element = DomHelper.createElement({
          id: timeSpanRecordId,
          tabIndex: 0,

          children: [{
            className: `${me.innerElCls}`
          }]
        });
      }

      availableDivs.add(element);
    }
  }

  updateRowTimeSpans(row, rowRecord, forceLayout = false, fromHorizontalScroll = false) {
  }

  renderer(renderData) {
  }

  updateFromHorizontalScroll(scrollLeft) {
    const scrollBuffer = 100,
      me = this,
      view = me.view,
      width = view.timeAxisSubGrid.width,
      startDate = view.getDateFromX(Math.max(0, scrollLeft - scrollBuffer)),
      endDate = view.getDateFromX(scrollLeft + width + scrollBuffer) || view.timeAxis.endDate,
      x = me.view.timeAxisSubGrid.scrollable.x,
      lastUpdateScrollPos = me.lastUpdateScrollPos;

    me.viewportStart = startDate && startDate.getTime();
    me.viewportEnd = endDate && endDate.getTime();


    if (!lastUpdateScrollPos || Math.abs(x - lastUpdateScrollPos.x) > scrollBuffer / 2) {
      me.update();
    }

    view.timeView.range = {
      startDate,
      endDate
    };
  }

  update() {
    const me = this,
      view = me.view;
    me.lastUpdateScrollPos = {
      x: view.timeAxisSubGrid.scrollable.x,
      y: view.scrollable.y
    };

    for (const row of view.rowManager) {
      const cell = row.getCell(view.timeAxisColumn.id),
        cellData = DomDataStore.get(cell),
        record = view.store.getById(cellData.id);

      if (record) {
        me.updateRowTimeSpans(cellData.row, record, false, true);
      }
    }
  }


  getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {
    let coord = xy[0];

    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }

    return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);
  }

  translateToScheduleCoordinate(x) {
    const pos = x - this.column.subGridElement.getBoundingClientRect().left;
    return pos + this.view.scrollLeft;
  }


  onBeforeToggleNode({
                       record
                     }) {
    const me = this,
      childCount = record.children && record.children.length;


    if (childCount) {


      let currentRowRecord = me.view.store.getNext(record);

      while (currentRowRecord && me.view.getRowFor(currentRowRecord)) {
        me.cache.clearRow(currentRowRecord.id);
        currentRowRecord = me.view.store.getNext(currentRowRecord.id);
      }
    }
  }

  onBeforeToggleAllNodes() {
    this.cache.clear();
  }

  onRowRecordUpdate({
                      record,
                      changes = {}
                    }) {


    if ('id' in changes) {
      this.cache.clearRow(changes.id.oldValue, false, true);
    }

    this.cache.clearRow(record.id, false, true);
  }

  onRowRecordRemove({
                      records
                    }) {


    records.forEach(record => record.traverse(r => this.cache.clearRow(r.id)));
  }


  getRowRegion(rowRecord, startDate, endDate) {
    const {
        view,
        column
      } = this,
      row = view.getRowById(rowRecord.id);

    if (!row) {
      return null;
    }

    const rowElement = row.getElement(column.region),
      taStart = this.timeAxis.startDate,
      taEnd = this.timeAxis.endDate,
      start = startDate ? DateHelper.max(taStart, startDate) : taStart,
      end = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
      startX = view.getCoordinateFromDate(start),
      endX = view.getCoordinateFromDate(end, true, true),
      y = row.top + view.verticalScroller.scrollTop,
      x = Math.min(startX, endX),
      bottom = y + rowElement.offsetHeight;
    return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);
  }

  getVisibleDateRange() {
    const view = this.view,
      scrollPos = view.timeAxisSubGrid.scrollable.x,
      width = view.timeAxisSubGrid.width;
    return {
      startDate: view.getDateFromX(scrollPos),
      endDate: view.getDateFromX(scrollPos + width) || view.timeAxis.endDate
    };
  }


  getConnectorStartSide(eventRecord) {
  }


  getConnectorEndSide(eventRecord) {
  }

}

BaseHorizontalMapper._$name = 'BaseHorizontalMapper';

class HorizontalEventMapperCache {
  constructor(mapper) {
    const me = this;
    me.mapper = mapper;

    me.renderedEventsMap = {};
    me.rowLayoutCache = {};
  }


  clear(removeDivs = false) {
    const me = this;
    me.renderedEventsMap = {};
    Object.keys(me.rowLayoutCache).forEach(resourceId => me.clearRow(resourceId, removeDivs ? 'immediate' : false));
  }

  addRenderedEvents(resourceId, data) {
    this.renderedEventsMap[resourceId] = data;
  }

  addRenderedEvent(eventData) {


    if (eventData.resourceId in this.renderedEventsMap) {
      const resourceRenderedEvents = this.renderedEventsMap[eventData.resourceId] || (this.renderedEventsMap[eventData.resourceId] = {});
      resourceRenderedEvents[eventData.id] = eventData;
    }
  }

  getRenderedTimeSpan(resourceId, eventElementId) {
    const resourceRenderedEvents = this.renderedEventsMap[resourceId];
    return resourceRenderedEvents && resourceRenderedEvents[eventElementId];
  }

  clearRenderedTimeSpan(resourceId, eventElementId) {
    const resourceRenderedEvents = this.renderedEventsMap[resourceId];

    if (resourceRenderedEvents) {
      const result = this.renderedEventsMap[resourceId][eventElementId];
      delete this.renderedEventsMap[resourceId][eventElementId];
      return result;
    }
  }

  getRenderedEvents(resourceId) {
    return this.renderedEventsMap[resourceId];
  }

  clearRenderedEvents(resourceId) {
    this.renderedEventsMap[resourceId] = null;
  }


  getTimeSpan(timeSpanId, rowId) {
    const timeSpanCache = this.getTimeSpanCache(timeSpanId, rowId);
    if (!timeSpanCache) return null;
    return timeSpanCache.layoutCache;
  }

  getTimeSpanCache(timeSpanId, rowId) {
    const resourceCache = this.rowLayoutCache[rowId];
    return resourceCache && resourceCache[timeSpanId];
  }


  clearEvent(eventId, resourceId, removeDiv = false, remainVisible = false) {
    const me = this,
      eventCache = me.getTimeSpan(eventId, resourceId);
    if (!eventCache) return null;

    if (eventCache.div) {
      me.mapper.clearDiv(eventCache.div, removeDiv, remainVisible);
    }

    me.rowLayoutCache[resourceId][eventId].layoutCache = null;
  }


  getRow(resourceId) {
    return this.rowLayoutCache[resourceId];
  }

  addRow(resourceId, data) {
    this.rowLayoutCache[resourceId] = data;
  }

  clearRow(resourceId, removeDivs = false, remainVisible = false) {
    const me = this,
      resourceCache = me.rowLayoutCache[resourceId];
    if (!resourceCache) return;
    if (me.renderedEventsMap[resourceId]) delete me.renderedEventsMap[resourceId];
    Object.keys(resourceCache).forEach(eventId => {
      if (eventId !== '_allEvents' && eventId !== '_rowHeight') {
        me.clearEvent(eventId, resourceId, removeDivs, remainVisible);
      }
    });
    delete me.rowLayoutCache[resourceId];
  }

}

HorizontalEventMapperCache._$name = 'HorizontalEventMapperCache';


const getStartEnd = (view, timeAxis, date, dateMS, useEnd) => {
    if (view.fillTicks) {
      let tick = timeAxis.getTickFromDate(date);

      if (tick >= 0) {

        if (useEnd && tick === Math.round(tick) && tick > 0) {
          tick--;
        }

        const tickIndex = Math.floor(tick),
          tickRecord = timeAxis.getAt(tickIndex);
        return tickRecord[useEnd ? 'endDate' : 'startDate'].getTime();
      }
    }

    return dateMS;
  },
  heightEventSorter = ({
                         startDateMS: lhs
                       }, {
                         startDateMS: rhs
                       }) => lhs - rhs;


class HorizontalEventMapper extends BaseHorizontalMapper {

  construct(scheduler) {
    this.scheduler = scheduler;
    super.construct(scheduler);
    this.cache = new HorizontalEventMapperCache(this);
  }

  init() {
    const me = this;
    super.init();
    this.scheduler.on({
      togglegroup: me.onToggleGroup,
      rowremove: me.onRowRemove,
      prio: 2,
      thisObj: me
    });
  }


  clearDiv(div, remove, remainVisible) {
    const me = this,
      divStyle = div.style;

    if (!remove || remainVisible) {
      me.releaseTimeSpanDiv(div, remainVisible);
    } else if (remove === 'immediate' || !me.scheduler.enableEventAnimations) {
      div.remove();
    } else {


      div.id = IdHelper.generateId('obsolete-event');
      divStyle.opacity = 0;
      divStyle.pointerEvents = 'none';
      me.setTimeout(() => {
        div.remove();
        divStyle.opacity = 1;
        divStyle.pointerEvents = '';
      }, 200);
    }
  }

  clearAllDivs() {
    const me = this;
    me.availableDivs.forEach(div => div.remove());
    me.availableDivs.clear();
  }

  clearEvents() {
    this.cache.clear(true);
  }


  releaseEvent(rowId, timeSpanElementId, remainVisible = false) {
    const me = this,
      timeSpanData = me.cache.getRenderedTimeSpan(rowId, timeSpanElementId),
      cache = timeSpanData && me.cache.getTimeSpan(timeSpanData.eventId, rowId);

    if (cache && cache.div) {

      me.releaseTimeSpanDiv(cache.div, remainVisible);
      cache.div = cache.eventEl = null;
    }

    return me.cache.clearRenderedTimeSpan(rowId, timeSpanElementId);
  }


  getElementFromEventRecord(eventRecord, resourceRecord = this.scheduler.eventStore.getResourcesForEvent(eventRecord)[0]) {
    if (resourceRecord) {
      const renderedRowEvents = this.cache.getRenderedEvents(resourceRecord.id);

      if (renderedRowEvents) {
        const layoutId = this.scheduler.getEventRenderId(eventRecord, resourceRecord),
          layout = renderedRowEvents[layoutId],
          layoutCache = layout && layout.layoutCache;
        return layoutCache && layoutCache.eventEl;
      }
    }
  }

  getElementsFromEventRecord(eventRecord, resourceRecord) {
    const me = this;

    if (resourceRecord) {
      return [me.getElementFromEventRecord(eventRecord, resourceRecord)];
    } else {
      return me.scheduler.eventStore.getResourcesForEvent(eventRecord).reduce((result, resourceRecord) => {
        const el = me.getElementFromEventRecord(eventRecord, resourceRecord);

        if (el) {
          result.push(el);
        }

        return result;
      }, []);
    }
  }

  resolveRowRecord(elementOrEvent) {
    const me = this,
      {
        view
      } = me,
      element = elementOrEvent instanceof Event ? elementOrEvent.target : elementOrEvent,

      el = element.nodeType === 3 ? element.parentElement : element,
      eventNode = el.matches(view.eventSelector) && el || DomHelper.up(el, view.eventSelector);

    if (eventNode) {
      return view.getResourceRecordFromDomId(eventNode.id);
    }

    return view.getRecordFromElement(el);
  }

  toggleCls(eventRecord, resourceRecord, cls, add = true) {
    if (!resourceRecord) {
      return;
    }

    const eventLayout = this.cache.getTimeSpanCache(eventRecord.id, resourceRecord.id),
      element = this.getElementFromEventRecord(eventRecord, resourceRecord);

    if (eventLayout) {
      eventLayout.cls[cls] = add ? 1 : 0;
    }

    if (element) {
      element.classList[add ? 'add' : 'remove'](cls);
    }
  }


  getResourceEventBox(eventId, resourceId) {
    const cached = this.cache.getTimeSpan(eventId, resourceId);

    if (cached) {
      return cached;
    }
  }


  getScheduleRegion(rowRecord, eventRecord, local = true) {
    const me = this,
      view = me.view,
      column = me.column;
    let region;

    if (rowRecord) {
      const eventElement = eventRecord && me.getElementsFromEventRecord(eventRecord, rowRecord)[0];
      region = Rectangle.from(view.getRowById(rowRecord.id).getElement('locked'));

      if (eventElement) {
        const eventRegion = Rectangle.from(eventElement, column.subGridElement);
        region.y = eventRegion.y;
        region.bottom = eventRegion.bottom;
      } else {
        region.y = region.y + view.resourceMargin;
        region.bottom = region.bottom - view.resourceMargin;
      }
    } else {


      region = Rectangle.from(column.subGridElement).moveTo(null, 0);
      region.width = column.subGridElement.scrollWidth;
      region.y = region.y + view.resourceMargin;
      region.bottom = region.bottom - view.resourceMargin;
    }

    const taStart = me.timeAxis.startDate,
      taEnd = me.timeAxis.endDate,
      dateConstraints = view.getDateConstraints(rowRecord, eventRecord) || {
        start: taStart,
        end: taEnd
      },
      top = region.y,
      bottom = region.bottom;
    let startX = view.getCoordinateFromDate(DateHelper.max(taStart, dateConstraints.start)),
      endX = view.getCoordinateFromDate(DateHelper.min(taEnd, dateConstraints.end));

    if (!local) {
      startX = me.translateToPageCoordinate(startX);
      endX = me.translateToPageCoordinate(endX);
    }

    return {
      top,
      right: Math.max(startX, endX),
      bottom,
      left: Math.min(startX, endX)
    };
  }

  getResoureEventBox(eventId, resourceId) {
    return this.cache.getTimeSpan(eventId, resourceId);
  }


  layoutEventVerticallyStack(bandIndex) {
    const {
      resourceMargin,
      rowHeight,
      barMargin
    } = this.scheduler;
    return bandIndex === 0 ? resourceMargin : resourceMargin + bandIndex * (rowHeight - resourceMargin * 2) + bandIndex * barMargin;
  }

  layoutEventVerticallyPack(topFraction, heightFraction) {
    const {
        resourceMargin,
        rowHeight,
        barMargin
      } = this.scheduler,

      availableHeight = rowHeight - 2 * resourceMargin,
      count = 1 / heightFraction,
      bandIndex = topFraction * count,

      height = (availableHeight - (count - 1) * barMargin) * heightFraction,
      top = resourceMargin + bandIndex * height + bandIndex * barMargin;
    return {
      top,
      height
    };
  }


  calculateRowHeight(resourceRecord) {
    const {
      scheduler
    } = this;

    if (scheduler.eventLayout === 'stack' && scheduler.eventStore.count) {
      const {
          eventStore,
          timeAxis,
          resourceMargin,
          barMargin
        } = scheduler,
        heightPerEvent = scheduler.rowHeight - resourceMargin * 2,


        eventFilter = e => eventStore.storage.filterFunction(e) && timeAxis.isTimeSpanInAxis(e),
        events = eventStore.getEventsForResource(resourceRecord).filter(eventFilter).sort(heightEventSorter).map(event => ({
          event,
          startMs: event.startDateMS,
          endMs: event.endDate ? event.endDateMS : event.startDateMS
        })),
        nbrOfBandsRequired = scheduler.currentEventLayout.layoutEventsInBands(events);

      return nbrOfBandsRequired * heightPerEvent + (nbrOfBandsRequired - 1) * barMargin + resourceMargin * 2;
    } else {
      return scheduler.rowHeight;
    }
  }


  calculateMS(eventRecord) {
    const me = this,
      view = me.view;
    let startMS = getStartEnd(view, me.timeAxis, eventRecord.startDate, eventRecord.startDateMS, false),
      endMS = getStartEnd(view, me.timeAxis, eventRecord.endDate, eventRecord.endDateMS, true),
      durationMS = endMS - startMS;

    if (view.milestoneLayoutMode !== 'default' && durationMS === 0) {
      const pxPerMinute = me.timeAxisViewModel.getSingleUnitInPixels('minute'),
        lengthInPx = view.getMilestoneLabelWidth(eventRecord),
        duration = lengthInPx * (1 / pxPerMinute);
      durationMS = duration * 60 * 1000;

      switch (view.milestoneAlign) {
        case 'start':
        case 'left':
          endMS = startMS + durationMS;
          break;

        case 'end':
        case 'right':
          endMS = startMS;
          startMS = endMS - durationMS;
          break;

        default:

          endMS = startMS + durationMS / 2;
          startMS = endMS - durationMS;
          break;
      }
    }

    return {
      startMS,
      endMS,
      durationMS
    };
  }


  layoutEvents(scheduler, resource, row) {
    const me = this,
      {
        timeAxis
      } = me,
      {
        eventStore
      } = scheduler,
      resourceId = resource.id,
      resourceEvents = eventStore.getEventsForResource(resourceId),


      availableEvents = eventStore.isFiltered ? resourceEvents.filter(eventRecord => eventStore.indexOf(eventRecord) > -1) : resourceEvents,


      allEvents = scheduler.getEventsToRender(resource, availableEvents) || [],
      events = allEvents.filter(e => timeAxis.isTimeSpanInAxis(e)),

      eventsTplData = events.reduce((result, event) => {
        const eventBox = scheduler.generateTplData(event, resource);

        if (eventBox) {
          result.push(eventBox);
        } else if (me.cache.getRenderedEvents(resourceId)) {
          me.releaseEvent(resourceId, scheduler.getEventRenderId(event, resource));
        }

        return result;
      }, []);


    if (!eventsTplData.length) {
      me.cache.clearRenderedEvents(resourceId);
      return false;
    }

    eventsTplData.sort(scheduler.horizontalEventSorterFn || me.eventSorter);
    let rowHeight = scheduler.rowHeight;
    const layout = scheduler.currentEventLayout,

      layoutEventData = eventsTplData.filter(d => d.event.isEvent || d.event.isTask);

    if (scheduler.eventLayout === 'stack') {
      const nbrOfBandsRequired = layout.applyLayout(layoutEventData, resource),
        heightPerEvent = scheduler.rowHeight - scheduler.resourceMargin * 2;
      rowHeight = nbrOfBandsRequired * heightPerEvent + (nbrOfBandsRequired - 1) * scheduler.barMargin + scheduler.resourceMargin * 2;
    } else if (scheduler.eventLayout === 'pack') {
      layout.applyLayout(layoutEventData, resource);
    }

    let absoluteTop = row.top;

    if (rowHeight !== row.height && row.estimatedTop) {
      absoluteTop = row.top + row.height - rowHeight;
    }

    const cache = {
      _allEvents: eventsTplData,
      _rowHeight: rowHeight
    };

    eventsTplData.forEach(data => {
      const layout = me.cache.getTimeSpan(data.eventId, resourceId),
        relativeTop = data.top;
      data.top += absoluteTop;
      data.rowTop = absoluteTop;


      if (data.fillSize) {
        data.height = rowHeight;
      }


      data.layoutCache = {
        layout: true,

        div: layout && layout.div,
        eventEl: layout && layout.eventEl,
        width: data.width,
        height: data.height,
        start: data.left,
        end: data.left + data.width,
        relativeTop: relativeTop,
        top: data.top,
        relativeBottom: relativeTop + data.height,
        bottom: data.top + data.height
      };
      cache[data.eventId] = data;
    });
    me.cache.addRow(resourceId, cache);

    return true;
  }


  eventSorter(a, b) {
    const startA = a.dataStartMs || a.startMs,

      endA = a.dataEndMs || a.endMs,
      startB = b.dataStartMs || b.startMs,
      endB = b.dataEndMs || b.endMs,
      sameStart = startA === startB;

    if (sameStart) {
      if (endA - endB === 0) {
        return a.event.name < b.event.name ? -1 : 1;
      }

      return endA > endB ? -1 : 1;
    }

    return startA < startB ? -1 : 1;
  }


  onTranslateRow({
                   row
                 }) {
    this.matchRowTranslation(row);
  }


  renderEvent(data) {
    const me = this,
      eventIdProperty = me.view.scheduledEventName + 'Id',
      eventId = data[eventIdProperty],
      layoutCache = me.cache.getTimeSpan(eventId, data.resourceId),
      renderedEvents = me.cache.getRenderedEvents(data.resourceId),
      meta = data.event.instanceMeta(me.scheduler),


      wrapperElement = me.renderTimeSpan(data, layoutCache, renderedEvents[data.id], meta.requireElement && !meta.fromDragProxy);

    if (data.assignment) {
      wrapperElement.dataset.assignmentId = data.assignment.id;
    }


    if (eventId) {
      wrapperElement.dataset[eventIdProperty] = eventId;
    }

    renderedEvents[data.id] = data;

    if (meta.requireElement) {
      delete meta.requireElement;
      delete meta.fromDragProxy;
    }

    me.scheduler.trigger('renderEvent', {
      eventRecord: data.event,
      resourceRecord: data.resource,
      assignmentRecord: data.assignment,
      element: wrapperElement,
      tplData: data
    });
  }

  triggerPaint(data, element, isRepaint = false) {
    const {
      scheduler
    } = this;
    scheduler.trigger(isRepaint ? 'eventRepaint' : 'eventPaint', {
      scheduler,
      eventRecord: data.event,
      resourceRecord: data.resource,
      element
    });
  }


  isEventInView(eventLayout) {

    if (eventLayout.startMs === eventLayout.endMs) {
      return eventLayout.startMs <= this.viewportEnd && eventLayout.endMs > this.viewportStart;
    }

    return eventLayout.startMs < this.viewportEnd && eventLayout.endMs > this.viewportStart;
  }

  updateRowTimeSpans(row, resource, forceLayout = false, fromHorizontalScroll = false) {
    const me = this,
      {
        scheduler,
        cache
      } = me,
      resourceId = resource.id;
    let renderedEvents = cache.getRenderedEvents(resourceId),
      resourceLayoutCache = cache.getRow(resourceId);

    if ((scheduler.forceLayout || forceLayout || !resourceLayoutCache) && !me.layoutEvents(scheduler, resource, row)) {
      return resourceLayoutCache && resourceLayoutCache._rowHeight || 0;
    }

    resourceLayoutCache = cache.getRow(resourceId);
    if (!resourceLayoutCache) return 0;

    const eventsInView = resourceLayoutCache._allEvents.filter(evt =>
      evt.event.instanceMeta(scheduler).retainElement ||
      evt.assignment && evt.assignment.instanceMeta(scheduler).retainElement ||
      me.isEventInView(evt));

    if (!renderedEvents) {
      renderedEvents = {};
      cache.addRenderedEvents(resourceId, renderedEvents);
    }

    for (let i = 0; i < eventsInView.length; i++) {
      const data = eventsInView[i];


      scheduler._firstRenderDone && scheduler._firstRenderDone();

      if (!fromHorizontalScroll && !data.event.instanceMeta(scheduler).retainElement || fromHorizontalScroll && !data.layoutCache.div) {
        const animation = scheduler.isFirstRender && data.top < scheduler.bodyHeight && scheduler.useInitialAnimation;

        if (animation) {
          data.wrapperCls.add('b-first-render');
          data.internalStyle = `animation-delay: ${data.row.index / 20}s;`;
        }

        me.renderEvent(data);
        data.wrapperCls['b-first-render'] = null;
      }
    }

    const renderedEventIds = Object.keys(renderedEvents);

    for (let i = 0; i < renderedEventIds.length; i++) {
      const eventId = renderedEventIds[i];

      if (!eventsInView.some(e => e.id === eventId)) {
        me.releaseEvent(resourceId, eventId);
      }
    }

    return resourceLayoutCache._rowHeight;
  }

  renderer(renderData) {

    renderData.size.height = this.updateRowTimeSpans(renderData.row, renderData.record);
  }


  matchRowTranslation(row) {
    const me = this,

      recordId = me.scheduler.store.getAt(row.dataIndex).id,
      resourceCache = me.cache.getRow(recordId),
      first = resourceCache && resourceCache._allEvents.length > 0 && resourceCache._allEvents[0];

    if (first && first.rowTop !== row.top) {
      const deltaY = row.top - first.rowTop;

      resourceCache._allEvents.forEach(data => {
        const eventLayout = data.layoutCache;
        eventLayout.top += deltaY;
        eventLayout.bottom += deltaY;

        if (eventLayout.div) {
          me.positionTimeSpan(eventLayout.div, eventLayout.start, eventLayout.top);
        }

        data.top += deltaY;
        data.rowTop = row.top;
      });
    }
  }

  onTimeAxisViewModelUpdate() {


    this.cache.clear();


    this.updateFromHorizontalScroll(this.scheduler.timeAxisSubGrid.scrollable.x);
  }

  onRowRemove({
                isCollapse
              }) {
    const {
      scheduler
    } = this;

    if (!isCollapse) {
      scheduler.runWithTransition(() => {
        scheduler.rowManager.forEach(row => this.matchRowTranslation(row));
      });
    }
  }


  onToggleGroup({
                  groupRecord,
                  collapse
                }) {
    const store = this.scheduler.store;

    let recordIndex = store.indexOf(groupRecord) + (collapse ? 1 : groupRecord.groupChildren.length);

    if (collapse) {

      groupRecord.groupChildren.forEach(child => {
        this.cache.clearRow(child.id);
      });
    }


    for (; recordIndex < store.count; recordIndex++) {
      this.cache.clearRow(store.getAt(recordIndex).id);
    }
  }

  onEventDataset() {


    this.cache.clear(true);


    this.scheduler.calculateAllRowHeights();
  }

  onEventAdd({
               records,
               resources
             }) {
    const me = this,
      {
        scheduler
      } = me,
      affectedResources = new Set();
    records.forEach(event => {
      const {
        startDate,
        endDate
      } = event;

      if (startDate && endDate && me.timeAxis.timeSpanInAxis(startDate, endDate)) {
        const eventResources = event.resources;


        if (eventResources && eventResources.some(resource => scheduler.getRowFor(resource))) {
          event.instanceMeta(scheduler).requireElement = true;
        }


        resources.forEach(resource => {
          me.cache.clearRow(resource.id, false, true);
          affectedResources.add(resource);
        });
      }
    });

    scheduler.calculateRowHeights([...affectedResources]);
  }

  onEventRemove({
                  resources
                }) {

    resources.forEach(resource => this.cache.clearRow(resource.id, true));

    this.scheduler.calculateRowHeights(resources);
  }

  onEventUpdate({
                  source: eventStore,
                  record: eventRecord,
                  changes = {},
                  resources
                }) {
    const me = this,
      {
        cache,
        scheduler
      } = me,
      resourceWasChanged = ('resourceId' in changes);

    if (!resourceWasChanged && !resources.length) {
      return;
    }

    if (resourceWasChanged) {
      const oldResource = eventStore.resourceStore.getById(changes.resourceId.oldValue),
        newResource = eventRecord.resource,
        eventRenderedAfterUpdate = newResource && eventStore.resourceStore.isAvailable(newResource),
        isVisible = eventRecord.resource && Boolean(me.getTimeSpanRenderData(eventRecord, eventRecord.resource));

      scheduler.calculateRowHeights([oldResource, newResource]);

      if (oldResource) {
        const oldLayout = cache.getTimeSpan(eventRecord.id, oldResource.id);

        if (oldLayout) {


          if (eventRenderedAfterUpdate) {


            if (oldLayout.div && newResource) {
              oldLayout.div.id = scheduler.getEventRenderId(eventRecord, newResource);
            }

            cache.clearRow(oldResource.id, false, eventRenderedAfterUpdate);
          } else {
            cache.clearEvent(eventRecord.id, changes.resourceId.oldValue, true);
          }
        }
      } else if (eventRenderedAfterUpdate) {
        eventRecord.instanceMeta(scheduler).requireElement = true;
      }

      eventRenderedAfterUpdate && cache.clearRow(newResource.id, false, isVisible);
    } else if ('startDate' in changes || 'endDate' in changes) {

      scheduler.calculateRowHeights(resources);
    }

    resources.forEach(resourceRecord => {
      const eventLayoutData = me.getTimeSpanRenderData(eventRecord, resourceRecord),
        isVisible = Boolean(eventLayoutData && me.isEventInView(eventLayoutData));

      cache.clearRow(resourceRecord.id, false, isVisible);
    });
  }

  onEventStoreIdChange({
                         oldValue,
                         value
                       }) {
    const {
      view
    } = this;
    DomHelper.forEachSelector(view.element, `[data-event-id="${oldValue}"]`, el => {
      el.id = view.getEventRenderId(value, view.getResourceIdFromDomNodeId(el.id));
    });
  }

  onEventClearChanges() {
    this.cache.clear();
  }

  onEventFilter() {
    this.cache.clear();
    this.scheduler.calculateAllRowHeights();
  }

  onEventRemoveAll() {
    this.cache.clear(true);
    this.scheduler.calculateAllRowHeights();
  }


  getConnectorStartSide(eventRecord) {
    return 'left';
  }


  getConnectorEndSide(eventRecord) {
    return 'right';
  }

}

HorizontalEventMapper._$name = 'HorizontalEventMapper';


class VerticalLayout extends PackMixin() {
  static get defaultConfig() {
    return {
      coordProp: 'leftFactor',
      sizeProp: 'widthFactor'
    };
  }

  applyLayout(events, columnWidth, resourceMargin, barMargin, columnIndex) {
    super.applyLayout(events, (tplData, clusterIndex, slot, slotSize) => {

      if (this.scheduler.eventLayout === 'none') {
        tplData.width = columnWidth - resourceMargin * 2;
        tplData.left += resourceMargin;
      } else {

        tplData.widthFactor = slotSize;
        const leftFactor = tplData.leftFactor = slot.start + clusterIndex * slotSize,

          packColumnCount = Math.round(1 / slotSize),

          packColumnIndex = leftFactor / slotSize,

          availableWidth = columnWidth - resourceMargin * 2 - barMargin * (packColumnCount - 1);

        if (this.scheduler.eventLayout === 'mixed' && packColumnCount === 2) {
          tplData.left += leftFactor * columnWidth / 5 + barMargin;
          tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;
          tplData.zIndex = 5 + packColumnIndex;
        } else {

          tplData.width = slotSize * availableWidth;

          tplData.left += leftFactor * availableWidth + resourceMargin + barMargin * packColumnIndex;
        }
      }
    });
  }

}

VerticalLayout._$name = 'VerticalLayout';

const releaseEventActions = {
    releaseElement: 1,

    reuseElement: 1

  },
  renderEventActions = {
    newElement: 1,
    reuseOwnElement: 1,
    reuseElement: 1
  };

class VerticalEventMapper extends Delayable(Base) {

  static get properties() {
    return {
      eventMap: {},
      resourceMap: {},
      releasedElements: {}
    };
  }

  construct(scheduler) {
    this.scheduler = scheduler;
    this.timeAxisViewModel = scheduler.timeAxisViewModel;
    this.verticalLayout = new VerticalLayout({
      scheduler
    });
    super.construct({});
  }

  init() {
    const me = this,
      {
        scheduler
      } = me;

    me.resourceColumns = scheduler.timeAxisColumn.resourceColumns;
    scheduler.element.classList.add('b-sch-vertical');
    scheduler.on({
      assignmentstorechange: me.onChangeAssignmentStore,
      resourcestorechange: me.onChangeResourceStore,
      thisObj: me
    });
    me.resourceColumns.on({
      columnWidthChange: me.onResourceColumnWidthChange,
      thisObj: me
    });
    me.resourceStore = scheduler.resourceStore;
    me.assignmentStore = scheduler.assignmentStore;
    me.initialized = true;

    if (scheduler.isPainted) {
      me.renderer();
    }

    me.resourceColumns.availableWidth = scheduler.timeAxisSubGrid.width;
  }


  resolveRowRecord(elementOrEvent, xy) {
    const me = this,
      {
        scheduler
      } = me,
      event = elementOrEvent instanceof Event ? elementOrEvent : null,
      element = event ? event.target : elementOrEvent,
      coords = event ? [event.offsetX, event.offsetY] : xy,

      el = element.nodeType === 3 ? element.parentElement : element,
      eventElement = DomHelper.up(el, scheduler.eventSelector);

    if (eventElement) {
      return scheduler.resourceStore.getById(eventElement.dataset.resourceId);
    }

    if (!DomHelper.up(element, '.b-sch-timeaxis-cell')) {
      return null;
    }

    if (!coords) {
      throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser
                event instead of element to extract element and coordinates from`);
    }

    const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);
    return scheduler.resourceStore.getAt(index);
  }

  getElementFromEventRecord(eventRecord, resourceRecord) {

    const elements = this.getElementsFromEventRecord(eventRecord, resourceRecord);

    return elements.length ? elements[0] : null;
  }

  getElementsFromEventRecord(eventRecord) {
    const

      {
        syncIdMap
      } = this.scheduler.foregroundCanvas,
      {
        eventInnerSelector
      } = this.scheduler,
      records = eventRecord.assignments || [eventRecord],
      elements = [];
    records.forEach(record => {
      if (syncIdMap[record.id]) {
        elements.push(syncIdMap[record.id].querySelector(eventInnerSelector));
      }
    });
    return elements;
  }

  toggleCls(eventRecord, resourceRecord, cls, add = true) {
    const eventData = ObjectHelper.getPath(this.eventMap, `${eventRecord.id}.${resourceRecord.id}`);

    if (eventData) {
      eventData.tplData.cls[cls] = add ? 1 : 0;


      const element = this.getElementFromEventRecord(eventRecord, resourceRecord);

      if (element) {
        element.classList[add ? 'add' : 'remove'](cls);
      }
    }
  }


  getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {
    let coord = xy[1];

    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }

    return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);
  }

  translateToScheduleCoordinate(y) {
    return y - this.scheduler._bodyRectangle.y + this.scheduler.scrollTop;
  }

  translateToPageCoordinate(y) {
    return y + this.scheduler._bodyRectangle.y - this.scheduler.scrollTop;
  }


  getResourceEventBox(eventId, resourceId) {
    let {
      tplData
    } = ObjectHelper.getPath(this.eventMap, `${eventId}.${resourceId}`) || {};

    if (!tplData) {

      this.layoutResource(this.scheduler.resourceStore.getById(resourceId));

      tplData = ObjectHelper.getPath(this.eventMap, `${eventId}.${resourceId}`).tplData;
    }

    return tplData ? {
      start: tplData.left,
      end: tplData.left + tplData.width,
      top: tplData.top,
      bottom: tplData.bottom
    } : null;
  }

  getScheduleRegion(resourceRecord, eventRecord, local) {
    const me = this,
      {
        scheduler
      } = me;
    const region = Rectangle.from(scheduler.timeAxisSubGridElement);

    if (resourceRecord) {

      region.left = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth;
      region.right = region.left + scheduler.resourceColumnWidth;
    }

    const start = scheduler.timeAxis.startDate,
      end = scheduler.timeAxis.endDate,
      dateConstraints = scheduler.getDateConstraints(resourceRecord, eventRecord) || {
        start,
        end
      },
      startY = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),
      endY = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));

    if (!local) {
      region.top = me.translateToPageCoordinate(startY);
      region.bottom = me.translateToPageCoordinate(endY);
    } else {
      region.top = startY;
      region.bottom = endY;
    }

    return region;
  }

  getRowRegion(resourceRecord, startDate, endDate) {
    const me = this,
      {
        scheduler
      } = me,
      x = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth,
      taStart = scheduler.timeAxis.startDate,
      taEnd = scheduler.timeAxis.endDate,
      start = startDate ? DateHelper.max(taStart, startDate) : taStart,
      end = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
      startY = scheduler.getCoordinateFromDate(start),
      endY = scheduler.getCoordinateFromDate(end, true, true),
      y = Math.min(startY, endY),
      height = Math.abs(startY - endY);
    return new Rectangle(x, y, scheduler.resourceColumnWidth, height);
  }

  getVisibleDateRange() {
    const scheduler = this.scheduler,
      scrollPos = scheduler.scrollable.y,
      height = scheduler.scrollable.clientHeight;
    return {
      startDate: scheduler.getDateFromCoordinate(scrollPos),
      endDate: scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate
    };
  }


  onResourceColumnWidthChange({
                                width,
                                oldWidth
                              }) {
    const me = this,
      {
        scheduler
      } = me;

    me.resourceColumns.width = scheduler.timeAxisColumn.width = me.resourceStore.count * width;
    me.clearAll();

    scheduler.runWithTransition(() => me.renderer(), Math.abs(width - oldWidth) > 30);


  }


  onEventStoreChange({
                       action,
                       records,
                       record,
                       replaced,
                       changes,
                       fromRelationUpdate
                     }) {
    const me = this,
      eventRecords = records || (record ? [record] : []),
      resourceIds = new Set();
    let transition = true;
    eventRecords.forEach(eventRecord => {
      eventRecord.resources.forEach(resourceRecord => resourceIds.add(resourceRecord.id));
    });

    switch (action) {

      case 'sort':
      case 'group':
      case 'move':

        return;

      case 'dataset':
        me.clearAll();
        transition = false;
        break;

      case 'add':
      case 'remove':
      case 'updateMultiple':

        me.clearResources(resourceIds);
        break;

      case 'replace':

        replaced.forEach(([oldEvent, newEvent]) => {
          oldEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));
          newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));
        });

        me.clearResources(resourceIds);
        break;

      case 'removeall':
      case 'filter':


        me.clearAll();
        break;

      case 'update':


        if (record.meta.removingResource) {
          return;
        }

        let processed = false;

        if ('startDate' in changes || 'endDate' in changes || 'duration' in changes || 'id' in changes) {
          me.clearResources(resourceIds);
          processed = true;
        }

        if ('resourceId' in changes) {


          if (fromRelationUpdate) {
            return;
          }

          resourceIds.add(changes.resourceId.oldValue);
          me.clearResources(resourceIds);
          processed = true;
        }

        if (!processed) {
          const eventDatas = Object.values(me.eventMap[record.id]);
          eventDatas.forEach(eventData => {

            const {
              tplData
            } = eventData;
            eventData.tplData = me.scheduler.generateTplData(tplData.eventRecord, tplData.resourceRecord);
            eventData.tplData.left = tplData.left;
            eventData.tplData.width = tplData.width;
          });
        }

        break;
    }

    me.scheduler.runWithTransition(() => me.renderer(), transition);
  }


  set resourceStore(store) {
    const me = this;
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    me.resourceColumns.resourceStore = me._resourceStore = store;
    me.resourceStoreDetacher = store.on({
      change: me.onResourceStoreChange,
      refresh: me.onResourceStoreRefresh,
      thisObj: me,
      prio: 1

    });
  }

  get timeView() {
    return this.scheduler.timeView;
  }

  get resourceStore() {
    return this._resourceStore;
  }

  onChangeResourceStore({
                          newResourceStore
                        }) {
    const me = this;

    me.firstResource = me.lastResource = null;
    me.clearAll();
    me.resourceStore = newResourceStore;
    me.renderer();
  }

  onResourceStoreChange({
                          source: resourceStore,
                          action,
                          records,
                          record
                        }) {
    const me = this,
      resourceRecords = records || (record ? [record] : []);

    me.firstResource = me.lastResource = null;

    switch (action) {
      case 'add':

        const firstIndex = resourceRecords.reduce((index, record) => Math.min(index, resourceStore.indexOf(record)), resourceStore.count);

        for (let i = firstIndex; i < resourceStore.count; i++) {
          me.clearResources([resourceStore.getAt(i).id]);
        }

        return;


      case 'remove':
      case 'removeall':

        me.clearAll();
        return;


      case 'replace':
      case 'update':

        break;

      case 'filter':


        me.clearAll();
        break;
    }

    me.scheduler.runWithTransition(() => me.renderer());
  }

  onResourceStoreRefresh({
                           action
                         }) {
    const me = this;

    if (action === 'group') {
      throw new Error('Grouping of resources not supported in vertical mode');
    }

    if (action === 'sort') {

      me.firstResource = me.lastResource = null;
      me.clearAll();
      me.scheduler.runWithTransition(() => me.renderer());
    }
  }


  set assignmentStore(store) {
    const me = this;
    me.assignmentStoreDetacher && me.assignmentStoreDetacher();
    me._assignmentStore = store;

    if (store) {
      me.assignmentStoreDetacher = store.on({
        change: me.onAssignmentStoreChange,
        thisObj: me
      });
    }
  }

  get assignmentStore() {
    return this._assignmentStore;
  }

  onChangeAssignmentStore({
                            newAssignmentStore
                          }) {
    this.assignmentStore = newAssignmentStore;
  }

  onAssignmentStoreChange({
                            action,
                            records,
                            replaced,
                            record,
                            changes
                          }) {
    const me = this,
      assignmentRecords = records || (record ? [record] : []),
      resourceIds = new Set(assignmentRecords.map(assignmentRecord => assignmentRecord.resourceId));

    switch (action) {
      case 'add':
      case 'remove':
      case 'updateMultiple':
        me.clearResources(resourceIds);
        break;

      case 'filter':
      case 'removeall':
        me.clearAll();
        break;

      case 'replace':

        replaced.forEach(([oldAssignment, newAssignment]) => {
          resourceIds.add(oldAssignment.resourceId);
          resourceIds.add(newAssignment.resourceId);
        });

        me.clearResources(resourceIds);
        break;

      case 'update':

        if ('resourceId' in changes) {
          resourceIds.add(changes.resourceId.oldValue);
        }

        me.clearResources(resourceIds);
        break;
    }

    me.scheduler.runWithTransition(() => me.renderer());
  }


  refreshRows(reLayoutEvents) {
    if (reLayoutEvents) {
      this.clearAll();
      this.scheduler.refreshFromRerender = false;
    }
  }

  updateFromHorizontalScroll(scrollLeft) {
    if (scrollLeft !== this.prevScrollLeft) {
      this.renderer();
      this.prevScrollLeft = scrollLeft;
    }
  }

  updateFromVerticalScroll() {
    this.renderer();
  }

  scrollResourceIntoView(resourceRecord, options) {
    const {
        scheduler
      } = this,
      x = scheduler.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth;
    return scheduler.scrollHorizontallyTo(x, options);
  }

  onViewportResize(width) {
    this.resourceColumns.availableWidth = width;
    this.renderer();
  }

  onLocaleChange() {
    this.clearAll();
  }

  onDragAbort() {
  }

  onBeforeRowHeightChange() {
  }

  onTimeAxisViewModelUpdate() {
  }

  clearEvents() {
  }

  updateElementId() {
  }

  releaseTimeSpanDiv() {
  }


  get resourceRange() {
    const {
      scheduler,
      resourceStore
    } = this;

    if (!resourceStore || !resourceStore.count) {
      return {
        firstResource: -1,
        lastResource: -1
      };
    }

    return {
      firstResource: Math.max(Math.floor(scheduler.scrollLeft / scheduler.resourceColumnWidth) - 1, 0),
      lastResource: Math.min(Math.floor((scheduler.scrollLeft + scheduler.timeAxisSubGrid.width) / scheduler.resourceColumnWidth) + 1, resourceStore.count - 1)
    };
  }

  get dateRange() {
    const {
      scheduler
    } = this;
    let bottomDate = scheduler.getDateFromCoordinate(Math.min(scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1, (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1));


    if (!bottomDate) {
      bottomDate = scheduler.timeAxis.last.endDate;
    }

    return {
      topDate: scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0)),
      bottomDate
    };
  }

  getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {
    const me = this,
      {
        scheduler
      } = me,
      {
        startDate,
        endDate
      } = eventRecord,
      top = scheduler.getCoordinateFromDate(startDate),

      left = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth,
      width = scheduler.resourceColumnWidth - scheduler.resourceMargin * 2,
      startDateMS = startDate.getTime(),
      endDateMS = endDate.getTime();
    let bottom = scheduler.getCoordinateFromDate(endDate),
      height = bottom - top;

    if (bottom === -1) {
      height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('ms'));
      bottom = top + height;
    }

    return {
      eventRecord,
      resourceRecord,
      left,
      top,
      bottom,
      width,
      height,
      startDate,
      endDate,
      startDateMS,
      endDateMS,

      start: startDate,
      end: endDate,
      startMs: startDateMS,
      endMs: endDateMS
    };
  }


  eventSorter(a, b) {
    const startA = a.dataStartMs || a.startDateMS,

      endA = a.dataEndMs || a.endDateMS,
      startB = b.dataStartMs || b.startDateMS,
      endB = b.dataEndMs || b.endDateMS,
      sameStart = startA === startB;

    if (sameStart) {
      if (endA - endB === 0) {
        return a.eventRecord.name < b.eventRecord.name ? -1 : 1;
      }

      return endA > endB ? -1 : 1;
    }

    return startA < startB ? -1 : 1;
  }


  layoutResource(resourceRecord) {
    const me = this,
      {
        scheduler
      } = me,

      cache = me.resourceMap[resourceRecord.id] = {},

      resourceIndex = scheduler.resourceStore.indexOf(resourceRecord);

    let events = scheduler.eventStore.getEventsForResource(resourceRecord);

    events = scheduler.getEventsToRender(resourceRecord, events);

    const layoutData = events.reduce((toLayout, eventRecord) => {
      const tplData = scheduler.generateTplData(eventRecord, resourceRecord),

        eventData = {
          tplData
        };


      ObjectHelper.setPath(me.eventMap, `${tplData.eventId}.${resourceRecord.id}`, eventData);

      cache[tplData.eventId] = eventData;

      if (tplData.fillSize) {
        tplData.left = resourceIndex * scheduler.resourceColumnWidth;
        tplData.width = scheduler.resourceColumnWidth;
      } else {
        toLayout.push(tplData);
      }

      return toLayout;
    }, []);

    layoutData.sort(me.eventSorter);

    me.verticalLayout.applyLayout(layoutData, scheduler.resourceColumnWidth, scheduler.resourceMargin, scheduler.barMargin, resourceIndex);
    return cache;
  }


  addTemporaryDragElement(eventRecord) {
    const {
        scheduler
      } = this,
      tplData = scheduler.generateTplData(eventRecord, eventRecord.resource, {
        timeAxis: true,
        viewport: true
      });
    tplData.top = tplData.row ? tplData.top + tplData.row.top : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;
    const domConfig = this.renderEvent({
        tplData
      }),
      {
        dataset
      } = domConfig;
    delete domConfig.tabIndex;
    delete dataset.eventId;
    delete dataset.resourceId;
    delete dataset.syncId;
    dataset.transient = true;
    domConfig.parent = this.scheduler.foregroundCanvas;


    domConfig.retainElement = true;
    const result = DomHelper.createElement(domConfig);
    result.innerElement = result.firstChild;
    eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;
    return result;
  }


  renderEvent(eventData) {

    const data = eventData.tplData,
      {
        resourceRecord,
        eventRecord
      } = data,

      elementConfig = {
        className: data.wrapperCls,
        tabIndex: '0',
        children: [{
          className: data.cls,
          style: (data.internalStyle || '') + (data.style || ''),

          html: data.body.cloneNode(true),

          compareHtml: data.eventContent
        }],
        style: {
          transform: `translate(${data.left}px, ${data.top}px)`,

          height: data.height,
          width: data.width,
          zIndex: data.zIndex
        },
        dataset: {
          resourceId: resourceRecord.id,
          eventId: data.eventId,


          syncId: data.assignment ? data.assignment.id : data.eventId
        },

        elementData: eventData,

        retainElement: eventRecord.instanceMeta(this.scheduler).retainElement
      };

    if (data.assignment) {
      elementConfig.dataset.assignmentId = data.assignment.id;
    }

    return elementConfig;
  }

  renderResource(resourceRecord) {
    const me = this,

      {
        topDateMS,
        bottomDateMS
      } = me,

      syncConfigs = [];
    let resourceEntry = me.resourceMap[resourceRecord.id];

    if (!resourceEntry) {
      resourceEntry = me.layoutResource(resourceRecord);
    }

    for (const eventId in resourceEntry) {
      const eventData = resourceEntry[eventId],
        {
          endDateMS,
          startDateMS,
          eventRecord
        } = eventData.tplData;

      if (
        endDateMS >= topDateMS && startDateMS <= bottomDateMS &&
        !eventRecord.instanceMeta(me.scheduler).hasTemporaryDragElement) {
        syncConfigs.push(me.renderEvent(eventData));
      }
    }

    return syncConfigs;
  }


  renderer() {
    const me = this,
      {
        scheduler
      } = me,
      {
        resourceStore
      } = scheduler,

      {
        firstResource,
        lastResource
      } = me.resourceRange,

      {
        topDate,
        bottomDate
      } = me.dateRange,
      syncConfigs = [],
      featureDomConfigs = [];

    if (!me.initialized) {
      return;
    }

    if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {

      me.topDate = topDate;
      me.bottomDate = bottomDate;
      me.topDateMS = topDate.getTime();
      me.bottomDateMS = bottomDate.getTime();
      me.timeView.range = {
        startDate: topDate,
        endDate: bottomDate
      };
    }

    if (firstResource !== -1 && lastResource !== -1) {

      for (let i = firstResource; i <= lastResource; i++) {
        syncConfigs.push.apply(syncConfigs, me.renderResource(resourceStore.getAt(i)));
      }
    }

    scheduler.getForegroundDomConfigs(featureDomConfigs);
    syncConfigs.push.apply(syncConfigs, featureDomConfigs);
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: syncConfigs
      },
      targetElement: scheduler.foregroundCanvas,
      syncIdField: 'syncId',


      callback({
                 action,
                 domConfig,
                 lastDomConfig,
                 targetElement
               }) {

        if (domConfig && domConfig.className && domConfig.className[scheduler.eventCls + '-wrap']) {
          const

            isRelease = releaseEventActions[action],
            isRender = renderEventActions[action];

          if (isRelease && lastDomConfig && !lastDomConfig.isReleased) {
            const data = lastDomConfig.elementData.tplData,
              event = {
                tplData: data,
                assignmentRecord: data.assignment,
                eventRecord: data.eventRecord,
                resourceRecord: data.resourceRecord,
                targetElement
              };

            scheduler.trigger('releaseEvent', event);
          }

          if (isRender) {
            const data = domConfig.elementData.tplData,
              event = {
                tplData: data,
                assignmentRecord: data.assignment,
                eventRecord: data.eventRecord,
                resourceRecord: data.resourceRecord,
                targetElement
              };

            targetElement.elementData.element = targetElement;
            event.reusingElement = action === 'reuseElement';

            scheduler.trigger('renderEvent', event);
          }

          if (action === 'none') {
            domConfig.elementData.element = targetElement;
          }
        }
      }

    });

    if (me.firstResource !== firstResource || me.lastResource !== lastResource) {

      me.resourceColumns.range = {
        firstResource,
        lastResource
      };

      me.firstResource = firstResource;
      me.lastResource = lastResource;
    }
  }


  clearResources(resourceIds) {
    resourceIds.forEach(resourceId => {
      if (this.resourceMap[resourceId]) {
        Object.keys(this.resourceMap[resourceId]).forEach(eventId => {
          delete this.eventMap[eventId][resourceId];
        });
        delete this.resourceMap[resourceId];
      }
    });
  }

  clearAll() {
    this.resourceMap = {};
    this.eventMap = {};
  }

}

VerticalEventMapper._$name = 'VerticalEventMapper';


class VerticalTimeAxis extends TimeAxisBase {
  static get $name() {
    return 'VerticalTimeAxis';
  }

  static get defaultConfig() {
    return {
      cls: 'b-verticaltimeaxis',
      sizeProperty: 'height',
      positionProperty: 'top',
      wrapText: true
    };
  }

  get height() {
    return this.size;
  }

}

VerticalTimeAxis._$name = 'VerticalTimeAxis';

class VerticalTimeAxisColumn extends Column {
  static get type() {
    return 'verticalTimeAxis';
  }

  static get defaults() {
    return {

      draggable: false,


      groupable: false,


      hideable: false,


      showColumnPicker: false,


      filterable: false,


      sortable: false,


      searchable: false,


      editor: false,


      enableCellContextMenu: false,


      tooltipRenderer: false,
      cellCls: 'b-verticaltimeaxiscolumn'
    };
  }

  construct(data) {
    const me = this;
    super.construct(...arguments);
    me.timeAxisViewModel = data.timeline.timeAxisViewModel;
    me.view = new VerticalTimeAxis({
      model: me.timeAxisViewModel,
      client: data.timeline
    });
  }

  renderer({
             cellElement,
             size
           }) {
    this.view.render(cellElement);
    size.height = this.view.height;
  }

}

ColumnStore.registerColumnType(VerticalTimeAxisColumn);
VerticalTimeAxisColumn._$name = 'VerticalTimeAxisColumn';


class SchedulerBase extends base(TimelineBase).mixes(CrudManagerView, SchedulerDom, SchedulerDomEvents, SchedulerDragResize, SchedulerStores, SchedulerScroll, SchedulerState, SchedulerEventRendering, SchedulerRegions, EventSelection, EventNavigation) {

  static get $name() {
    return 'SchedulerBase';
  }

  static get defaultConfig() {
    return {

      mode: 'horizontal',


      eventCls: 'b-sch-event',


      timeCellCls: 'b-sch-timeaxis-cell',
      timeCellSelector: '.b-sch-timeaxis-cell',
      scheduledEventName: 'event',


      overScheduledEventClass: 'b-sch-event-hover',


      allowOverlap: true,


      rowHeight: 60,


      milestoneCharWidth: 10,


      milestoneAlign: 'center',


      preCalculateHeightLimit: 10000,

      milestoneMinWidth: 40,
      localeClass: 'Scheduler',
      crudManagerClass: CrudManager,
      testConfig: {
        loadMaskHideTimeout: 10
      }
    };
  }


  construct(config = {}) {
    const me = this;
    super.construct(config);

    if (me.createEventOnDblClick) {
      me.on('scheduledblclick', me.onSchedulerDblClick);
    }
  }


  set timeAxisViewModel(timeAxisViewModel) {
    super.timeAxisViewModel = timeAxisViewModel;

    if (this.eventStore) {
      this.timeAxisViewModel.eventStore = this.eventStore;
    }
  }

  get timeAxisViewModel() {
    return super.timeAxisViewModel;
  }

  get store() {
    return super.store;
  }

  set store(store) {
    super.store = store;
  }


  onLocaleChange() {
    this.currentOrientation.onLocaleChange();
    super.onLocaleChange();
  }

  onSchedulerDblClick({
                        date: startDate,
                        resourceRecord,
                        row
                      }) {
    const me = this;

    if (me.readOnly || resourceRecord.meta.specialRow) {
      return;
    }

    me.internalAddEvent(startDate, resourceRecord, row);
  }

  onColumnsChanged({
                     action,
                     changes,
                     record: column
                   }) {

    if (column === this.timeAxisColumn && 'width' in changes) {
      this.updateCanvasSize();
    }

    super.onColumnsChanged(...arguments);
  }

  onVerticalScroll({
                     scrollTop
                   }) {
    this.currentOrientation.updateFromVerticalScroll(scrollTop);
  }


  onEventCreated(eventRecord) {
  }


  get isHorizontal() {
    return this.mode === 'horizontal';
  }


  get isVertical() {
    return this.mode === 'vertical';
  }


  get mode() {
    return this._mode;
  }

  set mode(mode) {
    const me = this;
    me._mode = mode;

    if (!me[mode]) {
      if (mode === 'horizontal') {
        me.horizontal = new HorizontalEventMapper(me);

        if (me.isPainted) {
          me.horizontal.init();
        }

        me.un('scroll', me.onVerticalScroll, me);
      } else if (mode === 'vertical') {

        me.zoomOnTimeAxisDoubleClick = me.zoomOnMouseWheel = false;
        me.vertical = new VerticalEventMapper(me);

        if (me.rendered) {
          me.vertical.init();
        }

        me.on('scroll', me.onVerticalScroll, me);
      }
    }
  }

  get currentOrientation() {
    return this[this.mode];
  }


  onElementKeyDown(event) {
    super.onElementKeyDown(event);
  }

  onElementKeyUp(event) {
    super.onElementKeyUp(event);
  }

  onElementMouseOver(event) {
    super.onElementMouseOver(event);
  }

  onElementMouseOut(event) {
    super.onElementMouseOut(event);
  }


  getEventMenuItems() {
  }


  getScheduleMenuItems() {
  }


  internalAddEvent(startDate, resourceRecord, row) {
    const me = this,
      resourceRecords = [resourceRecord],
      eventRecord = new me.eventStore.modelClass({
        startDate,
        endDate: DateHelper.add(startDate, 1, me.timeAxis.unit)
      });
    me.onEventCreated(eventRecord);

    if (me.eventEdit) {
      const eventData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord),
        proxyEl = DomHelper.createElement({
          parent: me.foregroundCanvas,
          className: 'b-sch-dragcreator-proxy',
          style: `width:${eventData.width}px;height:${eventData.height}px`
        });
      DomHelper.setTranslateXY(proxyEl, eventData.left, (row && row.top || 0) + eventData.top);
      me.editEvent(eventRecord, resourceRecord, proxyEl);
      return;
    }


    if (me.trigger('beforeEventAdd', {
      eventRecord,
      resourceRecords,
      resources: resourceRecords
    }) !== false) {
      me.eventStore.add(eventRecord);
      me.eventStore.assignEventToResource(eventRecord, resourceRecord);
    }
  }


  isDateRangeAvailable(start, end, excludeEvent, resource) {
    return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);
  }


  toggleEmptyText() {
    const me = this;

    if (me.bodyContainer) {
      DomHelper.toggleClasses(me.bodyContainer, 'b-grid-empty', !(me.rowManager.rowCount || me.crudManager && me.crudManager.isLoading));
    }
  }


  getRowHeight(resourceRecord) {
    if (this.currentOrientation.calculateRowHeight) {
      const height = this.currentOrientation.calculateRowHeight(resourceRecord);
      this.rowManager.storeKnownHeight(resourceRecord.id, height);
      return height;
    }
  }

  calculateRowHeights(resourceRecords) {

    resourceRecords.forEach(resourceRecord => resourceRecord && this.getRowHeight(resourceRecord));
    this.rowManager.estimateTotalHeight(true);
  }

  calculateAllRowHeights(silent = false) {
    const {
        store,
        rowManager
      } = this,
      count = Math.min(store.count, this.preCalculateHeightLimit);

    if (count) {
      rowManager.clearKnownHeights();

      for (let i = 0; i < count; i++) {

        this.getRowHeight(store.getAt(i));
      }

      if (!silent) {
        rowManager.estimateTotalHeight(true);
      }
    }
  }

}

SchedulerBase.localeClass = 'Scheduler';
SchedulerBase._$name = 'SchedulerBase';
BryntumWidgetAdapterRegister.register('schedulerbase', SchedulerBase);


class ScheduleContextMenu extends TimeSpanRecordContextMenuBase {

  static get $name() {
    return 'ScheduleContextMenu';
  }

  static get defaultConfig() {
    return {

      items: null,


      processItems: null,


      defaultItems: {
        addEvent: true
      }
    };
  }


  construct(scheduler, config) {
    super.construct(scheduler, config);
    this.scheduler = scheduler;
  }


  showEventContextMenu(event) {
    const scheduler = this.scheduler,
      cellData = scheduler.getEventData(event),
      isTimeAxisColumn = cellData ? scheduler.columns.getById(cellData.columnId) === scheduler.timeAxisColumn : scheduler.timeAxisSubGrid.element === event.target,

      resourceRecord = scheduler.resolveResourceRecord(event) || scheduler.resourceStore.last;

    if (isTimeAxisColumn && !(resourceRecord && resourceRecord.meta.specialRow)) {
      this.showContextMenu({
        menuType: 'schedule',
        date: scheduler.getDateFromDomEvent(event, 'floor'),
        resourceRecord,
        event
      });
      event.preventDefault();
    }
  }

  get namedItems() {
    const client = this.client;

    if (!this._namedItems) {
      this._namedItems = {
        addEvent: {
          text: client.L('Add event', null),
          icon: 'b-icon b-icon-add',
          disabled: client.resourceStore.count === 0,
          weight: 100,

          onItem({
                   date,
                   resourceRecord
                 }) {
            client.internalAddEvent(date, resourceRecord, client.getRowFor(resourceRecord));
          }

        }
      };
    }

    return this._namedItems;
  }

}

ScheduleContextMenu.featureClass = '';
ScheduleContextMenu._$name = 'ScheduleContextMenu';
GridFeatureManager.registerFeature(ScheduleContextMenu, true, 'Scheduler');


class ScheduleTooltip extends InstancePlugin {

  static get $name() {
    return 'ScheduleTooltip';
  }

  static get defaultConfig() {
    return {
      messageTemplate: data => `<div class="b-sch-hovertip-msg">${data.message}</div>`
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }


  render() {
    const me = this,
      scheduler = me.client;

    if (me.hoverTip) {
      me.hoverTip.destroy();
    }

    let reshowListener;
    const tip = me.hoverTip = new Tooltip({
      id: `${scheduler.id}-schedule-tip`,
      cls: 'b-sch-scheduletip',
      allowOver: true,
      hoverDelay: 0,
      hideDelay: 100,
      showOnHover: true,
      forElement: scheduler.timeAxisSubGridElement,
      anchorToTarget: false,
      trackMouse: true,
      updateContentOnMouseMove: true,
      forSelector: '.b-schedulerbase:not(.b-animating):not(.b-dragging-event):not(.b-dragcreating) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',

      constrainTo: null,
      getHtml: me.getHoverTipHtml.bind(me),

      onDocumentMouseDown(event) {


        if (tip.forElement.contains(event.event.target)) {
          reshowListener = EventHelper.on({
            element: scheduler.timeAxisSubGridElement,
            mousemove: e => tip.internalOnPointerOver(e),
            capture: true
          });
        }

        const hideAnimation = tip.hideAnimation;
        tip.hideAnimation = false;
        tip.constructor.prototype.onDocumentMouseDown.call(tip, event);
        tip.hideAnimation = hideAnimation;
      },

      listeners: {
        pointerover: ({
                        event
                      }) => {
          const buttonsPressed = 'buttons' in event ? event.buttons > 0 : event.which > 0;


          if (!buttonsPressed && reshowListener) {
            reshowListener();
          }

          return !me.disabled && !scheduler.readOnly && !buttonsPressed;
        }
      }
    });
    me.clockTemplate = new ClockTemplate({
      scheduler
    });
  }

  doDestroy() {
    this.destroyProperties('clockTemplate', 'hoverTip');
    super.doDestroy();
  }


  getHoverTipHtml({
                    tip,
                    event
                  }) {
    const me = this,
      scheduler = me.client,
      date = event && scheduler.getDateFromDomEvent(event, 'floor', true);
    let html = me.lastHtml;

    if (date) {
      const resourceRecord = scheduler.resolveResourceRecord(event);

      if (date - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
        me.lastResource = resourceRecord;
        html = me.lastHtml = me.generateTipContent(date, event);
      }
    } else {
      tip.hide();
      me.lastTime = null;
      me.lastResource = null;
    }

    return html;
  }


  generateTipContent(date, event) {
    const me = this,
      clockHtml = me.clockTemplate.generateContent({
        date: date,
        text: me.client.getFormattedDate(date)
      }),
      messageHtml = me.messageTemplate({
        message: me.getText(date, event) || ''
      });
    me.lastTime = date;
    return clockHtml + messageHtml;
  }


  getText(date, event) {
  }

}

ScheduleTooltip.featureClass = 'b-scheduletip';
ScheduleTooltip._$name = 'ScheduleTooltip';
GridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');


class Scheduler extends SchedulerBase {
  static get $name() {
    return 'Scheduler';
  }

}

Scheduler._$name = 'Scheduler';
BryntumWidgetAdapterRegister.register('scheduler', Scheduler);


class ScheduleTableExporter extends Localizable(TableExporter) {
  static get defaultConfig() {
    return {

      includeUnassigned: true,


      eventColumns: [{
        text: 'Task',
        field: 'name'
      }, {
        text: 'Starts',
        field: 'startDate',
        width: 140
      }, {
        text: 'Ends',
        field: 'endDate',
        width: 140
      }]
    };
  }

  normalizeColumns(config) {
    super.normalizeColumns(config);
    config.eventColumns = config.eventColumns.map(col => {
      if (typeof col === 'string') {
        return {
          field: col
        };
      } else {
        return col;
      }
    });
  }

  generateExportData(config) {
    const me = this,
      isScheduler = this.target instanceof Scheduler,
      resourceColumns = me.generateColumns(config),
      eventColumns = isScheduler ? me.generateEventColumns(config) : [],
      columns = resourceColumns.concat(eventColumns),
      rows = me.generateRows(config);
    return {
      columns,
      rows
    };
  }

  generateEventColumns(config) {
    return config.eventColumns.map(column => this.processEventColumn(column, config));
  }

  processEventColumn(column, config) {
    const {
        width,
        minWidth
      } = column,
      {
        defaultColumnWidth
      } = config;
    return {
      field: column.field,
      value: column.text,
      width: Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth),
      eventColumn: true,
      type: this.getColumnType(column, this.target.eventStore)
    };
  }

  generateRows(config) {
    const me = this,
      {
        target
      } = me;
    let result;

    if (!(target instanceof Scheduler)) {
      result = super.generateRows(config);
    } else {
      result = [];

      target.resourceStore.map(resourceRecord => {

        const events = resourceRecord.events || [];

        if (!events.length) {
          events.push('');
        }

        events.forEach(eventRecord => result.push(me.getRowData(config, resourceRecord, eventRecord)));
      });

      if (config.includeUnassigned && config.eventColumns.length) {
        const notAssignedEvents = target.eventStore.query(eventRecord => {
          return !eventRecord.resources.length &&

            !target.resourceStore.isAvailable(eventRecord);
        });

        if (notAssignedEvents.length) {

          const cells = new Array(config.columns.length).fill('');
          cells.push(me.L('No resource assigned'));
          result.push(cells);

          notAssignedEvents.forEach(eventRecord => result.push(me.getRowData(config, null, eventRecord)));
        }
      }

      result = result.filter(cells => cells.length);
    }

    return result;
  }

  getRowData(config, resource, event) {
    const {
        columns,
        eventColumns
      } = config,
      cells = [];
    cells.push(...this.processRecord(resource, columns, config));

    if (!resource || !resource.meta.specialRow) {
      cells.push(...this.processRecord(event, eventColumns, config));
    }

    return cells;
  }

}

ScheduleTableExporter._$name = 'ScheduleTableExporter';


class ExcelExporter$1 extends ExcelExporter {
  static get $name() {
    return 'ExcelExporter';
  }

  static get defaultConfig() {
    return {

      exporterClass: ScheduleTableExporter,


      exporterConfig: null
    };
  }

}

ExcelExporter$1._$name = 'ExcelExporter';
GridFeatureManager.registerFeature(ExcelExporter$1, false, 'Scheduler');


class ResourceInfoColumn extends Column {
  static get type() {
    return 'resourceInfo';
  }

  static get fields() {
    return ['showEventCount', 'showRole', 'showImage', 'imagePath', 'validNames', 'defaultImageName', 'autoScaleThreshold'];
  }

  static get defaults() {
    return {

      showImage: true,


      showEventCount: true,


      showRole: false,


      imagePath: null,


      validNames: ['amit', 'angelo', 'arcady', 'arnold', 'celia', 'chang', 'dan', 'dave', 'emilia', 'george', 'gloria', 'henrik', 'hitomi', 'jong', 'kate', 'lee', 'linda', 'lisa', 'lola', 'macy', 'madison', 'malik', 'mark', 'maxim', 'mike', 'rob', 'steve'],


      defaultImageName: null,


      autoScaleThreshold: 40,
      field: 'name',
      htmlEncode: false,
      width: 140,
      cellCls: 'b-resourceinfo-cell',
      editor: VersionHelper.isTestEnv ? false : 'text'
    };
  }

  construct() {
    const me = this;
    super.construct(...arguments);

    if (me.grid.isPainted) {
      me.addErrorListener();
    } else {
      me.grid.on({
        paint: me.addErrorListener,
        thisObj: me,
        once: true
      });
    }
  }

  set imagePath(path) {
    this.set('imagePath', path);
  }

  get imagePath() {
    return this.get('imagePath') || this.grid.resourceImagePath;
  }

  set defaultImageName(name) {
    this.set('defaultImageName', name);
  }

  get defaultImageName() {
    return this.get('defaultImageName') || this.grid.defaultResourceImageName;
  }

  getImageURL(imageName) {
    return StringHelper.joinPaths([this.imagePath || '', imageName || '']);
  }

  addErrorListener() {
    EventHelper.on({
      element: this.grid.element,
      delegate: '.b-resource-image',
      error: event => this.setDefaultResourceImage(event.target),
      capture: true
    });
  }

  setDefaultResourceImage(target) {
    if (this.defaultImageName) {
      const defaultURL = this.getImageURL(this.defaultImageName);

      if (target.src && !target.src.endsWith(defaultURL.replace(/^[./]*/gm, ''))) {
        target.src = defaultURL;
      }
    }
  }

  template(record) {
    const me = this,
      {
        showImage,
        showRole,
        showEventCount
      } = me,
      roleField = typeof showRole === 'string' ? showRole : 'role',
      count = record.events.length,
      value = record.get(me.field);
    let imageUrl;

    if (showImage) {
      if (record.imageUrl) {
        imageUrl = record.imageUrl;
      } else {

        const imageName = typeof showImage === 'string' ? showImage : record.image || value && value.toLowerCase() + me.grid.resourceImageExtension || me.defaultImageName;
        imageUrl = me.getImageURL(imageName);

        if (!imageName.includes('.')) {

          if (!me.validNames || me.validNames.includes(imageName)) {
            imageUrl += me.grid.resourceImageExtension;
          } else {
            imageUrl = me.getImageURL(me.defaultImageName);
          }
        }
      }
    }

    return {
      class: 'b-resource-info',
      children: [imageUrl ? {
        tag: 'img',
        draggable: 'false',
        class: 'b-resource-image',
        src: imageUrl
      } : null, {
        tag: 'dl',
        children: [{
          tag: 'dt',
          html: value
        }, showRole ? {
          tag: 'dd',
          class: 'b-resource-role',
          html: record[roleField]
        } : null, showEventCount ? {
          tag: 'dd',
          class: 'b-resource-events',
          html: me.L('eventCountText', count)
        } : null]
      }]
    };
  }

  defaultRenderer({
                    grid,
                    record,
                    cellElement,
                    value,
                    isExport
                  }) {
    let result;

    if (record.meta.specialRow) {
      result = '';
    } else if (isExport) {
      result = value;
    } else {
      if (this.autoScaleThreshold && grid.rowHeight < this.autoScaleThreshold) {
        cellElement.style.fontSize = grid.rowHeight / 40 + 'em';
      } else {
        cellElement.style.fontSize = '';
      }

      result = this.template(record);
    }

    return result;
  }

}

ColumnStore.registerColumnType(ResourceInfoColumn);
ResourceInfoColumn._$name = 'ResourceInfoColumn';


class EndDateField extends DateField {
  static get $name() {
    return 'EndDateField';
  }

  static get defaultConfig() {
    return {

      project: null
    };
  }

  transformTimeValue(value) {
    const calendar = this.project && this.project.calendar;

    if (calendar) {
      const startOfTheDay = DateHelper.clearTime(value),
        startOfNextDay = DateHelper.add(startOfTheDay, 1, 'day'),

        latestTime = calendar.skipNonWorkingTime(startOfNextDay, false);

      if (DateHelper.isValidDate(latestTime) && DateHelper.isEqual(latestTime, startOfTheDay, 'day')) {
        return DateHelper.copyTimeValues(startOfTheDay, latestTime);
      }
    }

    return super.transformTimeValue(value);
  }

}

EndDateField._$name = 'EndDateField';
BryntumWidgetAdapterRegister.register('enddatefield', EndDateField);
BryntumWidgetAdapterRegister.register('enddate', EndDateField);

var ReadyStatePropagator = (Target => class extends (Target || Events(Base)) {
  get isReadyStatePropagator() {
    return true;
  }

  get canSave() {
    return true;
  }

  requestReadyStateChange() {
    this.trigger('readystatechange', {
      canSave: this.canSave
    });
  }


  get widgetClass() {
  }

});


var EventLoader = (Target => class extends (Target || Container) {
  getProject() {
    return this.record && this.record.getProject();
  }

  loadEvent(record) {
    this.record = record;
  }

  resetData() {
    this.record = null;
  }

  beforeSave() {
  }

  afterSave() {
    this.resetData();
  }

  beforeCancel() {
  }

  afterCancel() {
    this.resetData();
  }

  beforeDelete() {
  }

  afterDelete() {
    this.resetData();
  }


  get widgetClass() {
  }

});


var EventChangePropagator = (Target => class extends (Target || Events(Base)) {
  get isEventChangePropagator() {
    return true;
  }

  requestPropagation() {
    this.trigger('requestPropagation');
  }


  get widgetClass() {
  }

});


var TaskEditorTab = (Target => class extends Target {
  startConfigure(config) {
    if (config.extraItems && config.items) {
      config.items.push(...config.extraItems);
      config.items.sort((widgetA, widgetB) => (widgetA.index | 0) - (widgetB.index - 0));
    }

    super.afterConfigure();
  }


  get widgetClass() {
  }

});


class FormTab extends EventChangePropagator(TaskEditorTab(EventLoader(Container))) {
  static get $name() {
    return 'FormTab';
  }

  static get defaultConfig() {
    return {
      layoutStyle: {
        flexFlow: 'row wrap',
        alignItems: 'flex-start',
        alignContent: 'flex-start'
      },
      defaults: {
        labelWidth: '7em'
      }
    };
  }

  afterConfigure() {
    const me = this;
    super.afterConfigure();
    Object.values(me.widgetMap).forEach(w => {
      w.name && w.on('change', me.onWidgetValueChange, me);
    });
    LocaleManagerSingelton.on({
      locale: me.onLocaleChange,
      thisObj: me
    });
  }

  loadEvent(eventRecord) {
    this._loading = true;
    super.loadEvent(eventRecord);
    this._loading = false;
  }

  resetData() {
    this._loading = true;
    super.resetData();
    this._loading = false;
  }

  onWidgetValueChange({
                        source,
                        value,
                        checked,
                        valid
                      }) {
    const me = this,
      project = me.getProject();
    valid = valid !== undefined ? valid : typeof source.isValid === 'function' ? source.isValid() : source.isValid;

    if (!me._loading && valid && project && !project.isPropagating()) {
      const record = me.record,
        setterName = `set${StringHelper.capitalizeFirstLetter(source.name)}`;

      if (setterName in record || source.name in record || record.$[source.name]) {
        if (setterName in record) {
          record[setterName](value);
        } else if (source.name in record) {
          record[source.name] = value;
        } else {
          record.$[source.name].put(value);
        }

        me.requestPropagation();
      }
    }
  }

  onLocaleChange() {
    Object.values(this.widgetMap).forEach(w => {
      if (w instanceof Field && w.parent === this) {
        w.labelWidth = this.L('labelWidth');
      }
    });
  }

}

FormTab._$name = 'FormTab';


class StartDateField extends DateField {
  static get $name() {
    return 'StartDateField';
  }

  static get defaultConfig() {
    return {

      project: null
    };
  }

  transformTimeValue(value) {
    const calendar = this.project && this.project.calendar;

    if (calendar) {
      const startOfTheDay = DateHelper.clearTime(value),

        earliestTime = calendar.skipNonWorkingTime(startOfTheDay);

      if (DateHelper.isValidDate(earliestTime) && DateHelper.isEqual(earliestTime, startOfTheDay, 'day')) {
        return DateHelper.copyTimeValues(startOfTheDay, earliestTime);
      }
    }

    return super.transformTimeValue(value);
  }

}

StartDateField._$name = 'StartDateField';
BryntumWidgetAdapterRegister.register('startdatefield', StartDateField);
BryntumWidgetAdapterRegister.register('startdate', StartDateField);


class EffortField extends DurationField {
  static get $name() {
    return 'EffortField';
  }

  static get type() {
    return 'effort';
  }

}

EffortField._$name = 'EffortField';
BryntumWidgetAdapterRegister.register(EffortField.type, EffortField);
BryntumWidgetAdapterRegister.register(`${EffortField.type}field`, EffortField);


class GeneralTab extends FormTab {
  static get $name() {
    return 'GeneralTab';
  }

  static get type() {
    return 'generaltab';
  }

  static get defaultConfig() {
    return {
      localeClass: this,
      title: 'L{General}',
      ref: 'generaltab',
      defaults: {
        localeClass: this,
        labelWidth: this.L('labelWidth')
      },
      items: [{
        type: 'text',
        required: true,
        label: 'L{Name}',
        clearable: true,
        name: 'name',
        ref: 'nameField',
        cls: 'b-name'
      }, {
        type: 'number',
        label: 'L{% complete}',
        name: 'renderedPercentDone',
        ref: 'percentDoneField',
        cls: 'b-percent-done b-inline',
        flex: '1 0 50%',
        min: 0,
        max: 100
      }, {
        type: 'effort',
        label: 'L{Effort}',
        name: 'fullEffort',
        ref: 'effortField',
        flex: '1 0 50%'
      }, {
        html: '',
        dataset: {
          text: this.L('Dates')
        },
        cls: 'b-divider',
        flex: '1 0 100%'
      }, {
        type: 'startdate',
        label: 'L{Start}',
        name: 'startDate',
        ref: 'startDateField',
        cls: 'b-start-date b-inline',
        flex: '1 0 50%'
      }, {
        type: 'enddate',
        label: 'L{Finish}',
        name: 'endDate',
        ref: 'endDateField',
        cls: 'b-end-date',
        flex: '1 0 50%'
      }, {
        type: 'durationfield',
        label: 'L{Duration}',
        name: 'fullDuration',
        ref: 'fullDurationField',
        flex: '.5 0',
        cls: 'b-inline'
      }]
    };
  }

  loadEvent(record) {
    const step = {
        unit: record.durationUnit,
        magnitude: 1
      },
      {
        isParent
      } = record,
      {
        fullDurationField,
        percentDoneField,
        startDateField,
        endDateField,
        effortField
      } = this.widgetMap;

    if (fullDurationField) {
      fullDurationField.disabled = isParent;
    }

    if (percentDoneField) {
      percentDoneField.disabled = isParent;
    }

    if (startDateField) {
      startDateField.step = step;
    }

    if (endDateField) {
      endDateField.step = step;
      endDateField.disabled = isParent;
    }

    if (effortField) {
      effortField.unit = record.effortUnit;
      effortField.disabled = isParent;
    }

    super.loadEvent(record);
  }

}

GeneralTab._$name = 'GeneralTab';
BryntumWidgetAdapterRegister.register(GeneralTab.type, GeneralTab);


class ModelCombo extends Combo {
  static get $name() {
    return 'ModelCombo';
  }

  static get type() {
    return 'modelcombo';
  }

  get value() {
    const superValue = super.value,
      model = this.store.getById(superValue);
    return model || superValue;
  }

  set value(v) {
    super.value = v;
  }

}

ModelCombo._$name = 'ModelCombo';
BryntumWidgetAdapterRegister.register(ModelCombo.type, ModelCombo);


class CalendarField extends ModelCombo {
  static get $name() {
    return 'CalendarField';
  }

  static get type() {
    return 'calendarfield';
  }

  static get defaultConfig() {
    return {
      valueField: 'id',
      displayField: 'name',
      editable: false,
      listItemTpl: c => {
        return c && c.name ? c.name : this.L('Default calendar');
      },
      displayValueRenderer: c => {
        return c ? c.name : this.L('Default calendar');
      }
    };
  }

  get value() {
    return super.value;
  }

  set value(v) {
    if (v && v.isDefault && v.isDefault()) {
      v = null;
    }

    super.value = v;
  }

}

CalendarField._$name = 'CalendarField';
BryntumWidgetAdapterRegister.register(CalendarField.type, CalendarField);


class SchedulerGeneralTab extends GeneralTab {
  static get $name() {
    return 'SchedulerGeneralTab';
  }

  static get type() {
    return 'schedulergeneraltab';
  }

  static get defaultConfig() {
    return {
      localeClass: this,
      title: 'L{General}',
      ref: 'generaltab',
      defaults: {
        localeClass: this,
        labelWidth: this.L('labelWidth')
      },
      items: [{
        type: 'text',
        required: true,
        label: 'L{Name}',
        clearable: true,
        name: 'name',
        ref: 'nameField',
        cls: 'b-name'
      }, {
        type: 'number',
        label: 'L{% complete}',
        name: 'renderedPercentDone',
        ref: 'percentDoneField',
        cls: 'b-percent-done b-inline',
        flex: '1 0 50%',
        min: 0,
        max: 100
      }, {
        type: 'calendarfield',
        ref: 'calendarField',
        name: 'calendar',
        label: 'L{Calendar}',
        flex: '1 0 50%'
      }, {
        html: '',
        dataset: {
          text: this.L('Dates')
        },
        cls: 'b-divider',
        flex: '1 0 100%'
      }, {
        type: 'date',
        label: 'L{Start}',
        name: 'startDate',
        ref: 'startDateField',
        cls: 'b-start-date b-inline',
        flex: '1 0 50%'
      }, {
        type: 'date',
        label: 'L{Finish}',
        name: 'endDate',
        ref: 'endDateField',
        cls: 'b-end-date',
        flex: '1 0 50%'
      }, {
        type: 'durationfield',
        label: 'L{Duration}',
        name: 'fullDuration',
        ref: 'fullDurationField',
        flex: '1 0 50%',
        cls: 'b-inline'
      }, {
        type: 'checkbox',
        ref: 'manuallyScheduledField',
        name: 'manuallyScheduled',
        label: 'L{Manually scheduled}',
        flex: '1 0 50%'
      }]
    };
  }

  loadEvent(record) {
    const step = {
        unit: record.durationUnit,
        magnitude: 1
      },
      {
        isParent
      } = record,
      {
        fullDurationField,
        percentDoneField,
        startDateField,
        endDateField,
        calendarField
      } = this.widgetMap,
      firstLoad = !this.record;

    if (fullDurationField) {
      fullDurationField.disabled = isParent;
    }

    if (percentDoneField) {
      percentDoneField.disabled = isParent;
    }

    if (startDateField) {
      startDateField.step = step;
    }

    if (endDateField) {
      endDateField.step = step;
      endDateField.disabled = isParent;
    }

    if (calendarField && firstLoad) {
      calendarField.store = record.getProject().getCalendarManagerStore();
    }

    super.loadEvent(record);
  }

}

SchedulerGeneralTab._$name = 'SchedulerGeneralTab';
BryntumWidgetAdapterRegister.register(SchedulerGeneralTab.type, SchedulerGeneralTab);

var TimeUnit;

(function (TimeUnit) {
  TimeUnit["Millisecond"] = "millisecond";
  TimeUnit["Second"] = "second";
  TimeUnit["Minute"] = "minute";
  TimeUnit["Hour"] = "hour";
  TimeUnit["Day"] = "day";
  TimeUnit["Week"] = "week";
  TimeUnit["Month"] = "month";
  TimeUnit["Quarter"] = "quarter";
  TimeUnit["Year"] = "year";
})(TimeUnit || (TimeUnit = {}));

var ConstraintType;

(function (ConstraintType) {
  ConstraintType["MustStartOn"] = "muststarton";
  ConstraintType["MustFinishOn"] = "mustfinishon";
  ConstraintType["StartNoEarlierThan"] = "startnoearlierthan";
  ConstraintType["StartNoLaterThan"] = "startnolaterthan";
  ConstraintType["FinishNoEarlierThan"] = "finishnoearlierthan";
  ConstraintType["FinishNoLaterThan"] = "finishnolaterthan";
})(ConstraintType || (ConstraintType = {}));

var SchedulingMode;

(function (SchedulingMode) {
  SchedulingMode["Normal"] = "Normal";
  SchedulingMode["FixedDuration"] = "FixedDuration";
  SchedulingMode["FixedEffort"] = "FixedEffort";
  SchedulingMode["FixedUnits"] = "FixedUnits";
})(SchedulingMode || (SchedulingMode = {}));

var DependencyType;

(function (DependencyType) {
  DependencyType[DependencyType["StartToStart"] = 0] = "StartToStart";
  DependencyType[DependencyType["StartToEnd"] = 1] = "StartToEnd";
  DependencyType[DependencyType["EndToStart"] = 2] = "EndToStart";
  DependencyType[DependencyType["EndToEnd"] = 3] = "EndToEnd";
})(DependencyType || (DependencyType = {}));

var DependenciesCalendar;

(function (DependenciesCalendar) {
  DependenciesCalendar["Project"] = "Project";
  DependenciesCalendar["FromEvent"] = "FromEvent";
  DependenciesCalendar["ToEvent"] = "ToEvent";
})(DependenciesCalendar || (DependenciesCalendar = {}));

var ProjectType;

(function (ProjectType) {
  ProjectType[ProjectType["Unknown"] = 0] = "Unknown";
  ProjectType[ProjectType["Gantt"] = 1] = "Gantt";
  ProjectType[ProjectType["Scheduler"] = 2] = "Scheduler";
})(ProjectType || (ProjectType = {}));

var Direction;

(function (Direction) {
  Direction["Forward"] = "Forward";
  Direction["Backward"] = "Backward";
  Direction["None"] = "None";
})(Direction || (Direction = {}));


class SchedulerProCommon extends Localizable() {
}

SchedulerProCommon._$name = 'SchedulerProCommon';


const buildItems = items => items.map((item, index) => [index, item]);


class DependencyTypePicker extends Combo {
  static get $name() {
    return 'DependencyTypePicker';
  }

  static get type() {
    return 'dependencytypepicker';
  }

  construct(config) {
    super.construct(config);

    LocaleManagerSingelton.on({
      locale: ({
                 locale
               }) => {
        this.items = buildItems(locale.SchedulerProCommon.dependencyTypesLong);
      },
      thisObj: this
    });
  }

  get store() {
    if (!this._items) {
      this.items = this._items = buildItems(SchedulerProCommon.L('dependencyTypesLong'));
    }

    return super.store;
  }

  set store(store) {
    super.store = store;
  }

}

DependencyTypePicker._$name = 'DependencyTypePicker';
BryntumWidgetAdapterRegister.register(DependencyTypePicker.type, DependencyTypePicker);


class DurationColumn extends NumberColumn {
  static get type() {
    return 'duration';
  }

  static get isGanttColumn() {
    return true;
  }

  get durationUnitField() {
    return `${this.field}Unit`;
  }

  static get fields() {
    return [

      {
        name: 'decimalPrecision',
        defaultValue: null
      }];
  }

  static get defaults() {
    return {
      field: 'fullDuration',
      text: 'Duration',
      min: 0,
      step: 1,
      instantUpdate: true
    };
  }

  defaultRenderer({
                    record,
                    isExport
                  }) {
    const value = record[this.field],
      type = typeof value,
      durationValue = type === 'number' ? value : value && value.magnitude;

    if (typeof durationValue !== 'number') {
      return isExport ? '' : null;
    }

    switch (type) {

      case 'number':
        return this.round(durationValue) + ' ' + DateHelper.getLocalizedNameOfUnit(record[this.durationUnitField], value !== 1);


      case 'object':
        return this.round(durationValue) + ' ' + DateHelper.getLocalizedNameOfUnit(value.unit, value.magnitude !== 1);
    }
  }

  round(value) {
    let {
      decimalPrecision
    } = this;

    if (decimalPrecision === false) {
      return value;
    }

    if (decimalPrecision == null) {
      decimalPrecision = this.grid.durationDisplayPrecision || 1;
    }

    const multiplier = Math.pow(10, decimalPrecision);
    return Math.round(value * multiplier) / multiplier;
  }

  get defaultEditor() {
    return {
      type: 'duration',
      name: this.field
    };
  }

  canEdit(record) {
    return record.isLeaf;
  }

}

ColumnStore.registerColumnType(DurationColumn);
DurationColumn._$name = 'DurationColumn';


const markDependencyValid = (dep, grid) => {
  dep.instanceMeta(grid).valid = true;
};

const markDependencyInvalid = (dep, grid) => {
  dep.instanceMeta(grid).valid = false;
};

const isDependencyMarkedValid = (dep, grid) => {
  return dep.instanceMeta(grid).valid !== false;
};


class DependencyTab extends ReadyStatePropagator(EventChangePropagator(TaskEditorTab(EventLoader(Delayable(Container))))) {
  static get $name() {
    return 'DependencyTab';
  }

  static makeDefaultConfig(direction) {
    const ref = direction === 'fromEvent' ? 'predecessorstab' : 'successorstab',
      negDirection = direction === 'fromEvent' ? 'toEvent' : 'fromEvent';
    return {
      direction,
      negDirection,
      ref,
      localeClass: this,
      title: direction === 'fromEvent' ? 'L{Predecessors}' : 'L{Successors}',
      layoutStyle: {
        flexFlow: 'column nowrap'
      },
      items: [{
        type: 'container',
        flex: '0 0 auto',
        items: [{
          type: 'button',
          cls: 'b-add-button b-green',
          icon: 'b-icon b-icon-add',
          ref: `${ref}-add`
        }, {
          type: 'button',
          cls: 'b-remove-button b-red',
          icon: 'b-icon b-icon-trash',
          disabled: true,
          ref: `${ref}-remove`
        }]
      }, {
        type: 'grid',
        flex: '1 1 auto',
        ref: `${ref}-grid`,
        emptyText: '',
        columns: [{
          localeClass: this,
          text: 'L{ID}',
          flex: 1,
          editor: false,
          htmlEncode: false,

          renderer({
                     record: dependency,
                     row,
                     grid
                   }) {
            let html;

            if (isDependencyMarkedValid(dependency, grid)) {
              const event = dependency[direction];
              html = !event || event.hasGeneratedId ? '*' : event.id;
            } else {
              row.addCls('b-invalid');
              html = '<div class="b-icon b-icon-warning"></div>';
            }

            return html;
          }

        }, {
          localeClass: this,
          text: 'L{Name}',
          field: direction,
          flex: 5,

          renderer({
                     value
                   }) {
            return value && value.name || '';
          },

          editor: {
            type: 'modelcombo',
            displayField: 'name',
            valueField: 'id',
            editable: false,
            allowInvalid: true
          }
        }, {
          localeClass: this,
          text: 'L{Type}',
          field: 'type',
          flex: 3,
          editor: 'dependencytypepicker',

          renderer({
                     value
                   }) {
            return SchedulerProCommon.L('dependencyTypesLong')[value];
          }

        }, {
          localeClass: this,
          text: 'L{Lag}',
          type: 'duration',
          field: 'fullLag',
          flex: 2,
          editor: {
            allowNegative: true
          }
        }],
        disableGridRowModelWarning: true
      }]
    };
  }

  afterConstruct() {
    super.afterConstruct();
    const me = this,
      addButton = me.addButton = me.widgetMap[`${me.ref}-add`],
      removeButton = me.removeButton = me.widgetMap[`${me.ref}-remove`],
      grid = me.grid = me.widgetMap[`${me.ref}-grid`];
    addButton && addButton.on('click', me.onAddClick, me);
    removeButton && removeButton.on('click', me.onRemoveClick, me);
    grid.on({
      selectionChange: me.onGridSelectionChange,
      startCellEdit: me.onGridStartCellEdit,
      finishCellEdit: me.onGridFinishCellEdit,
      cancelCellEdit: me.onGridCancelCellEdit,
      thisObj: me
    });
  }

  get dependencyGrid() {
    return this.widgetMap && this.widgetMap[`${this.ref}-grid`];
  }

  get taskCombo() {
    const grid = this.dependencyGrid,
      from = grid && grid.columns.get(this.direction);
    return from && from.editor;
  }

  loadEvent(eventRecord) {
    const me = this,
      grid = me.dependencyGrid,
      firstLoad = !grid.store.chained,
      recordChange = !firstLoad && eventRecord !== me.record;
    super.loadEvent(eventRecord);
    const taskCombo = me.taskCombo,
      depStore = me.getProject().getDependencyStore(),
      eventStore = me.getProject().getEventStore();


    if (firstLoad) {


      me.depStoreGeneration = depStore.storage.generation;
      me.eventStoreGeneration = eventStore.storage.generation;
      grid.store = depStore.makeChained(d => d[me.negDirection] === me.record, null);
      taskCombo.store = eventStore.makeChained(
        e => e !== me.record, null, {
          doRelayToMaster: [],

          excludeCollapsedRecords: false
        });


      taskCombo.store.filterBy(e => !grid.store.find(d => d[me.direction] === e));
      taskCombo.on({
        thisObj: me,
        change: 'onGridCellEditChange'
      });
    } else {


      if (recordChange || depStore.storage.generation !== me.depStoreGeneration) {
        grid.store.fillFromMaster();
        me.depStoreGeneration = depStore.storage.generation;
      }

      if (recordChange || eventStore.storage.generation !== me.eventStoreGeneration) {
        taskCombo.store.fillFromMaster();
        me.eventStoreGeneration = eventStore.storage.generation;
      }
    }

    me.requestReadyStateChange();
  }

  unshadowAll() {
    this.dependencyGrid.store.forEach(d => {
      if (d.isShadowed) {
        d.forEachFieldAtom(a => {
          a.clearUserInput();
        });
        markDependencyValid(d, this.dependencyGrid);
        d.unshadow();
      }
    });
  }

  beforeSave() {
    this.unshadowAll();
    super.beforeSave();
  }

  beforeCancel() {
    const activeCellEdit = this._activeCellEdit;

    if (activeCellEdit) {


      activeCellEdit.editor.cancelEdit();
    }

    this.unshadowAll();
    super.beforeCancel();
  }

  async insertNewDependency() {
    const me = this,
      grid = me.dependencyGrid,
      depStore = grid.store,
      projectDepStore = me.getProject().getDependencyStore();

    const [newDep] = depStore.insert(0, {
      type: DependencyType.EndToStart,
      lag: 0,
      lagUnit: TimeUnit.Day,
      [me.negDirection]: me.record
    });

    me.depStoreGeneration = projectDepStore.storage.generation;
    grid.features.cellEdit.startEditing({
      field: me.direction,
      id: newDep.id
    });
    markDependencyInvalid(newDep, grid);
    return newDep;
  }

  onAddClick() {
    this.insertNewDependency();
  }

  onRemoveClick() {
    const me = this,
      toRemove = me.dependencyGrid.selectedRecords,
      needPropagation = toRemove.some(r => !r.isShadowed());
    me.getProject().getDependencyStore().remove(toRemove);
    me.dependencyGrid.selectedRecords = null;
    me.taskCombo.store.fillFromMaster();
    me.removeButton.disable();

    if (needPropagation) {
      me.requestPropagation();
    }
  }

  onGridSelectionChange({
                          selection
                        }) {
    if (selection && selection.length) {
      this.removeButton.enable();
    } else {
      this.removeButton.disable();
    }
  }

  clearActiveEditorErrors() {
    const me = this,
      activeCellEdit = me._activeCellEdit;

    if (activeCellEdit && activeCellEdit.column.field === me.direction) {
      activeCellEdit.editor.inputField.clearError();
    }
  }

  onGridCellEditChange() {


    this.clearActiveEditorErrors();
  }

  onGridStartCellEdit({
                        editorContext
                      }) {
    const me = this,
      dep = me._editingDependency = editorContext.record,
      depGrid = me.dependencyGrid,
      dir = me.direction;
    me._activeCellEdit = editorContext;

    if (editorContext.column.field === dir) {
      if (!isDependencyMarkedValid(dep, depGrid)) {
        if (!dep[dir]) {
          editorContext.editor.inputField.setError(me.L('Invalid dependency'));
        } else {
          editorContext.editor.inputField.setError(me.L('Cyclic dependency has been detected'));
        }
      } else {
        me.clearActiveEditorErrors();
      }

      dep.shadow();
    }
  }

  onGridFinishCellEdit({
                         editorContext
                       }) {
    const me = this,
      {
        record: dependency,
        column
      } = editorContext,
      dir = me.direction,
      depGrid = me.dependencyGrid;

    if (column.field === dir) {
      if (dependency[dir]) {
        const projectDepStore = me.getProject().getDependencyStore();
        projectDepStore.isValidDependency({
          [me.direction]: dependency[me.direction],
          [me.negDirection]: dependency[me.negDirection],
          lag: dependency.lag,
          lagUnit: dependency.lagUnit,
          type: dependency.type
        }).then(valid => {
          if (valid) {
            markDependencyValid(dependency, me.dependencyGrid);
            dependency.unshadow();
            me.taskCombo.store.fillFromMaster();
            me.redrawDependencyRow(dependency);

            me.requestPropagation();
            me.requestReadyStateChange();
          } else {
            markDependencyInvalid(dependency, depGrid);
            me.redrawDependencyRow(dependency);
            Toast.show({
              html: me.L('Cyclic dependency has been detected')
            });
            me.requestReadyStateChange();
          }
        });
      } else {
        markDependencyInvalid(dependency, depGrid);
        me.redrawDependencyRow(dependency);
        me.requestReadyStateChange();
      }
    } else {
      me.redrawDependencyRow(dependency);

      if (dependency[dir] && isDependencyMarkedValid(dependency, depGrid)) {
        dependency.unshadow();
        me.requestPropagation();
      }

      me.requestReadyStateChange();
    }

    me._activeCellEdit = me._editingDependency = null;
  }

  onGridCancelCellEdit(data) {
    const me = this;

    if (me._editingDependency) {
      const dep = me._editingDependency,
        depGrid = me.dependencyGrid;

      if (!dep[me.direction]) {
        markDependencyInvalid(dep, depGrid);
        me.redrawDependencyRow(dep);
      } else if (isDependencyMarkedValid(dep, depGrid)) {
        dep.unshadow();
      }

      me._activeCellEdit = me._editingDependency = null;
    }

    me.requestReadyStateChange();
  }

  redrawDependencyRow(dep) {
    const grid = this.dependencyGrid,
      row = grid.rowManager.getRowById(dep);

    row && row.render(grid.store.indexOf(dep), dep);
  }

  get canSave() {
    const depGrid = this.dependencyGrid;
    return depGrid.store.reduce((r, d) => r && isDependencyMarkedValid(d, depGrid), true);
  }

}

DependencyTab._$name = 'DependencyTab';


class SuccessorsTab extends DependencyTab {
  static get $name() {
    return 'SuccessorsTab';
  }

  static get type() {
    return 'successorstab';
  }

  static get defaultConfig() {
    return Object.assign(this.makeDefaultConfig('toEvent'), {
      cls: 'b-successors-tab'
    });
  }

}

SuccessorsTab._$name = 'SuccessorsTab';
BryntumWidgetAdapterRegister.register(SuccessorsTab.type, SuccessorsTab);


class PredecessorsTab extends DependencyTab {
  static get $name() {
    return 'PredecessorsTab';
  }

  static get type() {
    return 'predecessorstab';
  }

  static get defaultConfig() {
    return Object.assign(this.makeDefaultConfig('fromEvent'), {
      cls: 'b-predecessors-tab'
    });
  }

}

PredecessorsTab._$name = 'PredecessorsTab';
BryntumWidgetAdapterRegister.register(PredecessorsTab.type, PredecessorsTab);


class ResourcesTab extends EventChangePropagator(TaskEditorTab(EventLoader(Container))) {
  static get $name() {
    return 'ResourcesTab';
  }

  static get type() {
    return 'resourcestab';
  }

  static get defaultConfig() {
    return {
      localeClass: this,
      ref: 'resourcestab',
      title: 'L{Resources}',
      layoutStyle: {
        flexFlow: 'column nowrap'
      },
      items: [{
        type: 'container',
        flex: '0 0 auto',
        items: [{
          type: 'button',
          cls: 'b-add-button b-green',
          icon: 'b-icon b-icon-add',
          ref: 'resourcestab-add'
        }, {
          type: 'button',
          cls: 'b-remove-button b-red',
          icon: 'b-icon b-icon-trash',
          disabled: true,
          ref: 'resourcestab-remove'
        }]
      }, {
        type: 'grid',
        flex: '1 1 auto',
        ref: 'resourcestab-grid',
        columns: [{
          localeClass: this,
          text: 'L{Resource}',
          field: 'resource',
          flex: 7,
          renderer: ({
                       value
                     }) => {
            return value && value.name || '';
          },
          editor: {
            type: 'modelcombo',
            displayField: 'name',
            valueField: 'id',
            editable: false
          }
        }, {
          localeClass: this,
          text: 'L{Units}',
          field: 'units',
          flex: 3,
          renderer: data => {
            return this.L('unitsTpl', data);
          },
          editor: {
            type: 'numberfield',
            min: 0,
            max: 100,
            step: 10
          }
        }],
        disableGridRowModelWarning: true
      }]
    };
  }

  afterConstruct() {
    super.afterConstruct();
    const me = this,
      addButton = me.addButton = me.widgetMap['resourcestab-add'],
      removeButton = me.removeButton = me.widgetMap['resourcestab-remove'],
      grid = me.grid = me.widgetMap['resourcestab-grid'];
    addButton && addButton.on('click', me.onAddClick, me);
    removeButton && removeButton.on('click', me.onRemoveClick, me);
    grid.on({
      selectionChange: me.onGridSelectionChange,
      startCellEdit: me.onGridStartCellEdit,
      finishCellEdit: me.onGridFinishCellEdit,
      thisObj: me
    });
  }

  get assignmentGrid() {
    return this.widgetMap && this.widgetMap['resourcestab-grid'];
  }

  get resourceCombo() {
    const grid = this.assignmentGrid,
      from = grid && grid.columns.get('resource');
    return from && from.editor;
  }

  loadEvent(eventRecord) {
    const me = this,
      grid = me.assignmentGrid,
      firstLoad = !grid.store.chained,
      recordChange = !firstLoad && eventRecord !== me.record;
    super.loadEvent(eventRecord);
    const resourceCombo = me.resourceCombo,
      assignmentStore = me.getProject().getAssignmentStore(),
      resourceStore = me.getProject().getResourceStore();

    if (firstLoad) {


      me.assignmentStoreGeneration = assignmentStore.storage.generation;
      me.resourceStoreGeneration = resourceStore.storage.generation;
      grid.store = assignmentStore.makeChained(a => me.record && a.event === me.record, ['resource']);
      resourceCombo.store = resourceStore.makeChained(resource => {
        return me.record && !me.record.isAssignedTo(resource) || !me.activeAssignment || me.activeAssignment.resource === resource;
      });
    } else {


      if (recordChange || assignmentStore.storage.generation !== me.assignmentStoreGeneration) {
        grid.store.fillFromMaster();
      }

      if (recordChange || resourceStore.storage.generation !== me.resourceStoreGeneration) {
        resourceCombo.store.fillFromMaster();
      }
    }
  }

  get activeAssignment() {
    return this.assignmentGrid.features.cellEdit.activeRecord;
  }

  async insertNewAssignment() {
    const me = this,
      project = me.getProject(),
      assignmentStore = project.getAssignmentStore(),
      grid = me.assignmentGrid;
    const [newAssignment] = assignmentStore.insert(0, {
      event: me.record,
      resource: null,
      units: 100
    });

    me.assignmentStoreGeneration = assignmentStore.storage.generation;
    grid.features.cellEdit.startEditing({
      field: 'resource',
      id: newAssignment.id
    });
    return newAssignment;
  }

  onAddClick() {
    this.insertNewAssignment();
  }

  onRemoveClick() {
    const me = this;
    me.assignmentGrid.store.remove(me.assignmentGrid.selectedRecords);
    me.assignmentGrid.selectedRecords = null;
    me.removeButton.disable();
    me.requestPropagation();
  }

  onGridSelectionChange({
                          selection
                        }) {
    if (selection && selection.length) {
      this.removeButton.enable();
    } else {
      this.removeButton.disable();
    }
  }

  onGridStartCellEdit({
                        editorContext
                      }) {
    if (editorContext.column.field === 'resource') {
      this.resourceCombo.store.fillFromMaster();
      this._editingAssignment = editorContext.record;
    }
  }

  onGridFinishCellEdit() {
    const me = this;

    if (me._editingAssignment) {
      if (me._editingAssignment.resource) {
        me.requestPropagation();
      }

      me._editingAssignment = null;
    } else {
      me.requestPropagation();
    }
  }

  pruneInvalidAssignments() {
    const store = this.assignmentGrid.store;
    store.remove(store.query(a => !a.isValid));
  }

}

ResourcesTab._$name = 'ResourcesTab';
BryntumWidgetAdapterRegister.register(ResourcesTab.type, ResourcesTab);


class ConstraintTypePicker extends Combo {
  static get $name() {
    return 'ConstraintTypePicker';
  }

  static get type() {
    return 'constrainttypepicker';
  }

  updateLocalization() {
    super.updateLocalization();

    this.store.data = this.buildStoreData();
  }

  buildStoreData() {
    const me = this;

    return [{
      'id': 'none',
      text: me.L('None')
    }, {
      'id': 'muststarton',
      text: me.L('muststarton')
    }, {
      'id': 'mustfinishon',
      text: me.L('mustfinishon')
    }, {
      'id': 'startnoearlierthan',
      text: me.L('startnoearlierthan')
    }, {
      'id': 'startnolaterthan',
      text: me.L('startnolaterthan')
    }, {
      'id': 'finishnoearlierthan',
      text: me.L('finishnoearlierthan')
    }, {
      'id': 'finishnolaterthan',
      text: me.L('finishnolaterthan')
    }];
  }

  set value(value) {
    super.value = value;
  }

  get value() {
    const value = super.value;
    return value === 'none' ? null : value;
  }

  get store() {
    if (!this._store) {
      this.store = new Store({
        data: this.buildStoreData(),
        allowNullId: true
      });
    }

    return this._store;
  }

  set store(store) {
    super.store = store;
  }

}

ConstraintTypePicker._$name = 'ConstraintTypePicker';
BryntumWidgetAdapterRegister.register(ConstraintTypePicker.type, ConstraintTypePicker);


class SchedulingModePicker extends Combo {
  static get $name() {
    return 'SchedulingModePicker';
  }

  static get type() {
    return 'schedulingmodecombo';
  }

  buildStoreData() {
    return [{
      id: SchedulingMode.Normal,
      text: this.L('Normal')
    }, {
      id: SchedulingMode.FixedDuration,
      text: this.L('Fixed Duration')
    }, {
      id: SchedulingMode.FixedUnits,
      text: this.L('Fixed Units')
    }, {
      id: SchedulingMode.FixedEffort,
      text: this.L('Fixed Effort')
    }];
  }

  get store() {
    if (!this._store) {
      this.store = new Store({
        data: this.buildStoreData()
      });
    }

    return this._store;
  }

  set store(store) {
    super.store = store;
  }

  updateLocalization() {
    super.updateLocalization();

    this.store.data = this.buildStoreData();
  }

}

SchedulingModePicker._$name = 'SchedulingModePicker';
BryntumWidgetAdapterRegister.register(SchedulingModePicker.type, SchedulingModePicker);


class AdvancedTab extends FormTab {
  static get $name() {
    return 'AdvancedTab';
  }

  static get type() {
    return 'advancedtab';
  }

  static get defaultConfig() {
    return {
      localeClass: this,
      title: 'L{Advanced}',
      ref: 'advancedtab',
      defaults: {
        localeClass: this,
        labelWidth: this.L('labelWidth')
      },
      items: [{
        type: 'calendarfield',
        ref: 'calendarField',
        name: 'calendar',
        label: 'L{Calendar}',
        flex: '1 0 50%',
        cls: 'b-inline'
      }, {
        type: 'checkbox',
        ref: 'manuallyScheduledField',
        name: 'manuallyScheduled',
        label: 'L{Manually scheduled}',
        flex: '1 0 50%'
      }, {
        type: 'schedulingmodecombo',
        ref: 'schedulingModeField',
        name: 'schedulingMode',
        label: 'L{Scheduling mode}',
        flex: '1 0 50%',
        cls: 'b-inline'
      }, {
        type: 'checkbox',
        ref: 'effortDrivenField',
        name: 'effortDriven',
        label: 'L{Effort driven}',
        flex: '1 0 50%'
      }, {
        html: '',
        dataset: {
          text: this.L('Constraint')
        },
        cls: 'b-divider',
        flex: '1 0 100%'
      }, {
        type: 'constrainttypepicker',
        ref: 'constraintTypeField',
        name: 'constraintType',
        label: 'L{Constraint type}',
        clearable: true,
        flex: '1 0 50%',
        cls: 'b-inline'
      }, {
        type: 'date',
        ref: 'constraintDateField',
        name: 'constraintDate',
        label: 'L{Constraint date}',
        flex: '1 0 50%',
        cls: 'b-inline'
      }, {
        type: 'checkbox',
        ref: 'rollupField',
        name: 'rollup',
        label: 'L{Rollup}',
        flex: '1 0 50%',
        cls: 'b-inline'
      }]
    };
  }

  get calendarField() {
    return this.widgetMap.calendarField;
  }

  get constraintTypeField() {
    return this.widgetMap.constraintTypeField;
  }

  get constraintDateField() {
    return this.widgetMap.constraintDateField;
  }

  loadEvent(eventRecord) {
    const me = this,
      firstLoad = !me.record;
    const calendarField = this.calendarField;

    if (calendarField && firstLoad) {
      calendarField.store = eventRecord.getProject().getCalendarManagerStore();
    }

    super.loadEvent(eventRecord);
  }

}

AdvancedTab._$name = 'AdvancedTab';
BryntumWidgetAdapterRegister.register(AdvancedTab.type, AdvancedTab);


class NotesTab extends FormTab {
  static get $name() {
    return 'NotesTab';
  }

  static get type() {
    return 'notestab';
  }

  static get defaultConfig() {
    return {
      localeClass: this,
      title: 'L{Notes}',
      ref: 'notestab',
      layoutConfig: {
        alignItems: 'flex-start',
        alignContent: 'stretch'
      },
      items: [{
        type: 'textareafield',
        cls: 'b-taskeditor-notes-field',
        name: 'note'
      }]
    };
  }

}

NotesTab._$name = 'NotesTab';
BryntumWidgetAdapterRegister.register(NotesTab.type, NotesTab);


class TaskEditorBase extends ReadyStatePropagator(Popup) {
  static get $name() {
    return 'TaskEditorBase';
  }

  static get defaultConfig() {
    return {
      localeClass: this,
      title: 'L{Information}',
      width: this.L('editorWidth'),
      cls: 'b-schedulerpro-taskeditor',
      closable: true,
      draggable: {
        handleSelector: ':not(button,.b-field-inner)'

      },
      axisLock: 'flexible',
      autoClose: true,
      onChange: null,
      onCancel: null,
      onSave: null,
      autoShow: false,

      height: '30em',
      closeAction: 'cancelAndHide',
      items: null,

      bbar: [{
        localeClass: this,
        text: 'L{Save}',
        type: 'button',
        color: 'b-green',
        ref: 'saveButton'
      }, {
        localeClass: this,
        text: 'L{Delete}',
        type: 'button',
        color: 'b-gray',
        ref: 'deleteButton'
      }, {
        localeClass: this,
        text: 'L{Cancel}',
        type: 'button',
        color: 'b-gray',
        ref: 'cancelButton'
      }],


      durationDecimalPrecision: 1,


      extraItems: null,


      tabsConfig: null,


      extraWidgets: null,
      defaultTabs: null,
      project: null
    };
  }

  get extraWidgets() {
    console.warn('`extraWidgets` was deprecated in 1.0.1, please change your code to use `extraItems`');
    return this.extraItems;
  }

  set extraWidgets(widgets) {
    console.warn('`extraWidgets` was deprecated in 1.0.1, please change your code to use `extraItems`');
    this.extraItems = widgets;
  }

  processWidgetConfig(widgetConfig) {

    switch (widgetConfig.ref) {
      case 'startDateField':
      case 'endDateField':
        widgetConfig.project = this.project;
        break;

      case 'fullDurationField':
        widgetConfig.decimalPrecision = this.durationDecimalPrecision;
        break;

      case 'predecessorstab-grid':
      case 'successorstab-grid':
        widgetConfig.durationDisplayPrecision = this.durationDisplayPrecision;
        break;

      case 'tabs':
        widgetConfig.items.forEach(cfg => {
          cfg.extraItems = (this.extraItems || {})[cfg.type];
        });
        break;
    }

    if (widgetConfig.ref === 'deleteButton' && !this.showDeleteButton) return false;
    return widgetConfig;
  }

  startConfigure(config) {
    const tabsConfig = config.tabsConfig || {},
      tabs = ObjectHelper.clone(config.defaultTabs);
    Object.keys(tabsConfig).forEach(tabType => {
      let index;
      const config = tabsConfig[tabType],
        tab = tabs.find((t, i) => {
          index = i;
          return (tabType || '').toLowerCase() === t.type;
        });

      if (tab) {

        if (config === false) {
          tabs.splice(index, 1);
        } else if (typeof config === 'object') {
          Object.assign(tab, config);
        }
      } else {
        tabs.push(config);
      }
    });

    config.items[0].items = tabs;
    super.startConfigure(config);
  }

  afterConfigure() {
    const me = this,
      widgetMap = me.widgetMap,
      bbarWidgets = me.bbar && me.bbar.widgetMap || {},
      {
        cancelButton,
        deleteButton,
        saveButton
      } = bbarWidgets;
    saveButton && saveButton.on('click', me.onSaveClick, me);
    cancelButton && cancelButton.on('click', me.onCancelClick, me);
    deleteButton && deleteButton.on('click', me.onDeleteClick, me);
    Object.values(widgetMap).forEach(w => {
      if (w.isEventChangePropagator) {
        w.on('requestPropagation', me.onPropagationRequested, me);
      }

      if (w.isReadyStatePropagator) {
        w.on('readystatechange', me.onReadyStateChange, me);
      }
    });
    LocaleManagerSingelton.on({
      locale: me.onLocaleChange,
      thisObj: me
    });
  }

  onSaveClick() {
    if (this.canSave) {
      this.trigger('save');
    } else {
      Toast.show({
        html: this.L('Can\'t save, please correct errors first.')
      });
    }
  }

  onCancelClick() {
    this.trigger('cancel');
  }

  onDeleteClick() {
    this.trigger('delete');
  }

  onPropagationRequested() {
    this.trigger('requestPropagation');
  }

  onReadyStateChange({
                       source,
                       canSave
                     }) {
    this.requestReadyStateChange();

    if (!source.couldSaveTitle) {
      source.couldSaveTitle = source.title;
    }

    if (source.parent === this.widgetMap.tabs) {
      if (canSave) {
        source.titleElement.classList.remove('b-invalid');
        source.title = source.couldSaveTitle;
        source.couldSaveTitle = null;
      } else {
        source.titleElement.classList.add('b-invalid');
        source.title = `<span class='b-icon b-icon-warning'></span>${source.couldSaveTitle}`;
      }
    }
  }

  get canSave() {
    let canSave = true;

    Object.values(this.widgetMap).forEach(w => {
      if (w.isReadyStatePropagator) {
        canSave = canSave && w.canSave;
      }
    });
    return canSave;
  }

  get canCancel() {
    let canCancel = true;

    Object.values(this.widgetMap).forEach(w => {
      if (w.isReadyStatePropagator) {
        canCancel = canCancel && w.canCancel;
      }
    });
    return canCancel;
  }

  cancelAndHide() {


    this.onCancelClick();
  }


  loadEvent(record) {
    this.eachWidget(w => {
      if (typeof w.loadEvent === 'function') {
        w.loadEvent(record);
      }

      return true;
    });
  }

  beforeSave() {
    this.callWidgetHook('beforeSave');
  }

  afterSave() {
    this.callWidgetHook('afterSave');
  }

  beforeCancel() {
    this.callWidgetHook('beforeCancel');
  }

  afterCancel() {
    this.callWidgetHook('afterCancel');
  }

  beforeDelete() {
    this.callWidgetHook('beforeDelete');
  }

  afterDelete() {
    this.callWidgetHook('afterDelete');
  }

  callWidgetHook(name, args = []) {
    this.eachWidget(w => {
      if (typeof w[name] === 'function') {
        w[name](...args);
      }
    });
  }

  onInternalKeyDown(event) {
    if (event.key === 'Enter' && this.owner.features.taskEdit.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {
      if (event.target.matches('input')) {

        const field = IdHelper.fromElement(event.target);

        if (field && field.internalOnChange) {
          field.internalOnChange();
        }
      }


      event.preventDefault();
      this.onSaveClick();
    }

    super.onInternalKeyDown(event);
  }

  onLocaleChange() {
    this.width = this.L('editorWidth');
  }

}

TaskEditorBase._$name = 'TaskEditorBase';


class GanttTaskEditor extends TaskEditorBase {
  static get $name() {
    return 'GanttTaskEditor';
  }

  static get defaultConfig() {
    return {
      items: [{
        type: 'tabpanel',
        ref: 'tabs',
        flex: '1 0 100%',
        layoutConfig: {
          alignItems: 'stretch',
          alignContent: 'stretch'
        },
        items: []
      }],
      defaultTabs: [{
        type: 'generaltab'
      }, {
        type: 'successorstab'
      }, {
        type: 'predecessorstab'
      }, {
        type: 'resourcestab'
      }, {
        type: 'advancedtab'
      }, {
        type: 'notestab'
      }]
    };
  }

}

GanttTaskEditor._$name = 'GanttTaskEditor';


var ProAssignmentAPI = (Target => class ProAssignmentAPI extends (Target || Base) {

  addAssignment({
                  event,
                  resource,
                  assignmentStore,
                  assignmentConfig
                }) {
    const result = {
      assignment: assignmentStore.add(Object.assign({}, assignmentConfig, {
        event: event,
        resource: resource
      }))[0]
    };
    result.propagationPromise = assignmentStore.getProject().propagate();
    return result;
  }

  removeAssignments(records, removeUnassignedEvent) {
    const removedEvents = new Set();
    records.forEach(assignment => {
      const eventRecord = assignment.event;

      if (eventRecord && !eventRecord.placeHolder && removeUnassignedEvent) {
        const remainingAssignments = eventRecord.assignments;


        if (remainingAssignments.every(assignment => records.includes(assignment))) {
          if (!removedEvents.has(eventRecord.id)) {
            eventRecord.remove();
            removedEvents.add(eventRecord.id);
          }
        } else {
          assignment.remove();
        }
      }
    });
    return this.project.propagate();
  }

});


const throwIfNotTheSameStore = (oldStore, newStore) => {
  if (oldStore !== newStore) {
    throw new Error('Store set is prohibited for Scheduler Pro entity!');
  }
};


var PartOfProject = (Target => class PartOfProject extends (Target || Base) {


  static get relationConfig() {

    return [];
  }


  get taskStore() {
    return this.eventStore;
  }

  set taskStore(store) {
    this.eventStore = store;
  }


  get eventStore() {
    const project = this.getProject();
    return project && project.getEventStore() || null;
  }

  get leftProjectEventStore() {
    const project = this.leftProject;
    return project && project.getEventStore() || null;
  }

  set eventStore(store) {
    throwIfNotTheSameStore(this.eventStore, store);
  }


  get dependencyStore() {
    const project = this.getProject();
    return project && project.getDependencyStore() || null;
  }

  set dependencyStore(store) {
    throwIfNotTheSameStore(this.dependencyStore, store);
  }


  get assignmentStore() {
    const project = this.getProject();
    return project && project.getAssignmentStore() || null;
  }

  set assignmentStore(store) {
    throwIfNotTheSameStore(this.assignmentStore, store);
  }


  get resourceStore() {
    const project = this.getProject();
    return project && project.getResourceStore() || null;
  }

  set resourceStore(store) {
    throwIfNotTheSameStore(this.resourceStore, store);
  }


  get calendarManagerStore() {
    const project = this.getProject();
    return project && project.getCalendarManagerStore() || null;
  }

  set calendarManagerStore(store) {
    throwIfNotTheSameStore(this.calendarManagerStore, store);
  }

});

class Base$1 {
  initialize(props) {
    props && Object.assign(this, props);
  }

  static new(props) {
    const instance = new this();
    instance.initialize(props);
    return instance;
  }

}

var EffectResolutionResult;

(function (EffectResolutionResult) {
  EffectResolutionResult[EffectResolutionResult["Cancel"] = 0] = "Cancel";
  EffectResolutionResult[EffectResolutionResult["Restart"] = 1] = "Restart";
  EffectResolutionResult[EffectResolutionResult["Resume"] = 2] = "Resume";
})(EffectResolutionResult || (EffectResolutionResult = {}));

class Effect extends Base$1 {
}

class PromiseEffect extends Effect {
}

class CancelPropagationEffect extends Effect {
}

class RestartPropagationEffect extends Effect {
}

class GraphCycleDetectedEffect extends Effect {
}

var OnCycleAction;

(function (OnCycleAction) {
  OnCycleAction[OnCycleAction["Cancel"] = 0] = "Cancel";
  OnCycleAction[OnCycleAction["Resume"] = 1] = "Resume";
})(OnCycleAction || (OnCycleAction = {}));

class WalkContext extends Base$1 {
  onNode(node) {
  }

  onTopologicalNode(node) {
  }

  onCycle(node, stack) {
    return OnCycleAction.Cancel;
  }

}

const Walkable = base => class Walkable extends base {
  walkDepth(context) {
    const visitedAt = new Map();
    const visitedTopologically = new Set();
    const toVisit = [{
      node: this,
      from: this
    }];
    let depth;

    while (depth = toVisit.length) {
      const node = toVisit[depth - 1].node;

      if (visitedTopologically.has(node)) {
        toVisit.pop();
        continue;
      }

      const visitedAtDepth = visitedAt.get(node);

      if (visitedAtDepth != null) {
        if (visitedAtDepth < depth) {
          if (context.onCycle(node, toVisit) !== OnCycleAction.Resume) break;
        } else {
          visitedTopologically.add(node);
          context.onTopologicalNode(node);
        }

        toVisit.pop();
      } else {
        visitedAt.set(node, depth);
        context.onNode(node);
        const lengthBefore = toVisit.length;
        context.forEachNext(node, nextNode => toVisit.push({
          node: nextNode,
          from: node
        }));

        if (toVisit.length === lengthBefore) {
          visitedTopologically.add(node);
          context.onTopologicalNode(node);
          toVisit.pop();
        }
      }
    }
  }

};
const cycleInfo = stack => {
  const cycleSource = stack[stack.length - 1].node;
  const cycle = [cycleSource];
  let pos = stack.length - 1;
  let anotherNodePos = stack.length - 1;

  do {
    for (; pos >= 0 && stack[pos].from === stack[anotherNodePos].from; pos--) ;

    if (pos >= 0) {
      cycle.push(stack[pos].node);
      anotherNodePos = pos;
      pos--;
    }
  } while (pos >= 0 && stack[pos].node !== cycleSource);

  cycle.push(cycleSource);
  return cycle.reverse();
};

class WalkForwardContext extends WalkContext {
  forEachNext(node, func) {
    node.forEachOutgoing(this, func);
  }

}

const WalkableForward = base => {
  class WalkableForward extends base {
    forEachOutgoing(context, func) {
      this.getOutgoing(context).forEach(func);
    }

  }

  return WalkableForward;
};
const WalkableBackward = base => {
  class WalkableBackward extends base {
    forEachIncoming(context, func) {
      this.getIncoming(context).forEach(func);
    }

  }

  return WalkableBackward;
};

const WalkableForwardNode = base => class WalkableForwardNode extends base {
  constructor() {
    super(...arguments);
    this.outgoing = new Set();
  }

  hasEdgeTo(toNode) {
    return this.outgoing.has(toNode);
  }

  addEdgeTo(toNode) {
    this.outgoing.add(toNode);
  }

  removeEdgeTo(toNode) {
    this.outgoing.delete(toNode);
  }

  addEdgesTo(toNodes) {
    toNodes.forEach(toNode => this.addEdgeTo(toNode));
  }

  getOutgoing(context) {
    return Array.from(this.outgoing);
  }

  forEachOutgoing(context, func) {
    this.outgoing.forEach(func);
  }

};
const WalkableBackwardNode = base => class WalkableBackwardNode extends base {
  constructor() {
    super(...arguments);
    this.incoming = new Set();
  }

  hasEdgeFrom(fromNode) {
    return this.incoming.has(fromNode);
  }

  addEdgeFrom(fromNode) {
    this.incoming.add(fromNode);
  }

  removeEdgeFrom(fromNode) {
    this.incoming.delete(fromNode);
  }

  addEdgesFrom(fromNodes) {
    fromNodes.forEach(fromNode => this.addEdgeFrom(fromNode));
  }

  getIncoming(context) {
    return Array.from(this.incoming);
  }

  forEachIncoming(context, func) {
    this.incoming.forEach(func);
  }

};
const Node$1 = base => class Node extends base {
  addEdgeTo(toNode) {
    super.addEdgeTo(toNode);
    toNode.incoming.add(this);
  }

  removeEdgeTo(toNode) {
    super.removeEdgeTo(toNode);
    toNode.incoming.delete(this);
  }

  addEdgeFrom(fromNode) {
    super.addEdgeFrom(fromNode);
    fromNode.outgoing.add(this);
  }

  removeEdgeFrom(fromNode) {
    super.removeEdgeFrom(fromNode);
    fromNode.outgoing.delete(this);
  }

};

class MinimalNode extends Node$1(WalkableForwardNode(WalkableBackwardNode(WalkableForward(WalkableBackward(Walkable(Base$1)))))) {
}

const Graph = base => class Graph extends base {
  constructor() {
    super(...arguments);
    this.nodes = new Set();
  }

  getNodes() {
    return this.nodes;
  }

  hasDirectNode(node) {
    return this.getNodes().has(node);
  }

  addNodes(nodes) {
    nodes.forEach(node => this.addNode(node));
  }

  addNode(node) {
    this.nodes.add(node);
    return node;
  }

  removeNodes(nodes) {
    nodes.forEach(node => this.removeNode(node));
  }

  removeNode(node) {
    if (!this.hasDirectNode(node)) throw new Error(`This [${node}] does not exists in the graph`);
    node.outgoing.forEach(toNode => toNode.removeEdgeFrom(node));
    node.incoming.forEach(fromNode => fromNode.removeEdgeTo(node));
    this.nodes.delete(node);
  }

  getIncoming() {
    return Array.from(this.nodes);
  }

  getOutgoing() {
    return Array.from(this.nodes);
  }

  forEachIncoming(context, func) {
    this.nodes.forEach(func);
  }

  forEachOutgoing(context, func) {
    this.nodes.forEach(func);
  }

};

class MinimalGraph extends Graph(WalkableForwardNode(WalkableBackwardNode(WalkableForward(WalkableBackward(Walkable(Base$1)))))) {
}

const uppercaseFirst = str => str.slice(0, 1).toUpperCase() + str.slice(1);
const isAtomicValue = value => Object(value) !== value;
const lazyBuild = (target, property, value) => {
  Object.defineProperty(target, property, {
    value
  });
  return value;
};
const preWalk = (data, childrenFn, fn) => {
  let walkStack = [data],
    node,
    children;

  while (walkStack.length) {
    node = walkStack.pop();
    fn(node);
    children = childrenFn(node);

    if (children) {
      walkStack = walkStack.concat(children.slice().reverse());
    }
  }
};

var PropagationResult;

(function (PropagationResult) {
  PropagationResult[PropagationResult["Canceled"] = 0] = "Canceled";
  PropagationResult[PropagationResult["Completed"] = 1] = "Completed";
  PropagationResult[PropagationResult["Passed"] = 2] = "Passed";
})(PropagationResult || (PropagationResult = {}));

const ChronoGraph = base => class ChronoGraph extends base {
  constructor() {
    super(...arguments);
    this.nodesMap = new Map();
    this.needRecalculationAtoms = new Set();
    this.stableAtoms = new Set();
    this.isPropagating = false;
    this.propagateCompletedListeners = [];
    this.propagateSuspended = 0;
  }

  isAtomNeedRecalculation(atom) {
    return this.needRecalculationAtoms.has(atom);
  }

  markAsNeedRecalculation(atom) {
    this.needRecalculationAtoms.add(atom);
  }

  markProcessed(atom) {
    this.needRecalculationAtoms.delete(atom);
  }

  markStable(atom) {
    this.stableAtoms.add(atom);
  }

  isAtomStable(atom) {
    return this.stableAtoms.has(atom);
  }

  commit() {
    this.needRecalculationAtoms.forEach(atom => atom.clearUserInput());
    this.needRecalculationAtoms.clear();
    this.changedAtoms.forEach(atom => atom.commitValue());
    this.stableAtoms.forEach(atom => atom.commitEdges());
    this.stableAtoms.clear();
  }

  reject() {
    this.rejectPartialProgress();
    this.needRecalculationAtoms.forEach(atom => atom.clearUserInput());
    this.needRecalculationAtoms.clear();
  }

  rejectPartialProgress() {
    this.touchedAtoms.forEach((_, atom) => atom.reject());
    this.stableAtoms.clear();
  }

  addNode(node) {
    const res = super.addNode(node);
    this.nodesMap.set(node.id, node);
    this.markAsNeedRecalculation(node);
    node.onEnterGraph(this);
    return res;
  }

  removeNode(node) {
    node.outgoing.forEach(toNode => this.markAsNeedRecalculation(toNode));
    const res = super.removeNode(node);
    this.nodesMap.delete(node.id);
    this.needRecalculationAtoms.delete(node);
    this.stableAtoms.delete(node);
    node.onLeaveGraph(this);
    return res;
  }

  startAtomCalculation(sourceAtom) {
    const iterator = sourceAtom.calculate(sourceAtom.proposedValue);
    let iteratorValue = iterator.next();
    const value = iteratorValue.value;

    if (value instanceof Effect) {
      return {
        effect: value,
        continuation: {
          iterator: iterator
        }
      };
    } else if (iteratorValue.done) {
      return {
        value
      };
    } else {
      return {
        continuation: {
          atom: value,
          iterator: iterator
        }
      };
    }
  }

  continueAtomCalculation(sourceAtom, continuation, maybeDirtyAtoms) {
    const me = this,
      iterator = continuation.iterator;
    let incomingAtom = continuation.atom;

    do {
      let iteratorValue;

      if (incomingAtom) {
        sourceAtom.observedDuringCalculation.push(incomingAtom);

        if (maybeDirtyAtoms.has(incomingAtom) && !this.isAtomStable(incomingAtom)) {
          let cycle;
          me.walkDepth(WalkForwardContext.new({
            forEachNext: function (atom, func) {
              if (atom === me) {
                me.needRecalculationAtoms.forEach(func);
              } else {
                atom.observedDuringCalculation.forEach(func);
              }
            },
            onCycle: (node, stack) => {
              cycle = cycleInfo(stack);
              return OnCycleAction.Cancel;
            }
          }));
          iteratorValue = {
            value: GraphCycleDetectedEffect.new({
              cycle
            }),
            done: true
          };
        } else {
          iteratorValue = iterator.next(incomingAtom.hasNextStableValue() ? incomingAtom.getNextStableValue() : incomingAtom.getConsistentValue());
        }
      } else {
        iteratorValue = iterator.next();
      }

      const value = iteratorValue.value;

      if (value instanceof Effect) {
        return {
          effect: value,
          continuation: {
            iterator: iterator
          }
        };
      }

      if (iteratorValue.done) {
        return {
          value
        };
      }

      incomingAtom = value;
    } while (!maybeDirtyAtoms.has(incomingAtom) || this.isAtomStable(incomingAtom));

    return {
      continuation: {
        iterator,
        atom: incomingAtom
      }
    };
  }

  * propagateSingle() {
    const toCalculate = [];
    const maybeDirty = new Set();
    const me = this;
    let cycle = null;
    this.walkDepth(WalkForwardContext.new({
      forEachNext: function (atom, func) {
        if (atom === me) {
          me.needRecalculationAtoms.forEach(func);
        } else {
          WalkForwardContext.prototype.forEachNext.call(this, atom, func);
        }
      },
      onNode: atom => {
      },
      onCycle: (node, stack) => {
        cycle = cycleInfo(stack);
        return OnCycleAction.Cancel;
      },
      onTopologicalNode: atom => {
        if (atom === this) return;
        maybeDirty.add(atom);
        toCalculate.push(atom);
      }
    }));

    if (cycle) {
      return GraphCycleDetectedEffect.new({
        cycle
      });
    }

    let depth;
    const conts = this.touchedAtoms = new Map();
    const visitedAt = new Map();
    const changedAtoms = this.changedAtoms = [];

    while (depth = toCalculate.length) {
      const sourceAtom = toCalculate[depth - 1];

      if (this.isAtomStable(sourceAtom) || !maybeDirty.has(sourceAtom)) {
        toCalculate.pop();
        continue;
      }

      const visitedAtDepth = visitedAt.get(sourceAtom);
      let calcRes;

      if (visitedAtDepth != null) {
        const cont = conts.get(sourceAtom);
        calcRes = this.continueAtomCalculation(sourceAtom, cont, maybeDirty);
      } else {
        visitedAt.set(sourceAtom, depth);
        calcRes = this.startAtomCalculation(sourceAtom);
      }

      if (calcRes.effect) {
        yield calcRes.effect;
      }

      if (calcRes.continuation) {
        conts.set(sourceAtom, calcRes.continuation);
        const atom = calcRes.continuation.atom;

        if (atom) {
          sourceAtom.observedDuringCalculation.push(atom);
          toCalculate.push(atom);
        }
      } else {
        conts.set(sourceAtom, null);
        const consistentValue = calcRes.value;

        if (!sourceAtom.equality(consistentValue, sourceAtom.getConsistentValue())) {
          changedAtoms.push(sourceAtom);
          sourceAtom.nextStableValue = consistentValue;
        }

        this.markStable(sourceAtom);
        toCalculate.pop();
      }
    }

    return {
      success: true
    };
  }

  async onEffect(effect) {
    if (effect instanceof PromiseEffect) {
      await effect.promise;
      return EffectResolutionResult.Resume;
    }

    if (effect instanceof CancelPropagationEffect) {
      return EffectResolutionResult.Cancel;
    }

    if (effect instanceof RestartPropagationEffect) {
      return EffectResolutionResult.Restart;
    }

    if (effect instanceof GraphCycleDetectedEffect) {
      throw new Error('Graph cycle detected');
    }

    return EffectResolutionResult.Resume;
  }

  waitForPropagateCompleted() {
    if (!this.isPropagating) return Promise.resolve(null);
    return new Promise(resolve => {
      this.propagateCompletedListeners.push(resolve);
    });
  }

  suspendPropagate() {
    this.propagateSuspended++;
  }

  async resumePropagate(trigger) {
    if (this.propagateSuspended) {
      if (--this.propagateSuspended) {
        return this.resumePromise;
      } else if (this.resumePromise && trigger !== false) {
        return this.propagate();
      }
    }

    return Promise.resolve(PropagationResult.Completed);
  }

  async propagate(onEffect, dryRun = false) {
    const me = this;

    if (me.propagateSuspended) {
      if (!me.resumePromise) {
        me.resumePromise = new Promise((resolve, reject) => {
          me.resumeResolved = resolve;
          me.resumeRejected = reject;
        });
      }

      return me.resumePromise;
    } else {
      if (me.resumePromise) {
        const resolve = me.resumeResolved,
          reject = me.resumeRejected;
        me.resumePromise = me.resumeResolved = me.resumeRejected = null;
        return me.propagateUnsuspended(onEffect, dryRun).then(value => {
          resolve(value);
          return value;
        }, value => {
          reject(value);
          return value;
        });
      } else {
        return me.propagateUnsuspended(onEffect, dryRun);
      }
    }
  }

  async propagateUnsuspended(onEffect, dryRun = false) {
    if (this.isPropagating) throw new Error("Can not nest calls to `propagate`, use `waitForPropagateCompleted`");
    let needToRestart, result;
    this.isPropagating = true;

    do {
      needToRestart = false;
      const propagationIterator = this.propagateSingle();
      let iteratorValue;

      do {
        iteratorValue = propagationIterator.next();
        const value = iteratorValue.value;

        if (value instanceof Effect) {
          let resolutionResult;

          if (onEffect) {
            resolutionResult = await onEffect(value);
          } else {
            resolutionResult = await this.onEffect(value);
          }

          if (resolutionResult === EffectResolutionResult.Cancel) {
            if (typeof dryRun === 'function') {
              dryRun();
            }

            this.reject();
            this.isPropagating = false;
            await this.propagationCompletedHook();
            this.onPropagationCompleted(PropagationResult.Canceled);
            return PropagationResult.Canceled;
          } else if (resolutionResult === EffectResolutionResult.Restart) {
            this.rejectPartialProgress();
            needToRestart = true;
            break;
          }
        }
      } while (!iteratorValue.done);
    } while (needToRestart);

    if (dryRun) {
      if (typeof dryRun === 'function') {
        dryRun();
      }

      this.reject();
      this.isPropagating = false;
      await this.propagationCompletedHook();
      this.onPropagationCompleted(PropagationResult.Completed);
      result = PropagationResult.Passed;
    } else {
      this.commit();
      this.isPropagating = false;
      await this.propagationCompletedHook();
      this.onPropagationCompleted(PropagationResult.Completed);
      result = PropagationResult.Completed;
    }

    return result;
  }

  async tryPropagateWithNodes(onEffect, nodes, hatchFn) {
    if (nodes && nodes.length) {
      nodes = nodes.filter(n => n.graph !== this);

      if (nodes.length) {
        this.addNodes(nodes);
      }
    }

    const result = await this.propagate(onEffect, hatchFn || true);

    if (nodes && nodes.length) {
      nodes && this.removeNodes(nodes);
    }

    return result;
  }

  async propagationCompletedHook() {
  }

  onPropagationCompleted(result) {
    this.propagateCompletedListeners.forEach(listener => listener(result));
    this.propagateCompletedListeners = [];
  }

  commitAllEdges() {
    this.nodes.forEach(atom => atom.commitEdges());
  }

  toDotOnCycleException() {
    this.commitAllEdges();
    return this.toDot();
  }

  toDotAtomName(atom) {
    let [idGroup, idField] = String(atom.id).split('/');

    if (atom.self) {
      const entity = atom.self;

      if (entity.name) {
        idGroup = entity.name;
      }
    }

    return `${idGroup}/${idField || 'self'}`;
  }

  toDotAtomValue(atom) {
    let value;

    if (atom.newRefs && atom.oldRefs) {
      const collection = atom.get();
      value = `Set(${collection && collection.size || 0})`;
    } else {
      value = atom.get();
    }

    if (value instanceof Date) {
      value = [value.getFullYear(), '.', value.getMonth() + 1, '.', value.getDate(), ' ', value.getHours() + ':' + value.getMinutes()].join('');
    } else if (Array.isArray(value)) {
      value = `Array(${value.length})`;
    }

    return value;
  }

  toDotAtomColor(atom) {
    return !this.isAtomNeedRecalculation(atom) || this.isAtomStable(atom) ? 'darkgreen' : 'red';
  }

  toDotObtainCycle() {
    let cycle = {};
    this.walkDepth(WalkForwardContext.new({
      onCycle: (_node, stack) => {
        const ci = cycleInfo(stack);
        cycle = ci.reduce(([cycle, prevNode], curNode) => {
          if (prevNode) {
            cycle[prevNode.id] = curNode.id;
          }

          return [cycle, curNode];
        }, [cycle, null])[0];
        return OnCycleAction.Cancel;
      }
    }));
    return cycle;
  }

  toDot() {
    let dot = ['digraph ChronoGraph {', 'splines=spline'];
    const arrAtoms = Array.from(this.nodesMap.entries());
    const namedAtomsByGroup = arrAtoms.reduce((map, [atomId, atom]) => {
      let [group, label] = String(atomId).split('/');
      const {
          id,
          name
        } = atom.self || {},
        {
          field
        } = atom;
      group = name || id || group;
      label = field && field.name || label;

      if (!map.has(group)) {
        map.set(group, new Set([[label || '', atom]]));
      } else {
        map.get(group).add([label, atom]);
      }

      return map;
    }, new Map());
    dot = Array.from(namedAtomsByGroup.entries()).reduce((dot, [group, namedAtoms], index) => {
      dot.push(`subgraph cluster_${index} {`);
      dot.push(`label="${group}"`);
      dot = Array.from(namedAtoms.values()).reduce((dot, [name, atom]) => {
        let value = this.toDotAtomValue(atom);
        let color = this.toDotAtomColor(atom);
        dot.push(`"${atom.id}" [label="${name}=${value}\", fontcolor="${color}"]`);
        return dot;
      }, dot);
      dot.push('}');
      return dot;
    }, dot);
    let cycle = this.toDotObtainCycle();
    dot = arrAtoms.reduce((dot, [fromId, fromAtom]) => {
      const outgoingEdges = fromAtom.outgoing;
      Array.from(outgoingEdges).reduce((dot, toAtom) => {
        const edgeLabel = '';
        let color = !this.isAtomNeedRecalculation(fromAtom) || this.isAtomStable(fromAtom) ? 'darkgreen' : 'red';
        let penwidth = cycle[fromId] == toAtom.id ? 5 : 1;
        dot.push(`"${fromId}" -> "${toAtom.id}" [label="${edgeLabel}", color="${color}", penwidth=${penwidth}]`);
        return dot;
      }, dot);
      return dot;
    }, dot);
    dot.push('}');
    return dot.join('\n');
  }

  toDotAtomIncoming(atom) {
    let dot = ['digraph ChronoGraph {', 'splines=spline'];
    let subGraph = new Set();
    preWalk(atom, subGraphAtom => Array.from(subGraphAtom.incoming), subGraphAtom => subGraph.add(subGraphAtom));
    dot = Array.from(subGraph).reduce((dot, incomingAtom) => {
      const name = this.toDotAtomName(incomingAtom),
        value = this.toDotAtomValue(incomingAtom);
      let color, penwidth;

      if (incomingAtom == atom) {
        color = 'orange';
        penwidth = 5;
      } else {
        color = this.toDotAtomColor(incomingAtom);
        penwidth = 1;
      }

      dot.push(`"${incomingAtom.id}" [label="${name}=${value}\", fontcolor="${color}", penwidth=${penwidth}]`);
      return dot;
    }, dot);
    const cycle = this.toDotObtainCycle();
    dot = Array.from(subGraph).reduce((dot, subGraphAtom) => Array.from(subGraphAtom.incoming).reduce((dot, incomingAtom) => {
      const fromId = incomingAtom.id;
      const toId = subGraphAtom.id;
      const color = this.toDotAtomColor(incomingAtom);
      const penwidth = cycle[fromId] == toId ? 5 : 1;
      dot.push(`"${fromId}" -> "${toId}" [label="", color="${color}", penwidth=${penwidth}]`);
      return dot;
    }, dot), dot);
    dot.push('}');
    return dot.join('\n');
  }

};

class MinimalChronoGraph extends ChronoGraph(MinimalGraph) {
}

const IteratorReturnedEarly = Symbol("IteratorReturnedEarly");

class Entity extends Base$1 {
  constructor() {
    super(...arguments);
    this.fields = new Map();
  }

  hasField(name) {
    return this.getField(name) !== undefined;
  }

  getField(name) {
    let result = undefined;
    this.forEachParent(entity => {
      const field = entity.fields.get(name);

      if (field) {
        result = field;
        return IteratorReturnedEarly;
      }
    });
    return result;
  }

  addField(field) {
    const name = field.name;
    if (!name) throw new Error(`Field must have a name`);
    if (this.fields.has(name)) throw new Error(`Field with name [${String(name)}] already exists`);
    field.entity = this;
    this.fields.set(name, field);
    return field;
  }

  forEachParent(func) {
    let entity = this;

    while (entity) {
      if (func(entity) === IteratorReturnedEarly) return IteratorReturnedEarly;
      entity = entity.parentEntity;
    }
  }

  forEachField(func) {
    const visited = new Set();
    this.forEachParent(entity => {
      entity.fields.forEach((field, name) => {
        if (!visited.has(name)) {
          visited.add(name);
          func(field, name);
        }
      });
    });
  }

}

let ATOM_ID = 1;
const chronoId = () => `chrono${ATOM_ID++}`;

const HasId = base => class HasId extends base {
  constructor() {
    super(...arguments);
    this.id = chronoId();
  }

};

const strictEqualityWithDates = (v1, v2) => {
  if (v1 instanceof Date && v2 instanceof Date) return v1 - v2 === 0;
  return v1 === v2;
};
const ChronoAtom = base => class ChronoAtom extends base {
  constructor() {
    super(...arguments);
    this.equality = strictEqualityWithDates;
    this.observedDuringCalculation = [];
  }

  clearUserInput() {
    this.proposedValue = undefined;
    this.proposedArgs = undefined;
  }

  commitValue() {
    const nextStableValue = this.nextStableValue;
    this.nextStableValue = undefined;
    this.value = nextStableValue;
  }

  commitEdges() {
    this.incoming.forEach(from => this.removeEdgeFrom(from));
    this.observedDuringCalculation.forEach(from => this.addEdgeFrom(from));
    this.observedDuringCalculation = [];
  }

  reject() {
    this.nextStableValue = undefined;
    this.observedDuringCalculation = [];
  }

  * calculate(proposedValue) {
    if (this.calculation) {
      return yield* this.calculation.call(this.calculationContext || this, proposedValue);
    } else return proposedValue !== undefined ? proposedValue : this.value;
  }

  hasValue() {
    return this.hasNextStableValue() || this.hasProposedValue() || this.hasConsistentValue();
  }

  hasStableValue() {
    return this.hasNextStableValue() || this.hasConsistentValue();
  }

  hasNextStableValue() {
    return this.nextStableValue !== undefined;
  }

  hasConsistentValue() {
    return this.value !== undefined;
  }

  hasProposedValue() {
    return this.proposedArgs !== undefined && this.proposedArgs[0] !== undefined;
  }

  get() {
    if (this.hasNextStableValue()) {
      return this.getNextStableValue();
    } else if (this.hasProposedValue()) {
      return this.getProposedValue();
    } else {
      return this.getConsistentValue();
    }
  }

  put(proposedValue, ...args) {
    this.proposedValue = proposedValue;
    this.proposedArgs = Array.prototype.slice.call(arguments);
    this.graph && this.graph.markAsNeedRecalculation(this);
  }

  getNextStableValue() {
    return this.nextStableValue;
  }

  getConsistentValue() {
    return this.value;
  }

  getProposedValue() {
    return this.proposedValue;
  }

  getProposedOrPreviousValue() {
    return this.proposedValue !== undefined ? this.proposedValue : this.value;
  }

  async set(proposedValue, ...args) {
    const graph = this.graph;
    this.put(proposedValue, ...args);
    return graph ? graph.propagate() : Promise.resolve(PropagationResult.Completed);
  }

  onEnterGraph(graph) {
    this.graph = graph;
  }

  onLeaveGraph(graph) {
    this.graph = undefined;
  }

};

class MinimalChronoAtom extends ChronoAtom(HasId(MinimalNode)) {
}

const FieldAtom = base => class FieldAtom extends base {
  put(proposedValue, ...args) {
    return super.put(this.field.converter ? this.field.converter(proposedValue, this.field) : proposedValue, ...args);
  }

  toString() {
    return `Field atom [${this.field.name}] of entity [${this.self}}]`;
  }

};

class MinimalFieldAtom extends FieldAtom(MinimalChronoAtom) {
}

const EntityAtom = base => class EntityAtom extends base {
  toString() {
    return `Entity atom [${this.self.id}]`;
  }

};

class MinimalEntityAtom extends EntityAtom(MinimalChronoAtom) {
}

class Field$1 extends Base$1 {
  constructor() {
    super(...arguments);
    this.persistent = true;
    this.createAccessors = true;
    this.atomCls = MinimalFieldAtom;
  }

}

const hasReplica = Symbol('isReplica');
const Replica = base => class Replica extends base {
  [hasReplica]() {
  }

  addEntity(entity) {
    entity.enterGraph(this);
  }

  addEntities(entities) {
    entities.forEach(entity => this.addEntity(entity));
  }

  removeEntity(entity) {
    entity.leaveGraph();
  }

  removeEntities(entities) {
    entities.forEach(entity => this.removeEntity(entity));
  }

  async tryPropagateWithEntities(onEffect, entities, hatchFn) {
    if (entities && entities.length) {
      entities = entities.filter(e => e.$$.graph !== this);
      this.addEntities(entities);
    }

    const result = await this.propagate(onEffect, hatchFn || true);

    if (entities && entities.length) {
      this.removeEntities(entities);
    }

    return result;
  }

};

class MinimalReplica extends Replica(MinimalChronoGraph) {
}

const isReplica = replica => Boolean(replica && replica[hasReplica]);

const isEntityMarker = Symbol('isEntity');
const Entity$1 = base => {
  class Entity extends base {
    [isEntityMarker]() {
    }

    get $entity() {
      return createEntityOnPrototype(this.constructor.prototype);
    }

    get $() {
      const atomsCollection = {};
      this.$entity.forEachField((field, name) => {
        atomsCollection[name] = this.createFieldAtom(field);
      });
      return lazyBuild(this, '$', atomsCollection);
    }

    get $$() {
      return lazyBuild(this, '$$', MinimalEntityAtom.new({
        entity: this.$entity,
        self: this,
        equality: () => false,
        calculation: this.calculateSelf,
        calculationContext: this
      }));
    }

    * calculateSelf() {
      return this;
    }

    createFieldAtom(field) {
      const name = field.name;
      const calculationFunction = this.$calculations && this[this.$calculations[name]];
      return field.atomCls.new({
        id: `${this.$$.id}/${name}`,
        field: field,
        self: this,
        calculationContext: calculationFunction ? this : undefined,
        calculation: calculationFunction
      });
    }

    getGraph() {
      return this.$$.graph;
    }

    forEachFieldAtom(func) {
      const fields = this.$;

      for (let name in fields) {
        func.call(this, fields[name], name);
      }
    }

    enterGraph(graph) {
      this.forEachFieldAtom(field => graph.addNode(field));
      graph.addNode(this.$$);
    }

    leaveGraph() {
      const graph = this.$$.graph;

      if (graph) {
        this.forEachFieldAtom(field => graph.removeNode(field));
        graph.removeNode(this.$$);
      }
    }

    isPropagating() {
      return this.getGraph().isPropagating;
    }

    suspendPropagate() {
      const graph = this.getGraph();
      graph && graph.suspendPropagate();
    }

    async resumePropagate(trigger) {
      const graph = this.getGraph();
      return graph && graph.resumePropagate(trigger) || Promise.resolve(PropagationResult.Completed);
    }

    async propagate(onEffect, dryRun = false) {
      const graph = this.getGraph();
      return graph && graph.propagate(onEffect, dryRun) || Promise.resolve(PropagationResult.Completed);
    }

    async waitForPropagateCompleted() {
      return this.getGraph().waitForPropagateCompleted();
    }

    async tryPropagateWithNodes(onEffect, nodes, hatchFn) {
      return this.getGraph().tryPropagateWithNodes(onEffect, nodes, hatchFn);
    }

    async tryPropagateWithEntities(onEffect, entities, hatchFn) {
      const graph = this.getGraph();
      let result;

      if (isReplica(graph)) {
        result = graph.tryPropagateWithEntities(onEffect, entities, hatchFn);
      } else {
        throw new Error("Entity is not part of replica");
      }

      return result;
    }

    markAsNeedRecalculation(atom) {
      const graph = this.getGraph();
      graph && graph.markAsNeedRecalculation(atom);
    }

    markStable(atom) {
      const graph = this.getGraph();
      graph && graph.markStable(atom);
    }

    static getField(name) {
      return this.getEntity().getField(name);
    }

    static getEntity() {
      return ensureEntityOnPrototype(this.prototype);
    }

    run(methodName, ...args) {
      const iterator = this[methodName](...args);
      let iteratorValue;
      let nextArgs;

      do {
        iteratorValue = iterator.next(nextArgs);
        const value = iteratorValue.value;
        if (value instanceof Effect) throw new Error("Helper methods can not yield effects during computation");
        if (iteratorValue.done) return value;
        const atom = value;
        if (this.getGraph().isAtomNeedRecalculation(atom)) throw new Error("Can not use stale atom for calculations");
        nextArgs = atom.get();
      } while (true);
    }

  }

  return Entity;
};
const createEntityOnPrototype = proto => {
  let parent = Object.getPrototypeOf(proto);
  return lazyBuild(proto, '$entity', Entity.new({
    parentEntity: parent.hasOwnProperty(isEntityMarker) ? null : parent.$entity
  }));
};
const ensureEntityOnPrototype = proto => {
  let entity = proto.$entity;
  if (!proto.hasOwnProperty('$entity')) entity = createEntityOnPrototype(proto);
  return entity;
};
const generic_field = (fieldConfig, fieldCls = Field$1) => {
  return function (target, propertyKey) {
    let entity = ensureEntityOnPrototype(target);
    const field = entity.addField(fieldCls.new(Object.assign(fieldConfig || {}, {
      name: propertyKey
    })));

    if (field.createAccessors) {
      const putterFnName = `put${uppercaseFirst(propertyKey)}`;
      let setter = putterFnName in target ? function (value) {
        return this[putterFnName](value);
      } : function (value) {
        return this.$[propertyKey].put(value);
      };
      Object.defineProperty(target, propertyKey, {
        get: function () {
          return this.$[propertyKey].get();
        },
        set: setter
      });
      const getterFnName = `get${uppercaseFirst(propertyKey)}`;
      const setterFnName = `set${uppercaseFirst(propertyKey)}`;

      if (!(getterFnName in target)) {
        target[getterFnName] = function (...args) {
          return this.$[propertyKey].get(...args);
        };
      }

      if (!(setterFnName in target)) {
        target[setterFnName] = function (...args) {
          return this.$[propertyKey].set(...args);
        };
      }
    }
  };
};
const field = generic_field;
const calculate = function (fieldName) {
  return function (target, propertyKey, _) {
    let calculations = target.$calculations;
    if (!calculations) calculations = target.$calculations = {};
    calculations[fieldName] = propertyKey;
  };
};

const ReferenceFieldMixin = base => class ReferenceFieldMixin extends base {
  constructor() {
    super(...arguments);
    this.atomCls = MinimalReferenceAtom;
  }

};

class ReferenceField extends ReferenceFieldMixin(Field$1) {
}

const ReferenceBucketFieldMixin = base => class ReferenceBucketFieldMixin extends base {
  constructor() {
    super(...arguments);
    this.persistent = false;
    this.atomCls = MinimalReferenceBucketAtom;
  }

};

class ReferenceBucketField extends ReferenceBucketFieldMixin(Field$1) {
}

const bucket = (fieldConfig, fieldCls = ReferenceBucketField) => generic_field(fieldConfig, fieldCls);
const reference = (fieldConfig, fieldCls = ReferenceField) => generic_field(fieldConfig, fieldCls);
const ReferenceBucketAtom = base => class ReferenceBucketAtom extends base {
  constructor() {
    super(...arguments);
    this.oldRefs = new Set();
    this.newRefs = new Set();
    this.value = new Set();
  }

  commitValue() {
    super.commitValue();
    this.oldRefs.clear();
    this.newRefs.clear();
  }

  reject() {
    super.reject();
    this.oldRefs.clear();
    this.newRefs.clear();
  }

  * calculate(proposedValue) {
    const result = new Set();
    let atom;

    for (atom of this.incoming) {
      if (!this.oldRefs.has(atom)) {
        const referencee = yield atom;
        if (referencee != null) result.add(referencee);
      }
    }

    for (atom of this.newRefs) {
      const referencee = yield atom;
      if (referencee != null) result.add(referencee);
    }

    return result;
  }

};

class MinimalReferenceBucketAtom extends ReferenceBucketAtom(MinimalFieldAtom) {
}

const ReferenceAtom = base => class ReferenceAtom extends base {
  hasBucket() {
    return Boolean(this.field.bucket);
  }

  addToBucket(bucket) {
    bucket.newRefs.add(this.self.$$);
    this.graph && this.graph.markAsNeedRecalculation(bucket);
  }

  removeFromBucket(bucket) {
    bucket.oldRefs.add(this.self.$$);
    this.graph && this.graph.markAsNeedRecalculation(bucket);
  }

  * calculate(proposedValue) {
    const value = this.resolve(proposedValue !== undefined ? proposedValue : this.value);
    if (!isAtomicValue(value)) yield value.$$;
    return value;
  }

  resolve(referencee) {
    const resolver = this.field.resolver;

    if (resolver && referencee !== undefined && isAtomicValue(referencee)) {
      return resolver.call(this.self, referencee);
    } else {
      return referencee;
    }
  }

  getBucket(entity) {
    return entity.$[this.field.bucket];
  }

  onEnterGraph(graph) {
    const value = this.get();
    let resolves = true;

    if (value !== undefined && isAtomicValue(value)) {
      resolves = false;
      const resolved = this.resolve(value);

      if (!isAtomicValue(resolved)) {
        this.put(resolved);
        resolves = true;
      }
    }

    super.onEnterGraph(graph);

    if (this.get() !== undefined && resolves && this.hasBucket()) {
      const referenceBucket = this.getBucket(this.get());
      this.addToBucket(referenceBucket);
    }
  }

  onLeaveGraph(graph) {
    if (this.hasValue() && this.hasBucket()) {
      const value = this.get();

      if (!isAtomicValue(value)) {
        const referenceBucket = this.getBucket(value);
        this.removeFromBucket(referenceBucket);
      }
    }

    super.onLeaveGraph(graph);
  }

  put(nextValue) {
    const value = this.value;

    if (this.hasBucket()) {
      if (value != null && !isAtomicValue(value)) {
        this.removeFromBucket(this.getBucket(value));
      }

      if (nextValue != null) {
        if (isAtomicValue(nextValue)) {
          const newValue = this.resolve(nextValue);

          if (newValue != null) {
            this.addToBucket(this.getBucket(newValue));
            nextValue = newValue;
          }
        } else {
          this.addToBucket(this.getBucket(nextValue));
        }
      }
    }

    super.put(nextValue);
  }

};

class MinimalReferenceAtom extends ReferenceAtom(FieldAtom(MinimalChronoAtom)) {
}

class ModelField extends Field$1 {
  constructor() {
    super(...arguments);
    this.atomCls = ChronoModelFieldAtom;
    this.modelFieldConfig = {};
  }

}

class ModelReferenceField extends ReferenceFieldMixin(ModelField) {
  constructor() {
    super(...arguments);
    this.atomCls = ChronoModelReferenceFieldAtom;
  }

}

class ModelBucketField extends ReferenceBucketFieldMixin(ModelField) {
  constructor() {
    super(...arguments);
    this.atomCls = ChronoModelReferenceBucketFieldAtom;
  }

  initialize(...args) {
    super.initialize(...args);
    this.modelFieldConfig = Object.assign({
      isEqual: () => false,
      defaultValue: new Set(),
      persist: false
    }, this.modelFieldConfig);
  }

}

class ChronoModelFieldAtom extends MinimalFieldAtom {
  get value() {
    return this.self.get(this.field.name);
  }

  set value(value) {
    this.self.set(this.field.name, value);
  }

}

class ChronoModelReferenceFieldAtom extends ReferenceAtom(ChronoModelFieldAtom) {
}

class ChronoModelReferenceBucketFieldAtom extends ReferenceBucketAtom(ChronoModelFieldAtom) {
  get value() {
    if (!this.self) return;
    return this.self.get(this.field.name);
  }

  set value(value) {
    if (!this.self) return;
    this.self.set(this.field.name, value);
  }

}

const model_field = function (modelFieldConfig = {}, chronoFieldConfig = {}) {
  return function (target, propertyKey) {
    const decoratorFn = generic_field(Object.assign({
      modelFieldConfig
    }, chronoFieldConfig), ModelField);
    decoratorFn(target, propertyKey);
    injectStaticFieldsProperty(target.constructor);
  };
};
const injectStaticFieldsProperty = prototype => {
  if (!prototype.hasOwnProperty('fields')) {
    Object.defineProperty(prototype, 'fields', {
      get: function () {
        return getDecoratedModelFields(this);
      }
    });
  }
};
const getDecoratedModelFields = constr => {
  let result = [];
  const proto = constr.prototype;
  if (proto.hasOwnProperty('$entity')) proto.$entity.fields.forEach(field => {
    if (field instanceof ModelField) {
      result.push(Object.assign(field.modelFieldConfig || {}, {
        name: field.name
      }));
    }
  });
  return result;
};
const dateConverter = (date, field) => {
  if (date === null) return null;

  if (!(date instanceof Date)) {
    date = DateHelper.parse(date, field.modelFieldConfig.format || field.modelFieldConfig.dateFormat);
  }

  return date || undefined;
};

const ChronoModelMixin = base => {
  class ChronoModelMixin extends base {
    construct(config, ...args) {
      this.constructor.exposeProperties();
      const commonConfig = {};
      const chronoConfig = {};
      this.originalData = config = config || {};

      for (let key in config) {
        const fieldDefinition = this.getFieldDefinitionFromDataSource(key);
        const field = fieldDefinition ? fieldDefinition.name : key;
        const chronoField = this.$entity.getField(field);
        if (!chronoField || field == 'expanded' || field == 'children') commonConfig[key] = config[key]; else {
          chronoConfig[field] = config[key];
        }
      }

      super.construct(commonConfig, ...args);
      Object.assign(this, chronoConfig);
    }

    copy(newId = null, proposed = true) {
      const copy = super.copy(newId);
      proposed && this.forEachFieldAtom((atom, fieldName) => {
        copy.$[fieldName].put(atom.get());
      });
      return copy;
    }

  }

  return ChronoModelMixin;
};

const hasMixin = Symbol('PartOfProjectStoreMixin');
const PartOfProjectStoreMixin = base => {
  class PartOfProjectStoreMixin extends base {
    [hasMixin]() {
    }

    calculateProject() {
      return this.project;
    }

    loadData(data) {
      super.loadData(data);
      const project = this.getProject();
      project && project.trigger('storerefresh', {
        store: this
      });
    }

  }

  return PartOfProjectStoreMixin;
};
const hasPartOfProjectStoreMixin = store => Boolean(store && store[hasMixin]);

const PartOfProjectMixin = base => {
  class PartOfProjectMixin extends base {
    joinStore(store) {
      let joinedProject = false;

      if (hasPartOfProjectStoreMixin(store)) {
        const project = store.getProject();

        if (project && !this.getProject() && !this.isShadowed()) {
          this.setProject(project);
          joinedProject = true;
        }
      }

      super.joinStore(store);
      if (joinedProject) this.joinProject();
    }

    unJoinStore(store) {
      super.unJoinStore(store);
      const project = this.isShadowed() ? this.shadowedProject : this.getProject();

      if (hasPartOfProjectStoreMixin(store) && project && project === store.getProject()) {
        this.leaveProject();
        this.setProject(null);
        this.shadowedProject = null;
      }
    }

    joinProject() {
      this.getGraph().addEntity(this);
    }

    leaveProject() {
      const project = this.getProject();

      if (!this.isShadowed()) {
        this.getGraph().removeEntity(this);
      }

      this.leftProject = project;
    }

    shadow() {
      const project = this.getProject();

      if (project) {
        this.leaveProject();
        this.setProject(null);
        this.shadowedProject = project;
      }

      return this;
    }

    unshadow() {
      if (this.shadowedProject) {
        this.setProject(this.shadowedProject);
        this.shadowedProject = null;
        this.joinProject();
      }

      return this;
    }

    isShadowed() {
      return !!this.shadowedProject;
    }

    getProject() {
      return this.isShadowed() ? null : super.getProject();
    }

    calculateProject() {
      const store = this.stores.find(s => hasPartOfProjectStoreMixin(s) && !!s.getProject());
      return store && store.getProject();
    }

    afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet) {
      if (wasSet && this.getProject() && this.getProject().getStm().isRestoring) {
        Object.keys(wasSet).forEach(key => {
          const atom = this.$[key];

          if (atom && atom.graph) {
            atom.graph.markAsNeedRecalculation(atom);
          }
        });
      }

      super.afterSet && super.afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet);
    }

  }

  return PartOfProjectMixin;
};

const PartOfProjectGenericMixin = base => {
  class PartOfProjectGenericMixin extends base {
    calculateProject() {
      throw new Error("Implement me");
    }

    setProject(project) {
      return this.project = project;
    }

    getProject() {
      if (this.project) return this.project;
      return this.setProject(this.calculateProject());
    }

    getGraph() {
      const project = this.getProject();
      return project && project.getGraph();
    }

    getEventStore() {
      const project = this.getProject();
      return project && project.eventStore;
    }

    getDependencyStore() {
      const project = this.getProject();
      return project && project.dependencyStore;
    }

    getAssignmentStore() {
      const project = this.getProject();
      return project && project.assignmentStore;
    }

    getResourceStore() {
      const project = this.getProject();
      return project && project.resourceStore;
    }

    getCalendarManagerStore() {
      const project = this.getProject();
      return project && project.calendarManagerStore;
    }

    getEventById(id) {
      return this.getEventStore() && this.getEventStore().getById(id);
    }

    getDependencyById(id) {
      return this.getDependencyStore() && this.getDependencyStore().getById(id);
    }

    getResourceById(id) {
      return this.getResourceStore() && this.getResourceStore().getById(id);
    }

    getAssignmentById(id) {
      return this.getAssignmentStore() && this.getAssignmentStore().getById(id);
    }

    getCalendarById(id) {
      return this.getCalendarManagerStore() && this.getCalendarManagerStore().getById(id);
    }

  }

  return PartOfProjectGenericMixin;
};

const later = function () {

  var later = {
    version: "1.2.0"
  };

  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement) {

      if (this == null) {
        throw new TypeError();
      }

      var t = Object(this);
      var len = t.length >>> 0;

      if (len === 0) {
        return -1;
      }

      var n = 0;

      if (arguments.length > 1) {
        n = Number(arguments[1]);

        if (n != n) {
          n = 0;
        } else if (n != 0 && n != Infinity && n != -Infinity) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
      }

      if (n >= len) {
        return -1;
      }

      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);

      for (; k < len; k++) {
        if (k in t && t[k] === searchElement) {
          return k;
        }
      }

      return -1;
    };
  }

  if (!String.prototype.trim) {
    String.prototype.trim = function () {
      return this.replace(/^\s+|\s+$/g, "");
    };
  }

  later.array = {};

  later.array.sort = function (arr, zeroIsLast) {
    arr.sort(function (a, b) {
      return +a - +b;
    });

    if (zeroIsLast && arr[0] === 0) {
      arr.push(arr.shift());
    }
  };

  later.array.next = function (val, values, extent) {
    var cur,
      zeroIsLargest = extent[0] !== 0,
      nextIdx = 0;

    for (var i = values.length - 1; i > -1; --i) {
      cur = values[i];

      if (cur === val) {
        return cur;
      }

      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {
        nextIdx = i;
        continue;
      }

      break;
    }

    return values[nextIdx];
  };

  later.array.nextInvalid = function (val, values, extent) {
    var min = extent[0],
      max = extent[1],
      len = values.length,
      zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0,
      next = val,
      i = values.indexOf(val),
      start = next;

    while (next === (values[i] || zeroVal)) {
      next++;

      if (next > max) {
        next = min;
      }

      i++;

      if (i === len) {
        i = 0;
      }

      if (next === start) {
        return undefined;
      }
    }

    return next;
  };

  later.array.prev = function (val, values, extent) {
    var cur,
      len = values.length,
      zeroIsLargest = extent[0] !== 0,
      prevIdx = len - 1;

    for (var i = 0; i < len; i++) {
      cur = values[i];

      if (cur === val) {
        return cur;
      }

      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {
        prevIdx = i;
        continue;
      }

      break;
    }

    return values[prevIdx];
  };

  later.array.prevInvalid = function (val, values, extent) {
    var min = extent[0],
      max = extent[1],
      len = values.length,
      zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0,
      next = val,
      i = values.indexOf(val),
      start = next;

    while (next === (values[i] || zeroVal)) {
      next--;

      if (next < min) {
        next = max;
      }

      i--;

      if (i === -1) {
        i = len - 1;
      }

      if (next === start) {
        return undefined;
      }
    }

    return next;
  };

  later.day = later.D = {
    name: "day",
    range: 86400,
    val: function (d) {
      return d.D || (d.D = later.date.getDate.call(d));
    },
    isValid: function (d, val) {
      return later.D.val(d) === (val || later.D.extent(d)[1]);
    },
    extent: function (d) {
      if (d.DExtent) return d.DExtent;
      var month = later.M.val(d),
        max = later.DAYS_IN_MONTH[month - 1];

      if (month === 2 && later.dy.extent(d)[1] === 366) {
        max = max + 1;
      }

      return d.DExtent = [1, max];
    },
    start: function (d) {
      return d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d)));
    },
    end: function (d) {
      return d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d)));
    },
    next: function (d, val) {
      val = val > later.D.extent(d)[1] ? 1 : val;
      var month = later.date.nextRollover(d, val, later.D, later.M),
        DMax = later.D.extent(month)[1];
      val = val > DMax ? 1 : val || DMax;
      return later.date.next(later.Y.val(month), later.M.val(month), val);
    },
    prev: function (d, val) {
      var month = later.date.prevRollover(d, val, later.D, later.M),
        DMax = later.D.extent(month)[1];
      return later.date.prev(later.Y.val(month), later.M.val(month), val > DMax ? DMax : val || DMax);
    }
  };
  later.dayOfWeekCount = later.dc = {
    name: "day of week count",
    range: 604800,
    val: function (d) {
      return d.dc || (d.dc = Math.floor((later.D.val(d) - 1) / 7) + 1);
    },
    isValid: function (d, val) {
      return later.dc.val(d) === val || val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7;
    },
    extent: function (d) {
      return d.dcExtent || (d.dcExtent = [1, Math.ceil(later.D.extent(d)[1] / 7)]);
    },
    start: function (d) {
      return d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, (later.dc.val(d) - 1) * 7 + 1 || 1)));
    },
    end: function (d) {
      return d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));
    },
    next: function (d, val) {
      val = val > later.dc.extent(d)[1] ? 1 : val;
      var month = later.date.nextRollover(d, val, later.dc, later.M),
        dcMax = later.dc.extent(month)[1];
      val = val > dcMax ? 1 : val;
      var next = later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));

      if (next.getTime() <= d.getTime()) {
        month = later.M.next(d, later.M.val(d) + 1);
        return later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));
      }

      return next;
    },
    prev: function (d, val) {
      var month = later.date.prevRollover(d, val, later.dc, later.M),
        dcMax = later.dc.extent(month)[1];
      val = val > dcMax ? dcMax : val || dcMax;
      return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), 1 + 7 * (val - 1)));
    }
  };
  later.dayOfWeek = later.dw = later.d = {
    name: "day of week",
    range: 86400,
    val: function (d) {
      return d.dw || (d.dw = later.date.getDay.call(d) + 1);
    },
    isValid: function (d, val) {
      return later.dw.val(d) === (val || 7);
    },
    extent: function () {
      return [1, 7];
    },
    start: function (d) {
      return later.D.start(d);
    },
    end: function (d) {
      return later.D.end(d);
    },
    next: function (d, val) {
      val = val > 7 ? 1 : val || 7;
      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));
    },
    prev: function (d, val) {
      val = val > 7 ? 7 : val || 7;
      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));
    }
  };
  later.dayOfYear = later.dy = {
    name: "day of year",
    range: 86400,
    val: function (d) {
      return d.dy || (d.dy = Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));
    },
    isValid: function (d, val) {
      return later.dy.val(d) === (val || later.dy.extent(d)[1]);
    },
    extent: function (d) {
      var year = later.Y.val(d);
      return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);
    },
    start: function (d) {
      return later.D.start(d);
    },
    end: function (d) {
      return later.D.end(d);
    },
    next: function (d, val) {
      val = val > later.dy.extent(d)[1] ? 1 : val;
      var year = later.date.nextRollover(d, val, later.dy, later.Y),
        dyMax = later.dy.extent(year)[1];
      val = val > dyMax ? 1 : val || dyMax;
      return later.date.next(later.Y.val(year), later.M.val(year), val);
    },
    prev: function (d, val) {
      var year = later.date.prevRollover(d, val, later.dy, later.Y),
        dyMax = later.dy.extent(year)[1];
      val = val > dyMax ? dyMax : val || dyMax;
      return later.date.prev(later.Y.val(year), later.M.val(year), val);
    }
  };
  later.hour = later.h = {
    name: "hour",
    range: 3600,
    val: function (d) {
      return d.h || (d.h = later.date.getHour.call(d));
    },
    isValid: function (d, val) {
      return later.h.val(d) === val;
    },
    extent: function () {
      return [0, 23];
    },
    start: function (d) {
      return d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));
    },
    end: function (d) {
      return d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));
    },
    next: function (d, val) {
      val = val > 23 ? 0 : val;
      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.h.val(d) ? 1 : 0), val);

      if (!later.date.isUTC && next.getTime() <= d.getTime()) {
        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), val + 1);
      }

      return next;
    },
    prev: function (d, val) {
      val = val > 23 ? 23 : val;
      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.h.val(d) ? -1 : 0), val);
    }
  };
  later.minute = later.m = {
    name: "minute",
    range: 60,
    val: function (d) {
      return d.m || (d.m = later.date.getMin.call(d));
    },
    isValid: function (d, val) {
      return later.m.val(d) === val;
    },
    extent: function (d) {
      return [0, 59];
    },
    start: function (d) {
      return d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));
    },
    end: function (d) {
      return d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));
    },
    next: function (d, val) {
      var m = later.m.val(d),
        s = later.s.val(d),
        inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m,
        next = new Date(d.getTime() + inc * later.MIN - s * later.SEC);

      if (!later.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 120) * later.MIN - s * later.SEC);
      }

      return next;
    },
    prev: function (d, val) {
      val = val > 59 ? 59 : val;
      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d) + (val >= later.m.val(d) ? -1 : 0), val);
    }
  };
  later.month = later.M = {
    name: "month",
    range: 2629740,
    val: function (d) {
      return d.M || (d.M = later.date.getMonth.call(d) + 1);
    },
    isValid: function (d, val) {
      return later.M.val(d) === (val || 12);
    },
    extent: function () {
      return [1, 12];
    },
    start: function (d) {
      return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));
    },
    end: function (d) {
      return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));
    },
    next: function (d, val) {
      val = val > 12 ? 1 : val || 12;
      return later.date.next(later.Y.val(d) + (val > later.M.val(d) ? 0 : 1), val);
    },
    prev: function (d, val) {
      val = val > 12 ? 12 : val || 12;
      return later.date.prev(later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0), val);
    }
  };
  later.second = later.s = {
    name: "second",
    range: 1,
    val: function (d) {
      return d.s || (d.s = later.date.getSec.call(d));
    },
    isValid: function (d, val) {
      return later.s.val(d) === val;
    },
    extent: function () {
      return [0, 59];
    },
    start: function (d) {
      return d;
    },
    end: function (d) {
      return d;
    },
    next: function (d, val) {
      var s = later.s.val(d),
        inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s,
        next = new Date(d.getTime() + inc * later.SEC);

      if (!later.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 7200) * later.SEC);
      }

      return next;
    },
    prev: function (d, val, cache) {
      val = val > 59 ? 59 : val;
      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d) + (val >= later.s.val(d) ? -1 : 0), val);
    }
  };
  later.time = later.t = {
    name: "time",
    range: 1,
    val: function (d) {
      return d.t || (d.t = later.h.val(d) * 3600 + later.m.val(d) * 60 + later.s.val(d));
    },
    isValid: function (d, val) {
      return later.t.val(d) === val;
    },
    extent: function () {
      return [0, 86399];
    },
    start: function (d) {
      return d;
    },
    end: function (d) {
      return d;
    },
    next: function (d, val) {
      val = val > 86399 ? 0 : val;
      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.t.val(d) ? 1 : 0), 0, 0, val);

      if (!later.date.isUTC && next.getTime() < d.getTime()) {
        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), val + 7200);
      }

      return next;
    },
    prev: function (d, val) {
      val = val > 86399 ? 86399 : val;
      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.t.val(d) ? -1 : 0), 0, 0, val);
    }
  };
  later.weekOfMonth = later.wm = {
    name: "week of month",
    range: 604800,
    val: function (d) {
      return d.wm || (d.wm = (later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);
    },
    isValid: function (d, val) {
      return later.wm.val(d) === (val || later.wm.extent(d)[1]);
    },
    extent: function (d) {
      return d.wmExtent || (d.wmExtent = [1, (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7]);
    },
    start: function (d) {
      return d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));
    },
    end: function (d) {
      return d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));
    },
    next: function (d, val) {
      val = val > later.wm.extent(d)[1] ? 1 : val;
      var month = later.date.nextRollover(d, val, later.wm, later.M),
        wmMax = later.wm.extent(month)[1];
      val = val > wmMax ? 1 : val || wmMax;
      return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2)));
    },
    prev: function (d, val) {
      var month = later.date.prevRollover(d, val, later.wm, later.M),
        wmMax = later.wm.extent(month)[1];
      val = val > wmMax ? wmMax : val || wmMax;
      return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2))));
    }
  };
  later.weekOfYear = later.wy = {
    name: "week of year (ISO)",
    range: 604800,
    val: function (d) {
      if (d.wy) return d.wy;
      var wThur = later.dw.next(later.wy.start(d), 5),
        YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur) - 1), 5);
      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK);
    },
    isValid: function (d, val) {
      return later.wy.val(d) === (val || later.wy.extent(d)[1]);
    },
    extent: function (d) {
      if (d.wyExtent) return d.wyExtent;
      var year = later.dw.next(later.wy.start(d), 5),
        dwFirst = later.dw.val(later.Y.start(year)),
        dwLast = later.dw.val(later.Y.end(year));
      return d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52];
    },
    start: function (d) {
      return d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)));
    },
    end: function (d) {
      return d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)));
    },
    next: function (d, val) {
      val = val > later.wy.extent(d)[1] ? 1 : val;
      var wyThur = later.dw.next(later.wy.start(d), 5),
        year = later.date.nextRollover(wyThur, val, later.wy, later.Y);

      if (later.wy.val(year) !== 1) {
        year = later.dw.next(year, 2);
      }

      var wyMax = later.wy.extent(year)[1],
        wyStart = later.wy.start(year);
      val = val > wyMax ? 1 : val || wyMax;
      return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), later.D.val(wyStart) + 7 * (val - 1));
    },
    prev: function (d, val) {
      var wyThur = later.dw.next(later.wy.start(d), 5),
        year = later.date.prevRollover(wyThur, val, later.wy, later.Y);

      if (later.wy.val(year) !== 1) {
        year = later.dw.next(year, 2);
      }

      var wyMax = later.wy.extent(year)[1],
        wyEnd = later.wy.end(year);
      val = val > wyMax ? wyMax : val || wyMax;
      return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), later.D.val(wyEnd) + 7 * (val - 1)));
    }
  };
  later.year = later.Y = {
    name: "year",
    range: 31556900,
    val: function (d) {
      return d.Y || (d.Y = later.date.getYear.call(d));
    },
    isValid: function (d, val) {
      return later.Y.val(d) === val;
    },
    extent: function () {
      return [1970, 2099];
    },
    start: function (d) {
      return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));
    },
    end: function (d) {
      return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));
    },
    next: function (d, val) {
      return val > later.Y.val(d) && val <= later.Y.extent()[1] ? later.date.next(val) : later.NEVER;
    },
    prev: function (d, val) {
      return val < later.Y.val(d) && val >= later.Y.extent()[0] ? later.date.prev(val) : later.NEVER;
    }
  };
  later.fullDate = later.fd = {
    name: "full date",
    range: 1,
    val: function (d) {
      return d.fd || (d.fd = d.getTime());
    },
    isValid: function (d, val) {
      return later.fd.val(d) === val;
    },
    extent: function () {
      return [0, 3250368e7];
    },
    start: function (d) {
      return d;
    },
    end: function (d) {
      return d;
    },
    next: function (d, val) {
      return later.fd.val(d) < val ? new Date(val) : later.NEVER;
    },
    prev: function (d, val) {
      return later.fd.val(d) > val ? new Date(val) : later.NEVER;
    }
  };
  later.modifier = {};

  later.modifier.after = later.modifier.a = function (constraint, values) {
    var value = values[0];
    return {
      name: "after " + constraint.name,
      range: (constraint.extent(new Date())[1] - value) * constraint.range,
      val: constraint.val,
      isValid: function (d, val) {
        return this.val(d) >= value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function (startDate, val) {
        if (val != value) val = constraint.extent(startDate)[0];
        return constraint.next(startDate, val);
      },
      prev: function (startDate, val) {
        val = val === value ? constraint.extent(startDate)[1] : value - 1;
        return constraint.prev(startDate, val);
      }
    };
  };

  later.modifier.before = later.modifier.b = function (constraint, values) {
    var value = values[values.length - 1];
    return {
      name: "before " + constraint.name,
      range: constraint.range * (value - 1),
      val: constraint.val,
      isValid: function (d, val) {
        return this.val(d) < value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function (startDate, val) {
        val = val === value ? constraint.extent(startDate)[0] : value;
        return constraint.next(startDate, val);
      },
      prev: function (startDate, val) {
        val = val === value ? value - 1 : constraint.extent(startDate)[1];
        return constraint.prev(startDate, val);
      }
    };
  };

  later.compile = function (schedDef) {
    var constraints = [],
      constraintsLen = 0,
      tickConstraint;

    for (var key in schedDef) {
      var nameParts = key.split("_"),
        name = nameParts[0],
        mod = nameParts[1],
        vals = schedDef[key],
        constraint = mod ? later.modifier[mod](later[name], vals) : later[name];
      constraints.push({
        constraint: constraint,
        vals: vals
      });
      constraintsLen++;
    }

    constraints.sort(function (a, b) {
      var ra = a.constraint.range,
        rb = b.constraint.range;
      return rb < ra ? -1 : rb > ra ? 1 : 0;
    });
    tickConstraint = constraints[constraintsLen - 1].constraint;

    function compareFn(dir) {
      return dir === "next" ? function (a, b) {
        return a.getTime() > b.getTime();
      } : function (a, b) {
        return b.getTime() > a.getTime();
      };
    }

    return {
      start: function (dir, startDate) {
        var next = startDate,
          nextVal = later.array[dir],
          maxAttempts = 1e3,
          done;

        while (maxAttempts-- && !done && next) {
          done = true;

          for (var i = 0; i < constraintsLen; i++) {
            var constraint = constraints[i].constraint,
              curVal = constraint.val(next),
              extent = constraint.extent(next),
              newVal = nextVal(curVal, constraints[i].vals, extent);

            if (!constraint.isValid(next, newVal)) {
              next = constraint[dir](next, newVal);
              done = false;
              break;
            }
          }
        }

        if (next !== later.NEVER) {
          next = dir === "next" ? tickConstraint.start(next) : tickConstraint.end(next);
        }

        return next;
      },
      end: function (dir, startDate) {
        var result,
          nextVal = later.array[dir + "Invalid"],
          compare = compareFn(dir);

        for (var i = constraintsLen - 1; i >= 0; i--) {
          var constraint = constraints[i].constraint,
            curVal = constraint.val(startDate),
            extent = constraint.extent(startDate),
            newVal = nextVal(curVal, constraints[i].vals, extent),
            next;

          if (newVal !== undefined) {
            next = constraint[dir](startDate, newVal);

            if (next && (!result || compare(result, next))) {
              result = next;
            }
          }
        }

        return result;
      },
      tick: function (dir, date) {
        return new Date(dir === "next" ? tickConstraint.end(date).getTime() + later.SEC : tickConstraint.start(date).getTime() - later.SEC);
      },
      tickStart: function (date) {
        return tickConstraint.start(date);
      }
    };
  };

  later.schedule = function (sched) {
    if (!sched) throw new Error("Missing schedule definition.");
    if (!sched.schedules) throw new Error("Definition must include at least one schedule.");
    var schedules = [],
      schedulesLen = sched.schedules.length,
      exceptions = [],
      exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;

    for (var i = 0; i < schedulesLen; i++) {
      schedules.push(later.compile(sched.schedules[i]));
    }

    for (var j = 0; j < exceptionsLen; j++) {
      exceptions.push(later.compile(sched.exceptions[j]));
    }

    function getInstances(dir, count, startDate, endDate, isRange) {
      var compare = compareFn(dir),
        loopCount = count,
        maxAttempts = 1e3,
        schedStarts = [],
        exceptStarts = [],
        next,
        end,
        results = [],
        isForward = dir === "next",
        lastResult,
        rStart = isForward ? 0 : 1,
        rEnd = isForward ? 1 : 0;
      startDate = startDate ? new Date(startDate) : new Date();
      if (!startDate || !startDate.getTime()) throw new Error("Invalid start date.");
      setNextStarts(dir, schedules, schedStarts, startDate);
      setRangeStarts(dir, exceptions, exceptStarts, startDate);

      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {
        if (endDate && compare(next, endDate)) {
          break;
        }

        if (exceptionsLen) {
          updateRangeStarts(dir, exceptions, exceptStarts, next);

          if (end = calcRangeOverlap(dir, exceptStarts, next)) {
            updateNextStarts(dir, schedules, schedStarts, end);
            continue;
          }
        }

        if (isRange) {
          var maxEndDate = calcMaxEndDate(exceptStarts, compare);
          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);
          var r = isForward ? [new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined] : [end ? new Date(endDate ? Math.max(endDate, end.getTime() + later.SEC) : end.getTime() + later.SEC) : undefined, new Date(Math.min(startDate, next.getTime() + later.SEC))];

          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {
            lastResult[rEnd] = r[rEnd];
            loopCount++;
          } else {
            lastResult = r;
            results.push(lastResult);
          }

          if (!end) break;
          updateNextStarts(dir, schedules, schedStarts, end);
        } else {
          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));
          tickStarts(dir, schedules, schedStarts, next);
        }

        loopCount--;
      }

      for (var i = 0, len = results.length; i < len; i++) {
        var result = results[i];
        results[i] = Object.prototype.toString.call(result) === "[object Array]" ? [cleanDate(result[0]), cleanDate(result[1])] : cleanDate(result);
      }

      return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;
    }

    function cleanDate(d) {
      if (d instanceof Date && !isNaN(d.valueOf())) {
        return new Date(d);
      }

      return undefined;
    }

    function setNextStarts(dir, schedArr, startsArr, startDate) {
      for (var i = 0, len = schedArr.length; i < len; i++) {
        startsArr[i] = schedArr[i].start(dir, startDate);
      }
    }

    function updateNextStarts(dir, schedArr, startsArr, startDate) {
      var compare = compareFn(dir);

      for (var i = 0, len = schedArr.length; i < len; i++) {
        if (startsArr[i] && !compare(startsArr[i], startDate)) {
          startsArr[i] = schedArr[i].start(dir, startDate);
        }
      }
    }

    function setRangeStarts(dir, schedArr, rangesArr, startDate) {

      for (var i = 0, len = schedArr.length; i < len; i++) {
        var nextStart = schedArr[i].start(dir, startDate);

        if (!nextStart) {
          rangesArr[i] = later.NEVER;
        } else {
          rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];
        }
      }
    }

    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {
      var compare = compareFn(dir);

      for (var i = 0, len = schedArr.length; i < len; i++) {
        if (rangesArr[i] && !compare(rangesArr[i][0], startDate)) {
          var nextStart = schedArr[i].start(dir, startDate);

          if (!nextStart) {
            rangesArr[i] = later.NEVER;
          } else {
            rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];
          }
        }
      }
    }

    function tickStarts(dir, schedArr, startsArr, startDate) {
      for (var i = 0, len = schedArr.length; i < len; i++) {
        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {
          startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));
        }
      }
    }

    function getStart(schedArr, startsArr, startDate, minEndDate) {
      var result;

      for (var i = 0, len = startsArr.length; i < len; i++) {
        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {
          var start = schedArr[i].tickStart(startDate);

          if (minEndDate && start < minEndDate) {
            return minEndDate;
          }

          if (!result || start > result) {
            result = start;
          }
        }
      }

      return result;
    }

    function calcRangeOverlap(dir, rangesArr, startDate) {
      var compare = compareFn(dir),
        result;

      for (var i = 0, len = rangesArr.length; i < len; i++) {
        var range = rangesArr[i];

        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {
          if (!result || compare(range[1], result)) {
            result = range[1];
          }
        }
      }

      return result;
    }

    function calcMaxEndDate(exceptsArr, compare) {
      var result;

      for (var i = 0, len = exceptsArr.length; i < len; i++) {
        if (exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {
          result = exceptsArr[i][0];
        }
      }

      return result;
    }

    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {
      var compare = compareFn(dir),
        result;

      for (var i = 0, len = schedArr.length; i < len; i++) {
        var start = startsArr[i];

        if (start && start.getTime() === startDate.getTime()) {
          var end = schedArr[i].end(dir, start);

          if (maxEndDate && (!end || compare(end, maxEndDate))) {
            return maxEndDate;
          }

          if (!result || compare(end, result)) {
            result = end;
          }
        }
      }

      return result;
    }

    function compareFn(dir) {
      return dir === "next" ? function (a, b) {
        return !b || a.getTime() > b.getTime();
      } : function (a, b) {
        return !a || b.getTime() > a.getTime();
      };
    }

    function findNext(arr, compare) {
      var next = arr[0];

      for (var i = 1, len = arr.length; i < len; i++) {
        if (arr[i] && compare(next, arr[i])) {
          next = arr[i];
        }
      }

      return next;
    }

    return {
      isValid: function (d) {
        return getInstances("next", 1, d, d) !== later.NEVER;
      },
      next: function (count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate);
      },
      prev: function (count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate);
      },
      nextRange: function (count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate, true);
      },
      prevRange: function (count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate, true);
      }
    };
  };

  later.setTimeout = function (fn, sched) {
    var s = later.schedule(sched),
      t;

    if (fn) {
      scheduleTimeout();
    }

    function scheduleTimeout() {
      var now = Date.now(),
        next = s.next(2, now);

      if (!next[0]) {
        t = undefined;
        return;
      }

      var diff = next[0].getTime() - now;

      if (diff < 1e3) {
        diff = next[1] ? next[1].getTime() - now : 1e3;
      }

      if (diff < 2147483647) {
        t = setTimeout(fn, diff);
      } else {
        t = setTimeout(scheduleTimeout, 2147483647);
      }
    }

    return {
      isDone: function () {
        return !t;
      },
      clear: function () {
        clearTimeout(t);
      }
    };
  };

  later.setInterval = function (fn, sched) {
    if (!fn) {
      return;
    }

    var t = later.setTimeout(scheduleTimeout, sched),
      done = t.isDone();

    function scheduleTimeout() {
      if (!done) {
        fn();
        t = later.setTimeout(scheduleTimeout, sched);
      }
    }

    return {
      isDone: function () {
        return t.isDone();
      },
      clear: function () {
        done = true;
        t.clear();
      }
    };
  };

  later.date = {};

  later.date.timezone = function (useLocalTime) {
    later.date.build = useLocalTime ? function (Y, M, D, h, m, s) {
      return new Date(Y, M, D, h, m, s);
    } : function (Y, M, D, h, m, s) {
      return new Date(Date.UTC(Y, M, D, h, m, s));
    };
    var get = useLocalTime ? "get" : "getUTC",
      d = Date.prototype;
    later.date.getYear = d[get + "FullYear"];
    later.date.getMonth = d[get + "Month"];
    later.date.getDate = d[get + "Date"];
    later.date.getDay = d[get + "Day"];
    later.date.getHour = d[get + "Hours"];
    later.date.getMin = d[get + "Minutes"];
    later.date.getSec = d[get + "Seconds"];
    later.date.isUTC = !useLocalTime;
  };

  later.date.UTC = function () {
    later.date.timezone(false);
  };

  later.date.localTime = function () {
    later.date.timezone(true);
  };

  later.date.UTC();
  later.SEC = 1e3;
  later.MIN = later.SEC * 60;
  later.HOUR = later.MIN * 60;
  later.DAY = later.HOUR * 24;
  later.WEEK = later.DAY * 7;
  later.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  later.NEVER = 0;

  later.date.next = function (Y, M, D, h, m, s) {
    return later.date.build(Y, M !== undefined ? M - 1 : 0, D !== undefined ? D : 1, h || 0, m || 0, s || 0);
  };

  later.date.nextRollover = function (d, val, constraint, period) {
    var cur = constraint.val(d),
      max = constraint.extent(d)[1];
    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later.SEC) : period.start(d);
  };

  later.date.prev = function (Y, M, D, h, m, s) {
    var len = arguments.length;
    M = len < 2 ? 11 : M - 1;
    D = len < 3 ? later.D.extent(later.date.next(Y, M + 1))[1] : D;
    h = len < 4 ? 23 : h;
    m = len < 5 ? 59 : m;
    s = len < 6 ? 59 : s;
    return later.date.build(Y, M, D, h, m, s);
  };

  later.date.prevRollover = function (d, val, constraint, period) {
    var cur = constraint.val(d);
    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);
  };

  later.parse = {};

  later.parse.cron = function (expr, hasSeconds) {
    var NAMES = {
      JAN: 1,
      FEB: 2,
      MAR: 3,
      APR: 4,
      MAY: 5,
      JUN: 6,
      JUL: 7,
      AUG: 8,
      SEP: 9,
      OCT: 10,
      NOV: 11,
      DEC: 12,
      SUN: 1,
      MON: 2,
      TUE: 3,
      WED: 4,
      THU: 5,
      FRI: 6,
      SAT: 7
    };
    var REPLACEMENTS = {
      "* * * * * *": "0/1 * * * * *",
      "@YEARLY": "0 0 1 1 *",
      "@ANNUALLY": "0 0 1 1 *",
      "@MONTHLY": "0 0 1 * *",
      "@WEEKLY": "0 0 * * 0",
      "@DAILY": "0 0 * * *",
      "@HOURLY": "0 * * * *"
    };
    var FIELDS = {
      s: [0, 0, 59],
      m: [1, 0, 59],
      h: [2, 0, 23],
      D: [3, 1, 31],
      M: [4, 1, 12],
      Y: [6, 1970, 2099],
      d: [5, 1, 7, 1]
    };

    function getValue(value, offset, max) {
      return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);
    }

    function cloneSchedule(sched) {
      var clone = {},
        field;

      for (field in sched) {
        if (field !== "dc" && field !== "d") {
          clone[field] = sched[field].slice(0);
        }
      }

      return clone;
    }

    function add(sched, name, min, max, inc) {
      var i = min;

      if (!sched[name]) {
        sched[name] = [];
      }

      while (i <= max) {
        if (sched[name].indexOf(i) < 0) {
          sched[name].push(i);
        }

        i += inc || 1;
      }

      sched[name].sort(function (a, b) {
        return a - b;
      });
    }

    function addHash(schedules, curSched, value, hash) {
      if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {
        schedules.push(cloneSchedule(curSched));
        curSched = schedules[schedules.length - 1];
      }

      add(curSched, "d", value, value);
      add(curSched, "dc", hash, hash);
    }

    function addWeekday(s, curSched, value) {
      var except1 = {},
        except2 = {};

      if (value === 1) {
        add(curSched, "D", 1, 3);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", 2, 2);
        add(except1, "d", NAMES.TUE, NAMES.FRI);
        add(except2, "D", 3, 3);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      } else {
        add(curSched, "D", value - 1, value + 1);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", value - 1, value - 1);
        add(except1, "d", NAMES.MON, NAMES.THU);
        add(except2, "D", value + 1, value + 1);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      }

      s.exceptions.push(except1);
      s.exceptions.push(except2);
    }

    function addRange(item, curSched, name, min, max, offset) {
      var incSplit = item.split("/"),
        inc = +incSplit[1],
        range = incSplit[0];

      if (range !== "*" && range !== "0") {
        var rangeSplit = range.split("-");
        min = getValue(rangeSplit[0], offset, max);
        max = getValue(rangeSplit[1], offset, max) || max;
      }

      add(curSched, name, min, max, inc);
    }

    function parse(item, s, name, min, max, offset) {
      var value,
        split,
        schedules = s.schedules,
        curSched = schedules[schedules.length - 1];

      if (item === "L") {
        item = min - 1;
      }

      if ((value = getValue(item, offset, max)) !== null) {
        add(curSched, name, value, value);
      } else if ((value = getValue(item.replace("W", ""), offset, max)) !== null) {
        addWeekday(s, curSched, value);
      } else if ((value = getValue(item.replace("L", ""), offset, max)) !== null) {
        addHash(schedules, curSched, value, min - 1);
      } else if ((split = item.split("#")).length === 2) {
        value = getValue(split[0], offset, max);
        addHash(schedules, curSched, value, getValue(split[1]));
      } else {
        addRange(item, curSched, name, min, max, offset);
      }
    }

    function isHash(item) {
      return item.indexOf("#") > -1 || item.indexOf("L") > 0;
    }

    function itemSorter(a, b) {
      return isHash(a) && !isHash(b) ? 1 : a - b;
    }

    function parseExpr(expr) {
      var schedule = {
          schedules: [{}],
          exceptions: []
        },
        components = expr.replace(/(\s)+/g, " ").split(" "),
        field,
        f,
        component,
        items;

      for (field in FIELDS) {
        f = FIELDS[field];
        component = components[f[0]];

        if (component && component !== "*" && component !== "?") {
          items = component.split(",").sort(itemSorter);
          var i,
            length = items.length;

          for (i = 0; i < length; i++) {
            parse(items[i], schedule, field, f[1], f[2], f[3]);
          }
        }
      }

      return schedule;
    }

    function prepareExpr(expr) {
      var prepared = expr.toUpperCase();
      return REPLACEMENTS[prepared] || prepared;
    }

    var e = prepareExpr(expr);
    return parseExpr(hasSeconds ? e : "0 " + e);
  };

  later.parse.recur = function () {
    var schedules = [],
      exceptions = [],
      cur,
      curArr = schedules,
      curName,
      values,
      every,
      modifier,
      applyMin,
      applyMax,
      i,
      last;

    function add(name, min, max) {
      name = modifier ? name + "_" + modifier : name;

      if (!cur) {
        curArr.push({});
        cur = curArr[0];
      }

      if (!cur[name]) {
        cur[name] = [];
      }

      curName = cur[name];

      if (every) {
        values = [];

        for (i = min; i <= max; i += every) {
          values.push(i);
        }

        last = {
          n: name,
          x: every,
          c: curName.length,
          m: max
        };
      }

      values = applyMin ? [min] : applyMax ? [max] : values;
      var length = values.length;

      for (i = 0; i < length; i += 1) {
        var val = values[i];

        if (curName.indexOf(val) < 0) {
          curName.push(val);
        }
      }

      values = every = modifier = applyMin = applyMax = 0;
    }

    return {
      schedules: schedules,
      exceptions: exceptions,
      on: function () {
        values = arguments[0] instanceof Array ? arguments[0] : arguments;
        return this;
      },
      every: function (x) {
        every = x || 1;
        return this;
      },
      after: function (x) {
        modifier = "a";
        values = [x];
        return this;
      },
      before: function (x) {
        modifier = "b";
        values = [x];
        return this;
      },
      first: function () {
        applyMin = 1;
        return this;
      },
      last: function () {
        applyMax = 1;
        return this;
      },
      time: function () {
        for (var i = 0, len = values.length; i < len; i++) {
          var split = values[i].split(":");
          if (split.length < 3) split.push(0);
          values[i] = +split[0] * 3600 + +split[1] * 60 + +split[2];
        }

        add("t");
        return this;
      },
      second: function () {
        add("s", 0, 59);
        return this;
      },
      minute: function () {
        add("m", 0, 59);
        return this;
      },
      hour: function () {
        add("h", 0, 23);
        return this;
      },
      dayOfMonth: function () {
        add("D", 1, applyMax ? 0 : 31);
        return this;
      },
      dayOfWeek: function () {
        add("d", 1, 7);
        return this;
      },
      onWeekend: function () {
        values = [1, 7];
        return this.dayOfWeek();
      },
      onWeekday: function () {
        values = [2, 3, 4, 5, 6];
        return this.dayOfWeek();
      },
      dayOfWeekCount: function () {
        add("dc", 1, applyMax ? 0 : 5);
        return this;
      },
      dayOfYear: function () {
        add("dy", 1, applyMax ? 0 : 366);
        return this;
      },
      weekOfMonth: function () {
        add("wm", 1, applyMax ? 0 : 5);
        return this;
      },
      weekOfYear: function () {
        add("wy", 1, applyMax ? 0 : 53);
        return this;
      },
      month: function () {
        add("M", 1, 12);
        return this;
      },
      year: function () {
        add("Y", 1970, 2450);
        return this;
      },
      fullDate: function () {
        for (var i = 0, len = values.length; i < len; i++) {
          values[i] = values[i].getTime();
        }

        add("fd");
        return this;
      },
      customModifier: function (id, vals) {
        var custom = later.modifier[id];
        if (!custom) throw new Error("Custom modifier " + id + " not recognized!");
        modifier = id;
        values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];
        return this;
      },
      customPeriod: function (id) {
        var custom = later[id];
        if (!custom) throw new Error("Custom time period " + id + " not recognized!");
        add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);
        return this;
      },
      startingOn: function (start) {
        return this.between(start, last.m);
      },
      between: function (start, end) {
        cur[last.n] = cur[last.n].splice(0, last.c);
        every = last.x;
        add(last.n, start, end);
        return this;
      },
      and: function () {
        cur = curArr[curArr.push({}) - 1];
        return this;
      },
      except: function () {
        curArr = exceptions;
        cur = null;
        return this;
      }
    };
  };

  later.parse.text = function (str) {
    var recur = later.parse.recur,
      pos = 0,
      input = "",
      error;
    var TOKENTYPES = {
      eof: /^$/,
      rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/,
      time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/,
      dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/,
      monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/,
      yearIndex: /^(\d\d\d\d)\b/,
      every: /^every\b/,
      after: /^after\b/,
      before: /^before\b/,
      second: /^(s|sec(ond)?(s)?)\b/,
      minute: /^(m|min(ute)?(s)?)\b/,
      hour: /^(h|hour(s)?)\b/,
      day: /^(day(s)?( of the month)?)\b/,
      dayInstance: /^day instance\b/,
      dayOfWeek: /^day(s)? of the week\b/,
      dayOfYear: /^day(s)? of the year\b/,
      weekOfYear: /^week(s)?( of the year)?\b/,
      weekOfMonth: /^week(s)? of the month\b/,
      weekday: /^weekday\b/,
      weekend: /^weekend\b/,
      month: /^month(s)?\b/,
      year: /^year(s)?\b/,
      between: /^between (the)?\b/,
      start: /^(start(ing)? (at|on( the)?)?)\b/,
      at: /^(at|@)\b/,
      and: /^(,|and\b)/,
      except: /^(except\b)/,
      also: /(also)\b/,
      first: /^(first)\b/,
      last: /^last\b/,
      "in": /^in\b/,
      of: /^of\b/,
      onthe: /^on the\b/,
      on: /^on\b/,
      through: /(-|^(to|through)\b)/
    };
    var NAMES = {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12,
      sun: 1,
      mon: 2,
      tue: 3,
      wed: 4,
      thu: 5,
      fri: 6,
      sat: 7,
      "1st": 1,
      fir: 1,
      "2nd": 2,
      sec: 2,
      "3rd": 3,
      thi: 3,
      "4th": 4,
      "for": 4
    };

    function t(start, end, text, type) {
      return {
        startPos: start,
        endPos: end,
        text: text,
        type: type
      };
    }

    function peek(expected) {
      var scanTokens = expected instanceof Array ? expected : [expected],
        whiteSpace = /\s+/,
        token,
        curInput,
        m,
        scanToken,
        start,
        len;
      scanTokens.push(whiteSpace);
      start = pos;

      while (!token || token.type === whiteSpace) {
        len = -1;
        curInput = input.substring(start);
        token = t(start, start, input.split(whiteSpace)[0]);
        var i,
          length = scanTokens.length;

        for (i = 0; i < length; i++) {
          scanToken = scanTokens[i];
          m = scanToken.exec(curInput);

          if (m && m.index === 0 && m[0].length > len) {
            len = m[0].length;
            token = t(start, start + len, curInput.substring(0, len), scanToken);
          }
        }

        if (token.type === whiteSpace) {
          start = token.endPos;
        }
      }

      return token;
    }

    function scan(expectedToken) {
      var token = peek(expectedToken);
      pos = token.endPos;
      return token;
    }

    function parseThroughExpr(tokenType) {
      var start = +parseTokenValue(tokenType),
        end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start,
        nums = [];

      for (var i = start; i <= end; i++) {
        nums.push(i);
      }

      return nums;
    }

    function parseRanges(tokenType) {
      var nums = parseThroughExpr(tokenType);

      while (checkAndParse(TOKENTYPES.and)) {
        nums = nums.concat(parseThroughExpr(tokenType));
      }

      return nums;
    }

    function parseEvery(r) {
      var num, period, start, end;

      if (checkAndParse(TOKENTYPES.weekend)) {
        r.on(NAMES.sun, NAMES.sat).dayOfWeek();
      } else if (checkAndParse(TOKENTYPES.weekday)) {
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      } else {
        num = parseTokenValue(TOKENTYPES.rank);
        r.every(num);
        period = parseTimePeriod(r);

        if (checkAndParse(TOKENTYPES.start)) {
          num = parseTokenValue(TOKENTYPES.rank);
          r.startingOn(num);
          parseToken(period.type);
        } else if (checkAndParse(TOKENTYPES.between)) {
          start = parseTokenValue(TOKENTYPES.rank);

          if (checkAndParse(TOKENTYPES.and)) {
            end = parseTokenValue(TOKENTYPES.rank);
            r.between(start, end);
          }
        }
      }
    }

    function parseOnThe(r) {
      if (checkAndParse(TOKENTYPES.first)) {
        r.first();
      } else if (checkAndParse(TOKENTYPES.last)) {
        r.last();
      } else {
        r.on(parseRanges(TOKENTYPES.rank));
      }

      parseTimePeriod(r);
    }

    function parseScheduleExpr(str) {
      pos = 0;
      input = str;
      error = -1;
      var r = recur();

      while (pos < input.length && error < 0) {
        var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);

        switch (token.type) {
          case TOKENTYPES.every:
            parseEvery(r);
            break;

          case TOKENTYPES.after:
            if (peek(TOKENTYPES.time).type !== undefined) {
              r.after(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else {
              r.after(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }

            break;

          case TOKENTYPES.before:
            if (peek(TOKENTYPES.time).type !== undefined) {
              r.before(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else {
              r.before(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }

            break;

          case TOKENTYPES.onthe:
            parseOnThe(r);
            break;

          case TOKENTYPES.on:
            r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
            break;

          case TOKENTYPES.of:
            r.on(parseRanges(TOKENTYPES.monthName)).month();
            break;

          case TOKENTYPES["in"]:
            r.on(parseRanges(TOKENTYPES.yearIndex)).year();
            break;

          case TOKENTYPES.at:
            r.on(parseTokenValue(TOKENTYPES.time)).time();

            while (checkAndParse(TOKENTYPES.and)) {
              r.on(parseTokenValue(TOKENTYPES.time)).time();
            }

            break;

          case TOKENTYPES.and:
            break;

          case TOKENTYPES.also:
            r.and();
            break;

          case TOKENTYPES.except:
            r.except();
            break;

          default:
            error = pos;
        }
      }

      return {
        schedules: r.schedules,
        exceptions: r.exceptions,
        error: error
      };
    }

    function parseTimePeriod(r) {
      var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);

      switch (timePeriod.type) {
        case TOKENTYPES.second:
          r.second();
          break;

        case TOKENTYPES.minute:
          r.minute();
          break;

        case TOKENTYPES.hour:
          r.hour();
          break;

        case TOKENTYPES.dayOfYear:
          r.dayOfYear();
          break;

        case TOKENTYPES.dayOfWeek:
          r.dayOfWeek();
          break;

        case TOKENTYPES.dayInstance:
          r.dayOfWeekCount();
          break;

        case TOKENTYPES.day:
          r.dayOfMonth();
          break;

        case TOKENTYPES.weekOfMonth:
          r.weekOfMonth();
          break;

        case TOKENTYPES.weekOfYear:
          r.weekOfYear();
          break;

        case TOKENTYPES.month:
          r.month();
          break;

        case TOKENTYPES.year:
          r.year();
          break;

        default:
          error = pos;
      }

      return timePeriod;
    }

    function checkAndParse(tokenType) {
      var found = peek(tokenType).type === tokenType;

      if (found) {
        scan(tokenType);
      }

      return found;
    }

    function parseToken(tokenType) {
      var t = scan(tokenType);

      if (t.type) {
        t.text = convertString(t.text, tokenType);
      } else {
        error = pos;
      }

      return t;
    }

    function parseTokenValue(tokenType) {
      return parseToken(tokenType).text;
    }

    function convertString(str, tokenType) {
      var output = str;

      switch (tokenType) {
        case TOKENTYPES.time:
          var parts = str.split(/(:|am|pm)/),
            hour = parts[3] === "pm" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0],
            min = parts[2].trim();
          output = (hour.length === 1 ? "0" : "") + hour + ":" + min;
          break;

        case TOKENTYPES.rank:
          output = parseInt(/^\d+/.exec(str)[0], 10);
          break;

        case TOKENTYPES.monthName:
        case TOKENTYPES.dayName:
          output = NAMES[str.substring(0, 3)];
          break;
      }

      return output;
    }

    return parseScheduleExpr(str.toLowerCase());
  };

  return later;
}();
later.date.localTime();

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const CalendarIntervalMixin = base => {
  class CalendarIntervalMixin extends base {
    getCalendar() {
      return this.stores[0].calendar;
    }

    resetPriority() {
      this.priorityField = null;
    }

    getPriorityField() {
      if (this.priorityField != null) return this.priorityField;
      let base = 10000 + this.getCalendar().getDepth() * 100;
      let priority = this.priority;

      if (priority == null) {
        priority = this.isRecurrent() ? 20 : 30;
      }

      return this.priorityField = base + priority;
    }

    isRecurrent() {
      return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule());
    }

    isStatic() {
      return Boolean(this.startDate && this.endDate);
    }

    parseDateSchedule(schedule) {
      if (schedule && schedule !== Object(schedule)) {
        schedule = later.parse.text(schedule);

        if (schedule !== Object(schedule) || schedule.error > 0) {
          try {
            schedule = JSON.parse(schedule);
          } catch (e) {
            return null;
          }
        }
      }

      return schedule;
    }

    getStartDateSchedule() {
      if (this.startDateSchedule) return this.startDateSchedule;
      const schedule = this.parseDateSchedule(this.recurrentStartDate);
      return this.startDateSchedule = later.schedule(schedule);
    }

    getEndDateSchedule() {
      if (this.endDateSchedule) return this.endDateSchedule;
      const schedule = this.parseDateSchedule(this.recurrentEndDate);
      return this.endDateSchedule = later.schedule(schedule);
    }

  }

  __decorate([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ'
  }, {
    converter: dateConverter
  })], CalendarIntervalMixin.prototype, "startDate", void 0);

  __decorate([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ'
  }, {
    converter: dateConverter
  })], CalendarIntervalMixin.prototype, "endDate", void 0);

  __decorate([model_field({
    type: 'string'
  })], CalendarIntervalMixin.prototype, "recurrentStartDate", void 0);

  __decorate([model_field({
    type: 'string'
  })], CalendarIntervalMixin.prototype, "recurrentEndDate", void 0);

  __decorate([model_field({
    type: 'boolean',
    defaultValue: false
  })], CalendarIntervalMixin.prototype, "isWorking", void 0);

  __decorate([model_field({
    type: 'number'
  })], CalendarIntervalMixin.prototype, "priority", void 0);

  return CalendarIntervalMixin;
};
const BuildMinimalCalendarInterval = (base = Model) => CalendarIntervalMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(base)))));

class MinimalCalendarInterval extends BuildMinimalCalendarInterval() {
}


class ProCalendarIntervalModel extends PartOfProject(BuildMinimalCalendarInterval(Model)) {


}

ProCalendarIntervalModel._$name = 'ProCalendarIntervalModel';

const MIN_DATE = new Date(-8640000000000000);
const MAX_DATE = new Date(8640000000000000);
const isDateFinite = date => {
  if (!date) return false;
  const time = date.getTime();
  return time !== MIN_DATE.getTime() && time !== MAX_DATE.getTime();
};

var EdgeInclusion;

(function (EdgeInclusion) {
  EdgeInclusion[EdgeInclusion["Left"] = 0] = "Left";
  EdgeInclusion[EdgeInclusion["Right"] = 1] = "Right";
})(EdgeInclusion || (EdgeInclusion = {}));

var CalendarIteratorResult;

(function (CalendarIteratorResult) {
  CalendarIteratorResult[CalendarIteratorResult["FullRangeIterated"] = 0] = "FullRangeIterated";
  CalendarIteratorResult[CalendarIteratorResult["StoppedByIterator"] = 1] = "StoppedByIterator";
  CalendarIteratorResult[CalendarIteratorResult["MaxCacheExtendCyclesReached"] = 2] = "MaxCacheExtendCyclesReached";
})(CalendarIteratorResult || (CalendarIteratorResult = {}));

class CalendarCache {
  constructor(config) {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalsCachingChunkDuration = 30;
    this.intervalsCachingChunkUnit = TimeUnit.Day;
    this.maxCacheExtendCycles = 1000;
    config && Object.assign(this, config);
  }

  includeWrappingRangeFrom(cache, startDate, endDate) {
    cache.ensureCacheFilledForInterval(startDate, endDate);
    this.intervalCache.includeWrappingRange(cache.intervalCache, startDate, endDate);
  }

  ensureCacheFilledForInterval(startDate, endDate) {
    const cacheFilledStartDateN = this.cacheFilledStartDate.getTime();
    const cacheFilledEndDateN = this.cacheFilledEndDate.getTime();

    if (cacheFilledStartDateN !== MAX_DATE.getTime()) {
      const startDateN = startDate.getTime();
      const endDateN = endDate.getTime();
      if (cacheFilledStartDateN <= startDateN && endDateN <= cacheFilledEndDateN) return;

      if (endDateN <= cacheFilledStartDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else if (startDateN >= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN + 1);
      } else if (cacheFilledStartDateN <= startDateN && startDateN <= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN + 1);
      } else if (cacheFilledStartDateN <= endDateN && endDateN <= cacheFilledEndDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else {
        this.ensureCacheFilledForInterval(startDate, new Date(cacheFilledStartDateN - 1));
        this.ensureCacheFilledForInterval(new Date(cacheFilledEndDateN + 1), endDate);
        return;
      }
    }

    if (cacheFilledStartDateN === MAX_DATE.getTime() || startDate.getTime() < cacheFilledEndDateN) {
      this.cacheFilledStartDate = startDate;
    }

    if (cacheFilledEndDateN === MIN_DATE.getTime() || cacheFilledEndDateN < endDate.getTime()) {
      this.cacheFilledEndDate = endDate;
    }

    this.fillCache(startDate, endDate);
  }

  fillCache(_1, _2) {
    throw new Error("Abstract method");
  }

  clear() {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalCache.clear();
  }

  forEachAvailabilityInterval(options, func, scope) {
    scope = scope || this;
    const startDate = options.startDate;
    const endDate = options.endDate;
    const startDateN = startDate && startDate.getTime();
    const endDateN = endDate && endDate.getTime();
    const isForward = options.isForward !== false;

    if (isForward ? !startDate : !endDate) {
      throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
    }

    const intervalCache = this.intervalCache;
    let cacheCursorDate = isForward ? startDate : endDate;
    let cursorDate = isForward ? startDate : endDate;

    for (let cycle = 1; cycle < this.maxCacheExtendCycles; cycle++) {
      if (isForward) {
        this.ensureCacheFilledForInterval(cacheCursorDate, endDate || DateHelper.add(cacheCursorDate, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit));
      } else {
        this.ensureCacheFilledForInterval(startDate || DateHelper.add(cacheCursorDate, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), cacheCursorDate);
      }

      let interval = intervalCache.getIntervalOf(cursorDate, isForward ? EdgeInclusion.Left : EdgeInclusion.Right);

      while (interval) {
        const intervalStartDate = interval.startDate;
        const intervalEndDate = interval.endDate;

        if (isForward && endDateN && intervalStartDate.getTime() >= endDateN || !isForward && startDateN && intervalEndDate.getTime() <= startDateN) {
          return CalendarIteratorResult.FullRangeIterated;
        }

        if (isForward && intervalStartDate.getTime() > this.cacheFilledEndDate.getTime() || !isForward && intervalEndDate.getTime() < this.cacheFilledStartDate.getTime()) {
          break;
        }

        cursorDate = isForward ? intervalEndDate : intervalStartDate;
        const countFrom = startDateN && intervalStartDate.getTime() < startDateN ? startDate : intervalStartDate;
        const countTill = endDateN && intervalEndDate.getTime() > endDateN ? endDate : intervalEndDate;

        if (func.call(scope, countFrom, countTill, interval.cacheInterval) === false) {
          return CalendarIteratorResult.StoppedByIterator;
        }

        interval = isForward ? intervalCache.getNextInterval(interval) : intervalCache.getPrevInterval(interval);
      }

      if (isForward && cursorDate.getTime() === MAX_DATE.getTime() || !isForward && cursorDate.getTime() === MIN_DATE.getTime()) {
        return CalendarIteratorResult.FullRangeIterated;
      }

      cacheCursorDate = isForward ? this.cacheFilledEndDate : this.cacheFilledStartDate;
    }

    return CalendarIteratorResult.MaxCacheExtendCyclesReached;
  }

}

const stripDuplicates = array => {
  const seen = new Map();
  return array.filter(el => {
    if (seen.has(el)) return false;
    seen.set(el, true);
    return true;
  });
};

class CalendarCacheInterval {
  constructor(config) {
    this.intervals = [];
    config && Object.assign(this, config);
    if (!this.calendar) throw new Error("Required attribute `calendar` is missing");
  }

  includeInterval(interval) {
    if (this.intervals.indexOf(interval) == -1) {
      const copy = this.intervals.slice();
      copy.push(interval);
      return new CalendarCacheInterval({
        intervals: copy,
        calendar: this.calendar
      });
    } else return this;
  }

  combineWith(interval) {
    return new CalendarCacheInterval({
      intervals: this.intervals.concat(interval.intervals),
      calendar: this.calendar
    });
  }

  getIsWorking() {
    if (this.isWorking != null) return this.isWorking;
    const intervals = this.intervals = this.normalizeIntervals(this.intervals);
    return this.isWorking = intervals[0].isWorking;
  }

  normalizeIntervals(intervals) {
    const filtered = stripDuplicates(intervals);
    filtered.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());
    return filtered;
  }

}

const binarySearch = (value, array, comparator = (a, b) => a - b) => {
  let left = 0;
  let right = array.length;

  while (left < right) {
    const mid = (left + right) / 2 | 0;
    const compare = comparator(value, array[mid]);
    if (compare === 0) return {
      found: true,
      index: mid
    }; else if (compare < 0) right = mid; else left = mid + 1;
  }

  return {
    found: false,
    index: right
  };
};

var IndexPosition;

(function (IndexPosition) {
  IndexPosition[IndexPosition["Exact"] = 0] = "Exact";
  IndexPosition[IndexPosition["Next"] = 1] = "Next";
})(IndexPosition || (IndexPosition = {}));

class SortedMap {
  constructor(comparator) {
    this.keys = [];
    this.values = [];

    this.comparator = comparator || ((a, b) => a - b);
  }

  set(key, value) {
    const search = binarySearch(key, this.keys, this.comparator);

    if (search.found) {
      this.values[search.index] = value;
    } else {
      this.keys.splice(search.index, 0, key);
      this.values.splice(search.index, 0, value);
    }

    return search.index;
  }

  insertAt(index, key, value) {
    this.keys.splice(index, 0, key);
    this.values.splice(index, 0, value);
  }

  setValueAt(index, value) {
    this.values[index] = value;
  }

  get(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return search.found ? this.values[search.index] : undefined;
  }

  getEntryAt(index) {
    return index < this.keys.length ? {
      key: this.keys[index],
      value: this.values[index]
    } : undefined;
  }

  getKeyAt(index) {
    return this.keys[index];
  }

  getValueAt(index) {
    return this.values[index];
  }

  delete(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found) this.deleteAt(search.index);
  }

  size() {
    return this.keys.length;
  }

  deleteAt(index) {
    this.keys.splice(index, 1);
    this.values.splice(index, 1);
  }

  indexOfKey(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return {
      found: search.found ? IndexPosition.Exact : IndexPosition.Next,
      index: search.index
    };
  }

  map(func) {
    const keys = this.keys;
    const values = this.values;
    const result = [];

    for (let i = 0; i < keys.length; i++) result.push(func(values[i], keys[i], i));

    return result;
  }

  getAllEntries() {
    return this.map((value, key) => {
      return {
        value,
        key
      };
    });
  }

  clear() {
    this.keys.length = 0;
    this.values.length = 0;
  }

}

var EdgeInclusion$1;

(function (EdgeInclusion) {
  EdgeInclusion[EdgeInclusion["Left"] = 0] = "Left";
  EdgeInclusion[EdgeInclusion["Right"] = 1] = "Right";
})(EdgeInclusion$1 || (EdgeInclusion$1 = {}));

class IntervalCache {
  constructor(config) {
    this.points = new SortedMap((a, b) => a.getTime() - b.getTime());
    this.leftInfinityKey = MIN_DATE;
    this.rightInfinityKey = MAX_DATE;
    Object.assign(this, config);
    if (this.emptyInterval === undefined || !this.combineIntervalsFn) throw new Error("All of `emptyPoint`, `combineIntervalsFn` are required");
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }

  size() {
    return this.points.size();
  }

  indexOf(date) {
    return this.points.indexOfKey(date);
  }

  getDateAt(index) {
    return this.points.getKeyAt(index);
  }

  getPointAt(index) {
    return this.points.getValueAt(index);
  }

  getIntervalOf(date, edgeInclusion = EdgeInclusion$1.Left) {
    let {
      found,
      index
    } = this.indexOf(date);
    let startDateIndex;

    if (edgeInclusion === EdgeInclusion$1.Left) {
      startDateIndex = found === IndexPosition.Exact ? index : index - 1;
    } else {
      startDateIndex = index - 1;
    }

    return this.getIntervalWithStartDateIndex(startDateIndex);
  }

  getPrevInterval(interval) {
    if (interval.startDateIndex === 0) return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex - 1);
  }

  getNextInterval(interval) {
    if (interval.startDateIndex >= this.size() - 1) return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex + 1);
  }

  getIntervalWithStartDateIndex(startDateIndex) {
    return {
      startDateIndex: startDateIndex,
      startDate: this.getDateAt(startDateIndex),
      endDate: startDateIndex + 1 < this.size() ? this.getDateAt(startDateIndex + 1) : this.rightInfinityKey,
      cacheInterval: this.getPointAt(startDateIndex)
    };
  }

  addInterval(startDate, endDate, extendInterval) {
    const points = this.points;
    const {
      found,
      index
    } = points.indexOfKey(startDate);
    let curIndex;
    let lastUpdatedPoint;

    if (found == IndexPosition.Exact) {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index));
      points.setValueAt(index, inclusion);
      curIndex = index + 1;
    } else {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index - 1));
      points.insertAt(index, startDate, inclusion);
      curIndex = index + 1;
    }

    while (curIndex < points.size()) {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() >= endDate.getTime()) break;
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(curIndex));
      points.setValueAt(curIndex, inclusion);
      curIndex++;
    }

    if (curIndex === points.size()) {
      points.insertAt(points.size(), endDate, this.emptyInterval);
    } else {
      const curDate = points.getKeyAt(curIndex);

      if (curDate.getTime() === endDate.getTime()) ; else {
        points.insertAt(curIndex, endDate, lastUpdatedPoint);
      }
    }
  }

  includeWrappingRange(intervalCache, startDate, endDate) {
    let interval = intervalCache.getIntervalOf(startDate);

    while (interval) {
      this.addInterval(interval.startDate, interval.endDate, existingInterval => this.combineIntervalsFn(existingInterval, interval.cacheInterval));
      if (interval.endDate.getTime() > endDate.getTime()) break;
      interval = intervalCache.getNextInterval(interval);
    }
  }

  getSummary() {
    return this.points.map((label, date) => {
      return {
        label,
        date
      };
    });
  }

  clear() {
    this.points.clear();
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }

}

class CalendarCacheSingle extends CalendarCache {
  constructor(config) {
    super(config);
    this.staticIntervalsCached = false;
    if (!this.unspecifiedTimeInterval) throw new Error("Required attribute `unspecifiedTimeInterval` is missing");
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheInterval({
        intervals: [this.unspecifiedTimeInterval],
        calendar: this.calendar
      }),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }

  fillCache(startDate, endDate) {
    if (!this.staticIntervalsCached) {
      this.cacheStaticIntervals();
      this.staticIntervalsCached = true;
    }

    if (this.parentCache) this.includeWrappingRangeFrom(this.parentCache, startDate, endDate);
    const startDateN = startDate.getTime();
    const endDateN = endDate.getTime();
    if (startDateN > endDateN) throw new Error("Invalid cache fill interval");
    this.forEachRecurrentInterval(interval => {
      const startSchedule = interval.getStartDateSchedule();
      const endSchedule = interval.getEndDateSchedule();
      let wrappingStartDate = startSchedule.prev(1, startDate);
      let wrappingEndDate = endSchedule.next(1, endDate);

      if (wrappingStartDate !== later.NEVER && wrappingStartDate.getTime() === startDateN) {
        const wrappingStartDates = startSchedule.prev(2, startDate);
        if (wrappingStartDates !== later.NEVER && wrappingStartDates.length === 2) wrappingStartDate = wrappingStartDates[1];
      }

      if (wrappingEndDate !== later.NEVER && wrappingEndDate.getTime() === endDateN) {
        const wrappingEndDates = endSchedule.next(2, endDate);
        if (wrappingEndDates !== later.NEVER && wrappingEndDates.length === 2) wrappingEndDate = wrappingEndDates[1];
      }

      const startDates = startSchedule.next(Infinity, wrappingStartDate !== later.NEVER ? wrappingStartDate : startDate, wrappingEndDate !== later.NEVER ? new Date(wrappingEndDate.getTime() - 1) : endDate);
      if (startDates === later.NEVER) return;
      const endDates = endSchedule.next(Infinity, new Date(startDates[0].getTime() + 1), wrappingEndDate !== later.NEVER ? wrappingEndDate : endDate);

      if (endDates.length > startDates.length) {
        endDates.length = startDates.length;
      } else if (endDates.length < startDates.length) {
        startDates.length = endDates.length;
      }

      startDates.forEach((startDate, index) => {
        const recStartDate = startDate;
        const recEndDate = endDates[index];
        if (recStartDate.getTime() > recEndDate.getTime()) throw new Error("Recurrent interval inconsistency: " + interval + ", startDate: " + startDate + ", endDate: " + endDates[index]);
        this.intervalCache.addInterval(recStartDate, recEndDate, existingCacheInterval => existingCacheInterval.includeInterval(interval));
      });
    });
  }

  clear() {
    this.staticIntervalsCached = false;
    super.clear();
  }

  cacheStaticIntervals() {
    this.forEachStaticInterval(interval => {
      this.intervalCache.addInterval(interval.startDate, interval.endDate, existingCacheInterval => existingCacheInterval.includeInterval(interval));
    });
  }

  forEachStaticInterval(func) {
    this.intervalStore.forEach(interval => {
      if (interval.isStatic()) func(interval);
    });
  }

  forEachRecurrentInterval(func) {
    this.intervalStore.forEach(interval => {
      if (interval.isRecurrent()) func(interval);
    });
  }

}

class CalendarIntervalStore extends PartOfProjectStoreMixin(PartOfProjectGenericMixin(Store)) {
  static get defaultConfig() {
    return {
      modelClass: MinimalCalendarInterval
    };
  }

}

var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class UnspecifiedTimeIntervalModel extends MinimalCalendarInterval {
  getCalendar() {
    return this.calendar;
  }

  getPriorityField() {
    if (this.priorityField != null) return this.priorityField;
    return this.priorityField = this.getCalendar().getDepth();
  }

}

__decorate$1([model_field({
  type: 'number',
  defaultValue: 10
})], UnspecifiedTimeIntervalModel.prototype, "priority", void 0);

var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$1 = Symbol('CalendarMixin');
const CalendarMixin = base => {
  class CalendarMixin extends base {
    constructor() {
      super(...arguments);
      this.version = 1;
    }

    [hasMixin$1]() {
    }

    * calculateSelf() {
      yield this.$.version;
      return this;
    }

    afterConstruct() {
      super.afterConstruct();
      const hoursPerDay = this.hoursPerDay;
      const daysPerWeek = this.daysPerWeek;
      const daysPerMonth = this.daysPerMonth;
      this.unitsInMs = {
        millisecond: 1,
        second: 1000,
        minute: 60 * 1000,
        hour: 60 * 60 * 1000,
        day: hoursPerDay * 60 * 60 * 1000,
        week: daysPerWeek * hoursPerDay * 60 * 60 * 1000,
        month: daysPerMonth * hoursPerDay * 60 * 60 * 1000,
        quarter: 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1000,
        year: 4 * 3 * daysPerMonth * hoursPerDay * 60 * 60 * 1000
      };
      this.intervalStore = new CalendarIntervalStore({
        calendar: this,
        modelClass: this.constructor.defaultConfig.calendarIntervalModelClass || MinimalCalendarInterval
      });

      if (this.intervals && this.intervals.length) {
        this.addIntervals(this.intervals);
      }
    }

    isDefault() {
      const project = this.getProject();

      if (project) {
        return this === project.defaultCalendar;
      }

      return false;
    }

    getDepth() {
      return this.childLevel + 1;
    }

    forEachAvailabilityInterval(options, func, scope) {
      return this.calendarCache.forEachAvailabilityInterval(options, func, scope);
    }

    accumulateWorkingTime(date, duration, unit, isForward) {
      if (duration === 0) return {
        finalDate: new Date(date),
        remainingDurationInMs: 0
      };
      if (isNaN(duration)) throw new Error("Invalid duration");
      let remainingDurationInMs = this.convertDuration(duration, unit, TimeUnit.Millisecond);
      let finalDate = date;
      this.forEachAvailabilityInterval(isForward ? {
        startDate: date,
        isForward: true
      } : {
        endDate: date,
        isForward: false
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        let result = true;

        if (calendarCacheInterval.getIsWorking()) {
          const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
          const diff = intervalEndDate.getTime() - intervalStartDate.getTime() + dstDiff * 60 * 1000;

          if (remainingDurationInMs <= diff) {
            finalDate = isForward ? new Date(intervalStartDate.getTime() + remainingDurationInMs) : new Date(intervalEndDate.getTime() - remainingDurationInMs);
            remainingDurationInMs = 0;
            result = false;
          } else {
            finalDate = isForward ? intervalEndDate : intervalStartDate;
            remainingDurationInMs -= diff;
          }
        }

        return result;
      });
      return {
        finalDate: new Date(finalDate),
        remainingDurationInMs: remainingDurationInMs
      };
    }

    calculateDuration(startDate, endDate, unit) {
      let duration = 0;
      this.forEachAvailabilityInterval({
        startDate: startDate,
        endDate: endDate
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
          duration += intervalEndDate.getTime() - intervalStartDate.getTime() + dstDiff * 60 * 1000;
        }
      });
      return this.convertDuration(duration, TimeUnit.Millisecond, unit);
    }

    calculateEndDate(startDate, duration, unit) {
      const res = this.accumulateWorkingTime(startDate, duration, unit, true);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }

    calculateStartDate(endDate, duration, unit) {
      const res = this.accumulateWorkingTime(endDate, duration, unit, false);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }

    skipNonWorkingTime(date, isForward = true) {
      let workingDate;
      this.forEachAvailabilityInterval(isForward ? {
        startDate: date,
        isForward: true
      } : {
        endDate: date,
        isForward: false
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          workingDate = isForward ? intervalStartDate : intervalEndDate;
          return false;
        }
      });
      return workingDate ? new Date(workingDate) : new Date(date);
    }

    convertDuration(duration, fromUnit, toUnit) {
      let result = duration;

      if (fromUnit !== toUnit) {
        result = duration * this.unitsInMs[fromUnit] / this.unitsInMs[toUnit];
      }

      return result;
    }

    addInterval(interval) {
      return this.addIntervals([interval]);
    }

    addIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.add(intervals);
    }

    bumpVersion() {
      this.clearCache();
      this.version++;
    }

    get calendarCache() {
      if (this.$calendarCache !== undefined) return this.$calendarCache;
      const unspecifiedTimeInterval = new UnspecifiedTimeIntervalModel({
        isWorking: this.unspecifiedTimeIsWorking
      });
      unspecifiedTimeInterval.calendar = this;
      return this.$calendarCache = new CalendarCacheSingle({
        calendar: this,
        unspecifiedTimeInterval: unspecifiedTimeInterval,
        intervalStore: this.intervalStore,
        parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null
      });
    }

    clearCache() {
      this.$calendarCache && this.$calendarCache.clear();
      this.$calendarCache = undefined;
    }

    resetPriorityOfAllIntervals() {
      this.traverse(calendar => {
        calendar.intervalStore.forEach(interval => interval.resetPriority());
      });
    }

    appendChild(child) {
      let res = super.appendChild(child);

      if (!Array.isArray(res)) {
        res = [res];
      }

      res.forEach(r => {
        r.bumpVersion();
        r.resetPriorityOfAllIntervals();
      });
      return res;
    }

    insertChild(child, before) {
      let res = super.insertChild(child, before);

      if (!Array.isArray(res)) {
        res = [res];
      }

      res.forEach(r => {
        r.bumpVersion();
        r.resetPriorityOfAllIntervals();
      });
      return res;
    }

    joinProject() {
      super.joinProject();
      this.intervalStore.setProject(this.getProject());
    }

    leaveProject() {
      super.leaveProject();
      this.intervalStore.setProject(null);
    }

    isDayHoliday(day) {
      const startDate = DateHelper.clearTime(day),
        endDate = DateHelper.getNext(day, TimeUnit.Day);
      let hasWorkingTime = false;
      this.forEachAvailabilityInterval({
        startDate,
        endDate,
        isForward: true
      }, (_intervalStartDate, _intervalEndDate, calendarCacheInterval) => {
        hasWorkingTime = calendarCacheInterval.getIsWorking();
        return !hasWorkingTime;
      });
      return !hasWorkingTime;
    }

    getDailyHolidaysRanges(startDate, endDate) {
      let result = [];
      startDate = DateHelper.clearTime(startDate);

      while (startDate < endDate) {
        if (this.isDayHoliday(startDate)) {
          result.push({
            startDate,
            endDate: DateHelper.getStartOfNextDay(startDate, true, true)
          });
        }

        startDate = DateHelper.getNext(startDate, TimeUnit.Day);
      }

      return result;
    }

  }

  __decorate$2([field({
    persistent: false
  })], CalendarMixin.prototype, "version", void 0);

  __decorate$2([model_field({
    type: 'string'
  })], CalendarMixin.prototype, "name", void 0);

  __decorate$2([model_field({
    type: 'number',
    defaultValue: 24
  })], CalendarMixin.prototype, "hoursPerDay", void 0);

  __decorate$2([model_field({
    type: 'number',
    defaultValue: 7
  })], CalendarMixin.prototype, "daysPerWeek", void 0);

  __decorate$2([model_field({
    type: 'number',
    defaultValue: 30
  })], CalendarMixin.prototype, "daysPerMonth", void 0);

  __decorate$2([model_field({
    type: 'boolean',
    defaultValue: true
  })], CalendarMixin.prototype, "unspecifiedTimeIsWorking", void 0);

  __decorate$2([model_field()], CalendarMixin.prototype, "intervals", void 0);

  return CalendarMixin;
};
const BuildMinimalCalendar = (base = Model) => CalendarMixin(PartOfProjectMixin(PartOfProjectGenericMixin(Entity$1(base))));

class MinimalCalendar extends BuildMinimalCalendar() {
}


class ProCalendarModel extends PartOfProject(BuildMinimalCalendar(Model)) {


  static get fields() {
    return [];
  }

  static get defaultConfig() {
    return {
      calendarIntervalModelClass: ProCalendarIntervalModel
    };
  }

}

ProCalendarModel._$name = 'ProCalendarModel';


var CrudManager$1 = (Base => class ProCrudManager extends JsonEncoder(AjaxTransport(AbstractCrudManagerMixin(Base))) {
  construct(...args) {
    const me = this;
    super.construct(...args);

    me.addPrioritizedStore(me.calendarManagerStore);
    me.addPrioritizedStore(me.assignmentStore);
    me.addPrioritizedStore(me.dependencyStore);
    me.addPrioritizedStore(me.resourceStore);
    me.addPrioritizedStore(me.eventStore);
    me.addPrioritizedStore(me.timeRangeStore);
  }

  async applyResponse(requestType, response, options) {
    await super.applyResponse(requestType, response, options);

    response && response.project && Object.assign(this, response.project);

    await this.propagate(conflict => {
      if (conflict instanceof GraphCycleDetectedEffect) {
        const cycleEntityIds = Array.from(new Set(conflict.cycle.map(node => node.self.id)));
        const error = new Error('Graph cycle: ' + cycleEntityIds);
        error.conflict = conflict;
        throw error;
      } else {
        return EffectResolutionResult.Resume;
      }
    });

    this.clearCrudStoresChanges();
  }

  clearCrudStoresChanges() {


    this.crudStores.forEach(store => {
      const me = store.store;
      me.remove(me.added.values, true);
      me.modified.forEach(r => r.clearChanges(false));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
    });
  }

  applyProjectResponse(projectResponse) {
    this.loadProjectFields(projectResponse);
  }

});


var ProEventAPI = (Target => class ProEventAPI extends (Target || Base) {

  async addEventToResource({
                             event,
                             resource,
                             eventStore,
                             assignmentStore
                           }) {
    const {
      assignment
    } = super.addEventToResource({
      event,
      resource,
      eventStore,
      assignmentStore
    });
    const result = await this.propagate();
    return {
      event,
      assignment,
      result
    };
  }

  addEventToResourceWithoutPropagation(arg) {
    return super.addEventToResource(arg);
  }

  async removeEvents(records) {
    records.forEach(record => record.remove());
    await this.project.propagate();
  }

});


var ProDependencyAPI = (Target => class ProDependencyAPI extends (Target || Base) {
  isValidDependency({
                      sourceEvent,
                      targetEvent,
                      type,
                      dependencyStore
                    }) {
    return dependencyStore.isValidDependency({
      fromEvent: sourceEvent,
      toEvent: targetEvent,
      type
    });
  }

  async createDependency({
                           sourceEvent,
                           targetEvent,
                           type,
                           dependencyStore
                         }) {
    const dependency = dependencyStore.add({
      fromEvent: sourceEvent,
      toEvent: targetEvent,
      type
    })[0];
    const result = await this.propagate();
    return {
      result,
      dependency
    };
  }

});


var ProResourceAPI = (Target => class ProResourceAPI extends (Target || Base) {
});


var ProProjectAPI = (Target => class ProProjectAPI extends (Target || Base) {
  get project() {
    const me = this,
      host = me.host;

    if (!me._project) {
      me._project = host.getProjectForDataAPI && host.getProjectForDataAPI(me) || host.getProject && host.getProject(me);
    }

    return me._project;
  }

  propagate() {
    return this.project.propagate();
  }

  beginPropagationBatch() {
    this.project.suspendPropagate();
  }

  endPropagationBatch(trigger = true) {
    return this.project.resumePropagate(trigger);
  }

});


var ProDataAPI = (Target => {

  const APIs = [ResourceAPI, EventAPI, AssignmentAPI, DependencyAPI, ProResourceAPI, ProEventAPI, ProAssignmentAPI, ProDependencyAPI, ProProjectAPI];
  const RAW_API = base(Base).mixes(...APIs);
  return class ProDataAPI extends (Target || Base) {

    get dataApi() {
      if (!this._dataApi) {
        this._dataApi = new RAW_API({
          host: this.dataApiHost || this
        });
      }

      return this._dataApi;
    }

  };
});


class ProDependencies extends base(Dependencies).mixes(ProDataAPI) {
  static get featureClass() {
    return 'b-dependencies';
  }

  static get defaultConfig() {
    return {
      terminalSides: ['left', 'right']
    };
  }

  getProjectForDataAPI() {
    return this.dependencyStore.getProject();
  }

  obtainResourceStore(scheduler, config) {
    return scheduler.project.getResourceStore();
  }

  obtainDependencyStore(scheduler, config) {
    return scheduler.project.getDependencyStore();
  }

  obtainAssignmentStore(scheduler, config) {
    return scheduler.project.getAssignmentStore();
  }

  obtainEventStore(scheduler, config) {
    return scheduler.project.getEventStore();
  }

}

ProDependencies._$name = 'ProDependencies';
GridFeatureManager.registerFeature(ProDependencies, true, 'ProScheduler', 'Dependencies');

var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$2 = Symbol('hasMixin');
const DependencyMixin = base => {
  class DependencyMixin extends base {
    [hasMixin$2]() {
    }

    * calculateSelf() {
      yield this.$.lag;
      yield this.$.lagUnit;
      yield this.$.type;
      return this;
    }

    * calculateCalendar() {
      const dependenciesCalendar = yield this.getProject().$.dependenciesCalendar;
      let calendar;

      switch (dependenciesCalendar) {
        case DependenciesCalendar.Project:
          calendar = yield this.getProject().$.calendar;
          break;

        case DependenciesCalendar.FromEvent:
          const fromEvent = yield this.$.fromEvent;
          calendar = fromEvent && !isAtomicValue(fromEvent) ? yield fromEvent.$.calendar : null;
          break;

        case DependenciesCalendar.ToEvent:
          const toEvent = yield this.$.toEvent;
          calendar = toEvent && !isAtomicValue(toEvent) ? yield toEvent.$.calendar : null;
          break;
      }

      if (!calendar) calendar = yield this.getProject().$.calendar;
      yield calendar.$$;
      return calendar;
    }

    async setLag(lag, lagUnit = this.lagUnit) {
      this.$.lag.put(lag);
      this.$.lagUnit.put(lagUnit);
      return this.propagate();
    }

  }

  __decorate$3([generic_field({
    bucket: 'outgoingDeps',
    resolver: function (id) {
      return this.getEventById(id);
    },
    modelFieldConfig: {
      persist: true,
      serialize: event => event.id
    }
  }, ModelReferenceField)], DependencyMixin.prototype, "fromEvent", void 0);

  __decorate$3([generic_field({
    bucket: 'incomingDeps',
    resolver: function (id) {
      return this.getEventById(id);
    },
    modelFieldConfig: {
      persist: true,
      serialize: event => event.id
    }
  }, ModelReferenceField)], DependencyMixin.prototype, "toEvent", void 0);

  __decorate$3([model_field({
    type: 'number',
    defaultValue: 0
  })], DependencyMixin.prototype, "lag", void 0);

  __decorate$3([model_field({
    type: 'string',
    defaultValue: TimeUnit.Day
  }, {
    converter: DateHelper.normalizeUnit
  })], DependencyMixin.prototype, "lagUnit", void 0);

  __decorate$3([model_field({
    type: 'string',
    defaultValue: DependencyType.EndToStart
  })], DependencyMixin.prototype, "type", void 0);

  __decorate$3([field()], DependencyMixin.prototype, "calendar", void 0);

  __decorate$3([calculate('calendar')], DependencyMixin.prototype, "calculateCalendar", null);

  return DependencyMixin;
};
const BuildMinimalDependency = (base = Model) => DependencyMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(base)))));

class MinimalDependency extends BuildMinimalDependency() {
}

const hasDependencyMixin = model => Boolean(model && model[hasMixin$2]);

const canonicalDependencyTypes$1 = ['SS', 'SF', 'FS', 'FF'];


class ProDependencyModel extends PartOfProject(BuildMinimalDependency(DependencyBaseModel)) {
  static get fields() {
    return [{
      name: 'from',
      persist: false
    }, {
      name: 'to',
      persist: false
    }];
  }


  constructor(...args) {
    const [config] = args;

    if (config && config.fromTask) {
      config.fromEvent = config.fromTask;
    }

    if (config && config.toTask) {
      config.toEvent = config.toTask;
    }

    super(...args);
  }


  set sourceTask(task) {
    this.fromEvent = task;
  }

  get sourceTask() {
    return this.fromEvent;
  }

  set sourceEvent(task) {
    this.fromEvent = task;
  }

  get sourceEvent() {
    return this.fromEvent;
  }

  get from() {
    return this.fromEvent && this.fromEvent.id;
  }

  get fromTask() {
    return this.fromEvent;
  }

  set fromTask(task) {
    this.fromEvent = task;
  }

  getFromTask() {
    return this.getFromEvent();
  }

  setFromTask(...args) {
    return this.setFromEvent(...args);
  }


  set targetTask(task) {
    this.toEvent = task;
  }

  get to() {
    return this.toEvent && this.toEvent.id;
  }

  get targetTask() {
    return this.toEvent;
  }

  set targetEvent(task) {
    this.toEvent = task;
  }

  get targetEvent() {
    return this.toEvent;
  }

  get toTask() {
    return this.toEvent;
  }

  set toTask(task) {
    this.toEvent = task;
  }

  getToTask() {
    return this.getToEvent();
  }

  setToTask(...args) {
    return this.setToEvent(...args);
  }


  getTypeFromSides(fromSide, toSide, rtl) {
    const types = DependencyBaseModel.Type,
      startSide = rtl ? 'right' : 'left',
      endSide = rtl ? 'left' : 'right';

    if (fromSide === startSide) {
      return toSide === startSide ? types.StartToStart : types.StartToEnd;
    }

    return toSide === endSide ? types.EndToEnd : types.EndToStart;
  }

  getConnectorString(raw) {
    const rawValue = canonicalDependencyTypes$1[this.type];

    if (raw) {
      return rawValue;
    }

    if (this.type === DependencyBaseModel.Type.EndToStart) {
      return '';
    }

    const locale = LocaleManagerSingelton.locale;

    if (locale) {
      const localized = locale.SchedulerProCommon && locale.SchedulerProCommon[rawValue];

      if (localized) {
        return localized;
      }
    }

    return rawValue;
  }

}

ProDependencyModel._$name = 'ProDependencyModel';


class ProEventDrag extends base(EventDrag).mixes(ProDataAPI) {
  getProjectForDataAPI() {
    return this.eventStore.getProject();
  }

  updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed) {


    const me = this,
      draggedAssignments = context.draggedRecords,
      consistentStartDates = draggedAssignments.map(a => {
        return me.dataApi.getAssignmentEvent({
          assignment: a,
          eventStore: me.eventStore
        }).startDate;
      });
    this.dataApi.beginPropagationBatch();
    super.updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
    context.valid = true;

    return this.dataApi.endPropagationBatch().then(result => {


      draggedAssignments.forEach((a, i) => {
        const eventDragged = me.dataApi.getAssignmentEvent({
            assignment: a,
            eventStore: me.eventStore
          }),
          consistentStartDate = consistentStartDates[i];

        if (consistentStartDate - eventDragged.startDate === 0) {

          const eventElement = me.client.getElementFromAssignmentRecord(a);

          if (eventElement) {
            DomHelper.setTranslateX(eventElement.parentElement, me.client.getCoordinateFromDate(consistentStartDate));

            const depFeature = me.client.features.dependencies;

            if (depFeature) {
              depFeature.updateDependenciesForTimeSpan(a, eventElement);
            }
          }
        }
      });
      return result;
    });
  }

}

ProEventDrag._$name = 'ProEventDrag';
GridFeatureManager.registerFeature(ProEventDrag, true, 'ProScheduler', 'EventDrag');


class ProEventDragCreate extends base(EventDragCreate).mixes(SchedulerFeatureDataLayer, ProDataAPI) {
  static get featureClass() {
    return 'b-eventdragcreate';
  }

  async finalizeDragCreate(context) {
    const me = this,
      creatorFn = () => {
        me.eventStore.modelClass.exposeProperties();
        const defaultDurationUnit = me.eventStore.modelClass.getFieldDefinition('durationUnit').defaultValue,
          {
            event,
            assignment
          } = me.dataApi.addEventToResourceWithoutPropagation({
            event: {
              startDate: context.startDate,
              duration: context.rowRecord.getCalendar().calculateDuration(context.startDate, context.endDate, defaultDurationUnit)
            },
            resource: context.rowRecord,
            eventStore: me.eventStore,
            assignmentStore: me.assignmentStore
          });
        me.scheduler.trigger('dragCreateEnd', {
          newEventRecord: event,
          newAssignmentRecord: assignment,
          resourceRecord: context.rowRecord,
          event: context.event,
          proxyElement: me.proxy
        });
        return event;
      };

    if (me.client.hasFeature('eventEdit')) {
      me.client.features.eventEdit.editEvent(creatorFn, context.rowRecord);
    } else {
      creatorFn();
      await me.dataApi.propagate();
    }
  }

  getProjectForDataAPI() {
    return this.eventStore.getProject();
  }


  obtainResourceStore(scheduler, config) {
    return scheduler.project.getResourceStore();
  }

  obtainDependencyStore(scheduler, config) {
    return scheduler.project.getDependencyStore();
  }

  obtainAssignmentStore(scheduler, config) {
    return scheduler.project.getAssignmentStore();
  }

  obtainEventStore(scheduler, config) {
    return scheduler.project.getEventStore();
  }

}

ProEventDragCreate._$name = 'ProEventDragCreate';
GridFeatureManager.registerFeature(ProEventDragCreate, true, 'ProScheduler', 'EventDragCreate');


class ProNonWorkingTime extends AbstractTimeRanges {

  static get defaultConfig() {
    return {
      showHeaderElements: true,
      cls: 'b-sch-nonworkingtime',


      calendar: null
    };
  }


  construct(client, config) {
    super.construct(client, config);
    this.bindProject(client.project);
  }

  get calendar() {
    return this._calendar;
  }

  set calendar(calendar) {
    const me = this;

    if (calendar !== me._calendar) {
      me._calendar = calendar;
      me.client.isPainted && me.renderRanges();
    }
  }

  doDestroy() {
    this.unbindProject();
    super.doDestroy();
  }


  bindProject(project) {
    const me = this;

    if (!me.calendar) {
      me.calendar = project.getCalendar();
      me.projectDetacher = project.eventStore.on('change', ({
                                                              record,
                                                              changes
                                                            }) => {
        if (record === project && changes.calendar) {
          me.calendar = project.getCalendar();
        }
      });
    }

    me.cmsDetacher = project.getCalendarManagerStore().on({
      update({
               record
             }) {
        if (record === me.calendar && me.client.isPainted) {
          me.renderRanges();
        }
      },

      thisObj: me
    });
  }

  unbindProject() {
    const me = this;
    me.cmsDetacher && me.cmsDetacher();
    me.cmsDetacher = null;
    me.projectDetacher && me.projectDetacher();
    me.projectDetacher = null;
  }


  renderRanges() {
    const me = this,
      {
        store
      } = me,
      {
        timeAxis
      } = me.client;

    if (store && !store.isDestroyed) {
      const shouldPaint = DateHelper.as(timeAxis.unit, 1, 'week') >= 1;
      store.removeAll(true);

      if (me.calendar && shouldPaint) {
        store.add(me.calendar.getDailyHolidaysRanges(timeAxis.startDate, timeAxis.endDate), true);
      }
    }

    super.renderRanges();
  }

}

ProNonWorkingTime._$name = 'ProNonWorkingTime';
GridFeatureManager.registerFeature(ProNonWorkingTime, true, ['ProScheduler', 'Gantt'], 'nonWorkingTime');

var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$3 = Symbol('HasCalendarMixin');
const HasCalendarMixin = base => {
  class HasCalendarMixin extends base {
    constructor() {
      super(...arguments);
      this.calendarInherited = true;
    }

    [hasMixin$3]() {
    }

    async setCalendar(calendar) {
      this.calendar = calendar;
      return this.propagate();
    }

    getCalendar() {
      return this.calendar;
    }

    * calculateCalendar(proposedValue) {
      const calendarManager = this.getCalendarManagerStore();
      let resolved, calendar;

      if (proposedValue != null) {
        if (isAtomicValue(proposedValue)) {
          resolved = calendarManager.getById(proposedValue) || null;
          proposedValue = resolved;
        }

        this.calendarInherited = false;
        calendar = proposedValue;
      } else if (proposedValue === undefined && this.$.calendar.hasConsistentValue() && !this.calendarInherited) {
        calendar = this.$.calendar.getConsistentValue();
      }

      if (calendar == null) {
        const project = this.getProject();

        if (project !== this) {
          calendar = yield project.$.calendar;
          this.calendarInherited = true;
        }
      }

      !isAtomicValue(calendar) && (yield calendar.$$);
      return calendar;
    }

  }

  __decorate$4([model_field({
    serialize: calendar => calendar && calendar.id
  })], HasCalendarMixin.prototype, "calendar", void 0);

  __decorate$4([calculate('calendar')], HasCalendarMixin.prototype, "calculateCalendar", null);

  return HasCalendarMixin;
};

class Conflict extends Effect {
}

class DateInterval extends Base$1 {
  initialize(...args) {
    super.initialize(...args);
    if (!this.startDate) this.startDate = MIN_DATE;
    if (!this.endDate) this.endDate = MAX_DATE;
  }

  startDateIsFinite() {
    return !this.isIntervalEmpty() && this.startDate.getTime() !== MIN_DATE.getTime();
  }

  endDateIsFinite() {
    return !this.isIntervalEmpty() && this.endDate.getTime() !== MAX_DATE.getTime();
  }

  containsDate(date, edgeInclusion = EdgeInclusion.Left) {
    return edgeInclusion === EdgeInclusion.Left && date >= this.startDate && date < this.endDate || edgeInclusion === EdgeInclusion.Right && date > this.startDate && date <= this.endDate;
  }

  isIntervalEmpty() {
    return this.startDate > this.endDate;
  }

  intersect(another) {
    const anotherStart = another.startDate;
    const anotherEnd = another.endDate;
    const start = this.startDate;
    const end = this.endDate;

    if (end < anotherStart || start > anotherEnd) {
      return EMPTY_INTERVAL;
    }

    const newStart = new Date(Math.max(start.getTime(), anotherStart.getTime()));
    const newEnd = new Date(Math.min(end.getTime(), anotherEnd.getTime()));
    return this.constructor.new({
      startDate: newStart,
      endDate: newEnd
    });
  }

}

const EMPTY_INTERVAL = DateInterval.new({
  startDate: MAX_DATE,
  endDate: MIN_DATE
});
const intersectIntervals = dateIntervals => {
  return dateIntervals.reduce((acc, currentInterval) => acc.intersect(currentInterval), DateInterval.new());
};

var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class ConstraintInterval extends DateInterval {
  toString() {
    return `from ${this.startDate} till ${this.endDate}`;
  }

}

const calculateEffectiveStartDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration) {
  if (endDateIntervalIntersection.isIntervalEmpty()) return EMPTY_INTERVAL;
  const startDate = endDateIntervalIntersection.startDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.startDate, false, duration) : null;
  const endDate = endDateIntervalIntersection.endDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(endDateIntervalIntersection.endDate, false, duration) : null;
  return intersectIntervals([startDateIntervalIntersection, DateInterval.new({
    startDate,
    endDate
  })]);
};
const calculateEffectiveEndDateConstraintInterval = function* (event, startDateIntervalIntersection, endDateIntervalIntersection, duration) {
  if (startDateIntervalIntersection.isIntervalEmpty()) return EMPTY_INTERVAL;
  const startDate = startDateIntervalIntersection.startDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.startDate, true, duration) : null;
  const endDate = startDateIntervalIntersection.endDateIsFinite() ? yield* event.calculateProjectedXDateWithDuration(startDateIntervalIntersection.endDate, true, duration) : null;
  return intersectIntervals([endDateIntervalIntersection, DateInterval.new({
    startDate,
    endDate
  })]);
};
const ConstrainedEvent = base => {
  class ConstrainedEvent extends base {
    async setManuallyScheduled(mode) {
      this.$.manuallyScheduled.put(mode);
      return this.propagate();
    }

    * maybeSkipNonWorkingTime(date, isForward = true) {
      let duration = yield* this.calculateEffectiveDuration();
      return date && duration > 0 ? yield* this.skipNonWorkingTime(date, isForward) : date;
    }

    * calculateEffectiveConstraintInterval(isStartDate, startDateConstraintIntervals, endDateConstraintIntervals) {
      const effectiveDurationToUse = yield* this.calculateEffectiveDuration();

      if (effectiveDurationToUse === null) {
        return null;
      }

      const calculateIntervalFn = isStartDate ? calculateEffectiveStartDateConstraintInterval : calculateEffectiveEndDateConstraintInterval;
      const effectiveInterval = yield* calculateIntervalFn(this, intersectIntervals(startDateConstraintIntervals), intersectIntervals(endDateConstraintIntervals), effectiveDurationToUse);
      return effectiveInterval;
    }

    * calculateStartDateConstraintIntervals() {
      return [];
    }

    * calculateEndDateConstraintIntervals() {
      return [];
    }

    * calculateEarlyStartDateConstraintIntervals() {
      return [];
    }

    * calculateEarlyEndDateConstraintIntervals() {
      return [];
    }

    * calculateEarlyStartDateRaw() {
      if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) {
        return yield this.$.startDate;
      }

      const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;
      const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;
      const effectiveInterval = yield* this.calculateEffectiveConstraintInterval(true, startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals));
      if (!effectiveInterval) return null;

      if (effectiveInterval.isIntervalEmpty()) {
        if (this.$.startDate.value === undefined) {
          yield PromiseEffect.new({
            promise: Promise.resolve()
          });
          return null;
        }

        yield Conflict.new();
      }

      if (!isDateFinite(effectiveInterval.startDate)) return null;
      return effectiveInterval.startDate;
    }

    * calculateEarlyStartDate() {
      const date = yield this.$.earlyStartDateRaw;
      return yield* this.maybeSkipNonWorkingTime(date, true);
    }

    * calculateEarlyEndDateRaw() {
      if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) {
        return yield this.$.endDate;
      }

      const startDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;
      const endDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;
      const effectiveInterval = yield* this.calculateEffectiveConstraintInterval(false, startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals));
      if (!effectiveInterval) return null;

      if (effectiveInterval.isIntervalEmpty()) {
        if (this.$.endDate.value === undefined) {
          yield PromiseEffect.new({
            promise: Promise.resolve()
          });
          return null;
        }

        yield Conflict.new();
      }

      if (!isDateFinite(effectiveInterval.startDate)) return null;
      return effectiveInterval.startDate;
    }

    * calculateEarlyEndDate() {
      const date = yield this.$.earlyEndDateRaw;
      return yield* this.maybeSkipNonWorkingTime(date, false);
    }

    * isConstrainedEarly() {
      const startDateIntervals = yield this.$.startDateConstraintIntervals;
      const endDateIntervals = yield this.$.endDateConstraintIntervals;
      const earlyStartDateConstraintIntervals = yield this.$.earlyStartDateConstraintIntervals;
      const earlyEndDateConstraintIntervals = yield this.$.earlyEndDateConstraintIntervals;
      return Boolean(startDateIntervals.length || endDateIntervals.length || earlyStartDateConstraintIntervals.length || earlyEndDateConstraintIntervals.length);
    }

    * calculateStartDatePure() {
      const direction = yield this.$.direction;

      if (direction === Direction.Forward) {
        if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) {
          return yield* super.calculateStartDatePure();
        }

        return (yield this.$.earlyStartDate) || (yield* super.calculateStartDatePure());
      } else {
        return yield* super.calculateStartDatePure();
      }
    }

    * calculateStartDateProposed() {
      const direction = yield this.$.direction;

      switch (direction) {
        case Direction.Forward:
          if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) {
            return yield* super.calculateStartDateProposed();
          }

          return (yield this.$.earlyStartDate) || (yield* super.calculateStartDateProposed());

        default:
          return yield* super.calculateStartDateProposed();
      }
    }

    * calculateEndDatePure() {
      const direction = yield this.$.direction;

      if (direction === Direction.Forward) {
        if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) {
          return yield* super.calculateEndDatePure();
        }

        return (yield this.$.earlyEndDate) || (yield* super.calculateEndDatePure());
      } else {
        return yield* super.calculateEndDatePure();
      }
    }

    * calculateEndDateProposed() {
      const direction = yield this.$.direction;

      switch (direction) {
        case Direction.Forward:
          if (!(yield* this.isConstrainedEarly()) || (yield this.$.manuallyScheduled)) {
            return yield* super.calculateEndDateProposed();
          }

          return (yield this.$.earlyEndDate) || (yield* super.calculateEndDateProposed());

        default:
          return yield* super.calculateEndDateProposed();
      }
    }

  }

  __decorate$5([field()], ConstrainedEvent.prototype, "earlyStartDateRaw", void 0);

  __decorate$5([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ',
    persist: false
  }, {
    converter: dateConverter,
    persistent: false
  })], ConstrainedEvent.prototype, "earlyStartDate", void 0);

  __decorate$5([field()], ConstrainedEvent.prototype, "earlyEndDateRaw", void 0);

  __decorate$5([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ',
    persist: false
  }, {
    converter: dateConverter,
    persistent: false
  })], ConstrainedEvent.prototype, "earlyEndDate", void 0);

  __decorate$5([model_field({
    type: 'boolean',
    defaultValue: false
  })], ConstrainedEvent.prototype, "manuallyScheduled", void 0);

  __decorate$5([field()], ConstrainedEvent.prototype, "startDateConstraintIntervals", void 0);

  __decorate$5([field()], ConstrainedEvent.prototype, "earlyStartDateConstraintIntervals", void 0);

  __decorate$5([field()], ConstrainedEvent.prototype, "endDateConstraintIntervals", void 0);

  __decorate$5([field()], ConstrainedEvent.prototype, "earlyEndDateConstraintIntervals", void 0);

  __decorate$5([calculate('startDateConstraintIntervals')], ConstrainedEvent.prototype, "calculateStartDateConstraintIntervals", null);

  __decorate$5([calculate('endDateConstraintIntervals')], ConstrainedEvent.prototype, "calculateEndDateConstraintIntervals", null);

  __decorate$5([calculate('earlyStartDateConstraintIntervals')], ConstrainedEvent.prototype, "calculateEarlyStartDateConstraintIntervals", null);

  __decorate$5([calculate('earlyEndDateConstraintIntervals')], ConstrainedEvent.prototype, "calculateEarlyEndDateConstraintIntervals", null);

  __decorate$5([calculate('earlyStartDateRaw')], ConstrainedEvent.prototype, "calculateEarlyStartDateRaw", null);

  __decorate$5([calculate('earlyStartDate')], ConstrainedEvent.prototype, "calculateEarlyStartDate", null);

  __decorate$5([calculate('earlyEndDateRaw')], ConstrainedEvent.prototype, "calculateEarlyEndDateRaw", null);

  __decorate$5([calculate('earlyEndDate')], ConstrainedEvent.prototype, "calculateEarlyEndDate", null);

  return ConstrainedEvent;
};

const RequiredProperties = Symbol('RequiredProperties');
const required = (proto, propertyKey) => {
  let required = proto[RequiredProperties];
  if (!required) required = proto[RequiredProperties] = [];
  required.push(propertyKey);
};
const validateRequiredProperties = context => {
  const required = context[RequiredProperties];

  if (required) {
    for (let i = 0; i < required.length; i++) if (context[required[i]] === undefined) throw new Error(`Required attribute [${String(required[i])}] is not provided`);
  }
};

function split(iterable) {
  const gen1Pending = [];
  const gen2Pending = [];
  let iterator;

  const gen1 = function* () {
    if (!iterator) iterator = iterable[Symbol.iterator]();

    while (true) {
      if (gen1Pending.length) {
        yield* gen1Pending;
        gen1Pending.length = 0;
      }

      if (!iterator) break;
      const {
        value,
        done
      } = iterator.next();

      if (done) {
        iterator = null;
        iterable = null;
        break;
      }

      gen2Pending.push(value);
      yield value;
    }
  };

  const gen2 = function* () {
    if (!iterator) iterator = iterable[Symbol.iterator]();

    while (true) {
      if (gen2Pending.length) {
        yield* gen2Pending;
        gen2Pending.length = 0;
      }

      if (!iterator) break;
      const {
        value,
        done
      } = iterator.next();

      if (done) {
        iterator = null;
        iterable = null;
        break;
      }

      gen1Pending.push(value);
      yield value;
    }
  };

  return [gen1(), gen2()];
}

function* inBatchesBySize(iterator, batchSize) {
  if (batchSize < 0) throw new Error("Batch size needs to a natural number");
  batchSize = batchSize | 0;
  const runningBatch = [];

  for (const el of iterator) {
    if (runningBatch.length === batchSize) {
      yield runningBatch;
      runningBatch.length = 0;
    }

    runningBatch.push(el);
  }

  if (runningBatch.length > 0) yield runningBatch;
}

function* filter(iterator, func) {
  let i = 0;

  for (const el of iterator) {
    if (func(el, i++)) yield el;
  }
}

function* drop(iterator, howMany) {
  let i = 0;

  for (const el of iterator) {
    if (++i > howMany) yield el;
  }
}

function every(iterator, func) {
  let i = 0;

  for (const el of iterator) {
    if (!func(el, i++)) return false;
  }

  return true;
}

function some(iterator, func) {
  let i = 0;

  for (const el of iterator) {
    if (func(el, i++)) return true;
  }

  return false;
}

function* map(iterator, func) {
  let i = 0;

  for (const el of iterator) yield func(el, i++);
}

function reduce(iterator, func, initialAcc) {
  let i = 0;
  let acc = initialAcc;

  for (const el of iterator) {
    acc = func(acc, el, i++);
  }

  return acc;
}

function* uniqueOnly(iterator) {
  const seen = new Set();

  for (const el of iterator) {
    if (!seen.has(el)) {
      seen.add(el);
      yield el;
    }
  }
}

function* uniqueOnlyBy(iterator, func) {
  const seen = new Set();

  for (const el of iterator) {
    const uniqueBy = func(el);

    if (!seen.has(uniqueBy)) {
      seen.add(uniqueBy);
      yield el;
    }
  }
}

function* takeWhile(iterator, func) {
  let i = 0;

  for (const el of iterator) {
    if (func(el, i++)) yield el; else return;
  }
}

function* concatIterable(iteratorsProducer) {
  for (const iterator of iteratorsProducer) yield* iterator;
}

class ChainedIteratorClass {
  constructor(iterable) {
    this.iterable = undefined;
    if (!iterable) throw new Error("Require an iterable instance for chaining");
    this.iterable = iterable;
  }

  derive(iterable) {
    this.iterable = undefined;
    return new ChainedIteratorClass(iterable);
  }

  copy() {
    const [iter1, iter2] = split(this.iterable);
    this.iterable = iter2;
    return new ChainedIteratorClass(iter1);
  }

  split() {
    const [iter1, iter2] = split(this.iterable);
    return [new ChainedIteratorClass(iter1), this.derive(iter2)];
  }

  inBatchesBySize(batchSize) {
    return this.derive(inBatchesBySize(this.iterable, batchSize));
  }

  filter(func) {
    return this.derive(filter(this.iterable, func));
  }

  drop(howMany) {
    return this.derive(drop(this.iterable, howMany));
  }

  map(func) {
    return this.derive(map(this.iterable, func));
  }

  reduce(func, initialAcc) {
    return reduce(this, func, initialAcc);
  }

  concat() {
    return this.derive(concatIterable(this.iterable));
  }

  uniqueOnly() {
    return this.derive(uniqueOnly(this.iterable));
  }

  uniqueOnlyBy(func) {
    return this.derive(uniqueOnlyBy(this.iterable, func));
  }

  every(func) {
    return every(this, func);
  }

  some(func) {
    return some(this, func);
  }

  takeWhile(func) {
    return this.derive(takeWhile(this.iterable, func));
  }

  * [Symbol.iterator]() {
    let iterable = this.iterable;
    if (!iterable) throw new Error("Chained iterator already exhausted or used to derive the new one");
    this.iterable = undefined;
    yield* iterable;
    iterable = undefined;
  }

  toArray() {
    return Array.from(this);
  }

  sort(order) {
    return Array.from(this).sort(order);
  }

  toSet() {
    return new Set(this);
  }

  toMap() {
    return new Map(this);
  }

  flush() {
    for (const element of this) {
    }
  }

  memoize() {
    return new MemoizedIteratorClass(this);
  }

}

const ChainedIterator = iterator => new ChainedIteratorClass(iterator);
const CI = ChainedIterator;

class MemoizedIteratorClass extends ChainedIteratorClass {
  constructor() {
    super(...arguments);
    this.elements = [];
    this.$iterator = undefined;
  }

  set iterable(iterable) {
    this.$iterable = iterable;
  }

  get iterable() {
    return this;
  }

  derive(iterable) {
    return new ChainedIteratorClass(iterable);
  }

  * [Symbol.iterator]() {
    const elements = this.elements;

    if (this.$iterable) {
      if (!this.$iterator) this.$iterator = this.$iterable[Symbol.iterator]();
      let iterator = this.$iterator;
      let alreadyConsumed = elements.length;
      if (alreadyConsumed > 0) yield* elements;

      while (true) {
        if (elements.length > alreadyConsumed) {
          for (let i = alreadyConsumed; i < elements.length; i++) yield elements[i];

          alreadyConsumed = elements.length;
        }

        if (!iterator) break;
        const {
          value,
          done
        } = iterator.next();

        if (done) {
          iterator = this.$iterator = null;
          this.$iterable = null;
        } else {
          elements.push(value);
          alreadyConsumed++;
          yield value;
        }
      }
    } else {
      yield* elements;
    }
  }

}

var OnCycleAction$1;

(function (OnCycleAction) {
  OnCycleAction["Cancel"] = "Cancel";
  OnCycleAction["Resume"] = "Resume";
})(OnCycleAction$1 || (OnCycleAction$1 = {}));

const WalkSource = Symbol('WalkSource');
const NOT_VISITED = -1;
const VISITED_TOPOLOGICALLY = -2;

class WalkContext$1 extends Base$1 {
  constructor() {
    super(...arguments);
    this.visited = new Map();
    this.toVisit = [];
    this.currentEpoch = 0;
  }

  startFrom(sourceNodes) {
    this.continueFrom(sourceNodes);
  }

  continueFrom(sourceNodes) {
    this.toVisit.push.apply(this.toVisit, sourceNodes.map(node => {
      return {
        node: node,
        from: WalkSource,
        label: undefined
      };
    }));
    this.walkDepth();
  }

  onNode(node, walkStep) {
  }

  onTopologicalNode(node) {
  }

  onCycle(node, stack) {
    return OnCycleAction$1.Cancel;
  }

  forEachNext(node, func) {
    throw new Error("Abstract method called");
  }

  collectNext(node, toVisit, visitInfo) {
    throw new Error("Abstract method called");
  }

  getVisitedInfo(node) {
    return this.visited.get(node);
  }

  setVisitedInfo(node, visitedAt, info) {
    if (!info) {
      info = {
        visitedAt,
        visitEpoch: this.currentEpoch
      };
      this.visited.set(node, info);
    } else {
      info.visitedAt = visitedAt;
      info.visitEpoch = this.currentEpoch;
    }

    return info;
  }

  walkDepth() {
    const visited = this.visited;
    const toVisit = this.toVisit;
    let depth;

    while (depth = toVisit.length) {
      const node = toVisit[depth - 1].node;
      const visitedInfo = this.getVisitedInfo(node);

      if (visitedInfo && visitedInfo.visitedAt === VISITED_TOPOLOGICALLY && visitedInfo.visitEpoch === this.currentEpoch) {
        toVisit.pop();
        continue;
      }

      if (visitedInfo && visitedInfo.visitEpoch === this.currentEpoch && visitedInfo.visitedAt !== NOT_VISITED) {
        if (visitedInfo.visitedAt < depth) {
          if (this.onCycle(node, toVisit) !== OnCycleAction$1.Resume) break;
        } else {
          visitedInfo.visitedAt = VISITED_TOPOLOGICALLY;
          this.onTopologicalNode(node);
        }

        toVisit.pop();
      } else {
        if (this.onNode(node, toVisit[depth - 1]) === false) break;
        const visitedInfo2 = this.setVisitedInfo(node, depth, visitedInfo);
        const lengthBefore = toVisit.length;
        this.collectNext(node, toVisit, visitedInfo2);

        if (toVisit.length === lengthBefore) {
          visitedInfo2.visitedAt = VISITED_TOPOLOGICALLY;
          this.onTopologicalNode(node);
          toVisit.pop();
        }
      }
    }
  }

}

var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let FORMULA_ID = 0;
const CalculateProposed = FORMULA_ID++;

class Formula extends Base$1 {
  constructor() {
    super(...arguments);
    this.formulaId = FORMULA_ID++;
    this.inputs = new Set();
  }

}

class VariableWalkContext extends WalkContext$1 {
  collectNext(sourceNode, toVisit) {
    if (sourceNode instanceof Formula) {
      toVisit.push({
        node: sourceNode.output,
        from: sourceNode,
        label: undefined
      });
    } else {
      const formulas = this.cache.formulasByInput.get(sourceNode);
      formulas && formulas.forEach(formula => toVisit.push({
        node: formula,
        from: sourceNode,
        label: undefined
      }));
    }
  }

}

class FormulasCache extends Base$1 {
  constructor() {
    super(...arguments);
    this.variables = new Set();
    this.formulas = new Set();
    this.$formulasByInput = undefined;
    this.$formulasByOutput = undefined;
  }

  get formulasByInput() {
    if (this.$formulasByInput !== undefined) return this.$formulasByInput;
    this.fillCache();
    return this.$formulasByInput;
  }

  get formulasByOutput() {
    if (this.$formulasByOutput !== undefined) return this.$formulasByOutput;
    this.fillCache();
    return this.$formulasByOutput;
  }

  add(formula) {
    this.$formulasByInput = undefined;
    this.$formulasByOutput = undefined;
    this.formulas.add(formula);
  }

  has(formula) {
    return this.formulas.has(formula);
  }

  fillCache() {
    this.$formulasByInput = new Map();
    this.$formulasByOutput = new Map();
    this.formulas.forEach(formula => {
      let formulasByOutput = this.$formulasByOutput.get(formula.output);

      if (!formulasByOutput) {
        formulasByOutput = new Set();
        this.$formulasByOutput.set(formula.output, formulasByOutput);
      }

      formulasByOutput.add(formula);
      formula.inputs.forEach(input => {
        let formulasByInput = this.$formulasByInput.get(input);

        if (!formulasByInput) {
          formulasByInput = new Set();
          this.$formulasByInput.set(input, formulasByInput);
        }

        formulasByInput.add(formula);
      });
    });
  }

  allInputVariables() {
    return uniqueOnly(concatIterable(map(this.formulas, formula => formula.inputs.values())));
  }

  isCyclic() {
    let isCyclic = false;
    const walkContext = VariableWalkContext.new({
      cache: this,
      onCycle: () => {
        isCyclic = true;
        return OnCycleAction$1.Cancel;
      }
    });
    walkContext.startFrom(Array.from(this.allInputVariables()));
    return isCyclic;
  }

}

class CycleDescription extends FormulasCache {
}

class CycleResolution extends Base$1 {
  constructor() {
    super(...arguments);
    this.description = undefined;
    this.defaultResolutionFormulas = new Set();
    this.resolutionsByInputHash = new Map();
  }

  clear() {
    this.resolutionsByInputHash.clear();
  }

  resolve(input) {
    const cached = this.resolutionsByInputHash.get(input.hash);
    if (cached !== undefined) return cached;
    const resolution = this.buildResolution(input);
    this.resolutionsByInputHash.set(input.hash, resolution);
    return resolution;
  }

  buildResolution(input) {
    const walkContext = WalkState.new({
      context: this,
      input
    });
    const allResolutions = Array.from(walkContext.next()).map(state => {
      return {
        resolution: state.asResolution(),
        nbrOfDefaultFormulas: Array.from(state.activatedFormulas.formulas).reduce((count, formula) => state.formulaIsDefault(formula) ? count + 1 : count, 0),
        unCoveredInputWeight: state.unCoveredInputWeight()
      };
    });
    allResolutions.sort((res1, res2) => {
      if (res1.unCoveredInputWeight < res2.unCoveredInputWeight) return -1;
      if (res1.unCoveredInputWeight > res2.unCoveredInputWeight) return 1;
      return res2.nbrOfDefaultFormulas - res1.nbrOfDefaultFormulas;
    });
    if (allResolutions.length > 0) return allResolutions[0].resolution; else debugger;
  }

}

var VariableInputState;

(function (VariableInputState) {
  VariableInputState[VariableInputState["NoInput"] = 0] = "NoInput";
  VariableInputState[VariableInputState["HasPreviousValue"] = 1] = "HasPreviousValue";
  VariableInputState[VariableInputState["HasProposedValue"] = 2] = "HasProposedValue";
  VariableInputState[VariableInputState["KeepIfPossible"] = 4] = "KeepIfPossible";
})(VariableInputState || (VariableInputState = {}));

class CycleResolutionInput extends Base$1 {
  constructor() {
    super(...arguments);
    this.context = undefined;
    this.input = undefined;
    this.$hash = '';
  }

  get hash() {
    if (this.$hash !== '') return this.$hash;
    return this.$hash = this.buildHash();
  }

  get description() {
    return this.context.description;
  }

  get resolution() {
    return this.context.resolve(this);
  }

  initialize(...args) {
    super.initialize(...args);
    validateRequiredProperties(this);
    this.input = new Map(CI(this.description.variables).map(variable => [variable, VariableInputState.NoInput]));
  }

  buildHash() {
    return String.fromCharCode(...CI(this.description.variables).inBatchesBySize(5).map(batch => this.batchToCharCode(batch)));
  }

  batchToCharCode(batch) {
    return batch.reduceRight((charCode, variable, index) => charCode | this.input.get(variable) << index * 3, 0);
  }

  addProposedValueFlag(variable) {

    const input = this.input.get(variable);
    this.input.set(variable, input | VariableInputState.HasProposedValue);
  }

  hasProposedValue(variable) {
    return Boolean(this.input.get(variable) & VariableInputState.HasProposedValue);
  }

  hasProposedValueVars() {
    return CI(this.description.variables).filter(variable => this.hasProposedValue(variable));
  }

  addPreviousValueFlag(variable) {

    const input = this.input.get(variable);
    this.input.set(variable, input | VariableInputState.HasPreviousValue);
  }

  hasPreviousValue(variable) {
    return Boolean(this.input.get(variable) & VariableInputState.HasPreviousValue);
  }

  hasPreviousValueVars() {
    return CI(this.description.variables).filter(variable => this.hasPreviousValue(variable));
  }

  addKeepIfPossibleFlag(variable) {

    const input = this.input.get(variable);
    this.input.set(variable, input | VariableInputState.KeepIfPossible);
  }

  keepIfPossible(variable) {
    return Boolean(this.input.get(variable) & VariableInputState.KeepIfPossible);
  }

  keepIfPossibleVars() {
    return CI(this.description.variables).filter(variable => this.keepIfPossible(variable));
  }

}

__decorate$6([required], CycleResolutionInput.prototype, "context", void 0);

class WalkState extends Base$1 {
  constructor() {
    super(...arguments);
    this.context = undefined;
    this.input = undefined;
    this.previous = undefined;
    this.activatedFormula = undefined;
    this.$activatedFormulas = undefined;
  }

  get activatedFormulas() {
    if (this.$activatedFormulas !== undefined) return this.$activatedFormulas;
    const cache = FormulasCache.new({
      variables: this.description.variables,
      formulas: CI(this.thisAndPreviousStates()).map(state => state.activatedFormula).toSet()
    });
    return this.$activatedFormulas = cache;
  }

  get description() {
    return this.context.description;
  }

  * thisAndPreviousStates() {
    let current = this;

    while (current && current.activatedFormula) {
      yield current;
      current = current.previous;
    }
  }

  formulaHasProposedValueInInput(formula) {
    return Array.from(formula.inputs).some(variable => this.input.hasProposedValue(variable));
  }

  unCoveredInputWeight() {
    const proposedVars = map(this.input.hasProposedValueVars(), variable => {
      return {
        variable,
        isProposed: true
      };
    });
    const keepIfPossibleVars = map(this.input.keepIfPossibleVars(), variable => {
      return {
        variable,
        isProposed: false
      };
    });
    const allInputVars = CI([proposedVars, keepIfPossibleVars]).concat().uniqueOnlyBy(el => el.variable);
    return allInputVars.reduce((totalWeight, {
      variable,
      isProposed
    }) => {
      let weight = 0;
      const isOverwrittenByFormulas = this.activatedFormulas.formulasByOutput.get(variable);

      if (isOverwrittenByFormulas) {
        const formula = isOverwrittenByFormulas.size === 1 ? Array.from(isOverwrittenByFormulas)[0] : null;

        if (formula && this.formulaIsDefault(formula) && this.formulaHasProposedValueInInput(formula)) {
          if (isProposed) weight += 1e6; else weight += 1e4;
        } else {
          if (isProposed) weight += 1e7; else weight += 1e5;
        }
      }

      const usedInFormulas = this.activatedFormulas.formulasByInput.get(variable);

      if (!(usedInFormulas && usedInFormulas.size > 0)) {
        if (isProposed) weight += 1e3; else weight += 1e2;
      }

      return totalWeight + weight;
    }, 0);
  }

  preferFormula(formula1, formula2) {
    const allInputsHasProposed1 = this.formulaAllInputsHasProposed(formula1);
    const allInputsHasProposed2 = this.formulaAllInputsHasProposed(formula2);
    if (allInputsHasProposed1 && !allInputsHasProposed2) return -1;
    if (allInputsHasProposed2 && !allInputsHasProposed1) return 1;
    const countInputsWithProposedOrKeep1 = this.formulaCountInputsWithProposedOrKeep(formula1);
    const countInputsWithProposedOrKeep2 = this.formulaCountInputsWithProposedOrKeep(formula2);
    if (countInputsWithProposedOrKeep1 > countInputsWithProposedOrKeep2) return -1;
    if (countInputsWithProposedOrKeep1 < countInputsWithProposedOrKeep2) return 1;
    if (this.formulaIsDefault(formula1) && !this.formulaIsDefault(formula2)) return -1;
    if (this.formulaIsDefault(formula2) && !this.formulaIsDefault(formula1)) return 1;
    return 0;
  }

  formulaIsDefault(formula) {
    return this.context.defaultResolutionFormulas.has(formula);
  }

  formulaCountInputsWithProposedOrKeep(formula) {
    let count = 0;
    Array.from(formula.inputs).forEach(variable => {
      if (this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable)) count++;
    });
    return count;
  }

  formulaAllInputsHasProposedOrKeep(formula) {
    return Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable) || this.input.keepIfPossible(variable));
  }

  formulaAllInputsHasProposed(formula) {
    return Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable));
  }

  formulaIsApplicable(formula) {
    const everyFormulaInputHasValue = Array.from(formula.inputs).every(variable => this.input.hasProposedValue(variable) || this.input.hasPreviousValue(variable) || this.activatedFormulas.formulasByOutput.has(variable));
    const cache = FormulasCache.new({
      formulas: new Set(this.activatedFormulas.formulas)
    });
    cache.add(formula);
    return everyFormulaInputHasValue && !cache.isCyclic();
  }

  formulaIsInsignificant(formula) {
    const outputVariableAlreadyCalculated = this.activatedFormulas.formulasByOutput.has(formula.output);
    const outputVariableHasPreviousValue = this.input.hasPreviousValue(formula.output);
    return outputVariableAlreadyCalculated || outputVariableHasPreviousValue && Array.from(formula.inputs).some(variable => !this.input.hasPreviousValue(variable) && !this.input.hasProposedValue(variable));
  }

  unvisitedFormulas() {
    return Array.from(this.description.formulas).filter(formula => !this.activatedFormulas.has(formula));
  }

  * next() {
    const unvisitedFormulas = this.unvisitedFormulas();
    unvisitedFormulas.sort(this.preferFormula.bind(this));
    let isFinal = true;

    for (const formula of unvisitedFormulas) {
      if (!this.formulaIsApplicable(formula) || this.formulaIsInsignificant(formula)) continue;
      const nextState = WalkState.new({
        previous: this,
        context: this.context,
        input: this.input,
        activatedFormula: formula
      });
      yield* nextState.next();
      isFinal = false;
    }

    if (isFinal) yield this;
  }

  asResolution() {
    return new Map(CI(this.description.variables).map(variable => {
      const formulas = this.activatedFormulas.formulasByOutput.get(variable);

      if (formulas) {
        for (const firstFormula of formulas) {
          return [variable, firstFormula.formulaId];
        }
      }

      return [variable, CalculateProposed];
    }));
  }

}

const isNotNumber = value => Number(value) !== value;

class CycleResolutionInputChrono extends CycleResolutionInput {
  collectInfo(atom, symbol) {
    if (atom.hasConsistentValue()) this.addPreviousValueFlag(symbol);
    if (atom.hasProposedValue()) this.addProposedValueFlag(symbol);
  }

}

var Instruction;

(function (Instruction) {
  Instruction["KeepDuration"] = "KeepDuration";
  Instruction["KeepStartDate"] = "KeepStartDate";
  Instruction["KeepEndDate"] = "KeepEndDate";
})(Instruction || (Instruction = {}));

const StartDateVar = Symbol('StartDate');
const EndDateVar = Symbol('EndDate');
const DurationVar = Symbol('Duration');
const startDateFormula = Formula.new({
  output: StartDateVar,
  inputs: new Set([DurationVar, EndDateVar])
});
const endDateFormula = Formula.new({
  output: EndDateVar,
  inputs: new Set([DurationVar, StartDateVar])
});
const durationFormula = Formula.new({
  output: DurationVar,
  inputs: new Set([StartDateVar, EndDateVar])
});
const SEDGraphDescription = CycleDescription.new({
  variables: new Set([StartDateVar, EndDateVar, DurationVar]),
  formulas: new Set([startDateFormula, endDateFormula, durationFormula])
});
const SEDForwardCycleResolutionContext = CycleResolution.new({
  description: SEDGraphDescription,
  defaultResolutionFormulas: new Set([endDateFormula])
});
const SEDBackwardCycleResolutionContext = CycleResolution.new({
  description: SEDGraphDescription,
  defaultResolutionFormulas: new Set([startDateFormula])
});

class SEDDispatcher extends CycleResolutionInputChrono {
  addInstruction(instruction) {
    if (instruction === Instruction.KeepStartDate) this.addKeepIfPossibleFlag(StartDateVar);
    if (instruction === Instruction.KeepEndDate) this.addKeepIfPossibleFlag(EndDateVar);
    if (instruction === Instruction.KeepDuration) this.addKeepIfPossibleFlag(DurationVar);
  }

}

class SEDDispatcherIdentifier extends MinimalFieldAtom {
  equality(v1, v2) {
    const resolution1 = v1.resolution;
    const resolution2 = v2.resolution;
    return resolution1.get(StartDateVar) === resolution2.get(StartDateVar) && resolution1.get(EndDateVar) === resolution2.get(EndDateVar) && resolution1.get(DurationVar) === resolution2.get(DurationVar);
  }

}

var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$4 = Symbol('EventMixin');
const EventMixin = base => {
  class EventMixin extends base {
    [hasMixin$4]() {
    }

    * calculateDispatcher() {
      const cycleDispatcher = yield* this.prepareDispatcher();
      const startDateProposedArgs = this.$.startDate.proposedArgs;
      const startInstruction = startDateProposedArgs ? startDateProposedArgs[1] ? Instruction.KeepDuration : Instruction.KeepEndDate : undefined;
      if (startInstruction) cycleDispatcher.addInstruction(startInstruction);
      const endDateProposedArgs = this.$.endDate.proposedArgs;
      const endInstruction = endDateProposedArgs ? endDateProposedArgs[1] ? Instruction.KeepDuration : Instruction.KeepStartDate : undefined;
      if (endInstruction) cycleDispatcher.addInstruction(endInstruction);
      const durationProposedArgs = this.$.duration.proposedArgs;
      let durationInstruction;

      if (durationProposedArgs) {
        switch (durationProposedArgs[1]) {
          case true:
            durationInstruction = Instruction.KeepStartDate;
            break;

          case false:
            durationInstruction = Instruction.KeepEndDate;
            break;
        }
      }

      if (!durationInstruction && cycleDispatcher.hasProposedValue(DurationVar)) {
        durationInstruction = Instruction.KeepStartDate;
      }

      if (durationInstruction) cycleDispatcher.addInstruction(durationInstruction);
      return cycleDispatcher;
    }

    * prepareDispatcher() {
      const dispatcherClass = yield* this.dispatcherClass();
      const cycleDispatcher = dispatcherClass.new({
        context: yield* this.cycleResolutionContext()
      });
      cycleDispatcher.collectInfo(this.$.startDate, StartDateVar);
      cycleDispatcher.collectInfo(this.$.endDate, EndDateVar);
      cycleDispatcher.collectInfo(this.$.duration, DurationVar);
      return cycleDispatcher;
    }

    * cycleResolutionContext() {
      return SEDForwardCycleResolutionContext;
    }

    * dispatcherClass() {
      return SEDDispatcher;
    }

    buildProposedDispatcher() {
      return;
    }

    * skipNonWorkingTime(date, isForward = true) {
      if (!date) return null;
      const calendar = yield this.$.calendar;
      return calendar.skipNonWorkingTime(date, isForward);
    }

    convertDuration(duration, fromUnit, toUnit) {
      const projectCalendar = this.getProject().calendar;
      return projectCalendar.convertDuration(duration, fromUnit, toUnit);
    }

    * $convertDuration(duration, fromUnit, toUnit) {
      const project = this.getProject(),
        projectCalendar = yield project.$.calendar;
      return projectCalendar.convertDuration(duration, fromUnit, toUnit);
    }

    * calculateStartDate() {
      const dispatch = yield this.$.dispatcher;
      const formulaId = dispatch.resolution.get(StartDateVar);

      if (formulaId === CalculateProposed) {
        return yield* this.calculateStartDateProposed();
      } else if (formulaId === startDateFormula.formulaId) {
        return yield* this.calculateStartDatePure();
      } else {
        throw new Error("Unknown formula for `startDate`");
      }
    }

    * calculateStartDatePure() {
      return yield* this.calculateProjectedXDateWithDuration(yield this.$.endDate, false, yield this.$.duration);
    }

    * calculateProjectedXDateWithDuration(baseDate, isForward = true, duration) {
      const durationUnit = yield this.$.durationUnit;
      const calendar = yield this.$.calendar;
      const project = this.getProject();
      if (!baseDate || isNotNumber(duration)) return null;
      const durationMs = yield* this.$convertDuration(duration, durationUnit, TimeUnit.Millisecond);

      if (isForward) {
        return calendar.calculateEndDate(baseDate, durationMs, TimeUnit.Millisecond);
      } else {
        return calendar.calculateStartDate(baseDate, durationMs, TimeUnit.Millisecond);
      }
    }

    * calculateStartDateProposed() {
      const startDate = this.$.startDate.getProposedOrPreviousValue();
      return yield* this.skipNonWorkingTime(startDate, true);
    }

    * calculateEndDate() {
      const dispatch = yield this.$.dispatcher;
      const formulaId = dispatch.resolution.get(EndDateVar);

      if (formulaId === CalculateProposed) {
        return yield* this.calculateEndDateProposed();
      } else if (formulaId === endDateFormula.formulaId) {
        return yield* this.calculateEndDatePure();
      } else {
        throw new Error("Unknown formula for `endDate`");
      }
    }

    * calculateEndDatePure() {
      return yield* this.calculateProjectedXDateWithDuration(yield this.$.startDate, true, yield this.$.duration);
    }

    * calculateEndDateProposed() {
      const endDate = this.$.endDate.getProposedOrPreviousValue();
      return yield* this.skipNonWorkingTime(endDate, false);
    }

    * calculateDuration(proposedValue) {
      const dispatch = yield this.$.dispatcher;
      const formulaId = dispatch.resolution.get(DurationVar);

      if (formulaId === CalculateProposed) {
        return yield* this.calculateDurationProposed();
      } else if (formulaId === durationFormula.formulaId) {
        return yield* this.calculateDurationPure();
      } else {
        throw new Error("Unknown formula for `duration`");
      }
    }

    * calculateDurationPure() {
      const startDate = yield this.$.startDate;
      const endDate = yield this.$.endDate;
      if (!startDate || !endDate) return null;

      if (startDate > endDate) {
        throw new Error("debug");
      } else {
        return yield* this.calculateProjectedDuration(startDate, endDate);
      }
    }

    * calculateDurationProposed() {
      return this.$.duration.getProposedOrPreviousValue();
    }

    * calculateProjectedDuration(startDate, endDate, durationUnit) {
      if (!startDate || !endDate) return null;
      if (!durationUnit) durationUnit = yield this.$.durationUnit;
      const calendar = yield this.$.calendar;
      const project = this.getProject();
      return yield* this.$convertDuration(calendar.calculateDuration(startDate, endDate, TimeUnit.Millisecond), TimeUnit.Millisecond, durationUnit);
    }

    * calculateEffectiveDuration() {
      const dispatch = yield this.$.dispatcher;
      let effectiveDurationToUse;
      const durationResolution = dispatch.resolution.get(DurationVar);

      if (durationResolution === CalculateProposed) {
        effectiveDurationToUse = yield this.$.duration;
      } else if (durationResolution === durationFormula.formulaId) {
        effectiveDurationToUse = yield* this.calculateProjectedDuration(this.$.startDate.getProposedOrPreviousValue(), this.$.endDate.getProposedOrPreviousValue());
      }

      return effectiveDurationToUse;
    }

    getStartDate() {
      return this.startDate;
    }

    putStartDate(date, keepDuration = true) {
      const isVeryFirstAssignment = this.$.startDate.getProposedOrPreviousValue() === undefined;
      if (date == null && isVeryFirstAssignment) return;

      if (date === null && !isVeryFirstAssignment) {
        this.$.endDate.proposedValue = null;
        this.$.endDate.proposedArgs = [null];
        this.$.duration.proposedValue = null;
        this.$.duration.proposedArgs = [null];
      }

      this.$.startDate.put(date, keepDuration);

      if (this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.endDate);
        this.markAsNeedRecalculation(this.$.duration);
      }
    }

    async setStartDate(date, keepDuration = true) {
      this.putStartDate(date, keepDuration);
      return this.propagate();
    }

    getEndDate() {
      return this.endDate;
    }

    putEndDate(date, keepDuration = false) {
      const isVeryFirstAssignment = this.$.startDate.getProposedOrPreviousValue() === undefined;
      if (date == null && isVeryFirstAssignment) return;

      if (date === null && !isVeryFirstAssignment) {
        this.$.startDate.proposedValue = null;
        this.$.startDate.proposedArgs = [null];
        this.$.duration.proposedValue = null;
        this.$.duration.proposedArgs = [null];
      }

      const startDate = this.getStartDate();

      if (!keepDuration && date && date.getTime && startDate && date.getTime() < startDate.getTime()) {
        date = startDate;
        this.putDuration(0);
      }

      this.$.endDate.put(date, keepDuration);

      if (this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.startDate);
        this.markAsNeedRecalculation(this.$.duration);
      }
    }

    async setEndDate(date, keepDuration = false) {
      this.putEndDate(date, keepDuration);
      return this.propagate();
    }

    getDuration(unit) {
      let duration = this.duration;

      if (unit) {
        duration = this.convertDuration(duration, this.durationUnit, unit);
      }

      return duration;
    }

    putDuration(duration, unit, keepStartDate = true) {
      const isVeryFirstAssignment = this.$.duration.getProposedOrPreviousValue() === undefined;
      if (duration == null && isVeryFirstAssignment) return;

      if (duration === null && !isVeryFirstAssignment) {
        this.$.startDate.proposedValue = null;
        this.$.startDate.proposedArgs = [null];
        this.$.endDate.proposedValue = null;
        this.$.endDate.proposedArgs = [null];
      }

      this.$.duration.put(duration, keepStartDate);

      if (this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.startDate);
        this.markAsNeedRecalculation(this.$.endDate);
      }

      if (unit != null && unit !== this.durationUnit) {
        this.$.durationUnit.put(unit);
      }
    }

    async setDuration(duration, unit, keepStartDate = true) {
      this.putDuration(duration, unit, keepStartDate);
      return this.propagate();
    }

    getDurationUnit() {
      return this.durationUnit;
    }

    setDurationUnit(_value) {
      throw new Error("Use `setDuration` instead");
    }

    toString() {
      return `Event ${this.id}`;
    }

  }

  __decorate$7([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ'
  }, {
    converter: dateConverter
  })], EventMixin.prototype, "startDate", void 0);

  __decorate$7([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ'
  }, {
    converter: dateConverter
  })], EventMixin.prototype, "endDate", void 0);

  __decorate$7([model_field({
    type: 'number',
    allowNull: true
  })], EventMixin.prototype, "duration", void 0);

  __decorate$7([model_field({
    type: 'string',
    defaultValue: TimeUnit.Day
  }, {
    converter: DateHelper.normalizeUnit
  })], EventMixin.prototype, "durationUnit", void 0);

  __decorate$7([field({
    atomCls: SEDDispatcherIdentifier
  })], EventMixin.prototype, "dispatcher", void 0);

  __decorate$7([model_field({
    type: 'string',
    defaultValue: Direction.Forward
  })], EventMixin.prototype, "direction", void 0);

  __decorate$7([calculate('dispatcher')], EventMixin.prototype, "calculateDispatcher", null);

  __decorate$7([calculate('startDate')], EventMixin.prototype, "calculateStartDate", null);

  __decorate$7([calculate('endDate')], EventMixin.prototype, "calculateEndDate", null);

  __decorate$7([calculate('duration')], EventMixin.prototype, "calculateDuration", null);

  return EventMixin;
};

class CalendarCacheIntervalMultiple {
  constructor(config) {
    this.intervalGroups = [];
    config && Object.assign(this, config);
  }

  combineWith(interval) {
    const copy = this.intervalGroups.slice();
    copy.push([interval.calendar, interval]);
    return new CalendarCacheIntervalMultiple({
      intervalGroups: copy
    });
  }

  getIsWorkingForEvery() {
    if (this.isWorkingForEvery != null) return this.isWorkingForEvery;

    for (let [_calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking) return this.isWorkingForEvery = false;
    }

    return this.isWorkingForEvery = true;
  }

  getIsWorkingForSome() {
    if (this.isWorkingForSome != null) return this.isWorkingForSome;

    for (let [_calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking) return this.isWorkingForSome = true;
    }

    return this.isWorkingForSome = false;
  }

  getCalendars() {
    this.getGroups();
    return this.calendars;
  }

  isCalendarWorking(calendar) {
    return this.getCalendarsWorkStatus().get(calendar);
  }

  getCalendarsWorkStatus() {
    if (this.calendarsWorkStatus) return this.calendarsWorkStatus;
    const res = new Map();

    for (let [calendar, intervals] of this.getGroups()) {
      res.set(calendar, intervals[0].isWorking);
    }

    return this.calendarsWorkStatus = res;
  }

  getCalendarsWorking() {
    if (this.calendarsWorking) return this.calendarsWorking;
    const calendars = [];

    for (let [calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking) calendars.push(calendar);
    }

    return this.calendarsWorking = calendars;
  }

  getCalendarsNonWorking() {
    if (this.calendarsNonWorking) return this.calendarsNonWorking;
    const calendars = [];

    for (let [calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking) calendars.push(calendar);
    }

    return this.calendarsNonWorking = calendars;
  }

  getGroups() {
    if (this.intervalsByCalendar) return this.intervalsByCalendar;
    const calendars = this.calendars = [];
    const intervalsByCalendar = new Map();
    this.intervalGroups.forEach(([calendar, interval]) => {
      let data = intervalsByCalendar.get(calendar);

      if (!data) {
        calendars.push(calendar);
        data = [];
        intervalsByCalendar.set(calendar, data);
      }

      data.push.apply(data, interval.intervals);
    });
    intervalsByCalendar.forEach((intervals, calendar) => {
      const unique = stripDuplicates(intervals);
      unique.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());
      intervalsByCalendar.set(calendar, unique);
    });
    return this.intervalsByCalendar = intervalsByCalendar;
  }

}

class CalendarCacheMultiple extends CalendarCache {
  constructor(config) {
    super(config);
    this.calendarCaches = stripDuplicates(this.calendarCaches);
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheIntervalMultiple(),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }

  fillCache(startDate, endDate) {
    this.calendarCaches.forEach(calendarCache => {
      calendarCache.fillCache(startDate, endDate);
      this.includeWrappingRangeFrom(calendarCache, startDate, endDate);
    });
  }

}

const COMBINED_CALENDARS_CACHE = new Map();
const combineCalendars = calendars => {
  const uniqueOnly = stripDuplicates(calendars);
  if (uniqueOnly.length === 0) throw new Error("No calendars to combine");
  uniqueOnly.sort((calendar1, calendar2) => {
    if (calendar1.internalId < calendar2.internalId) return -1; else return 1;
  });
  const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');
  const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');
  let cached = COMBINED_CALENDARS_CACHE.get(hash);
  let res;
  if (cached && cached.versionsHash === versionsHash) res = cached.cache; else {
    res = new CalendarCacheMultiple({
      calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache)
    });
    COMBINED_CALENDARS_CACHE.set(hash, {
      versionsHash: versionsHash,
      cache: res
    });
  }
  return res;
};

var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$5 = Symbol('HasAssignments');
const HasAssignments = base => {
  class HasAssignments extends base {
    constructor() {
      super(...arguments);
      this.assignmentsByCalendar = new Map();
    }

    [hasMixin$5]() {
    }

    get assignments() {
      return [...this.assigned];
    }

    getAssignmentFor(resource) {
      let result;
      this.assigned.forEach(assignment => {
        if (assignment.resource === resource) result = assignment;
      });
      return result;
    }

    isAssignedTo(resource) {
      return Boolean(this.getAssignmentFor(resource));
    }

    reassign(oldResource, newResource) {
      const assignment = this.getAssignmentFor(oldResource);
      if (!assignment) throw new Error(`Can't unassign resource \`${oldResource}\` from task \`${this}\` - resource is not assigned to the task!`);
      this.removeAssignment(assignment);
      if (this.getAssignmentFor(newResource)) throw new Error('Resource can\'t be assigned twice to the same task');
      const assignmentCls = this.getProject().assignmentStore.modelClass;
      this.addAssignment(new assignmentCls({
        event: this,
        resource: newResource
      }));
      return this.propagate();
    }

    async assign(resource, units = 100) {
      if (this.getAssignmentFor(resource)) throw new Error('Resource can\'t be assigned twice to the same task');
      const assignmentCls = this.getProject().assignmentStore.modelClass;
      this.addAssignment(new assignmentCls({
        event: this,
        resource: resource,
        units: units
      }));
      return this.propagate();
    }

    async unassign(resource) {
      const assignment = this.getAssignmentFor(resource);
      if (!assignment) throw new Error(`Can't unassign resource \`${resource}\` from task \`${this}\` - resource is not assigned to the task!`);
      this.removeAssignment(assignment);
      return this.propagate();
    }

    addAssignment(assignment) {
      this.getProject().assignmentStore.add(assignment);
      return assignment;
    }

    removeAssignment(assignment) {
      this.getProject().assignmentStore.remove(assignment);
      return assignment;
    }

    leaveProject() {
      const assignmentStore = this.getAssignmentStore();
      this.assigned.forEach(assignment => assignmentStore.remove(assignment));
      super.leaveProject();
    }

    * forEachAvailabilityInterval(options, func) {
      const calendar = yield this.$.calendar;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const effectiveCalendarsCombination = yield this.$.effectiveCalendarsCombination;
      return effectiveCalendarsCombination.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {
        const calendarsStatus = calendarCacheIntervalMultiple.getCalendarsWorkStatus();
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();

        if (calendarsStatus.get(calendar) && (options.ignoreResourceCalendars || workCalendars.some(calendar => assignmentsByCalendar.has(calendar)))) {
          return func(startDate, endDate, calendarCacheIntervalMultiple);
        }
      });
    }

    * calculateEffectiveCalendarsCombination() {
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const calendars = [...assignmentsByCalendar.keys(), yield this.$.calendar];
      return combineCalendars(calendars);
    }

    * calculateAssignmentsByCalendar() {
      const assignments = yield this.$.assigned;
      const result = new Map();

      for (const assignment of assignments) {
        const resource = yield assignment.$.resource;

        if (resource) {
          const resourceCalendar = yield resource.$.calendar;
          let assignments = result.get(resourceCalendar);

          if (!assignments) {
            assignments = [];
            result.set(resourceCalendar, assignments);
          }

          assignments.push(assignment);
        }
      }

      return result;
    }

    * getBaseOptionsForDurationCalculations() {
      return {
        ignoreResourceCalendars: false
      };
    }

    * skipNonWorkingTime(date, isForward = true) {
      if (!date) return null;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;

      if (assignmentsByCalendar.size > 0) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? {
          startDate: date,
          isForward
        } : {
          endDate: date,
          isForward
        });
        let workingDate;
        const skipRes = yield* this.forEachAvailabilityInterval(options, (startDate, endDate, calendarCacheIntervalMultiple) => {
          workingDate = isForward ? startDate : endDate;
          return false;
        });

        if (skipRes === CalendarIteratorResult.FullRangeIterated) {
          yield CancelPropagationEffect.new();
        }

        return new Date(workingDate);
      } else {
        return yield* super.skipNonWorkingTime(date, isForward);
      }
    }

    * calculateProjectedDuration(startDate, endDate, durationUnit) {
      if (!startDate || !endDate) {
        return null;
      }

      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;

      if (assignmentsByCalendar.size > 0) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), {
          startDate,
          endDate,
          isForward: true
        });
        let result = 0;
        yield* this.forEachAvailabilityInterval(options, (startDate, endDate) => {
          result += endDate.getTime() - startDate.getTime();
        });
        if (!durationUnit) durationUnit = yield this.$.durationUnit;
        return yield* this.getProject().$convertDuration(result, TimeUnit.Millisecond, durationUnit);
      } else {
        return yield* super.calculateProjectedDuration(startDate, endDate, durationUnit);
      }
    }

    * calculateProjectedXDateWithDuration(baseDate, isForward = true, duration) {
      if (baseDate == null || duration == null || isNaN(duration)) return null;
      if (duration == 0) return baseDate;
      const durationUnit = yield this.$.durationUnit;
      const durationMS = yield* this.getProject().$convertDuration(duration, durationUnit, TimeUnit.Millisecond);
      let resultN = baseDate.getTime();
      let leftDuration = durationMS;
      const calendar = yield this.$.calendar;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;

      if (assignmentsByCalendar.size > 0) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? {
          startDate: baseDate,
          isForward
        } : {
          endDate: baseDate,
          isForward
        });
        yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
          const intervalStartN = intervalStart.getTime(),
            intervalEndN = intervalEnd.getTime(),
            intervalDuration = intervalEndN - intervalStartN;

          if (intervalDuration >= leftDuration) {
            resultN = isForward ? intervalStartN + leftDuration : intervalEndN - leftDuration;
            return false;
          } else {
            const dstDiff = intervalStart.getTimezoneOffset() - intervalEnd.getTimezoneOffset();
            leftDuration -= intervalDuration + dstDiff * 60 * 1000;
          }
        });
        return new Date(resultN);
      } else {
        return calendar.accumulateWorkingTime(baseDate, durationMS, TimeUnit.Millisecond, isForward).finalDate;
      }
    }

    * hasProposedValueForUnits() {
      const assignments = yield this.$.assigned;

      for (const assignment of assignments) {
        const resource = yield assignment.$.resource;
        if (resource && assignment.$.units.hasProposedValue()) return true;
      }

      return false;
    }

    hasAssignmentChanges() {
      return this.$.assigned.newRefs.size > 0 || this.$.assigned.oldRefs.size > 0;
    }

  }

  __decorate$8([model_field()], HasAssignments.prototype, "dontRemoveMe", void 0);

  __decorate$8([generic_field({}, ModelBucketField)], HasAssignments.prototype, "assigned", void 0);

  __decorate$8([field()], HasAssignments.prototype, "effectiveCalendarsCombination", void 0);

  __decorate$8([field()], HasAssignments.prototype, "assignmentsByCalendar", void 0);

  __decorate$8([calculate('effectiveCalendarsCombination')], HasAssignments.prototype, "calculateEffectiveCalendarsCombination", null);

  __decorate$8([calculate('assignmentsByCalendar')], HasAssignments.prototype, "calculateAssignmentsByCalendar", null);

  return HasAssignments;
};

var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HasChildren = base => {
  class HasChildren extends base {
    * hasSubEvents() {
      const childEvents = yield this.$.childEvents;
      return childEvents.size > 0;
    }

    * subEventsIterable() {
      return yield this.$.childEvents;
    }

    * calculateStartDatePure() {
      const hasSubEvents = yield* this.hasSubEvents();

      if (hasSubEvents) {
        return yield* this.calculateMinChildrenStartDate();
      } else {
        return yield* super.calculateStartDatePure();
      }
    }

    * calculateEndDatePure() {
      const hasSubEvents = yield* this.hasSubEvents();

      if (hasSubEvents) {
        return yield* this.calculateMaxChildrenEndDate();
      } else {
        return yield* super.calculateEndDatePure();
      }
    }

    * calculateStartDateProposed() {
      const hasSubEvents = yield* this.hasSubEvents();

      if (hasSubEvents) {
        return yield* this.calculateStartDatePure();
      } else {
        return yield* super.calculateStartDateProposed();
      }
    }

    * calculateEndDateProposed() {
      const hasSubEvents = yield* this.hasSubEvents();

      if (hasSubEvents) {
        return yield* this.calculateEndDatePure();
      } else {
        return yield* super.calculateEndDateProposed();
      }
    }

    * calculateDurationProposed() {
      const hasSubEvents = yield* this.hasSubEvents();

      if (hasSubEvents) {
        return yield* this.calculateDurationPure();
      } else {
        return yield* super.calculateDurationProposed();
      }
    }

    * calculateMinChildrenStartDate() {
      const subEvents = yield* this.subEventsIterable();
      const subStartDates = [];

      for (const subEvent of subEvents) {
        subStartDates.push(yield subEvent.$.startDate);
      }

      let timestamp = subStartDates.reduce((acc, subStartDate) => subStartDate ? Math.min(acc, subStartDate.getTime()) : acc, MAX_DATE.getTime());
      if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime()) return null;
      return new Date(timestamp);
    }

    * calculateMaxChildrenEndDate() {
      const subEvents = yield* this.subEventsIterable();
      const subEndDates = [];

      for (const subEvent of subEvents) {
        subEndDates.push(yield subEvent.$.endDate);
      }

      let timestamp = subEndDates.reduce((acc, subEndDate) => subEndDate ? Math.max(acc, subEndDate.getTime()) : acc, MIN_DATE.getTime());
      if (timestamp === MIN_DATE.getTime() || timestamp === MAX_DATE.getTime()) return null;
      return new Date(timestamp);
    }

    get parent() {
      return this._parent;
    }

    set parent(value) {
      this._parent = value;
      this.$.parentEvent.put(value);
    }

    * maybeSkipNonWorkingTime(date, isForward = true) {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size > 0) return date;
      return yield* super.maybeSkipNonWorkingTime(date, isForward);
    }

    * calculateStartDateConstraintIntervals() {
      const intervals = yield* super.calculateStartDateConstraintIntervals();
      const parentEvent = yield this.$.parentEvent;

      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.startDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }

      return intervals;
    }

    * calculateEndDateConstraintIntervals() {
      const intervals = yield* super.calculateEndDateConstraintIntervals();
      const parentEvent = yield this.$.parentEvent;

      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.endDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }

      return intervals;
    }

    * calculateEarlyStartDateConstraintIntervals() {
      const intervals = yield* super.calculateEarlyStartDateConstraintIntervals();
      const parentEvent = yield this.$.parentEvent;

      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.earlyStartDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }

      return intervals;
    }

    * calculateEarlyEndDateConstraintIntervals() {
      const intervals = yield* super.calculateEarlyEndDateConstraintIntervals();
      const parentEvent = yield this.$.parentEvent;

      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.earlyEndDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }

      return intervals;
    }

    * calculateEarlyStartDateRaw() {
      const childEvents = yield this.$.childEvents;
      let result;

      if (childEvents.size) {
        result = MAX_DATE;

        for (let childEvent of childEvents) {
          const childDate = yield childEvent.$.earlyStartDateRaw;
          if (childDate && childDate < result) result = childDate;
        }

        result = result.getTime() !== MAX_DATE.getTime() ? result : null;
      } else {
        result = yield* super.calculateEarlyStartDateRaw();
      }

      return result;
    }

    * calculateEarlyEndDateRaw() {
      const childEvents = yield this.$.childEvents;
      let result;

      if (childEvents.size) {
        result = MIN_DATE;

        for (let childEvent of childEvents) {
          const childDate = yield childEvent.$.earlyEndDateRaw;
          if (childDate && childDate > result) result = childDate;
        }

        result = result.getTime() !== MIN_DATE.getTime() ? result : null;
      } else {
        result = yield* super.calculateEarlyEndDateRaw();
      }

      return result;
    }

  }

  __decorate$9([reference({
    bucket: 'childEvents'
  })], HasChildren.prototype, "parentEvent", void 0);

  __decorate$9([bucket()], HasChildren.prototype, "childEvents", void 0);

  __decorate$9([calculate('startDateConstraintIntervals')], HasChildren.prototype, "calculateStartDateConstraintIntervals", null);

  __decorate$9([calculate('endDateConstraintIntervals')], HasChildren.prototype, "calculateEndDateConstraintIntervals", null);

  __decorate$9([calculate('earlyStartDateConstraintIntervals')], HasChildren.prototype, "calculateEarlyStartDateConstraintIntervals", null);

  __decorate$9([calculate('earlyEndDateConstraintIntervals')], HasChildren.prototype, "calculateEarlyEndDateConstraintIntervals", null);

  __decorate$9([calculate('earlyStartDateRaw')], HasChildren.prototype, "calculateEarlyStartDateRaw", null);

  __decorate$9([calculate('earlyEndDateRaw')], HasChildren.prototype, "calculateEarlyEndDateRaw", null);

  return HasChildren;
};

var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HasDependencies = base => {
  class HasDependencies extends base {
    * calculateEarlyStartDateConstraintIntervals() {
      const intervals = yield* super.calculateEarlyStartDateConstraintIntervals();
      let dependency;

      for (dependency of yield this.$.incomingDeps) {
        const fromEvent = yield dependency.$.fromEvent;
        if (fromEvent == null || isAtomicValue(fromEvent)) continue;
        let interval;

        switch (dependency.type) {
          case DependencyType.EndToStart:
            const fromEventEndDate = yield fromEvent.$.earlyEndDateRaw;

            if (fromEventEndDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: calendar.calculateEndDate(fromEventEndDate, lag, lagUnit),
                endDate: null,
                originDescription: `"end to start" dependency from task ${fromEvent}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;

          case DependencyType.StartToStart:
            const fromEventStartDate = yield fromEvent.$.earlyStartDateRaw;

            if (fromEventStartDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: calendar.calculateEndDate(fromEventStartDate, lag, lagUnit),
                endDate: null,
                originDescription: `"start to start" dependency from task ${fromEvent}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;
        }

        interval && intervals.unshift(interval);
      }

      return intervals;
    }

    * calculateEarlyEndDateConstraintIntervals() {
      const intervals = yield* super.calculateEarlyEndDateConstraintIntervals();
      let dependency;

      for (dependency of yield this.$.incomingDeps) {
        const fromEvent = yield dependency.$.fromEvent;
        if (fromEvent == null || isAtomicValue(fromEvent)) continue;
        let interval;

        switch (dependency.type) {
          case DependencyType.EndToEnd:
            const fromEventEndDate = yield fromEvent.$.earlyEndDateRaw;

            if (fromEventEndDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: calendar.calculateEndDate(fromEventEndDate, lag, lagUnit),
                endDate: null,
                originDescription: `"end to end" dependency from task ${fromEvent}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;

          case DependencyType.StartToEnd:
            const fromEventStartDate = yield fromEvent.$.earlyStartDateRaw;

            if (fromEventStartDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: calendar.calculateEndDate(fromEventStartDate, lag, lagUnit),
                endDate: null,
                originDescription: `"start to end" dependency from task ${fromEvent}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;
        }

        interval && intervals.unshift(interval);
      }

      return intervals;
    }

    * calculateLateStartDateConstraintIntervals() {
      const intervals = yield* super.calculateLateStartDateConstraintIntervals();
      let dependency;

      for (dependency of yield this.$.outgoingDeps) {
        const successor = yield dependency.$.toEvent;
        if (successor == null || isAtomicValue(successor)) continue;
        let interval;

        switch (dependency.type) {
          case DependencyType.StartToStart:
            const successorStartDate = yield successor.$.lateStartDateRaw;

            if (successorStartDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: null,
                endDate: calendar.calculateStartDate(successorStartDate, lag, lagUnit),
                originDescription: `"start to start" dependency to task ${successor}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;

          case DependencyType.StartToEnd:
            const successorEndDate = yield successor.$.lateEndDateRaw;

            if (successorEndDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: null,
                endDate: calendar.calculateStartDate(successorEndDate, lag, lagUnit),
                originDescription: `"start to end" dependency to task ${successor}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;
        }

        interval && intervals.unshift(interval);
      }

      return intervals;
    }

    * calculateLateEndDateConstraintIntervals() {
      const intervals = yield* super.calculateLateEndDateConstraintIntervals();
      let dependency;

      for (dependency of yield this.$.outgoingDeps) {
        const successor = yield dependency.$.toEvent;
        if (successor == null || isAtomicValue(successor)) continue;
        let interval;

        switch (dependency.type) {
          case DependencyType.EndToEnd:
            const successorEndDate = yield successor.$.lateEndDateRaw;

            if (successorEndDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: null,
                endDate: calendar.calculateStartDate(successorEndDate, lag, lagUnit),
                originDescription: `"end to end" dependency to task ${successor}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;

          case DependencyType.EndToStart:
            const successorStartDate = yield successor.$.lateStartDateRaw;

            if (successorStartDate) {
              const lag = yield dependency.$.lag;
              const lagUnit = yield dependency.$.lagUnit;
              const calendar = yield dependency.$.calendar;
              interval = ConstraintInterval.new({
                startDate: null,
                endDate: calendar.calculateStartDate(successorStartDate, lag, lagUnit),
                originDescription: `"end to start" dependency to task ${successor}`,
                onRemoveAction: this.getOnRemoveAction(dependency)
              });
            }

            break;
        }

        interval && intervals.unshift(interval);
      }

      return intervals;
    }

    getOnRemoveAction(dependency) {
      return () => {
        this.getDependencyStore().remove(dependency);
      };
    }

    async setIncomingDeps(deps) {
      const dependencyStore = this.getDependencyStore();
      this.incomingDeps.forEach(dependency => dependencyStore.remove(dependency));
      deps.forEach(dependency => {
        dependency.toEvent = this;
        dependencyStore.add(dependency);
      });
      return this.propagate();
    }

    async setOutgoingDeps(deps) {
      const dependencyStore = this.getDependencyStore();
      this.outgoingDeps.forEach(dependency => dependencyStore.remove(dependency));
      deps.forEach(dependency => {
        dependency.fromEvent = this;
        dependencyStore.add(dependency);
      });
      return this.propagate();
    }

    leaveProject() {
      const dependencyStore = this.getDependencyStore();
      this.incomingDeps.forEach(dependency => dependencyStore.remove(dependency));
      this.outgoingDeps.forEach(dependency => dependencyStore.remove(dependency));
      super.leaveProject();
    }

  }

  __decorate$a([model_field()], HasDependencies.prototype, "dontRemoveMe", void 0);

  __decorate$a([generic_field({}, ModelBucketField)], HasDependencies.prototype, "outgoingDeps", void 0);

  __decorate$a([generic_field({}, ModelBucketField)], HasDependencies.prototype, "incomingDeps", void 0);

  __decorate$a([calculate('earlyStartDateConstraintIntervals')], HasDependencies.prototype, "calculateEarlyStartDateConstraintIntervals", null);

  __decorate$a([calculate('earlyEndDateConstraintIntervals')], HasDependencies.prototype, "calculateEarlyEndDateConstraintIntervals", null);

  __decorate$a([calculate('lateStartDateConstraintIntervals')], HasDependencies.prototype, "calculateLateStartDateConstraintIntervals", null);

  __decorate$a([calculate('lateEndDateConstraintIntervals')], HasDependencies.prototype, "calculateLateEndDateConstraintIntervals", null);

  return HasDependencies;
};

const ProjectUnconstrainedEvent = base => {
  class ProjectUnconstrainedEvent extends base {
  }

  return ProjectUnconstrainedEvent;
};

const BuildSchedulerEvent = (base = Model) => ProjectUnconstrainedEvent(HasAssignments(HasChildren(HasDependencies(ConstrainedEvent(EventMixin(HasCalendarMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(base)))))))))));

class SchedulerEvent extends BuildSchedulerEvent(Model) {
}


class ProTaskModel extends PartOfProject(BuildSchedulerEvent(TimeSpan)) {


  static get fields() {
    return [


      {
        name: 'note',
        type: 'string'
      },

      {
        name: 'percentDone',
        type: 'number',
        defaultValue: 0
      }, {
        name: 'parentId',

        serialize(value, record) {
          const eventStore = record.getEventStore(),
            project = record.getProject();

          if (eventStore && eventStore.getById(value) === project) {
            value = null;
          }

          return value;
        }

      },


      {
        name: 'phantomId',
        type: 'string'
      }, {
        name: 'phantomParentId',
        type: 'string'
      },

      {
        name: 'showInTimeline',
        type: 'boolean'
      },


      {
        name: 'index',
        type: 'int',
        persist: true
      },

      {
        name: 'iconCls'
      },

      {
        name: 'draggable',
        type: 'boolean',
        persist: false,
        defaultValue: true
      },


      {
        name: 'resizable',
        persist: false,
        defaultValue: true
      }
    ];
  }


  get isTask() {
    return true;
  }

  get successors() {
    return Array.from(this.outgoingDeps);
  }

  set successors(successors) {
    this.setOutgoingDeps(successors);
  }

  get predecessors() {
    return Array.from(this.incomingDeps);
  }

  set predecessors(predecessors) {
    this.setIncomingDeps(predecessors);
  }

  get renderedPercentDone() {
    if (this.percentDone <= 99) {
      return Math.round(this.percentDone);
    } else {
      return Math.floor(this.percentDone);
    }
  }

  get isDraggable() {
    return this.draggable;
  }

  get isResizable() {
    return this.resizable && !this.milestone && !this.isParent;
  }

  get isStarted() {
    return this.percentDone > 0;
  }

  get isCompleted() {
    return this.percentDone >= 100;
  }


  get milestone() {


    if (!this.isLeaf) {
      const {
        startDate,
        endDate
      } = this;

      if (startDate && endDate) {
        return endDate.getTime() === startDate.getTime();
      }
    }

    return this.duration === 0;
  }

  get isMilestone() {
    return this.milestone;
  }

  set milestone(value) {
    value ? this.convertToMilestone() : this.convertToRegular();
  }

  async setMilestone(value) {
    return value ? this.convertToMilestone() : this.convertToRegular();
  }


  async convertToMilestone() {
    return this.setDuration(0, this.durationUnit, false);
  }


  async convertToRegular() {
    const me = this;

    if (me.milestone) {
      return me.setDuration(1, me.durationUnit, false);
    }
  }


  get allDependencies() {
    return [...(this.predecessors || []), ...(this.successors || [])];
  }


  get predecessorTasks() {
    return this.predecessors.map(dependency => dependency.fromEvent);
  }


  get successorTasks() {
    return this.successors.map(dependency => dependency.toEvent);
  }


  get previousSiblingsTotalCount() {
    let task = this.previousSibling,
      count = this.parentIndex;

    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }

    return count;
  }


  get sequenceNumber() {
    let code = 0,
      task = this;


    while (task.parent) {
      code += task.previousSiblingsTotalCount + 1;
      task = task.parent;
    }

    return code;
  }


  get isSubProject() {
    return false;
  }


  get subProject() {
    const me = this;
    let project = null;

    if (me.isProject) {

      project = me;
    } else {
      me.bubbleWhile(t => {
        if (t.isProject) {
          project = t;
        }

        return !project;
      });
    }

    return project;
  }


  get fullEffort() {
    return {
      unit: this.effortUnit,
      magnitude: this.effort
    };
  }

  set fullEffort(effort) {
    this.setEffort(effort.magnitude, effort.unit);
  }

  get fullDuration() {
    return {
      unit: this.durationUnit,
      magnitude: this.duration
    };
  }

  set fullDuration(value) {
    this.setDuration(value.magnitude, value.unit);
  }


  normalize() {
  }

  inSetNormalize(field) {
  }


}

ProTaskModel.convertEmptyParentToLeaf = true;
ProTaskModel._$name = 'ProTaskModel';

var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const ConstrainedLateEvent = base => {
  class ConstrainedLateEvent extends base {
    * calculateLateStartDateConstraintIntervals() {
      const intervals = [];
      const parentEvent = yield this.$.parentEvent;

      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.lateStartDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }

      return intervals;
    }

    * calculateLateEndDateConstraintIntervals() {
      const intervals = [];
      const parentEvent = yield this.$.parentEvent;

      if (parentEvent) {
        const parentIntervals = yield parentEvent.$.lateEndDateConstraintIntervals;
        intervals.push.apply(intervals, parentIntervals);
      }

      return intervals;
    }

    * calculateLateStartDateRaw() {
      const childEvents = yield this.$.childEvents;
      let result;

      if (childEvents.size) {
        result = MAX_DATE;

        for (let childEvent of childEvents) {
          const childDate = yield childEvent.$.lateStartDateRaw;
          if (childDate && childDate < result) result = childDate;
        }

        result = result.getTime() - MAX_DATE.getTime() ? result : null;
      } else {
        if (!(yield* this.isConstrainedLate())) {
          return yield this.$.startDate;
        }

        const startDateConstraintIntervals = yield this.$.lateStartDateConstraintIntervals;
        const endDateConstraintIntervals = yield this.$.lateEndDateConstraintIntervals;
        const effectiveInterval = yield* this.calculateEffectiveConstraintInterval(true, startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals));
        if (!effectiveInterval || !isDateFinite(effectiveInterval.endDate)) return null;
        result = effectiveInterval.endDate;
      }

      return result;
    }

    * calculateLateStartDate() {
      const date = yield this.$.lateStartDateRaw;
      return yield* this.maybeSkipNonWorkingTime(date, true);
    }

    * calculateLateEndDateRaw() {
      const childEvents = yield this.$.childEvents;
      let result;

      if (childEvents.size) {
        result = MIN_DATE;

        for (let childEvent of childEvents) {
          const childDate = yield childEvent.$.lateEndDateRaw;
          if (childDate && childDate > result) result = childDate;
        }

        result = result.getTime() - MIN_DATE.getTime() ? result : null;
      } else {
        if (!(yield* this.isConstrainedLate())) {
          return yield this.$.endDate;
        }

        const startDateConstraintIntervals = yield this.$.lateStartDateConstraintIntervals;
        const endDateConstraintIntervals = yield this.$.lateEndDateConstraintIntervals;
        const effectiveInterval = yield* this.calculateEffectiveConstraintInterval(false, startDateConstraintIntervals.concat(yield this.$.startDateConstraintIntervals), endDateConstraintIntervals.concat(yield this.$.endDateConstraintIntervals));
        if (!effectiveInterval || !isDateFinite(effectiveInterval.endDate)) return null;
        result = effectiveInterval.endDate;
      }

      return result;
    }

    * calculateLateEndDate() {
      const date = yield this.$.lateEndDateRaw;
      return yield* this.maybeSkipNonWorkingTime(date, false);
    }

    * calculateTotalSlack() {
      const earlyStartDate = yield this.$.earlyStartDateRaw;
      const lateStartDate = yield this.$.lateStartDateRaw;
      const earlyEndDate = yield this.$.earlyEndDateRaw;
      const lateEndDate = yield this.$.lateEndDateRaw;
      const slackUnit = yield this.$.slackUnit;
      let endSlack, result;
      const isByEarly = earlyStartDate && lateStartDate && isDateFinite(earlyStartDate) && isDateFinite(lateStartDate);
      const isByLate = earlyEndDate && lateEndDate && isDateFinite(earlyEndDate) && isDateFinite(lateEndDate);

      if (isByEarly || isByLate) {
        if (isByEarly) {
          result = yield* this.calculateProjectedDuration(earlyStartDate, lateStartDate, slackUnit);

          if (isByLate) {
            endSlack = yield* this.calculateProjectedDuration(earlyEndDate, lateEndDate, slackUnit);
            if (endSlack < result) result = endSlack;
          }
        } else if (isByLate) {
          result = yield* this.calculateProjectedDuration(earlyEndDate, lateEndDate, slackUnit);
        }
      }

      return result;
    }

    * calculateCritical() {
      const totalSlack = yield this.$.totalSlack;
      return totalSlack <= 0;
    }

    * isConstrainedLate() {
      const startDateIntervals = yield this.$.startDateConstraintIntervals;
      const endDateIntervals = yield this.$.endDateConstraintIntervals;
      const lateStartDateConstraintIntervals = yield this.$.lateStartDateConstraintIntervals;
      const lateEndDateConstraintIntervals = yield this.$.lateEndDateConstraintIntervals;
      return Boolean(startDateIntervals.length || endDateIntervals.length || lateStartDateConstraintIntervals.length || lateEndDateConstraintIntervals.length);
    }

    * calculateStartDatePure() {
      const direction = yield this.$.direction;

      if (direction === Direction.Backward) {
        if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled)) {
          return yield* super.calculateStartDatePure();
        }

        return yield this.$.lateStartDate;
      } else {
        return yield* super.calculateStartDatePure();
      }
    }

    * calculateStartDateProposed() {
      const direction = yield this.$.direction;

      switch (direction) {
        case Direction.Backward:
          if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled)) {
            return yield* super.calculateStartDateProposed();
          }

          return yield* this.calculateStartDatePure();

        default:
          return yield* super.calculateStartDateProposed();
      }
    }

    * calculateEndDatePure() {
      const direction = yield this.$.direction;

      if (direction === Direction.Backward) {
        if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled)) {
          return yield* super.calculateEndDatePure();
        }

        return yield this.$.lateEndDate;
      } else {
        return yield* super.calculateEndDatePure();
      }
    }

    * calculateEndDateProposed() {
      const direction = yield this.$.direction;

      switch (direction) {
        case Direction.Backward:
          if (!(yield* this.isConstrainedLate()) || (yield this.$.manuallyScheduled)) {
            return yield* super.calculateEndDateProposed();
          }

          return yield* this.calculateEndDatePure();

        default:
          return yield* super.calculateEndDateProposed();
      }
    }

  }

  __decorate$b([field()], ConstrainedLateEvent.prototype, "lateStartDateRaw", void 0);

  __decorate$b([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ',
    persist: false
  }, {
    converter: dateConverter,
    persistent: false
  })], ConstrainedLateEvent.prototype, "lateStartDate", void 0);

  __decorate$b([field()], ConstrainedLateEvent.prototype, "lateEndDateRaw", void 0);

  __decorate$b([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ',
    persist: false
  }, {
    converter: dateConverter,
    persistent: false
  })], ConstrainedLateEvent.prototype, "lateEndDate", void 0);

  __decorate$b([field()], ConstrainedLateEvent.prototype, "lateStartDateConstraintIntervals", void 0);

  __decorate$b([field()], ConstrainedLateEvent.prototype, "lateEndDateConstraintIntervals", void 0);

  __decorate$b([model_field({
    type: 'number',
    persist: false
  }, {
    persistent: false
  })], ConstrainedLateEvent.prototype, "totalSlack", void 0);

  __decorate$b([model_field({
    type: 'string',
    defaultValue: TimeUnit.Day,
    persist: false
  }, {
    converter: DateHelper.normalizeUnit,
    persistent: false
  })], ConstrainedLateEvent.prototype, "slackUnit", void 0);

  __decorate$b([model_field({
    type: 'boolean',
    defaultValue: false,
    persist: false
  }, {
    persistent: false
  })], ConstrainedLateEvent.prototype, "critical", void 0);

  __decorate$b([calculate('lateStartDateConstraintIntervals')], ConstrainedLateEvent.prototype, "calculateLateStartDateConstraintIntervals", null);

  __decorate$b([calculate('lateEndDateConstraintIntervals')], ConstrainedLateEvent.prototype, "calculateLateEndDateConstraintIntervals", null);

  __decorate$b([calculate('lateStartDateRaw')], ConstrainedLateEvent.prototype, "calculateLateStartDateRaw", null);

  __decorate$b([calculate('lateStartDate')], ConstrainedLateEvent.prototype, "calculateLateStartDate", null);

  __decorate$b([calculate('lateEndDateRaw')], ConstrainedLateEvent.prototype, "calculateLateEndDateRaw", null);

  __decorate$b([calculate('lateEndDate')], ConstrainedLateEvent.prototype, "calculateLateEndDate", null);

  __decorate$b([calculate('totalSlack')], ConstrainedLateEvent.prototype, "calculateTotalSlack", null);

  __decorate$b([calculate('critical')], ConstrainedLateEvent.prototype, "calculateCritical", null);

  return ConstrainedLateEvent;
};

var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HasDateConstraint = base => {
  class HasDateConstraint extends base {
    putStartDate(date, keepDuration = true) {
      const isVeryInitialAssignment = this.$.startDate.getProposedOrPreviousValue() === undefined;
      const project = this.getProject();

      if (!isVeryInitialAssignment && !(project && project.getStm().isRestoring)) {
        const constrainType = this.getStartDatePinConstraintType();

        if (constrainType) {
          this.constraintType = constrainType;
          this.constraintDate = date;
        }
      }

      return super.putStartDate(date, keepDuration);
    }

    putEndDate(date, keepDuration = false) {
      const isVeryInitialAssignment = this.$.endDate.getProposedOrPreviousValue() === undefined;
      const project = this.getProject();

      if (!isVeryInitialAssignment && keepDuration && !(project && project.getStm().isRestoring)) {
        const constrainType = this.getEndDatePinConstraintType();

        if (constrainType) {
          this.constraintType = constrainType;
          this.constraintDate = date;
        }
      }

      return super.putEndDate(date, keepDuration);
    }

    * calculateConstraintType() {
      let constraintType = this.$.constraintType.getProposedOrPreviousValue();

      if (!(yield* this.isConstraintTypeApplicable(constraintType))) {
        constraintType = null;
      }

      return constraintType;
    }

    * calculateConstraintDate(Y) {
      let constraintDate = this.$.constraintDate.getProposedOrPreviousValue();
      const constraintType = yield this.$.constraintType;

      if (!constraintType) {
        constraintDate = null;
      } else if (!constraintDate) {
        constraintDate = this.getConstraintTypeDefaultDate(Y, constraintType);
      }

      return constraintDate;
    }

    getStartDatePinConstraintType() {
      const {
        direction
      } = this;
      if (!this.isTaskPinnableWithConstraint()) return null;

      switch (direction) {
        case Direction.Forward:
          return ConstraintType.StartNoEarlierThan;

        case Direction.Backward:
          return ConstraintType.FinishNoLaterThan;
      }
    }

    getEndDatePinConstraintType() {
      const {
        direction
      } = this;
      if (!this.isTaskPinnableWithConstraint()) return null;

      switch (direction) {
        case Direction.Forward:
          return ConstraintType.FinishNoEarlierThan;

        case Direction.Backward:
          return ConstraintType.FinishNoLaterThan;
      }
    }

    isTaskPinnableWithConstraint() {
      const {
        manuallyScheduled,
        constraintType
      } = this;
      let result = false;

      if (!manuallyScheduled) {
        if (constraintType) {
          switch (constraintType) {
            case ConstraintType.StartNoEarlierThan:
            case ConstraintType.FinishNoEarlierThan:
              result = true;
          }
        } else {
          result = true;
        }
      }

      return result;
    }

    getConstraintTypeDefaultDate(Y, constraintType) {
      switch (constraintType) {
        case ConstraintType.StartNoEarlierThan:
        case ConstraintType.StartNoLaterThan:
        case ConstraintType.MustStartOn:
          return this.$.startDate.getProposedOrPreviousValue();

        case ConstraintType.FinishNoEarlierThan:
        case ConstraintType.FinishNoLaterThan:
        case ConstraintType.MustFinishOn:
          return this.$.endDate.getProposedOrPreviousValue();
      }

      return null;
    }

    * isConstraintTypeApplicable(constraintType) {
      const childEvents = yield this.$.childEvents;
      const isSummary = childEvents.size > 0;

      switch (constraintType) {
        case ConstraintType.FinishNoEarlierThan:
        case ConstraintType.StartNoLaterThan:
        case ConstraintType.MustFinishOn:
        case ConstraintType.MustStartOn:
          return !isSummary;
      }

      return true;
    }

    async setConstraint(constraintType, constraintDate) {
      this.constraintType = constraintType;

      if (constraintDate !== undefined) {
        this.constraintDate = constraintDate;
      }

      return this.propagate();
    }

    * calculateEndDateConstraintIntervals() {
      const intervals = yield* super.calculateEndDateConstraintIntervals();
      const constraintType = yield this.$.constraintType;
      const constraintDate = yield this.$.constraintDate;

      if (constraintType && constraintDate) {
        switch (constraintType) {
          case ConstraintType.MustFinishOn:
            intervals.unshift(DateInterval.new({
              startDate: constraintDate,
              endDate: constraintDate
            }));
            break;

          case ConstraintType.FinishNoEarlierThan:
            intervals.unshift(DateInterval.new({
              startDate: constraintDate
            }));
            break;

          case ConstraintType.FinishNoLaterThan:
            intervals.unshift(DateInterval.new({
              endDate: constraintDate
            }));
            break;
        }
      }

      return intervals;
    }

    * calculateStartDateConstraintIntervals() {
      const intervals = yield* super.calculateStartDateConstraintIntervals();
      const constraintType = yield this.$.constraintType;
      const constraintDate = yield this.$.constraintDate;

      if (constraintType && constraintDate) {
        switch (constraintType) {
          case ConstraintType.MustStartOn:
            intervals.unshift(DateInterval.new({
              startDate: constraintDate,
              endDate: constraintDate
            }));
            break;

          case ConstraintType.StartNoEarlierThan:
            intervals.unshift(DateInterval.new({
              startDate: constraintDate
            }));
            break;

          case ConstraintType.StartNoLaterThan:
            intervals.unshift(DateInterval.new({
              endDate: constraintDate
            }));
            break;
        }
      }

      return intervals;
    }

  }

  __decorate$c([model_field({
    type: 'string'
  })], HasDateConstraint.prototype, "constraintType", void 0);

  __decorate$c([model_field({
    type: 'date',
    dateFormat: 'YYYY-MM-DDTHH:mm:ssZ'
  }, {
    converter: dateConverter
  })], HasDateConstraint.prototype, "constraintDate", void 0);

  __decorate$c([calculate('constraintType')], HasDateConstraint.prototype, "calculateConstraintType", null);

  __decorate$c([calculate('constraintDate')], HasDateConstraint.prototype, "calculateConstraintDate", null);

  return HasDateConstraint;
};

var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HasEffort = base => {
  class HasEffort extends base {
    setEffort(effort, unit) {
      this.putEffort(effort, unit);
      return this.propagate();
    }

    getEffort(unit) {
      const effort = this.effort;
      return unit !== undefined ? this.getProject().convertDuration(effort, this.effortUnit, unit) : effort;
    }

    putEffort(effort, unit) {
      if (effort < 0) effort = 0;
      const isVeryFirstAssignment = this.$.effort.getProposedOrPreviousValue() === undefined;
      if (effort == null && isVeryFirstAssignment) return;

      if (unit != null && unit !== this.effortUnit) {
        this.effortUnit = unit;
      }

      this.$.effort.put(effort);
    }

    setEffortUnit(_value) {
      throw new Error("Use `setEffort` instead");
    }

    * calculateTotalChildrenEffort() {
      const childEvents = yield this.$.childEvents;
      const project = this.getProject();
      let totalEffortMs = 0;

      for (const childEvent of childEvents) {
        const childEventEffortUnit = yield childEvent.$.effortUnit;
        totalEffortMs += yield* project.$convertDuration(yield childEvent.$.effort, childEventEffortUnit, TimeUnit.Millisecond);
      }

      return yield* project.$convertDuration(totalEffortMs, TimeUnit.Millisecond, yield this.$.effortUnit);
    }

    * calculateEffort() {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size > 0) return yield* this.calculateTotalChildrenEffort(); else {
        const proposed = this.$.effort.getProposedOrPreviousValue();
        return proposed !== undefined ? proposed : yield* this.calculateEffortPure();
      }
    }

    * calculateEffortPure() {
      const childEvents = yield this.$.childEvents;
      if (childEvents.size > 0) return yield* this.calculateTotalChildrenEffort(); else {
        return yield* this.calculateProjectedEffort(yield this.$.startDate, yield this.$.endDate);
      }
    }

    * calculateEffortProposed() {
      return this.$.effort.getProposedOrPreviousValue();
    }

    * calculateAssignmentUnits(assignment) {
      return yield* this.calculateAssignmentUnitsProposed(assignment);
    }

    * calculateAssignmentUnitsPure(assignment) {
      return yield* this.calculateUnitsByStartEndAndEffort(assignment);
    }

    * calculateAssignmentUnitsProposed(assignment) {
      return assignment.$.units.getProposedOrPreviousValue();
    }

    * getBaseOptionsForEffortCalculations() {
      return {
        ignoreResourceCalendars: false
      };
    }

    * calculateProjectedEffort(startDate, endDate) {
      if (startDate == null || endDate == null || startDate > endDate) return null;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const totalUnitsByCalendar = new Map();

      for (const [calendar, assignments] of assignmentsByCalendar) {
        let intervalUnits = 0;

        for (const assignment of assignments) {
          intervalUnits += yield assignment.$.units;
        }

        totalUnitsByCalendar.set(calendar, intervalUnits);
      }

      let resultN = 0;
      const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), {
        startDate,
        endDate
      });

      if (totalUnitsByCalendar.size === 0) {
        totalUnitsByCalendar.set(yield this.$.calendar, 100);
        options.ignoreResourceCalendars = true;
      }

      yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
        const intervalStartN = intervalStart.getTime(),
          intervalEndN = intervalEnd.getTime(),
          intervalDuration = intervalEndN - intervalStartN;
        let intervalUnits = 0;

        for (const workingCalendar of workCalendars) {
          intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;
        }

        resultN += intervalUnits * intervalDuration * 0.01;
      });
      return yield* this.getProject().$convertDuration(resultN, TimeUnit.Millisecond, yield this.$.effortUnit);
    }

    * calculateUnitsByStartEndAndEffort(_assignment) {
      const effort = yield this.$.effort,
        effortUnit = yield this.$.effortUnit,
        effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);
      let collectedEffort = 0;
      const options = Object.assign(yield* this.getBaseOptionsForEffortCalculations(), {
        startDate: yield this.$.startDate,
        endDate: yield this.$.endDate
      });
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
        const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
        const intervalStartN = intervalStart.getTime(),
          intervalEndN = intervalEnd.getTime(),
          intervalDuration = intervalEndN - intervalStartN;

        for (const workingCalendar of workCalendars) {
          collectedEffort += (assignmentsByCalendar.has(workingCalendar) ? assignmentsByCalendar.get(workingCalendar).length : 0) * intervalDuration;
        }
      });
      return collectedEffort ? 100 * effortMS / collectedEffort : 100;
    }

    * calculateProjectedXDateByEffort(baseDate, isForward = true) {
      const effort = yield this.$.effort,
        effortUnit = yield this.$.effortUnit,
        effortMS = yield* this.getProject().$convertDuration(effort, effortUnit, TimeUnit.Millisecond);
      if (baseDate == null || effort == null) return null;
      let resultN = baseDate.getTime();
      let leftEffort = effortMS;
      const calendar = yield this.$.calendar;
      const assignmentsByCalendar = yield this.$.assignmentsByCalendar;
      const totalUnitsByCalendar = new Map();

      for (const [calendar, assignments] of assignmentsByCalendar) {
        let intervalUnits = 0;

        for (const assignment of assignments) {
          intervalUnits += yield assignment.$.units;
        }

        totalUnitsByCalendar.set(calendar, intervalUnits);
      }

      if (assignmentsByCalendar.size > 0) {
        const options = Object.assign(yield* this.getBaseOptionsForDurationCalculations(), isForward ? {
          startDate: baseDate,
          isForward
        } : {
          endDate: baseDate,
          isForward
        });
        yield* this.forEachAvailabilityInterval(options, (intervalStart, intervalEnd, calendarCacheIntervalMultiple) => {
          const workCalendars = calendarCacheIntervalMultiple.getCalendarsWorking();
          const intervalStartN = intervalStart.getTime(),
            intervalEndN = intervalEnd.getTime(),
            intervalDuration = intervalEndN - intervalStartN;
          let intervalUnits = 0;

          for (const workingCalendar of workCalendars) {
            intervalUnits += totalUnitsByCalendar.get(workingCalendar) || 0;
          }

          const intervalEffort = intervalUnits * intervalDuration * 0.01;

          if (intervalEffort >= leftEffort) {
            resultN = isForward ? intervalStartN + leftEffort / (0.01 * intervalUnits) : intervalEndN - leftEffort / (0.01 * intervalUnits);
            return false;
          } else {
            leftEffort -= intervalEffort;
          }
        });
        return new Date(resultN);
      } else {
        return calendar.accumulateWorkingTime(baseDate, effortMS, TimeUnit.Millisecond, isForward).finalDate;
      }
    }

  }

  __decorate$d([model_field({
    'type': 'number'
  })], HasEffort.prototype, "effort", void 0);

  __decorate$d([model_field({
    'type': 'string',
    defaultValue: TimeUnit.Hour
  }, {
    converter: DateHelper.normalizeUnit
  })], HasEffort.prototype, "effortUnit", void 0);

  __decorate$d([calculate('effort')], HasEffort.prototype, "calculateEffort", null);

  return HasEffort;
};

var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HasPercentDone = base => {
  class HasPercentDone extends base {
    * calculatePercentDone(proposedValue) {
      const childEvents = yield this.$.childEvents;
      const project = this.getProject();
      const autoCalculatePercentDoneForParentTasks = yield project.$.autoCalculatePercentDoneForParentTasks;

      if (childEvents.size && autoCalculatePercentDoneForParentTasks) {
        const summaryData = yield this.$.percentDoneSummaryData;

        if (summaryData.totalDuration > 0) {
          return summaryData.completedDuration / summaryData.totalDuration;
        } else if (summaryData.milestonesNum > 0) {
          return summaryData.milestonesTotalPercentDone / summaryData.milestonesNum;
        } else {
          return null;
        }
      } else {
        if (proposedValue !== undefined) return proposedValue;
        return this.$.percentDone.value;
      }
    }

    * calculatePercentDoneSummaryData() {
      const childEvents = yield this.$.childEvents;

      if (childEvents.size) {
        let summary = {
          totalDuration: 0,
          completedDuration: 0,
          milestonesNum: 0,
          milestonesTotalPercentDone: 0
        };

        for (const childEvent of childEvents) {
          const childCompletedDuration = yield childEvent.$.percentDoneSummaryData;

          if (childCompletedDuration) {
            summary.totalDuration += childCompletedDuration.totalDuration;
            summary.completedDuration += childCompletedDuration.completedDuration;
            summary.milestonesNum += childCompletedDuration.milestonesNum;
            summary.milestonesTotalPercentDone += childCompletedDuration.milestonesTotalPercentDone;
          }
        }

        return summary;
      } else {
        const duration = yield this.$.duration;

        if (typeof duration == 'number') {
          const durationInMs = yield* this.$convertDuration(duration, yield this.$.durationUnit, TimeUnit.Millisecond);
          const percentDone = yield this.$.percentDone;
          return {
            totalDuration: durationInMs,
            completedDuration: durationInMs * percentDone,
            milestonesNum: durationInMs === 0 ? 1 : 0,
            milestonesTotalPercentDone: durationInMs === 0 ? percentDone : 0
          };
        } else {
          return null;
        }
      }
    }

  }

  __decorate$e([model_field({
    type: 'number',
    defaultValue: 0
  })], HasPercentDone.prototype, "percentDone", void 0);

  __decorate$e([field()], HasPercentDone.prototype, "percentDoneSummaryData", void 0);

  __decorate$e([calculate('percentDone')], HasPercentDone.prototype, "calculatePercentDone", null);

  __decorate$e([calculate('percentDoneSummaryData')], HasPercentDone.prototype, "calculatePercentDoneSummaryData", null);

  return HasPercentDone;
};

const EffortVar = Symbol('EffortVar');
const UnitsVar = Symbol('UnitsVar');
const effortFormula = Formula.new({
  output: EffortVar,
  inputs: new Set([StartDateVar, EndDateVar, UnitsVar])
});
const unitsFormula = Formula.new({
  output: UnitsVar,
  inputs: new Set([StartDateVar, EndDateVar, EffortVar])
});
const endDateByEffortFormula = Formula.new({
  output: EndDateVar,
  inputs: new Set([StartDateVar, EffortVar, UnitsVar])
});
const startDateByEffortFormula = Formula.new({
  output: StartDateVar,
  inputs: new Set([EndDateVar, EffortVar, UnitsVar])
});

class SEDWUDispatcher extends SEDDispatcher {
}

class SEDWUDispatcherIdentifier extends SEDDispatcherIdentifier {
  equality(v1, v2) {
    const resolution1 = v1.resolution;
    const resolution2 = v2.resolution;
    return resolution1.get(EffortVar) === resolution2.get(EffortVar) && resolution1.get(UnitsVar) === resolution2.get(UnitsVar) && super.equality(v1, v2);
  }

}

var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HasSchedulingMode = base => {
  class HasSchedulingMode extends base {
    * prepareDispatcher() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode !== SchedulingMode.Normal) {
        const cycleDispatcher = yield* super.prepareDispatcher();
        cycleDispatcher.collectInfo(this.$.effort, EffortVar);
        if (yield* this.hasProposedValueForUnits()) cycleDispatcher.addProposedValueFlag(UnitsVar);
        cycleDispatcher.addPreviousValueFlag(UnitsVar);
        return cycleDispatcher;
      } else {
        return yield* super.prepareDispatcher();
      }
    }

    * dispatcherClass() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode !== SchedulingMode.Normal) {
        return SEDWUDispatcher;
      } else {
        return yield* super.dispatcherClass();
      }
    }

    buildProposedDispatcher() {
      const dispatcher = super.buildProposedDispatcher();
      dispatcher.addPreviousValueFlag(EffortVar);
      dispatcher.addPreviousValueFlag(UnitsVar);
      return dispatcher;
    }

    * calculateAssignmentUnits(assignment) {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(UnitsVar);

        if (formulaId === CalculateProposed) {
          return yield* this.calculateAssignmentUnitsProposed(assignment);
        } else if (formulaId === unitsFormula.formulaId) {
          return yield* this.calculateAssignmentUnitsPure(assignment);
        } else {
          throw new Error("Unknown formula for `units`");
        }
      } else {
        return yield* super.calculateAssignmentUnits(assignment);
      }
    }

    putEffort(effort, unit) {
      const isVeryFirstAssignment = this.$.effort.getProposedOrPreviousValue() === undefined;
      if (effort == null && isVeryFirstAssignment) return super.putEffort(effort, unit);

      if (this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.startDate);
        this.markAsNeedRecalculation(this.$.endDate);
        this.markAsNeedRecalculation(this.$.duration);
        this.assigned.forEach(assignment => assignment.markAsNeedRecalculation(assignment.$.units));
      }

      super.putEffort(effort, unit);
    }

    putStartDate(date, keepDuration = true) {
      const isVeryFirstAssignment = this.$.startDate.getProposedOrPreviousValue() === undefined;

      if (!isVeryFirstAssignment && this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.startDate);
        this.markAsNeedRecalculation(this.$.endDate);
        this.markAsNeedRecalculation(this.$.duration);
        this.markAsNeedRecalculation(this.$.effort);
        this.assigned.forEach(assignment => assignment.markAsNeedRecalculation(assignment.$.units));
      }

      super.putStartDate(date, keepDuration);
    }

    putEndDate(date, keepDuration = false) {
      const isVeryFirstAssignment = this.$.endDate.getProposedOrPreviousValue() === undefined;

      if (!isVeryFirstAssignment && this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.startDate);
        this.markAsNeedRecalculation(this.$.endDate);
        this.markAsNeedRecalculation(this.$.duration);
        this.markAsNeedRecalculation(this.$.effort);
        this.assigned.forEach(assignment => assignment.markAsNeedRecalculation(assignment.$.units));
      }

      super.putEndDate(date, keepDuration);
    }

    putDuration(duration, unit, keepStartDate = true) {
      const isVeryFirstAssignment = this.$.duration.getProposedOrPreviousValue() === undefined;

      if (!isVeryFirstAssignment && this.getGraph()) {
        this.markAsNeedRecalculation(this.$.dispatcher);
        this.markAsNeedRecalculation(this.$.startDate);
        this.markAsNeedRecalculation(this.$.endDate);
        this.markAsNeedRecalculation(this.$.duration);
        this.markAsNeedRecalculation(this.$.effort);
        this.assigned.forEach(assignment => assignment.markAsNeedRecalculation(assignment.$.units));
      }

      super.putDuration(duration, unit, keepStartDate);
    }

    * calculateEffort() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(EffortVar);

        if (formulaId === CalculateProposed) {
          return yield* this.calculateEffortProposed();
        } else if (formulaId === effortFormula.formulaId) {
          return yield* this.calculateEffortPure();
        } else {
          throw new Error("Unknown formula for `effort`");
        }
      } else {
        return yield* super.calculateEffort();
      }
    }

    * calculateStartDate() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(StartDateVar);

        if (formulaId === startDateByEffortFormula.formulaId) {
          return yield* this.calculateProjectedXDateByEffort(yield this.$.endDate, false);
        } else {
          return yield* super.calculateStartDate();
        }
      } else {
        return yield* super.calculateStartDate();
      }
    }

    * calculateEndDate() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode !== SchedulingMode.Normal) {
        const dispatch = yield this.$.dispatcher;
        const formulaId = dispatch.resolution.get(EndDateVar);

        if (formulaId === endDateByEffortFormula.formulaId) {
          return yield* this.calculateProjectedXDateByEffort(yield this.$.startDate, true);
        } else {
          return yield* super.calculateEndDate();
        }
      } else {
        return yield* super.calculateEndDate();
      }
    }

    * calculateEffectiveDuration() {
      const dispatch = yield this.$.dispatcher;
      const durationResolution = dispatch.resolution.get(DurationVar);
      let effectiveDurationToUse;

      if (durationResolution === durationFormula.formulaId) {
        const proposedOrPreviousStartDate = this.$.startDate.getProposedOrPreviousValue();
        const proposedOrPreviousEndDate = this.$.endDate.getProposedOrPreviousValue();

        if (proposedOrPreviousStartDate && proposedOrPreviousEndDate || !proposedOrPreviousStartDate && !proposedOrPreviousEndDate) {
          effectiveDurationToUse = yield* super.calculateEffectiveDuration();
        } else if (proposedOrPreviousStartDate) {
          effectiveDurationToUse = yield* this.calculateProjectedDuration(proposedOrPreviousStartDate, yield* this.calculateProjectedXDateByEffort(proposedOrPreviousStartDate, true));
        } else {
          effectiveDurationToUse = yield* this.calculateProjectedDuration(yield* this.calculateProjectedXDateByEffort(proposedOrPreviousEndDate, false), proposedOrPreviousEndDate);
        }
      } else effectiveDurationToUse = yield* super.calculateEffectiveDuration();

      return effectiveDurationToUse;
    }

    * calculateSchedulingMode() {
      return this.$.schedulingMode.getProposedOrPreviousValue() || SchedulingMode.Normal;
    }

  }

  __decorate$f([model_field({
    'type': 'boolean',
    defaultValue: false
  })], HasSchedulingMode.prototype, "effortDriven", void 0);

  __decorate$f([model_field({
    type: 'string',
    defaultValue: SchedulingMode.Normal
  })], HasSchedulingMode.prototype, "schedulingMode", void 0);

  __decorate$f([field({
    atomCls: SEDWUDispatcherIdentifier
  })], HasSchedulingMode.prototype, "dispatcher", void 0);

  __decorate$f([calculate('effort')], HasSchedulingMode.prototype, "calculateEffort", null);

  __decorate$f([calculate('startDate')], HasSchedulingMode.prototype, "calculateStartDate", null);

  __decorate$f([calculate('endDate')], HasSchedulingMode.prototype, "calculateEndDate", null);

  __decorate$f([calculate('schedulingMode')], HasSchedulingMode.prototype, "calculateSchedulingMode", null);

  return HasSchedulingMode;
};

const fixedDurationSEDWUGraphDescription = CycleDescription.new({
  variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: new Set([startDateFormula, endDateFormula, durationFormula, unitsFormula, effortFormula])
});
const fixedDurationSEDWUForwardNonEffortDriven = CycleResolution.new({
  description: fixedDurationSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([endDateFormula, effortFormula])
});
const fixedDurationSEDWUForwardEffortDriven = CycleResolution.new({
  description: fixedDurationSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([endDateFormula, unitsFormula])
});
const fixedDurationSEDWUBackwardNonEffortDriven = CycleResolution.new({
  description: fixedDurationSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([startDateFormula, effortFormula])
});
const fixedDurationSEDWUBackwardEffortDriven = CycleResolution.new({
  description: fixedDurationSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([startDateFormula, unitsFormula])
});

const FixedDurationMixin = base => {
  class FixedDurationMixin extends base {
    * prepareDispatcher() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedDuration) {
        const cycleDispatcher = yield* super.prepareDispatcher();
        const effortDriven = yield this.$.effortDriven;

        if (effortDriven) {
          cycleDispatcher.addKeepIfPossibleFlag(EffortVar);
        }

        if (this.hasAssignmentChanges()) {
          const effortDriven = yield this.$.effortDriven;

          if (effortDriven) {
            cycleDispatcher.addProposedValueFlag(EffortVar);
          } else {
            cycleDispatcher.addProposedValueFlag(UnitsVar);
          }
        }

        return cycleDispatcher;
      } else {
        return yield* super.prepareDispatcher();
      }
    }

    * cycleResolutionContext() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedDuration) {
        const direction = yield this.$.direction;
        const effortDriven = yield this.$.effortDriven;

        if (direction === Direction.Forward || direction === Direction.None) {
          return effortDriven ? fixedDurationSEDWUForwardEffortDriven : fixedDurationSEDWUForwardNonEffortDriven;
        } else {
          return effortDriven ? fixedDurationSEDWUBackwardEffortDriven : fixedDurationSEDWUBackwardNonEffortDriven;
        }
      } else {
        return yield* super.cycleResolutionContext();
      }
    }

    * getBaseOptionsForDurationCalculations() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedDuration) {
        return {
          ignoreResourceCalendars: true
        };
      } else {
        return yield* super.getBaseOptionsForDurationCalculations();
      }
    }

  }

  return FixedDurationMixin;
};

const fixedEffortSEDWUGraphDescription = CycleDescription.new({
  variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: new Set([endDateByEffortFormula, durationFormula, unitsFormula, effortFormula, startDateByEffortFormula, startDateFormula, endDateFormula])
});
const fixedEffortSEDWUForward = CycleResolution.new({
  description: fixedEffortSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([endDateByEffortFormula, durationFormula])
});
const fixedEffortSEDWUBackward = CycleResolution.new({
  description: fixedEffortSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([startDateByEffortFormula, durationFormula])
});

const FixedEffortMixin = base => {
  class FixedEffortMixin extends base {
    * prepareDispatcher() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedEffort) {
        const cycleDispatcher = yield* super.prepareDispatcher();
        if (this.hasAssignmentChanges()) cycleDispatcher.addProposedValueFlag(UnitsVar);
        cycleDispatcher.addKeepIfPossibleFlag(EffortVar);
        return cycleDispatcher;
      } else {
        return yield* super.prepareDispatcher();
      }
    }

    * cycleResolutionContext() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedEffort) {
        const direction = yield this.$.direction;
        return direction === Direction.Forward || direction === Direction.None ? fixedEffortSEDWUForward : fixedEffortSEDWUBackward;
      } else {
        return yield* super.cycleResolutionContext();
      }
    }

  }

  return FixedEffortMixin;
};

const fixedUnitsSEDWUGraphDescription = CycleDescription.new({
  variables: new Set([StartDateVar, EndDateVar, DurationVar, EffortVar, UnitsVar]),
  formulas: new Set([endDateByEffortFormula, durationFormula, effortFormula, unitsFormula, startDateByEffortFormula, startDateFormula, endDateFormula])
});
const fixedUnitsSEDWUForwardNonEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([endDateByEffortFormula, endDateFormula, effortFormula])
});
const fixedUnitsSEDWUForwardEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([endDateByEffortFormula, endDateFormula, durationFormula])
});
const fixedUnitsSEDWUBackwardNonEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([startDateByEffortFormula, startDateFormula, effortFormula])
});
const fixedUnitsSEDWUBackwardEffortDriven = CycleResolution.new({
  description: fixedUnitsSEDWUGraphDescription,
  defaultResolutionFormulas: new Set([startDateByEffortFormula, startDateFormula, durationFormula])
});

const FixedUnitsMixin = base => {
  class FixedUnitsMixin extends base {
    * prepareDispatcher() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedUnits) {
        const cycleDispatcher = yield* super.prepareDispatcher();
        if (this.hasAssignmentChanges()) cycleDispatcher.addProposedValueFlag(UnitsVar);
        if (yield this.$.effortDriven) cycleDispatcher.addKeepIfPossibleFlag(EffortVar);
        cycleDispatcher.addKeepIfPossibleFlag(UnitsVar);
        return cycleDispatcher;
      } else {
        return yield* super.prepareDispatcher();
      }
    }

    * cycleResolutionContext() {
      const schedulingMode = yield this.$.schedulingMode;

      if (schedulingMode === SchedulingMode.FixedUnits) {
        const direction = yield this.$.direction;
        const effortDriven = yield this.$.effortDriven;

        if (direction === Direction.Forward || direction === Direction.None) {
          return effortDriven ? fixedUnitsSEDWUForwardEffortDriven : fixedUnitsSEDWUForwardNonEffortDriven;
        } else {
          return effortDriven ? fixedUnitsSEDWUBackwardEffortDriven : fixedUnitsSEDWUBackwardNonEffortDriven;
        }
      } else {
        return yield* super.cycleResolutionContext();
      }
    }

  }

  return FixedUnitsMixin;
};

const BuildGanttEvent = (base = Model) => HasDateConstraint(FixedUnitsMixin(FixedEffortMixin(FixedDurationMixin(HasSchedulingMode(HasEffort(HasAssignments(HasPercentDone(HasDependencies(ConstrainedLateEvent(HasChildren(ConstrainedEvent(EventMixin(HasCalendarMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(base))))))))))))))))));

class GanttEvent extends BuildGanttEvent(Model) {
}

const ChronoStoreMixin = base => class ChronoStoreMixin extends base {
};

const EventStoreMixin$1 = base => {
  class EventStoreMixin extends base {
    static get defaultConfig() {
      return {
        tree: true,
        modelClass: GanttEvent
      };
    }

    buildRootNode() {
      return this.getProject() || {};
    }

  }

  return EventStoreMixin;
};
const BuildMinimalEventStore = (base = Store) => EventStoreMixin$1(PartOfProjectStoreMixin(PartOfProjectGenericMixin(ChronoStoreMixin(base))));

class MinimalEventStore extends BuildMinimalEventStore() {
}


class TaskStore extends PartOfProject(BuildMinimalEventStore(EventStoreMixin(AjaxStore))) {

  static get defaultConfig() {
    return {
      tree: true,
      modelClass: ProTaskModel,


      loadPriority: 200,


      syncPriority: 300,
      storeId: 'tasks'
    };
  }


  updateIdMap() {

    super.updateIdMap();
  }

  getEvents(id) {
    const task = this.getById(id);
    return task && [task];
  }

  getEventsForResource(resourceId) {
    const resource = this.resourceStore.getById(resourceId),
      assignments = resource && resource.assignments.filter(assignment => assignment.isPartOfStore(this.assignmentStore)) || [];

    return [...assignments].map(r => r.event);
  }

  getResourcesForEvent(task) {
    return task.assignments.map(a => a.resource);
  }

}

TaskStore._$name = 'TaskStore';

const DependencyStoreBaseMixin = base => {
  class DependencyStoreBaseMixin extends base {
    static get defaultConfig() {
      return {
        modelClass: MinimalDependency
      };
    }

  }

  return DependencyStoreBaseMixin;
};

const hasMixin$6 = Symbol('DependencyValidationMixin');
const DependencyValidationMixin = base => {
  class DependencyValidationMixin extends base {
    [hasMixin$6]() {
    }

    async isValidDependency(dependency, toId, depType) {
      const me = this,
        project = me.getProject();
      console.assert(!hasDependencyMixin(dependency) || dependency.getProject() != project, 'Can\'t validate dependency, the dependency given is already a part of this project, validation can be done only on depepdencies which are not joined yet!');
      await project.waitForPropagateCompleted();

      const effectHandler = async effect => {
        let result;

        if (effect instanceof GraphCycleDetectedEffect) {
          result = EffectResolutionResult.Cancel;
        } else {
          result = EffectResolutionResult.Resume;
        }

        return result;
      };

      if (!hasDependencyMixin(dependency)) {
        const eventStore = me.getEventStore(),
          dependencyClass = me.getDependencyStore().modelClass;

        if (typeof dependency == 'object') {
          dependency = new dependencyClass(dependency);
        } else {
          dependency = new dependencyClass({
            fromEvent: eventStore.getById(dependency),
            toEvent: eventStore.getById(toId),
            type: depType
          });
        }
      }

      const oldProject = dependency.getProject();
      dependency.setProject(project);
      let result = await project.tryPropagateWithEntities(effectHandler, [dependency]);
      dependency.setProject(oldProject);
      return result == PropagationResult.Passed;
    }

  }

  return DependencyValidationMixin;
};

const DependencyStoreMixin = base => {
  class DependencyStoreMixin extends base {
  }

  return DependencyStoreMixin;
};
const BuildMinimalDependencyStore = (base = Store) => DependencyStoreMixin(DependencyValidationMixin(DependencyStoreBaseMixin(PartOfProjectStoreMixin(PartOfProjectGenericMixin(ChronoStoreMixin(base))))));

class MinimalDependencyStore extends BuildMinimalDependencyStore() {
}


class DependencyStore$1 extends PartOfProject(BuildMinimalDependencyStore(DependencyStore)) {

  static get defaultConfig() {
    return {
      modelClass: ProDependencyModel,


      loadPriority: 300,


      syncPriority: 500
    };
  }


  reduceTaskDependencies(task, reduceFn, result, flat, depsGetterFn) {
    return this.reduceEventDependencies(task, reduceFn, result, flat, depsGetterFn);
  }

  reduceTaskPredecessors(task, reduceFn, result, flat) {
    return this.reduceEventPredecessors(task, reduceFn, result, flat);
  }

  reduceTaskSuccessors(task, reduceFn, result, flat) {
    return this.reduceEventSuccessors(task, reduceFn, result, flat);
  }

  mapTaskDependencies(task, fn, filterFn, flat, depsGetterFn) {
    return this.mapEventDependencies(task, fn, filterFn, flat, depsGetterFn);
  }

  mapTaskPredecessors(task, fn, filterFn, flat) {
    return this.mapEventPredecessors(task, fn, filterFn, flat);
  }

  mapTaskSuccessors(task, fn, filterFn, flat) {
    return this.mapEventSuccessors(task, fn, filterFn, flat);
  }


  getTaskDependencies(task, flat) {
    return this.getEventDependencies(task, flat);
  }


  getTaskPredecessors(task, flat) {
    return this.getEventPredecessors(task, flat);
  }


  getTaskSuccessors(task, flat) {
    return this.getEventSuccessors(task, flat);
  }


  removeTaskDependencies(task, flat) {
    this.removeEventDependencies(task, flat);
  }


  removeTaskPredecessors(task, flat) {
    this.removeEventPredecessors(task, flat);
  }


  removeTaskSuccessors(task, flat) {
    this.removeEventSuccessors(task, flat);
  }


  getDependencyForSourceAndTargetTasks(sourceTask, targetTask) {
    return this.getDependencyForSourceAndTargetEvents(sourceTask, targetTask);
  }


  getTasksLinkingDependency(sourceEvent, targetEvent) {
    return this.getEventsLinkingDependency(sourceEvent, targetEvent);
  }

  async isValidDependencyToCreate(fromId, toId, type) {
    const isValid = await this.isValidDependency(fromId, toId, type),
      linked = Boolean(this.getDependencyForSourceAndTargetEvents(fromId, toId));
    return isValid && !linked;
  }

  getTaskById(id) {
    const taskStore = this.taskStore;
    return taskStore && taskStore.getById(id) || null;
  }


  getSourceTask(dependency) {
    const id = dependency instanceof ProDependencyModel ? dependency.sourceId : dependency;
    return this.getTaskById(id);
  }


  getTargetTask(dependency) {
    const id = dependency instanceof ProDependencyModel ? dependency.targetId : dependency;
    return this.getTaskById(id);
  }

}

DependencyStore$1._$name = 'DependencyStore';

var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$7 = Symbol('ResourceMixin');
const ResourceMixin = base => {
  class ResourceMixin extends base {
    [hasMixin$7]() {
    }

    get assignments() {
      return [...this.assigned];
    }

    leaveProject() {
      const assignmentStore = this.getAssignmentStore();
      this.assigned.forEach(assignment => assignmentStore.remove(assignment));
      super.leaveProject();
    }

  }

  __decorate$g([model_field({
    type: 'string'
  })], ResourceMixin.prototype, "name", void 0);

  __decorate$g([generic_field({}, ModelBucketField)], ResourceMixin.prototype, "assigned", void 0);

  return ResourceMixin;
};
const BuildMinimalResource = (base = Model) => ResourceMixin(HasCalendarMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(base))))));

class MinimalResource extends BuildMinimalResource() {
}


class ResourceModel$1 extends PartOfProject(BuildMinimalResource(ResourceModel)) {

  static get fields() {
    return [];
  }


  get tasks() {
    return this.events;
  }

}

ResourceModel$1._$name = 'ResourceModel';

const ResourceStoreMixin$1 = base => {
  class ResourceStoreMixin extends base {
    static get defaultConfig() {
      return {
        modelClass: MinimalResource
      };
    }

  }

  return ResourceStoreMixin;
};
const BuildMinimalResourceStore = (base = Store) => ResourceStoreMixin$1(PartOfProjectStoreMixin(PartOfProjectGenericMixin(ChronoStoreMixin(base))));

class MinimalResourceStore extends BuildMinimalResourceStore() {
}


class ResourceStore$1 extends PartOfProject(BuildMinimalResourceStore(ResourceStore)) {

  static get defaultConfig() {
    return {
      modelClass: ResourceModel$1,


      loadPriority: 400,


      syncPriority: 200,
      storeId: 'resources'
    };
  }

}

ResourceStore$1._$name = 'ResourceStore';

var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const hasMixin$8 = Symbol('AssignmentMixin');
const AssignmentMixin = base => {
  class AssignmentMixin extends base {
    [hasMixin$8]() {
    }

    getUnits() {
      return this.units;
    }

    setUnits(units) {
      this.putUnits(units);
      return this.propagate();
    }

    putUnits(units) {
      this.$.units.put(units);
      const event = this.event;

      if (event && this.getGraph()) {
        event.markAsNeedRecalculation(event.$.dispatcher);
        event.markAsNeedRecalculation(event.$.startDate);
        event.markAsNeedRecalculation(event.$.endDate);
        event.markAsNeedRecalculation(event.$.duration);
        event.markAsNeedRecalculation(event.$.effort);
        event.assigned.forEach(assignment => assignment.markAsNeedRecalculation(assignment.$.units));
      }
    }

    * calculateUnits(proposedValue) {
      const event = yield this.$.event;
      if (event && event.calculateAssignmentUnits) return yield* event.calculateAssignmentUnits(this, proposedValue);
      return proposedValue !== undefined ? proposedValue : this.$.units.getConsistentValue();
    }

  }

  __decorate$h([model_field({
    type: 'number',
    defaultValue: 100
  })], AssignmentMixin.prototype, "units", void 0);

  __decorate$h([generic_field({
    bucket: 'assigned',
    resolver: function (id) {
      return this.getEventById(id);
    },
    modelFieldConfig: {
      serialize: event => event.id
    }
  }, ModelReferenceField)], AssignmentMixin.prototype, "event", void 0);

  __decorate$h([generic_field({
    bucket: 'assigned',
    resolver: function (id) {
      return this.getResourceById(id);
    },
    modelFieldConfig: {
      serialize: resource => resource.id
    }
  }, ModelReferenceField)], AssignmentMixin.prototype, "resource", void 0);

  __decorate$h([calculate('units')], AssignmentMixin.prototype, "calculateUnits", null);

  return AssignmentMixin;
};
const BuildMinimalAssignment = (base = Model) => AssignmentMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(base)))));

class MinimalAssignment extends BuildMinimalAssignment() {
}


class AssignmentModel$1 extends PartOfProject(BuildMinimalAssignment(AssignmentModel)) {

  static get fields() {
    return [


      {
        name: 'eventId',
        persist: false
      },


      {
        name: 'resourceId',
        persist: false
      }

    ];
  }

  get units() {
    const me = this;
    return Math.max(0, me.get('units'));
  }

  set units(value) {
    if (value < 0) {
      throw new Error("`Units` value for an assignment can't be less than 0");
    }

    this.set('units', value);
  }


  get task() {
    return this.event;
  }

  set task(task) {
    this.event = task;
  }


  get taskName() {
    return this.task && this.task.name || '';
  }


  get eventId() {
    return this.event.id;
  }

  get resourceId() {
    return this.resource.id;
  }

  toString() {
    return this.resource.name + ' ' + this.units + '%';
  }

}

AssignmentModel$1._$name = 'AssignmentModel';

const AssignmentStoreMixin = base => {
  class AssignmentStoreMixin extends base {
    static get defaultConfig() {
      return {
        modelClass: MinimalAssignment
      };
    }

  }

  return AssignmentStoreMixin;
};
const BuildMinimalAssignmentStore = (base = Store) => AssignmentStoreMixin(PartOfProjectStoreMixin(PartOfProjectGenericMixin(ChronoStoreMixin(base))));

class MinimalAssignmentStore extends BuildMinimalAssignmentStore() {
}


class AssignmentStore$1 extends PartOfProject(BuildMinimalAssignmentStore(AssignmentStore)) {

  static get defaultConfig() {
    return {
      modelClass: AssignmentModel$1,


      loadPriority: 500,


      syncPriority: 400,
      storeId: 'assignments'
    };
  }


  mapAssignmentsForTask(task, fn, filterFn) {
    return this.mapAssignmentsForEvent(task, fn, filterFn);
  }


  getAssignmentsForTask(task) {
    return this.getAssignmentsForEvent(task);
  }


  removeAssignmentsForTask(task) {
    return this.removeAssignmentsForEvent(task);
  }


  getResourcesForTask(task) {
    return this.getResourcesForEvent(task);
  }


  getTasksForResource(resource) {
    return this.getEventsForResource(resource);
  }


  assignTaskToResource(task, resource, units) {
    return this.assignEventToResource(task, resource, assignment => {
      assignment.units = units;
      return assignment;
    });
  }


  unassignTaskFromResource(task, resource) {
    return this.unassignEventFromResource(task, resource);
  }


  isTaskAssignedToResource(task, resource, fn) {
    return this.isEventAssignedToResource(task, resource, fn);
  }


  getAssignmentForTaskAndResource(task, resource) {
    return this.getAssignmentForEventAndResource(task, resource);
  }

}

AssignmentStore$1._$name = 'AssignmentStore';

const CalendarManagerStoreMixin = base => {
  return class CalendarManagerStoreMixin extends base {
    static get defaultConfig() {
      return {
        tree: true,
        modelClass: MinimalCalendar
      };
    }

  };
};
const BuildMinimalCalendarManagerStore = (base = Store) => CalendarManagerStoreMixin(PartOfProjectStoreMixin(PartOfProjectGenericMixin(ChronoStoreMixin(base))));

class MinimalCalendarManagerStore extends BuildMinimalCalendarManagerStore() {
}


class CalendarManagerStore extends PartOfProject(BuildMinimalCalendarManagerStore(AjaxStore)) {
  static get defaultConfig() {
    return {
      tree: true,
      modelClass: ProCalendarModel,


      loadPriority: 100,


      syncPriority: 100,
      storeId: 'calendars'
    };
  }

}

CalendarManagerStore._$name = 'CalendarManagerStore';

class Schema extends Base$1 {
  constructor() {
    super(...arguments);
    this.entities = new Map();
  }

  hasEntity(name) {
    return this.entities.has(name);
  }

  getEntity(name) {
    return this.entities.get(name);
  }

  addEntity(entity) {
    const name = entity.name;
    if (!name) throw new Error(`Entity must have a name`);
    if (this.hasEntity(name)) throw new Error(`Entity with name [${String(name)}] already exists`);
    entity.schema = this;
    this.entities.set(name, entity);
    return entity;
  }

  getEntityDecorator() {
    return target => {
      const name = target.name;
      if (!name) throw new Error(`Can't add entity - the target class has no name`);
      let entity = ensureEntityOnPrototype(target.prototype);
      if (entity.name && entity.name != name) throw new Error(`Invalid state`);
      entity.name = name;
      this.addEntity(entity);
      return target;
    };
  }

}

const EngineReplica = base => class EngineReplica extends base {
  constructor() {
    super(...arguments);
    this.projectRefreshThreshold = 500;
  }

  async propagate(onEffect, dryRun = false) {
    const project = this.project;
    let result;

    if (!this.isPropagating) {
      project.trigger('propagationStart', {
        dryRun: !!dryRun
      });
      result = await super.propagate(onEffect, dryRun);
      project.trigger('propagationComplete', {
        dryRun: !!dryRun,
        result
      });
    } else {
      result = await super.propagate(onEffect, dryRun);
    }

    return result;
  }

  commit() {
    const project = this.project;
    const changedAtoms = this.changedAtoms;
    const records = new Set(changedAtoms.map(atom => atom.self));
    records.forEach(r => r.beginBatch());
    project.trigger('beforeCommit', {
      records,
      changedAtoms
    });
    super.commit();
    project.trigger('commit', {
      records,
      changedAtoms
    });
    const silent = records.size > this.projectRefreshThreshold;
    records.forEach(r => r.endBatch(silent));

    if (silent) {
      project.trigger('refresh', {
        records
      });
    }
  }

  async onEffect(effect) {
    const project = this.project;

    if (effect instanceof Conflict) {
      if (project.hasListener('schedulingconflict')) {
        return new Promise((resolve, reject) => {
          project.trigger('schedulingconflict', {
            conflict: effect,
            continueWithResolutionResult: resolve
          });
        });
      } else {
        return Promise.resolve(EffectResolutionResult.Cancel);
      }
    } else {
      return super.onEffect(effect);
    }
  }

};

var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const ProjectMixin = base => {
  class ProjectMixin extends base {
    construct(config = {}) {
      this.replica = EngineReplica(MinimalReplica).new({
        project: this,
        schema: Schema.new()
      });

      if (!config.hasOwnProperty('expanded')) {
        config.expanded = true;
      }

      const hasInlineStore = Boolean(config.calendarManagerStore || config.eventStore || config.dependencyStore || config.resourceStore || config.assignmentStore);
      super.construct(config);
      if (!this.eventModelClass) this.eventModelClass = this.getDefaultEventModelClass();
      if (!this.eventStoreClass) this.eventStoreClass = this.getDefaultEventStoreClass();
      if (!this.dependencyModelClass) this.dependencyModelClass = this.getDefaultDependencyModelClass();
      if (!this.dependencyStoreClass) this.dependencyStoreClass = this.getDefaultDependencyStoreClass();
      if (!this.resourceModelClass) this.resourceModelClass = this.getDefaultResourceModelClass();
      if (!this.resourceStoreClass) this.resourceStoreClass = this.getDefaultResourceStoreClass();
      if (!this.assignmentModelClass) this.assignmentModelClass = this.getDefaultAssignmentModelClass();
      if (!this.assignmentStoreClass) this.assignmentStoreClass = this.getDefaultAssignmentStoreClass();
      if (!this.calendarModelClass) this.calendarModelClass = this.getDefaultCalendarModelClass();
      if (!this.calendarManagerStoreClass) this.calendarManagerStoreClass = this.getDefaultCalendarManagerStoreClass();
      this.replica.addEntity(this);
      this.stm = new StateTrackingManager({
        disabled: true
      });
      this.stm.on({
        restoringStop: async () => {
          this.stm.disable();
          await this.propagate();
          this.stm.enable();
          this.trigger('stateRestoringDone');
        }
      });

      if (this.calendarManagerStore) {
        this.setCalendarManagerStore(this.calendarManagerStore);
      } else this.calendarManagerStore = new this.calendarManagerStoreClass({
        modelClass: this.calendarModelClass,
        project: this,
        stm: this.stm
      });

      this.defaultCalendar = new this.calendarManagerStore.modelClass({
        hoursPerDay: 24,
        daysPerWeek: 7,
        daysPerMonth: 30,
        unspecifiedTimeIsWorking: this.unspecifiedTimeIsWorking
      });
      this.defaultCalendar.project = this;

      if (this.eventStore) {
        this.setEventStore(this.eventStore);
      } else this.eventStore = new this.eventStoreClass({
        modelClass: this.eventModelClass,
        tree: true,
        project: this,
        stm: this.stm
      });

      if (this.dependencyStore) {
        this.setDependencyStore(this.dependencyStore);
      } else this.dependencyStore = new this.dependencyStoreClass({
        modelClass: this.dependencyModelClass,
        project: this,
        stm: this.stm
      });

      if (this.resourceStore) {
        this.setResourceStore(this.resourceStore);
      } else this.resourceStore = new this.resourceStoreClass({
        modelClass: this.resourceModelClass,
        project: this,
        stm: this.stm
      });

      if (this.assignmentStore) {
        this.setAssignmentStore(this.assignmentStore);
      } else this.assignmentStore = new this.assignmentStoreClass({
        modelClass: this.assignmentModelClass,
        project: this,
        stm: this.stm
      });

      const hasInlineData = Boolean(this.calendarsData || this.eventsData || this.dependenciesData || this.resourcesData || this.assignmentsData);

      if (hasInlineData) {
        this.loadInlineData({
          calendarsData: this.calendarsData,
          eventsData: this.eventsData,
          dependenciesData: this.dependenciesData,
          resourcesData: this.resourcesData,
          assignmentsData: this.assignmentsData
        });
        delete this.calendarsData;
        delete this.eventsData;
        delete this.dependenciesData;
        delete this.resourcesData;
        delete this.assignmentsData;
      }

      if (hasInlineStore && !hasInlineData) this.propagate();
    }

    getType() {
      return ProjectType.Unknown;
    }

    getDefaultEventModelClass() {
      return GanttEvent;
    }

    getDefaultEventStoreClass() {
      return MinimalEventStore;
    }

    getDefaultDependencyModelClass() {
      return MinimalDependency;
    }

    getDefaultDependencyStoreClass() {
      return MinimalDependencyStore;
    }

    getDefaultResourceModelClass() {
      return MinimalResource;
    }

    getDefaultResourceStoreClass() {
      return MinimalResourceStore;
    }

    getDefaultAssignmentModelClass() {
      return MinimalAssignment;
    }

    getDefaultAssignmentStoreClass() {
      return MinimalAssignmentStore;
    }

    getDefaultCalendarModelClass() {
      return MinimalCalendar;
    }

    getDefaultCalendarManagerStoreClass() {
      return MinimalCalendarManagerStore;
    }

    loadInlineData(data) {
      if (data.calendarsData) {
        this.calendarManagerStore.data = data.calendarsData;
      }

      if (data.eventsData) {
        this.eventStore.data = data.eventsData;
      }

      if (data.dependenciesData) {
        this.dependencyStore.data = data.dependenciesData;
      }

      if (data.resourcesData) {
        this.resourceStore.data = data.resourcesData;
      }

      if (data.assignmentsData) {
        this.assignmentStore.data = data.assignmentsData;
      }

      return this.propagate();
    }

    getGraph() {
      return this.replica;
    }

    getStm() {
      return this.stm;
    }

    calculateProject() {
      return this;
    }

    * calculateCalendar(proposedValue) {
      let result = yield* super.calculateCalendar(proposedValue);

      if (!result) {
        result = this.defaultCalendar;
        yield result.$$;
      }

      return result;
    }

    joinStoreRecords(store) {
      const fn = record => {
        record.setProject(this);
        record.joinProject();
      };

      if (store.rootNode) {
        store.rootNode.traverse(fn);
      } else {
        store.forEach(fn);
      }
    }

    setEventStore(store) {
      if (this.eventStore && this.stm.hasStore(this.eventStore)) {
        this.stm.removeStore(this.eventStore);
      }

      this.eventStore = store;

      if (store) {
        store.setProject(this);
        this.stm.addStore(store);

        if (store.rootNode !== this) {
          this.appendChild(store.rootNode.children || []);
          store.rootNode = this;
        }

        this.joinStoreRecords(store);
      }
    }

    setDependencyStore(store) {
      if (this.dependencyStore && this.stm.hasStore(this.dependencyStore)) {
        this.stm.removeStore(this.dependencyStore);
      }

      this.dependencyStore = store;

      if (store) {
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
    }

    setResourceStore(store) {
      if (this.resourceStore && this.stm.hasStore(this.resourceStore)) {
        this.stm.removeStore(this.resourceStore);
      }

      this.resourceStore = store;

      if (store) {
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
    }

    setAssignmentStore(store) {
      if (this.assignmentStore && this.stm.hasStore(this.assignmentStore)) {
        this.stm.removeStore(this.assignmentStore);
      }

      this.assignmentStore = store;

      if (store) {
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
    }

    setCalendarManagerStore(store) {
      if (this.calendarManagerStore && this.stm.hasStore(this.calendarManagerStore)) {
        this.stm.removeStore(this.calendarManagerStore);
      }

      this.calendarManagerStore = store;

      if (store) {
        store.setProject(this);
        this.stm.addStore(store);
        this.joinStoreRecords(store);
      }
    }

    async tryPropagateWithChanges(changerFn, onEffect) {
      const stm = this.stm;
      let stmInitiallyDisabled, stmInitiallyAutoRecord;

      const captureStm = () => {
        stmInitiallyDisabled = stm.disabled;
        stmInitiallyAutoRecord = stm.autoRecord;

        if (stmInitiallyDisabled) {
          stm.enable();
        } else {
          if (stmInitiallyAutoRecord) {
            stm.autoRecord = false;
          }

          if (stm.isRecording) {
            stm.stopTransaction();
          }
        }
      };

      const commitStmTransaction = () => {
        stm.stopTransaction();

        if (stmInitiallyDisabled) {
          stm.resetQueue();
        }
      };

      const rejectStmTransaction = () => {
        if (stm.transaction.length) {
          stm.forEachStore(s => s.beginBatch());
          stm.rejectTransaction();
          stm.forEachStore(s => s.endBatch());
        } else {
          stm.stopTransaction();
        }
      };

      const freeStm = () => {
        stm.disabled = stmInitiallyDisabled;
        stm.autoRecord = stmInitiallyAutoRecord;
      };

      captureStm();
      stm.startTransaction();
      this.suspendPropagate();
      changerFn();
      this.resumePropagate(false);
      const result = await this.propagate(onEffect || (effect => {
        let result;

        if (effect instanceof GraphCycleDetectedEffect) {
          result = EffectResolutionResult.Cancel;
        }

        return result;
      }));

      if (result === PropagationResult.Canceled) {
        rejectStmTransaction();
      } else {
        commitStmTransaction();
      }

      freeStm();
      return result;
    }

  }

  __decorate$i([model_field({
    type: 'boolean',
    defaultValue: true
  })], ProjectMixin.prototype, "unspecifiedTimeIsWorking", void 0);

  __decorate$i([model_field({
    type: 'string',
    defaultValue: DependenciesCalendar.ToEvent
  })], ProjectMixin.prototype, "dependenciesCalendar", void 0);

  __decorate$i([model_field({
    type: 'boolean',
    defaultValue: true
  })], ProjectMixin.prototype, "autoCalculatePercentDoneForParentTasks", void 0);

  return ProjectMixin;
};
const BuildMinimalProject = (base = Model) => ProjectMixin(HasEffort(HasAssignments(HasChildren(ConstrainedEvent(EventMixin(HasCalendarMixin(PartOfProjectMixin(PartOfProjectGenericMixin(ChronoModelMixin(Entity$1(Events(base))))))))))));

const SchedulerProjectMixin = base => {
  class SchedulerProjectMixin extends base {
  }

  return SchedulerProjectMixin;
};
const BuildMinimalSchedulerProject = (base = Model) => SchedulerProjectMixin(BuildMinimalProject(base));

class MinimalSchedulerProject extends BuildMinimalSchedulerProject() {
}


class ProProjectModel extends CrudManager$1(BuildMinimalSchedulerProject(Model)) {

  static get defaults() {
    return {


      expanded: true
    };
  }

  static get defaultConfig() {
    return {

      eventModelClass: null,


      taskModelClass: ProTaskModel,


      dependencyModelClass: ProDependencyModel,


      resourceModelClass: ResourceModel$1,


      assignmentModelClass: AssignmentModel$1,


      calendarModelClass: ProCalendarModel,


      eventStoreClass: null,


      taskStoreClass: TaskStore,


      dependencyStoreClass: DependencyStore$1,


      resourceStoreClass: ResourceStore$1,


      assignmentStoreClass: AssignmentStore$1,


      calendarManagerStoreClass: CalendarManagerStore,


      eventsData: null,


      tasksData: null,


      dependenciesData: null,


      resourcesData: null,


      assignmentsData: null,


      calendarsData: null,


      timeRangeStore: null,
      convertEmptyParentToLeaf: false
    };
  }


  construct(...args) {

    const config = args[0] || {};

    args[0] = config;

    if ('tasksData' in config) {
      config.eventsData = config.tasksData;
      delete config.tasksData;
    }

    if ('taskStore' in config) {
      config.eventStore = config.taskStore;
      delete config.taskStore;
    }


    config.eventModelClass = config.taskModelClass || config.eventModelClass || this.defaultEventModelClass;
    config.eventStoreClass = config.taskStoreClass || config.eventStoreClass || this.defaultEventStoreClass;

    if (!config.timeRangeStore) {
      config.timeRangeStore = {
        modelClass: TimeSpan,
        storeId: 'timeRanges'
      };
    }

    super.construct(...args);
  }

  get defaultEventModelClass() {
    return ProTaskModel;
  }

  get defaultEventStoreClass() {
    return TaskStore;
  }

  get taskStore() {
    return this.getEventStore();
  }

  get timeRangeStore() {
    return this._timeRangeStore;
  }

  set timeRangeStore(store) {
    const me = this;
    me._timeRangeStore = store && Store.getStore(store, Store);

    if (store && !me._timeRangeStore.storeId) {
      me._timeRangeStore.storeId = 'timeRanges';
    }
  }

}

ProProjectModel.applyConfigs = true;


ProProjectModel._$name = 'ProProjectModel';


var ProSchedulerStores = (Target => class ProSchedulerStores extends (Target || Base) {
  get project() {
    return this._project;
  }

  set project(project) {
    Object.assign(this, {
      _project: project,

      store: this.resourcesStore,
      resourceStore: project.getResourceStore(),
      eventStore: project.getEventStore(),
      assignmentStore: project.getAssignmentStore(),
      dependencyStore: project.getDependencyStore(),
      taskStore: project.getEventStore()
    });
  }

  onBeforeAssignmentRemove(event) {
    event.doRemoveLastEvent = false;
    super.onBeforeAssignmentRemove(event);
  }


  get widgetClass() {
  }

});


var ProTaskEditStm = (Target => class TaskEditStm extends (Target || Base) {
  getProject() {
    let result;

    if (super.getProject) {
      result = super.getProject();
    } else {
      throw new Error('Abstract method call!');
    }

    return result;
  }

  captureStm() {
    const me = this,
      project = me.getProject(),
      stm = project.getStm();
    me.stmInitiallyDisabled = stm.disabled;
    me.stmInitiallyAutoRecord = stm.autoRecord;

    if (me.stmInitiallyDisabled) {
      stm.enable();


      stm.autoRecord = false;
    } else {
      if (me.stmInitiallyAutoRecord) {
        stm.autoRecord = false;
      }

      if (stm.isRecording) {
        stm.stopTransaction();
      }
    }
  }

  startStmTransaction() {

    this.getProject().getStm().startTransaction();
  }

  commitStmTransaction() {
    const me = this,
      stm = me.getProject().getStm();
    stm.stopTransaction();

    if (me.stmInitiallyDisabled) {
      stm.resetQueue();
    }
  }

  rejectStmTransaction() {
    const stm = this.getProject().getStm(),
      {
        client
      } = this;

    if (stm.transaction.length) {
      client.suspendRefresh();
      stm.forEachStore(s => s.beginBatch());
      stm.rejectTransaction();
      stm.forEachStore(s => s.endBatch());
      client.resumeRefresh(true);
    } else {
      stm.stopTransaction();
    }
  }

  enableStm() {
    this.getProject().getStm().enable();
  }

  disableStm() {
    this.getProject().getStm().disable();
  }

  freeStm() {
    const me = this,
      stm = me.getProject().getStm();
    stm.disabled = me.stmInitiallyDisabled;
    stm.autoRecord = me.stmInitiallyAutoRecord;
  }

});


class SchedulerTaskEditor extends TaskEditorBase {
  static get $name() {
    return 'SchedulerTaskEditor';
  }

  static get defaultConfig() {
    return {
      items: [{
        type: 'tabpanel',
        ref: 'tabs',
        flex: '1 0 100%',
        layoutConfig: {
          alignItems: 'stretch',
          alignContent: 'stretch'
        }
      }],
      defaultTabs: [{
        type: 'schedulergeneraltab'
      }, {
        type: 'successorstab'
      }, {
        type: 'predecessorstab'
      }, {
        type: 'resourcestab'
      }, {
        type: 'notestab'
      }]
    };
  }

}

SchedulerTaskEditor._$name = 'SchedulerTaskEditor';


class ProTaskEdit extends base(InstancePlugin).mixes(Delayable, ProTaskEditStm) {
  static get pluginConfig() {
    return {
      chain: ['getEventMenuItems', 'onEnterKey'],
      assign: ['editEvent']
    };
  }

  static get defaultConfig() {
    return {

      triggerEvent: 'eventdblclick',


      editorClassMap: {
        [ProjectType.Unknown]: SchedulerTaskEditor,
        [ProjectType.Gantt]: GanttTaskEditor,
        [ProjectType.Scheduler]: SchedulerTaskEditor
      },


      editorClass: null,


      editorConfig: null,


      showDeleteButton: true,


      saveAndCloseOnEnter: true,


      tabsConfig: null
    };
  }

  construct(scheduler, config) {
    const me = this;
    scheduler.taskEdit = me;
    super.construct(scheduler, config);
    me._clientListenersDetacher = scheduler.on({
      [me.triggerEvent]: me.onActivateEditor,
      thisObj: me
    });
  }

  get scheduler() {
    return this.client;
  }

  getProject() {
    return this.scheduler.project;
  }

  doDestroy() {
    const me = this;

    me._clientListenersDetacher();

    me.detachFromProject();
    me.editor && me.editor.destroy();
    super.doDestroy();
  }

  get isEditing() {
    return !!this._editing;
  }

  onActivateEditor({
                     eventRecord,
                     resourceRecord
                   }) {
    this.editEvent(eventRecord, resourceRecord);
  }

  getElementFromTaskRecord(taskRecord, resourceRecord) {
    return this.client.getElementFromEventRecord(taskRecord, resourceRecord);
  }


  async editEvent(taskRecord, resourceRecord = null, element = null) {
    const me = this,
      scheduler = me.scheduler;

    if (!scheduler.readOnly && !me.disabled) {
      const partner = me.client.partner;

      if (partner && (partner.editEvent || partner.editTask)) {
        (partner.editEvent || partner.editTask)(taskRecord, resourceRecord, element);
      } else {
        const doScrollIntoView = !element;
        me._editing = true;
        me.captureStm();
        me.startStmTransaction();

        me.schedulerAutoCommit = scheduler.taskStore.autoCommit;
        scheduler.taskStore.autoCommit = false;

        me.schedulerAutoSync = scheduler.project.autoSync;
        scheduler.project.autoSync = false;

        if (typeof taskRecord === 'function') {
          taskRecord = taskRecord();
        }

        if (doScrollIntoView && scheduler.taskStore.includes(taskRecord)) {
          await me.scrollEventIntoView(taskRecord, resourceRecord);
        }

        const taskElement = element || DomHelper.down(me.getElementFromTaskRecord(taskRecord, resourceRecord), scheduler.eventInnerSelector),
          editor = me.getEditor(taskRecord);


        if (false !== scheduler.trigger('beforeTaskEdit', {
          taskEdit: me,
          taskRecord,
          taskElement
        })) {


          scheduler.element.classList.add('b-taskeditor-editing');


          scheduler.trigger('beforeTaskEditShow', {
            taskEdit: me,
            taskRecord,
            taskElement,
            editor
          });
          me.load(taskRecord);
          me.attachToProject();

          if (taskElement) {
            await editor.showBy({
              target: taskElement,
              anchor: true,
              offset: -5
            });
          } else {

            await editor.showBy({
              target: scheduler.element,
              anchor: false,

              align: 'c-c'
            });
          }
        } else {
          me.rejectStmTransaction();
          me.disableStm();
          me.freeStm();
          me._editing = false;
        }
      }
    }
  }

  getEditor(taskRecord = this.record) {
    const me = this,
      project = taskRecord && taskRecord.getProject() || this.getProject(),
      projectType = project.getType(),
      editorClass = me.editorClass || me.editorClassMap[projectType] || me.editorClassMap[ProjectType.Unknown] || SchedulerTaskEditor;

    if (!me.editor || me.editor.constructor !== editorClass) {
      me.editor && me.editor.destroy();
      me.editor = new editorClass(ObjectHelper.merge({
        showDeleteButton: me.showDeleteButton,
        owner: me.client,
        project: me.getProject(),
        durationDisplayPrecision: me.client.durationDisplayPrecision,
        tabsConfig: me.tabsConfig,
        listeners: {
          cancel: me.onCancel,
          delete: me.onDelete,
          save: me.onSave,
          beforehide: me.onBeforeHide,
          requestPropagation: me.onRequestPropagation,
          thisObj: me
        }
      }, me.editorConfig));
    }

    return me.editor;
  }

  load(taskRecord) {
    const me = this,
      editor = me.getEditor(taskRecord);
    me._loading = true;
    me.record = taskRecord;
    editor.loadEvent(taskRecord);
    me._loading = false;
  }

  async save() {
    const me = this,
      {
        scheduler
      } = me;

    if (me._editing) {
      const editor = me.getEditor();


      if (!me.isValid || scheduler.trigger('beforeTaskSave', {
        taskRecord: me.record,
        editor: editor
      }) === false) {
        return;
      }

      me.detachFromProject();
      const project = me.getProject();

      if (project.isPropagating()) {
        await project.waitForPropagateCompleted();
      }

      editor.beforeSave();
      me.commitStmTransaction();
      me.freeStm();

      editor.hide().then(() => editor.afterSave());
      me.resumeAutoSync(true);
      scheduler.element.classList.remove('b-taskeditor-editing');
      me._editing = false;
    }
  }

  async cancel() {
    const me = this,
      {
        scheduler
      } = me;

    if (me._editing) {
      me._canceling = true;
      me.detachFromProject();
      const taskRecord = me.record;
      const project = me.getProject();

      if (project.isPropagating()) {
        await project.waitForPropagateCompleted();
      }

      const editor = me.getEditor();
      editor.beforeCancel();
      await editor.hide();
      me.rejectStmTransaction();
      me.disableStm();
      await project.propagate();
      me.freeStm();
      editor.afterCancel();
      me.resumeAutoSync(false);
      me.scheduler.element.classList.remove('b-taskeditor-editing');
      me._canceling = false;
      me._editing = false;
      scheduler.trigger('taskEditCanceled', {
        taskRecord,
        editor
      });
    }
  }

  async delete() {
    const me = this,
      editor = me.getEditor();


    if (me.scheduler.trigger('beforeTaskDelete', {
      taskRecord: me.record,
      editor
    }) === false) {
      return;
    }

    const project = me.getProject();

    if (project.isPropagating()) {
      await project.waitForPropagateCompleted();
    }

    me.detachFromProject();
    editor.beforeDelete();
    me.record.remove();
    me.freeStm();
    await project.propagate();
    me.resumeAutoSync(true);
    editor.hide();
    editor.afterDelete();
    me.scheduler.element.classList.remove('b-taskeditor-editing');
    me._editing = false;
  }

  resumeAutoSync(commit) {
    const me = this,
      {
        scheduler
      } = me;
    scheduler.taskStore.autoCommit = me.schedulerAutoCommit;

    if (scheduler.taskStore.autoCommit && commit) {
      scheduler.taskStore.commit();
    }

    scheduler.project.autoSync = me.schedulerAutoSync;

    if (scheduler.project.autoSync && commit) {
      scheduler.project.sync();
    }
  }

  onSave() {


    this.requestAnimationFrame(() => this.save());
  }

  onCancel() {


    this.requestAnimationFrame(() => this.cancel());
  }

  onDelete() {


    this.requestAnimationFrame(() => this.delete());
  }

  onRequestPropagation() {
    const project = this.getProject();


    this.requestAnimationFrame(() => {
      if (!project.isPropagating()) {
        project.propagate();
      }
    });
  }

  onBeforeHide() {
    const resourcesTab = this.editor.items[0].widgetMap.resourcestab;

    if (resourcesTab) {
      resourcesTab.pruneInvalidAssignments();
    }
  }

  attachToProject() {
    const me = this,
      project = me.getProject();
    me.detachFromProject();
    me._projectEventDetacher = project.on({
      loadstart: () => me.save(),
      propagationStart: me.onPropagationStart,
      propagationComplete: me.onPropagationComplete,
      thisObj: me,
      detachable: true
    });
  }

  detachFromProject() {
    if (this._projectEventDetacher) {
      this._projectEventDetacher();

      this._projectEventDetacher = null;
    }
  }

  onPropagationStart() {
    const editor = this.getEditor();
    editor.mask('Calculating');
  }

  onPropagationComplete({
                          dryRun
                        }) {
    const me = this;
    me.getEditor().unmask();

    if (me.isEditing && !me.getProject().taskStore.includes(me.record)) {
      me.save();
    } else if (!dryRun && !me._canceling) {
      me.load(me.record);
    }
  }

  getEventMenuItems({
                      eventRecord,
                      resourceRecord,
                      items
                    }) {
    if (!this.scheduler.readOnly) {
      items.editEvent = {
        text: this.L('Edit event'),
        icon: 'b-icon b-icon-edit',
        weight: -200,
        disabled: this.disabled,
        onItem: () => this.editEvent(eventRecord, resourceRecord)
      };
    }
  }


  onEnterKey({
               assignmentRecord,
               eventRecord
             }) {
    if (assignmentRecord) {
      this.editEvent(eventRecord, assignmentRecord.resource);
    } else if (eventRecord) {
      this.editEvent(eventRecord, eventRecord.resource);
    }
  }

  scrollEventIntoView(eventRecord, resourceRecord) {
    this.client.scrollResourceEventIntoView(resourceRecord, eventRecord);
  }

  get isValid() {
    const me = this;
    return me.editor.eachWidget(widget => {
      if (widget.isValid === true || widget.hidden || widget.disabled || widget instanceof Field && !widget.name) {
        return true;
      }

      return widget.isValid !== false;
    }, true);
  }

}

ProTaskEdit._$name = 'ProTaskEdit';
GridFeatureManager.registerFeature(ProTaskEdit, true, 'ProScheduler', 'EventEdit');


const locale$4 =  locale_zh.locale$4
 
for (const i in locale$3) {
  locale$4[i] = locale$3[i];
}
LocaleManagerSingelton.registerLocale('En', {
  desc: 'English',
  locale: locale$4
});


class ProScheduler extends ProDataAPI(ProSchedulerStores(CrudManagerView(Scheduler))) {
  static get $name() {
    return 'ProScheduler';
  }

  static get type() {
    return 'schedulerpro';
  }

  static get defaultConfig() {
    return {

      project: null,


      durationDisplayPrecision: 1,

      calendars: null,
      resources: null,
      tasks: null,
      dependencies: null,
      assignments: null,
      features: {
        dependencies: true,
        eventEdit: true
      }
    };
  }

  construct(config) {
    const me = this,
      hasInlineStores = Boolean(config.calendars || config.taskStore || config.dependencyStore || config.resourceStore || config.assignmentStore),
      hasInlineData = Boolean(config.calendars || config.tasks || config.dependencies || config.resources || config.assignments);
    let project = config.project;

    if (project && (hasInlineStores || hasInlineData)) {
      throw new Error('Providing both project and inline data is not supported');
    }

    if (!project) {
      project = config.project = new ProProjectModel({
        calendarsData: config.calendars,
        eventsData: config.tasks,
        dependenciesData: config.dependencies,
        resourcesData: config.resources,
        assignmentsData: config.assignments,
        resourceStore: config.resourceStore,
        eventStore: config.taskStore,
        assignmentStore: config.assignmentStore,
        dependencyStore: config.dependencyStore,
        timeRangeStore: config.timeRangeStore
      });
      delete config.resourceStore;
      delete config.taskStore;
      delete config.assignmentStore;
      delete config.dependencyStore;
      delete config.timeRangeStore;
      delete config.calendars;
      delete config.resources;
      delete config.tasks;
      delete config.assignments;
      delete config.dependencies;
    }


    config.crudManager = project;
    project.on({
      refresh: me.onProjectRefresh,
      load: me.onProjectLoad,
      thisObj: me
    });
    super.construct(config);
  }

  onProjectRefresh() {
    this.refreshRows();

    const dependencyFeature = this.features.dependencies;


    if (dependencyFeature) {
      this.dependencies.forEach(dep => dependencyFeature.addToGridCache(dep));
    }
  }

  onProjectLoad() {
    const me = this;

    if (!('startDate' in me.initialConfig) && me.project.startDate) {
      me.startDate = me.project.startDate;
    }
  }

  getProjectForDataAPI() {
    return this.project;
  }


  async removeRecords(records) {
    const me = this;

    if (!me.readOnly && records.length) {
      if (records[0] instanceof ProTaskModel) {
        await me.dataApi.removeEvents(records);
      } else {
        const resources = records.map(r => r.resource);
        await me.dataApi.removeAssignments(records, me.removeUnassignedEvent);
        resources.forEach(r => me.repaintEventsForResource(r));
      }
    }
  }


  toggleEmptyText() {
    if (this.bodyContainer) {
      DomHelper.toggleClasses(this.bodyContainer, 'b-grid-empty', !(this.rowManager.rowCount || this.project.isCrudManagerLoading));
    }
  }

}

ProScheduler._$name = 'ProScheduler';
BryntumWidgetAdapterRegister.register(ProScheduler.type, ProScheduler);
VersionHelper.setVersion(ProScheduler.type, VersionHelper.getVersion('scheduler'));


class ProSubProjectModel extends ProTaskModel {

  static get defaultConfig() {
    return {
      recognizedSchedulingModes: ['Normal'],
      convertEmptyParentToLeaf: false
    };
  }


  static get fields() {
    return [

      {
        name: 'description',
        dataSource: 'note',
        type: 'string'
      },

      {
        name: 'allowDependencies',
        type: 'boolean',
        defaultValue: false,
        persist: false
      }];
  }


  get isSubProject() {
    return true;
  }

  isEditable(fieldName) {


    switch (fieldName) {
      case 'name':
      case 'startDate':
      case 'readOnly':
      case 'duration':
      case 'durationUnit':
      case 'description':
      case 'allowDependencies':
        return super.isEditable(fieldName);


      case 'endDate':
        return this.isManuallyScheduled && super.isEditable(fieldName);

      default:
        return false;
    }
  }


  indent() {
  }


  outdent() {
  }

}

ProSubProjectModel._$name = 'ProSubProjectModel';


class ProTaskSegmentModel extends ProTaskModel {
}


ProTaskSegmentModel._$name = 'ProTaskSegmentModel';


class AddNewColumn extends Column {
  static get type() {
    return 'addnew';
  }

  static get defaults() {
    return {
      text: 'New Column',
      cls: 'b-new-column-column',
      draggable: false,
      sortable: false,
      exportable: false,
      field: null,
      editor: null
    };
  }

  get columnCombo() {
    const me = this,
      columns = me.grid.columns;
    return me._columnCombo || (me._columnCombo = new Combo({
      owner: me.grid,
      cls: 'b-new-column-combo',
      placeholder: me.L('New Column'),
      triggers: false,
      autoExpand: true,
      store: me.ganttColumnStore,
      displayField: 'text',
      monitorResize: false,
      picker: {
        align: 't0-b0',
        minWidth: 200,

        onItem({
                 record: columnRecord
               }) {
          const newColumn = new columnRecord.value({
            region: me.region
          }, columns);


          columns.insert(columns.indexOf(me), newColumn);
          newColumn.element.focus();
        }

      },

      syncInputFieldValue() {
        this.input.value = '';
      },

      listeners: {

        keydown({
                  event
                }) {
          event.stopImmediatePropagation();
        }

      }
    }));
  }

  get ganttColumnStore() {


    return new Store({
      data: Object.values(ColumnStore.columnTypes).reduce((result, col) => {


        if (!col.propertiesExposedForData) {
          col.exposeProperties({});
        }


        if (col.isGanttColumn && col.text) {
          result.push({
            id: col.type,
            text: col.L(col.text),
            value: col
          });
        }

        return result;
      }, []),
      filters: [
        colRecord => !this.grid.columns.some(gridCol => gridCol.constructor === colRecord.value)],
      sorters: [{
        field: 'text'
      }]
    });
  }

  headerRenderer({
                   column,
                   headerElement,
                   isExport
                 }) {
    if (!isExport) {
      const {
        columnCombo
      } = column;
      columnCombo.render(headerElement);
      columnCombo.picker.forElement = headerElement;
    }
  }

  onKeyDown(event) {
    if (event.key === 'Enter') {
      this.columnCombo.focus();
    }
  }

  updateLocalization() {

    if (this._columnCombo) {
      this._columnCombo.destroy();

      this._columnCombo = null;
    }

    super.updateLocalization();
  }

}

ColumnStore.registerColumnType(AddNewColumn);
AddNewColumn._$name = 'AddNewColumn';


class CalendarPicker extends Combo {
  static get $name() {
    return 'CalendarPicker';
  }

  static get type() {
    return 'calendarpicker';
  }


  refreshCalendars(calendars) {
    this.store.data = calendars.map(c => {
      return {
        id: c.id,
        text: c.name
      };
    });
  }

  get store() {
    if (!this._store) {
      this.store = new Store();
    }

    return this._store;
  }

  set store(store) {
    super.store = store;
  }

  get value() {
    return super.value;
  }

  set value(value) {
    if (value) {
      if (value.isDefault && value.isDefault()) {
        value = null;
      } else if (value.id) {
        value = value.id;
      }
    }

    super.value = value;
  }

}

CalendarPicker._$name = 'CalendarPicker';
BryntumWidgetAdapterRegister.register(CalendarPicker.type, CalendarPicker);


class CalendarColumn extends Column {
  static get type() {
    return 'calendar';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'calendar',
      text: 'Calendar',
      editor: {
        type: CalendarPicker.type,
        clearable: true,
        allowInvalid: false
      }
    };
  }

  afterConstruct() {
    const me = this;
    super.afterConstruct();
    const project = me.grid.project;

    me.defaultCalendar = project.defaultCalendar;
    me.refreshCalendars();
    project.calendarManagerStore.on({
      change: me.refreshCalendars,
      refresh: me.refreshCalendars,
      thisObj: me
    });
  }

  refreshCalendars() {
    const me = this,
      project = me.grid.project;
    me.editor.refreshCalendars(project.calendarManagerStore.getRange());
  }

  renderer({
             value
           }) {
    const me = this;

    if (value === me.defaultCalendar) {
      return '';
    } else if (value && value.id) {
      const model = me.editor.store.getById(value.id);
      return model && model[me.editor.displayField] || '';
    } else {
      return '';
    }
  }

}

ColumnStore.registerColumnType(CalendarColumn);
CalendarColumn._$name = 'CalendarColumn';


class GanttDateColumn extends DateColumn {
  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      instantUpdate: true,
      width: 130,
      step: null,


      format: 'll'
    };
  }

  construct(data, store) {
    const me = this;
    me.gantt = store.grid;
    super.construct(data, store);

    if (me.format) {
      me.explicitFormat = true;
    } else {
      me.gantt.on({
        displayDateFormatChange({
                                  format
                                }) {
          if (!me.explicitFormat) {
            me.set('format', format);
          }
        }

      });
    }
  }

  set format(format) {
    this.explicitFormat = true;
    this.set('format', format);
  }

  get format() {
    return this.explicitFormat && this.data.format || this.gantt.displayDateFormat;
  }

}

GanttDateColumn._$name = 'GanttDateColumn';


class ConstraintDateColumn extends GanttDateColumn {
  static get type() {
    return 'constraintdate';
  }

  static get defaults() {
    return {
      field: 'constraintDate',
      text: 'Constraint Date',
      width: 146
    };
  }

}

ColumnStore.registerColumnType(ConstraintDateColumn);
ConstraintDateColumn._$name = 'ConstraintDateColumn';


class ConstraintTypeColumn extends Column {
  static get type() {
    return 'constrainttype';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'constraintType',
      text: 'Constraint Type',
      width: 146,
      editor: {
        type: ConstraintTypePicker.type,
        clearable: true,
        allowInvalid: false
      }
    };
  }

  afterConstruct() {
    const me = this;
    super.afterConstruct();
    me.grid.on({
      startCellEdit: me.onStartCellEdit,
      finishCellEdit: me.onDoneCellEdit,
      cancelCellEdit: me.onDoneCellEdit,
      thisObj: me
    });


    FunctionHelper.createSequence(me.editor.updateLocalization, me.onEditorLocaleChange, me);
  }

  onStartCellEdit({
                    editorContext: {
                      editor,
                      record
                    }
                  }) {
    if (editor.inputField instanceof ConstraintTypePicker) {
      editor.inputField.store.filter(r => record.run('isConstraintTypeApplicable', r.id));

      this._filterDetacher = () => editor.inputField.store.clearFilters();
    }
  }

  onDoneCellEdit() {
    this._filterDetacher && this._filterDetacher();
  }

  renderer({
             value
           }) {

    const model = value != null && value !== 'none' && this.editor.store.getById(value);
    return model && model.text || '';
  }


  onEditorLocaleChange() {
    this.grid.refreshColumn(this);
  }

}

ColumnStore.registerColumnType(ConstraintTypeColumn);
ConstraintTypeColumn._$name = 'ConstraintTypeColumn';


class DeadlineDateColumn extends GanttDateColumn {
  static get type() {
    return 'deadlinedate';
  }

  static get defaults() {
    return {
      field: 'deadlineDate',
      text: 'Deadline',
      width: 146
    };
  }

}

ColumnStore.registerColumnType(DeadlineDateColumn);
DeadlineDateColumn._$name = 'DeadlineDateColumn';


class DurationColumn$1 extends DurationColumn {
}

DurationColumn$1._$name = 'DurationColumn';


class EarlyEndDateColumn extends GanttDateColumn {
  static get type() {
    return 'earlyenddate';
  }

  static get defaults() {
    return {
      field: 'earlyEndDate',
      text: 'Early End'
    };
  }

  canEdit(record) {
    return false;
  }

}

ColumnStore.registerColumnType(EarlyEndDateColumn);
EarlyEndDateColumn._$name = 'EarlyEndDateColumn';


class EarlyStartDateColumn extends GanttDateColumn {
  static get type() {
    return 'earlystartdate';
  }

  static get defaults() {
    return {
      field: 'earlyStartDate',
      text: 'Early Start'
    };
  }

  canEdit(record) {
    return false;
  }

}

ColumnStore.registerColumnType(EarlyStartDateColumn);
EarlyStartDateColumn._$name = 'EarlyStartDateColumn';


class EffortColumn extends DurationColumn$1 {
  static get type() {
    return 'effort';
  }

  static get defaults() {
    return {
      field: 'fullEffort',
      text: 'Effort'
    };
  }

  get defaultEditor() {
    return {
      type: EffortField.type,
      name: this.field
    };
  }

  canEdit(record) {
    return record.isLeaf;
  }

}

ColumnStore.registerColumnType(EffortColumn);
EffortColumn._$name = 'EffortColumn';


class RollupColumn extends CheckColumn {
  static get type() {
    return 'rollup';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'rollup',
      text: 'Rollup'
    };
  }

}

ColumnStore.registerColumnType(RollupColumn);
RollupColumn._$name = 'RollupColumn';


class ShowInTimelineColumn extends CheckColumn {
  static get type() {
    return 'showintimeline';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'showInTimeline',
      text: 'Show in timeline'
    };
  }

}

ColumnStore.registerColumnType(ShowInTimelineColumn);
ShowInTimelineColumn._$name = 'ShowInTimelineColumn';


class EndDateColumn extends GanttDateColumn {
  static get type() {
    return 'enddate';
  }

  static get defaults() {
    return {
      field: 'endDate',
      text: 'Finish'
    };
  }

  get defaultEditor() {
    const editorCfg = super.defaultEditor;
    editorCfg.type = 'enddate';
    return editorCfg;
  }

  get editor() {
    let editor = this.data.editor;
    const init = editor && !(editor instanceof Widget);
    editor = super.editor;

    if (editor && init) {
      editor.project = this.gantt.project;
    }

    return editor;
  }

  canEdit(record) {
    return record.isLeaf;
  }

}

ColumnStore.registerColumnType(EndDateColumn);
EndDateColumn._$name = 'EndDateColumn';


class LateEndDateColumn extends GanttDateColumn {
  static get type() {
    return 'lateenddate';
  }

  static get defaults() {
    return {
      field: 'lateEndDate',
      text: 'Late End'
    };
  }

  canEdit(record) {
    return false;
  }

}

ColumnStore.registerColumnType(LateEndDateColumn);
LateEndDateColumn._$name = 'LateEndDateColumn';


class LateStartDateColumn extends GanttDateColumn {
  static get type() {
    return 'latestartdate';
  }

  static get defaults() {
    return {
      field: 'lateStartDate',
      text: 'Late Start'
    };
  }

  canEdit(record) {
    return false;
  }

}

ColumnStore.registerColumnType(LateStartDateColumn);
LateStartDateColumn._$name = 'LateStartDateColumn';


class ManuallyScheduledColumn extends CheckColumn {
  static get type() {
    return 'manuallyscheduled';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'manuallyScheduled',
      text: 'Manually scheduled'
    };
  }

}

ColumnStore.registerColumnType(ManuallyScheduledColumn);
ManuallyScheduledColumn._$name = 'ManuallyScheduledColumn';


class MilestoneColumn extends CheckColumn {
  static get type() {
    return 'milestone';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'milestone',
      text: 'Milestone'
    };
  }

}

ColumnStore.registerColumnType(MilestoneColumn);
MilestoneColumn._$name = 'MilestoneColumn';


class NameColumn extends TreeColumn {
  static get type() {
    return 'name';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      htmlEncode: false,
      width: 200,
      field: 'name',
      text: 'Name'
    };
  }

}

ColumnStore.registerColumnType(NameColumn);
NameColumn._$name = 'NameColumn';


class NoteColumn extends Column {
  static get type() {
    return 'note';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'note',
      text: 'Note',
      width: 150,
      editor: {
        type: 'textareafield',
        inline: false
      }
    };
  }

  renderer({
             value
           }) {
    return (value || '').trim();
  }

  get disableHtmlEncode() {
    return true;
  }

}

ColumnStore.registerColumnType(NoteColumn);
NoteColumn._$name = 'NoteColumn';


class PercentDoneColumn extends NumberColumn {
  static get type() {
    return 'percentdone';
  }

  static get isGanttColumn() {
    return true;
  }

  static get fields() {
    return [

      'showCircle'];
  }

  static get defaults() {
    return {
      field: 'percentDone',
      text: '% Done',
      unit: '%',
      step: 1,
      min: 0,
      max: 100,
      width: 90
    };
  }

  construct(config) {
    super.construct(...arguments);

    if (this.showCircle) {
      this.htmlEncode = false;
    }
  }

  defaultRenderer({
                    record
                  }) {
    const value = record.renderedPercentDone;

    if (this.showCircle) {
      const size = this.grid.rowHeight * 0.8;
      return {
        className: 'b-percentdone-circle',
        style: {
          animationDelay: `-${value - 0.1}s`,
          width: size,
          height: size
        },
        dataset: {
          value
        }
      };
    }

    return value + this.unit;
  }

  canEdit(record) {
    return record.isLeaf;
  }

}

ColumnStore.registerColumnType(PercentDoneColumn);
PercentDoneColumn._$name = 'PercentDoneColumn';


const toggleTypes = {
  from: [2, 3, 0, 1],
  to: [1, 0, 3, 2]
};


let dependencyTypes = ['SS', 'SF', 'FS', 'FF'],
  buildDependencySuffixRe = () => new RegExp(`(${dependencyTypes.join('|')})?((?:[+-])\\d+[a-z]*)?`, 'i'),
  dependencySuffixRe = buildDependencySuffixRe();

LocaleManagerSingelton.on({
  locale: ({
             locale
           }) => {
    dependencyTypes = locale.SchedulerProCommon.dependencyTypes;
    dependencySuffixRe = buildDependencySuffixRe();
  }
});


class DependencyField extends Combo {

  static get $name() {
    return 'DependencyField';
  }

  static get defaultConfig() {
    return {
      listCls: 'b-predecessor-list',
      valueField: 'name',
      displayField: 'name',


      delimiter: ';',


      otherSide: null,


      ourSide: null
    };
  }

  construct(config) {
    const me = this,
      {
        ourSide,
        otherSide
      } = config;
    me.dependencies = new Collection({
      extraKeys: otherSide
    });
    me.startCollection = new Collection({
      extraKeys: otherSide
    });
    super.construct(config);
    me.delimiterRegEx = new RegExp(`\\s*${me.delimiter}\\s*`);

    LocaleManagerSingelton.on({
      locale() {
        me.syncInputFieldValue();
      },

      thisObj: me
    });
  }

  internalOnInput() {

    if (this.isValid) {
      this.clearError();
      TextField.prototype.internalOnInput.call(this);
    } else {
      this.setError('Invalid dependency format');
    }
  }

  onInternalKeyDown(keyEvent) {
    const {
      key
    } = keyEvent;


    if (key !== 'Enter') {
      super.onInternalKeyDown && super.onInternalKeyDown(keyEvent);
    }

    if (this.pickerVisible && key === 'ArrowDown') {
      this.filterField.focus();
    }
  }

  onTriggerClick() {
    if (this.pickerVisible) {
      super.onTriggerClick();
    } else {
      this.doFilter(this.filterInput ? this.filterInput.value : null);
    }
  }

  set store(store) {
    const me = this;

    store = store.makeChained(r => !me.owner || !me.owner.record || r.id !== me.owner.record.id);

    store.tree = false;
    super.store = store;
  }

  get store() {
    return super.store;
  }

  createPicker() {
    const me = this,
      myInput = me.input,
      filterField = me.filterField = new TextField({
        cls: 'b-dependency-list-filter',
        owner: me,
        clearable: true,
        placeholder: 'Filter',
        triggers: {
          filter: {
            cls: 'b-icon b-icon-filter',
            align: 'start'
          }
        },
        listeners: {
          input({
                  value
                }) {
            me.input = filterFieldInput;
            me.filterList(value);
            me.input = myInput;
          },

          clear() {
            me.input = filterFieldInput;
            me.filterList();
            me.input = myInput;
          }

        }
      }),
      filterFieldInput = me.filterInput = filterField.input,
      result = new List({
        owner: me,
        floating: true,
        scrollAction: 'realign',
        itemsFocusable: false,
        activateOnMouseover: true,
        store: me.store,
        cls: me.listCls,
        itemTpl: me.listItemTpl,
        forElement: me[me.pickerAlignElement],
        align: {
          align: 't0-b0',
          axisLock: true,
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement]
        },
        navigator: {
          keyEventTarget: filterFieldInput,
          processEvent: e => {
            if (e.key === 'Escape') {
              me.hidePicker();
            } else {
              return e;
            }
          }
        },
        onItem: me.onPredecesssorClick,
        maxHeight: 324,
        minHeight: 161,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false,
        getItemClasses: function (task) {
          const result = List.prototype.getItemClasses.call(this, task),
            dependency = me.dependencies.getBy(me.otherSide + 'Event', task),
            cls = dependency ? ` b-selected b-${dependency.getConnectorString(1).toLowerCase()}` : '';
          return result + cls;
        }
      });
    filterField.render(result.contentElement);
    return result;
  }

  showPicker(focusPicker) {


    this.store.fillFromMaster();
    super.showPicker(focusPicker);
  }

  onPickerShow({
                 source: picker
               }) {
    const me = this,
      filterField = me.filterField,
      ourInput = me.input;
    picker.minWidth = me[me.pickerAlignElement].offsetWidth;
    picker.contentElement.insertBefore(filterField.element, picker.contentElement.firstChild);


    me.input = me.filterInput;
    super.onPickerShow();
    me.input = ourInput;
  }

  listItemTpl(task) {
    return `<div class="b-predecessor-item-text">${task.name}</div>
            <div class="b-sch-box b-from" data-side="from"></div>
            <div class="b-sch-box b-to" data-side="to"></div>`;
  }

  get isValid() {
    return Boolean(!this.owner || this.parseDependencies(this.input.value));
  }

  set value(dependencies) {
    const me = this,
      predecessorsCollection = me.dependencies,
      startCollection = me.startCollection;

    if (typeof dependencies === 'string') {
      me.input.value = dependencies;
      dependencies = me.parseDependencies(dependencies);

      if (!dependencies) {
        me.updateInvalid();
        return;
      }

      for (let i = 0; i < dependencies.length; i++) {


        let newPredecessor = new me.dependencyStore.modelClass(dependencies[i]),
          existingPredecessor = startCollection.getBy(me.otherSide, newPredecessor.fromEvent);

        if (existingPredecessor) {


          existingPredecessor = existingPredecessor.copy(existingPredecessor.id);
          existingPredecessor.type = newPredecessor.type;
          existingPredecessor.fullLag = newPredecessor.fullLag;
        }

        dependencies[i] = existingPredecessor || newPredecessor;
      }
    } else {
      me.startCollection.clear();
      me.startCollection.values = dependencies;
    }

    predecessorsCollection.clear();
    predecessorsCollection.values = dependencies;

    if (!me.inputting) {
      me.syncInputFieldValue();
    }
  }

  get value() {
    return this.dependencies.values;
  }

  onPredecesssorClick({
                        source: list,
                        item,
                        record: task,
                        index,
                        event
                      }) {
    const me = this.owner,
      dependencies = me.dependencies,
      box = event.target.closest('.b-sch-box'),
      side = box && box.dataset.side;
    let predecessor = dependencies.getBy(me.otherSide + 'Event', task);

    item.dataset.noselect = true;

    if (predecessor && !box) {
      dependencies.remove(predecessor);
    } else {

      if (predecessor) {


        predecessor = predecessor.copy(predecessor.id);
        predecessor.type = toggleTypes[side][predecessor.type];


        dependencies.add(predecessor);
      } else {
        dependencies.add(me.dependencyStore.createRecord({
          [`${me.otherSide}Event`]: task,
          [`${me.ourSide}Event`]: me.owner.record
        }, true));
      }
    }

    me.syncInputFieldValue();
    list.refresh();
  }

  syncInputFieldValue() {
    this.input.value = this.constructor.predecessorsToString(this.dependencies.values, this.otherSide, this.delimiter);
  }

  static predecessorsToString(dependencies, otherSide, delimiter = ';') {
    const result = [];

    if (dependencies && dependencies.length) {
      for (const dependency of dependencies) {
        const otherSideEvent = dependency[otherSide + 'Event'],
          otherSideEventId = otherSideEvent ? otherSideEvent.id : otherSideEvent || '';
        result.push(`${otherSideEventId}${dependency.getConnectorString()}${dependency.getLag()}`);
      }
    }

    return result.join(delimiter);
  }

  parseDependencies(value) {
    const me = this,
      grid = me.grid,
      task = me.owner.record,
      taskStore = me.store,
      dependencyStore = me.dependencyStore,
      dependencies = value.split(me.delimiterRegEx),
      DependencyModel = dependencyStore.modelClass,
      result = [];

    for (let i = 0; i < dependencies.length; i++) {
      const predecessorText = dependencies[i];

      if (predecessorText) {
        let idLen = predecessorText.length + 1,
          predecessorId,
          predecessor,
          remainder,
          dependency;

        for (; idLen && !predecessor; idLen--) {
          predecessorId = predecessorText.substr(0, idLen);
          predecessor = taskStore.getById(predecessorId);
        }

        if (!predecessor) {
          return null;
        }

        remainder = predecessorText.substr(idLen + 1);

        dependency = {


          [`${me.otherSide}Event`]: predecessor,


          [`${me.ourSide}Event`]: task,
          type: DependencyModel.Type.EndToStart
        };

        if (remainder.length) {
          const edgeAndLag = dependencySuffixRe.exec(remainder);

          if (edgeAndLag && (edgeAndLag[1] || edgeAndLag[2])) {

            if (edgeAndLag[1]) {
              dependency.type = dependencyTypes.indexOf(edgeAndLag[1].toUpperCase());
            }

            if (edgeAndLag[2]) {
              const parsedLag = DateHelper.parseDuration(edgeAndLag[2], true, grid.timeAxis.unit);
              dependency.lag = parsedLag.magnitude;
              dependency.lagUnit = parsedLag.unit;
            }
          } else {
            return null;
          }
        }

        result.push(dependency);
      }
    }

    return result;
  }

}

DependencyField._$name = 'DependencyField';
BryntumWidgetAdapterRegister.register('dependencyfield', DependencyField);


const hasNoProject = v => !v.project,
  depIsValid = v => v,


  checkNext = async (toValidate, dependencyStore, results) => {
    const dependency = toValidate.shift();

    if (dependency) {


      results.push(await dependencyStore.isValidDependency({
        fromEvent: dependency.fromEvent,
        toEvent: dependency.toEvent,
        lag: dependency.lag,
        lagUnit: dependency.lagUnit,
        type: dependency.type
      }));
      await checkNext(toValidate, dependencyStore, results);
    }
  };


class DependencyColumn extends Delayable(Column) {
  static get type() {
    return 'dependency';
  }

  static get fields() {
    return [

      {
        name: 'delimiter',
        defaultValue: ';'
      }];
  }

  static get defaults() {
    return {
      htmlEncode: false,
      width: 120,

      renderer({
                 record
               }) {
        return DependencyField.predecessorsToString(record[this.field], this.field === 'predecessors' ? 'from' : 'to', this.delimiter);
      }

    };
  }

  afterConstruct() {
    super.afterConstruct();
  }

  async finalizeCellEdit({
                           grid,
                           record,
                           inputField,
                           value,
                           oldValue,
                           editorContext
                         }) {
    if (record && value) {
      value = value.slice();
      const {
          dataField
        } = editorContext.editor,
        toValidate = value.filter(hasNoProject),
        results = [];

      await checkNext(toValidate, grid.dependencyStore, results);
      const valid = results.every(depIsValid);

      if (valid) {
        const setterName = `set${StringHelper.capitalizeFirstLetter(dataField)}`;

        if (record[setterName]) {
          record[setterName](value);
        } else {
          record[dataField] = value;
        }
      } else {
        inputField.value = oldValue;
        WidgetHelper.toast(editorContext.column.L('Invalid dependency found, change is reverted'));
      }

      return valid;
    }
  }

  get defaultEditor() {
    const me = this,
      isPredecessor = me.field === 'predecessors';
    return {
      type: 'dependencyfield',
      grid: me.grid,
      name: me.field,
      delimiter: me.delimiter,
      ourSide: isPredecessor ? 'to' : 'from',
      otherSide: isPredecessor ? 'from' : 'to',
      store: me.grid.eventStore || me.grid.taskStore,
      dependencyStore: me.grid.features.dependencies.store
    };
  }

}

ColumnStore.registerColumnType(DependencyColumn);
DependencyColumn._$name = 'DependencyColumn';


class PredecessorColumn extends DependencyColumn {
  static get type() {
    return 'predecessor';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      text: 'Predecessors',
      field: 'predecessors'
    };
  }

}

ColumnStore.registerColumnType(PredecessorColumn);
PredecessorColumn._$name = 'PredecessorColumn';


class AssignmentsManipulationModel extends Model {
  static get fields() {
    return [{
      name: 'assignment',
      type: 'object'
    }, {
      name: 'resource',
      type: 'object'
    }, {
      name: 'event',
      type: 'object'
    }, {
      name: 'units',
      type: 'number',
      defaultValue: 0
    }];
  }

  get name() {

    return this.resource ? this.resource.name : '';
  }

  get assigned() {
    return this.event && this.firstStore.projectEvent === this.event;
  }

  set assigned(value) {
    const me = this;

    if (value) {
      if (!me.assigned) {
        me.set({
          event: me.firstStore.projectEvent,
          units: me.units || 100
        });
      }
    } else {
      me.set({
        event: null,
        units: 0
      });
    }
  }

}

AssignmentsManipulationModel._$name = 'AssignmentsManipulationModel';

const {
  defineParser: defineParser$1,
  alt: alt$1,
  seq: seq$1,
  string: string$1,
  regexp: regexp$1,
  succeed: succeed$1,
  red: red$1,
  isSuccess: isSuccess$1
} = Parser;


const resourceNamePEG = defineParser$1(red$1(regexp$1('[^\\[\\,]+'), name => ({
  name: name.trim(),
  units: 100,
  match: name
})));


const integerPEG = defineParser$1(red$1(regexp$1('[0-9\\s]+'), value => ({
  value: value.split(/\s*/).join(''),
  match: value
})));


const decimalSeparatorPEG = defineParser$1(red$1(alt$1(string$1('.'), string$1(',')), value => ({
  value,
  match: value
})));


const unitsNumberPEG = defineParser$1(alt$1(red$1(seq$1(() => integerPEG, () => decimalSeparatorPEG, () => integerPEG), (integer, sep, fractional) => ({
  value: Number(`${integer.value}.${fractional.value}`),
  match: [integer.match, sep.match, fractional.match].join('')
})), red$1(seq$1(() => decimalSeparatorPEG, () => integerPEG), (sep, fractional) => ({
  value: Number(`0.${fractional.value}`),
  match: [sep.match, fractional.match].join('')
})), red$1(() => integerPEG, value => ({
  value: Number(`${value.value}`),
  match: value.match
}))));


const unitsPersentagePEG = defineParser$1(alt$1(red$1(seq$1(() => unitsNumberPEG, regexp$1('\\s*\\%')), (units, perc) => ({
  value: units.value,
  match: [units.match, perc].join('')
})), red$1(() => unitsNumberPEG, units => ({
  value: units.value,
  match: units.match
}))));


const unitsDesignationPEG = defineParser$1(red$1(seq$1(regexp$1('\\s*\\[\\s*'), () => unitsPersentagePEG, regexp$1('\\s*\\]')), (startSep, units, endSep) => ({
  units: units.value,
  match: [startSep, units.match, endSep].join('')
})));


const commaPEG = defineParser$1(red$1(regexp$1('\\s*,\\s*'), value => ({
  value,
  match: value
})));


const raPEG = defineParser$1(alt$1(seq$1(() => resourceNamePEG, () => unitsDesignationPEG, alt$1(seq$1(() => commaPEG, () => raPEG), succeed$1(''))), seq$1(() => resourceNamePEG, alt$1(seq$1(() => commaPEG, () => raPEG), succeed$1('')))));


const parse = str => {
  let gotSuccess = false,
    result = [],
    rest = '';
  raPEG(str, possibleResult => {
    if (isSuccess$1(possibleResult)) {
      const [, structuredResult, unstracturedRest] = possibleResult;

      if (structuredResult.length > result.length) {
        result = structuredResult;
        rest = unstracturedRest;
        gotSuccess = true;
      }
    }
  });
  let position = 0;
  return gotSuccess ? {
    rest,
    assignments: result.reduce((result, part) => {
      let currentResource;

      if (typeof part == 'object') {
        if (part.hasOwnProperty('name')) {
          currentResource = Object.assign({
            position
          }, part);
          result.push(currentResource);
        } else {
          currentResource = result[result.length - 1];

          if (part.hasOwnProperty('units')) {
            currentResource.units = part.units;
          }

          currentResource.match += part.match;
        }

        position += part.match.length;
      }

      return result;
    }, [])
  } : false;
};


const compose = (parseResult, exactIfPossible = false) => {
  let result = '';

  if (parseResult.assignments) {
    result += parseResult.assignments.reduce((str, {
      name,
      units,
      match
    }) => {
      if (match && exactIfPossible) {
        str += match;
      } else {
        str += (str.length ? ', ' : '') + `${name} [${units}%]`;
      }

      return str;
    }, result);
  }

  if (parseResult.rest) {
    result += parseResult.rest;
  }

  if (!exactIfPossible) {
    result = result.trim();
  }

  return result;
};


const normalize = str => compose(parse(str));
var Parser$1 = {
  parse,
  compose,
  normalize
};

const {
  compose: compose$1
} = Parser$1;


class AssignmentsManipulationStore extends Store {

  static get defaultConfig() {
    return {
      modelClass: AssignmentsManipulationModel,
      storeId: 'assignmentsmanipulation',
      storage: {
        extraKeys: ['resource']
      },
      callOnFunctions: true,


      projectEvent: null,


      floatAssignedResources: true,


      liveFloatAssignedResources: false
    };
  }

  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.addSorter({
      fn: me.defaultSort.bind(me)
    });
  }

  get projectEvent() {
    return this._projectEvent;
  }

  set projectEvent(projectEvent) {
    const me = this;

    if (projectEvent != me._projectEvent || projectEvent && projectEvent.generation !== me._projectEventGeneration) {
      me._projectEvent = projectEvent;
      me._projectEventGeneration = projectEvent.generation;

      if (projectEvent) {
        me.fillFromMaster();
        const {
            assignments
          } = projectEvent,
          originalAssignments = [];
        assignments.forEach(assignment => {
          const assignmentsManipulationRecord = me.find(assignmentsManipulationRecord => assignmentsManipulationRecord.resource === assignment.resource);

          if (assignmentsManipulationRecord) {
            assignmentsManipulationRecord.set({
              assignment,
              event: projectEvent,
              units: assignment.units || 0
            });
            originalAssignments.push(assignmentsManipulationRecord);
          }
        });
        me.originalAssignmentManipulationRecords = originalAssignments;
        me.acceptChanges();
        me.sort();
      } else {
        me.removeAll();
      }
    }
  }

  get floatAssignedResources() {
    return this._floatAssignedResources;
  }

  set floatAssignedResources(value) {
    const me = this;

    if (value !== me.floatAssignedResources) {
      me._floatAssignedResources = value;
      me.sort();
    }
  }

  get assignmentStore() {
    return this.projectEvent && this.projectEvent.getAssignmentStore() || null;
  }

  get resourceStore() {
    return this.projectEvent && this.projectEvent.getResourceStore() || null;
  }


  fillFromMaster() {
    const me = this,
      projectEvent = me.projectEvent;

    if (projectEvent) {
      me.data = me.resourceStore.map(resource => ({
        resource
      }));
    }
  }


  async applyChanges() {
    const me = this,
      {
        projectEvent,
        assignmentStore
      } = me,
      toAdd = [],
      assignmentManipulationRecords = me.query(record => record.event && record.units, true),
      removedAssignmentManipulationRecords = me.originalAssignmentManipulationRecords.filter(a => !assignmentManipulationRecords.includes(a));
    let result;

    if (assignmentManipulationRecords.length || removedAssignmentManipulationRecords.length) {

      const replica = projectEvent.project.replica,
        oldThreshold = replica.projectRefreshThreshold;
      assignmentManipulationRecords.forEach(assignmentManipulationRecord => {
        const realAssignment = assignmentManipulationRecord.assignment;

        if (realAssignment) {
          realAssignment.$.units.put(assignmentManipulationRecord.units);
        } else {
          toAdd.push({
            resource: assignmentManipulationRecord.resource,
            event: assignmentManipulationRecord.event,
            units: assignmentManipulationRecord.units
          });
        }
      });

      me.commit();
      assignmentStore.remove(removedAssignmentManipulationRecords.map(mani => mani.assignment));
      assignmentStore.add(toAdd);
      replica.projectRefreshThreshold = 0;
      result = await projectEvent.propagate();
      replica.projectRefreshThreshold = oldThreshold;

      assignmentStore.trigger('refresh', {
        action: 'dataset'
      });

      if (result === PropagationResult.Completed) {
        if (me.floatAssignedResources) {
          me.sort();
        }


        me.trigger('changesApplied');
      }
    } else {
      result = PropagationResult.Complete;
    }

    return result;
  }


  getResourceAssignment(resource) {
    return this.storage.getBy('resource', resource);
  }

  get activeAssignments() {
    const me = this,
      projectEvent = me.projectEvent;
    return me.query(a => a.event === projectEvent);
  }

  toValueString() {
    const {
      activeAssignments
    } = this;
    return compose$1({
      rest: '',
      assignments: activeAssignments
    });
  }

  defaultSort(lhs, rhs) {
    let result = 0;

    if (this.floatAssignedResources) {
      if (!rhs.event && lhs.event) {
        result = -1;
      } else if (!lhs.event && rhs.event) {
        result = 1;
      } else {
        result = lhs.name.localeCompare(rhs.name);
      }
    } else {
      result = lhs.name.localeCompare(rhs.name);
    }

    return result;
  }

  onUpdate({
             changes
           }) {
    const me = this;

    if (!me.isConfiguring) {
      if (Object.hasOwnProperty.call(changes, 'event')) {
        if (me.floatAssignedResources && me.liveFloatAssignedResources) {
          me.sort();
        }
      }
    }
  }

}

AssignmentsManipulationStore._$name = 'AssignmentsManipulationStore';


class AssignmentGrid extends Grid {
  static get $name() {
    return 'AssignmentGrid';
  }

  static get type() {
    return 'assignmentgrid';
  }

  static get defaultConfig() {
    return {
      selectionMode: {
        rowCheckboxSelection: true,
        multiSelect: true,
        showCheckAll: true
      },
      columns: [{
        cls: 'b-assignmentgrid-resource-column',
        field: 'resourceId',
        flex: 1,
        editor: null,
        renderer: p => p.record.name,
        filterable: {
          filterField: {
            placeholder: this.L('Name'),
            triggers: {
              filter: {
                align: 'start',
                cls: 'b-icon b-icon-filter'
              }
            }
          },
          filterFn: ({
                       value,
                       record
                     }) => {
            return record.name.toLowerCase().indexOf(value.toLowerCase()) !== -1;
          }
        },
        sortable: (lhs, rhs) => lhs.name < rhs.name ? -1 : lhs.name > rhs.name ? 1 : 0
      }, {
        field: 'units',
        type: NumberColumn.type,
        text: this.L('Units'),
        width: 70,
        min: 0,
        max: 100,
        step: 10,
        unit: this.L('%'),
        renderer: ({
                     value
                   }) => this.L('unitsTpl', {
          value
        }),
        filterable: false
      }],

      features: {
        group: false,
        filterBar: true,
        contextMenu: false
      },
      disableGridRowModelWarning: true,


      projectEvent: null
    };
  }

  construct() {
    super.construct(...arguments);
    this.on('selectionchange', ({
                                  selected,
                                  deselected
                                }) => {
      selected.forEach(resourceManipulationRecord => resourceManipulationRecord.assigned = true);
      deselected.forEach(resourceManipulationRecord => resourceManipulationRecord.assigned = false);
    });
  }

  get projectEvent() {
    const me = this,
      store = me.store;
    let projectEvent = me._projectEvent;

    if (store && projectEvent !== store.projectEvent) {
      projectEvent = me._projectEvent = store.projectEvent;
    }

    return projectEvent;
  }

  set projectEvent(projectEvent) {
    this._projectEvent = projectEvent;
    this.store.projectEvent = projectEvent;
    this.selectedRecords = this.store.originalAssignmentManipulationRecords;
  }

  get store() {
    return super.store;
  }

  set store(store) {
    const me = this,
      oldStore = me.store;

    if (oldStore !== store) {
      if (!(store instanceof AssignmentsManipulationStore)) {
        store = new AssignmentsManipulationStore(Object.assign({
          projectEvent: me._projectEvent
        }, store));
      }

      super.store = store;
    }
  }

}

AssignmentGrid._$name = 'AssignmentGrid';
BryntumWidgetAdapterRegister.register(AssignmentGrid.type, AssignmentGrid);


class AssignmentPicker extends Panel {
  static get $name() {
    return 'AssignmentPicker';
  }

  static get type() {
    return 'assignmentpicker';
  }

  static get defaultConfig() {
    return {

      grid: null,
      focusable: true,
      trapFocus: true,
      height: '20em',
      minWidth: '25em',
      items: [{
        ref: 'grid',
        type: AssignmentGrid.type
      }],
      bbar: [{
        type: 'button',
        text: this.L('Save'),
        ref: 'saveBtn',
        color: 'b-green'
      }, {
        type: 'button',
        text: this.L('Cancel'),
        ref: 'cancelBtn',
        color: 'b-gray'
      }],


      projectEvent: null,


      store: null
    };
  }

  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.bbar.widgetMap.saveBtn.on('click', me.onSaveClick, me);
    me.bbar.widgetMap.cancelBtn.on('click', me.onCancelClick, me);
  }

  get focusElement() {
    return this.element.querySelector('input[type=text]');
  }

  get grid() {
    return this.isConfiguring ? this._grid : this.widgetMap.grid;
  }

  set grid(grid) {
    this._grid = grid;
  }

  get projectEvent() {
    return this._projectEvent;
  }

  set projectEvent(projectEvent) {
    this._projectEvent = projectEvent;

    if (this.grid) {
      this.grid.projectEvent = projectEvent;
    }
  }

  createWidget(config) {
    if (config && config.ref === 'grid') {
      const me = this,
        gridClassConfig = BryntumWidgetAdapterRegister.getClass(config.type).defaultConfig;


      let gridExtraConfig = me.grid;

      if (gridExtraConfig) {

        if (gridExtraConfig.columns) {
          config.columns = [...gridClassConfig.columns, ...gridExtraConfig.columns];

          gridExtraConfig = Object.assign({}, gridExtraConfig);
          delete gridExtraConfig.columns;
        }

        ObjectHelper.merge(config, gridExtraConfig);
      }

      config.projectEvent = me.projectEvent;
      config.store = me.store;
      config.selectedRecordCollection = me.assignments;
    }

    return super.createWidget(config);
  }

  onSaveClick() {
    this.store.applyChanges();
    this.hide();
  }

  onCancelClick() {
    this.hide();
  }

}

AssignmentPicker._$name = 'AssignmentPicker';
BryntumWidgetAdapterRegister.register(AssignmentPicker.type, AssignmentPicker);


class AssignmentField extends Combo {
  static get $name() {
    return 'AssignmentField';
  }

  static get type() {
    return 'assignmentfield';
  }

  static get defaultConfig() {
    return {
      chipView: {
        cls: 'b-assignment-chipview',

        itemTpl(assignment, i) {
          return `${assignment.name} ${assignment.units}%`;
        },

        scrollable: {
          overflowX: 'hidden-scroll'
        }
      },
      triggers: {
        expand: {
          cls: 'b-icon-down',
          handler: 'onTriggerClick'
        }
      },
      multiSelect: true,
      clearable: false,

      editable: false,
      value: null,


      pickerWidth: null,


      projectEvent: null,


      store: null
    };
  }


  onChipClose(records) {
    this.showPicker();


    records.forEach(record => this.picker.grid.deselectRow(record));
  }

  syncInputFieldValue() {
    super.syncInputFieldValue();

    if (this.store) {
      this.tooltip = this.store.toValueString();
    }
  }


  onTriggerClick(event) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      PickerField.prototype.showPicker.call(this, event && 'key' in event);
    }
  }

  focusPicker() {
    this.picker.focus();
  }

  createPicker(picker) {
    const me = this;
    return WidgetHelper.createWidget(Object.assign({
      type: AssignmentPicker.type,
      projectEvent: me.projectEvent,
      store: me.store,
      readOnly: me.readOnly,
      owner: me,
      forElement: me[me.pickerAlignElement],
      floating: true,
      scrollAction: 'realign',
      assignments: me.valueCollection,
      align: {
        align: 't0-b0',
        axisLock: true,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      }
    }, picker));
  }


  get projectEvent() {
    return this._projectEvent;
  }

  set projectEvent(projectEvent) {
    const me = this;
    me._projectEvent = projectEvent;
    me._projectEventGeneration = projectEvent.generation;
    me.store.projectEvent = me.picker.projectEvent = projectEvent;
  }

  get store() {
    if (!this._store) {
      this.store = {};
    }

    return this._store;
  }

  set store(store) {
    const me = this;

    if (store !== me._store) {
      if (store instanceof AssignmentsManipulationStore) {
        me._store = store;
        me.projectEvent = store.projectEvent;
      } else if (store) {
        me._store = new AssignmentsManipulationStore(store);
        me._store.projectEvent = me.projectEvent;
      }
    }
  }


  get value() {
  }

  set value(v) {
  }


  onPickerKeyDown(event) {
    const grid = this.picker.grid;

    if (event.key === 'ArrowDown' && event.target.compareDocumentPosition(grid.bodyContainer) === document.DOCUMENT_POSITION_FOLLOWING) {
      grid.element.focus();
    }
  }

}

AssignmentField._$name = 'AssignmentField';
BryntumWidgetAdapterRegister.register(AssignmentField.type, AssignmentField);

const defaultUserImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA3CAYAAABQOymxAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAABCJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjU8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjYwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj41NTwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgICAgIDxkYzpzdWJqZWN0PgogICAgICAgICAgICA8cmRmOkJhZy8+CiAgICAgICAgIDwvZGM6c3ViamVjdD4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTgtMDMtMTBUMTE6MDM6NTc8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPlBpeGVsbWF0b3IgMy43PC94bXA6Q3JlYXRvclRvb2w+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpEgCIGAAADbUlEQVRoBe2aW08TQRTH/yVchVCg3Kyl1EAEg6VBjdpoor74ZUz8Nn4UIyHGy4NGLtEHoiLhBQpUkWAIt8itnkMt3SVud2b3DL0xSdPZnTNzzm8uZ87ubCCTyTwD8JR+1+hXyWme4J4HCPg7ZSodNjeQ8wycyV1Vw39NNUBaGWutF6bzh6Rg5XdeC8+t+nog3JK/ZzpnHDi9A0xNAUdH7ijt7cDjW+5yfiSMruHxD8Durr550Shw25AbNQL8hxhfvNIHtdZooWn+5J71jkzeiNMaf+PfuO1tYJo3TOEkDvx1WW29qnCkUsCBiqCGjDjw3JyGdgXRt5MKQhoiosA/PDgoN1u3ttwk9MpFgWdm9JSrSv/cU5V0lxMF3t93V+hFYpn8glQSBZYy6mw7ktF+WQCf7QA/1xfAfnovEPBT27lurWDEXxYjHAo5d4ZuSVkAR4K6WM7yZQHsbL5+yQWwfp/la5hyWpIv3URHOCi41vLdCEgaKdkWhoetZpZmXhT4crM8ZEODbJuiwGxaT4+sgfG4bHviwPcFDawh66JtJQ7M5tXVyRg5OCjTjrUV8RHmxmMxqwrv+Rv0ulY6GQGO92dPFPwY293tp7ZzXSPArK6vz1mpWwkHMA9G3aS8lRsDTlwFvD7W9fZ6g1GpZQyYlScSKibYZbiTkiP2e5JXRoH76XAsEtEzN5nUk9eVNgrMxjRrRl9twpHV2Q4xcpjGSn7RidrSErC+DuzQkalq6uwE+CGEt7YgOS/pJArMZ8Hz9OkIH4TxO2o/r1c5yuI4urUVGKPo7ZIQuW/ghTUgnc6OpB9ANx7uAN6bh4aAkI9IzjNwahNYXATWCPg8E3tx3rYGBryBawMz6MICsEn/x8fniWrXxeC81u+OAY32ooJXysB8MPh5Njt1Vb7XKKhVsJDXeVcXcEfx5YMrMB/cfSFHxOv0QPp0WhC8kYaZ9/zRWOFGCwJ/oqm7upr1uIWbKZ3SpiZ6hqanrBGHWP6/wLPkjHhEeXsp18TrOxwGrl+xE9iAD6ns3XTWIdnFyveKj2kekmPLJRvwy/fAnuBpe05Jsf87OoBHN7NWnMbSEx8rE5YxNzaA1/8+xzgZ4clv9A3kSrHHwbx+js9PRrgaYLk7OTI8ndLm+7f4GjjWrypg7vIL4OJPPLMWVN0I/wWcn9aXj4AzhgAAAABJRU5ErkJggg==';


class ResourceAssignmentColumn extends Column {
  static get type() {
    return 'resourceassignment';
  }

  static get isGanttColumn() {
    return true;
  }

  static get fields() {
    return [

      'showAvatars', 'sideMargin', 'imageSize'];
  }

  static get defaults() {
    return {
      field: 'assignments',
      instantUpdate: false,
      text: 'Assigned Resources',
      width: 250,
      cellCls: 'b-resourceassignment-cell',
      showAvatars: false,
      imageSize: 30,
      sideMargin: 20
    };
  }

  construct() {
    const me = this;
    super.construct(...arguments);

    if (me.showAvatars) {
      EventHelper.on({
        element: me.grid.element,
        error: me.onError,
        thisObj: me,
        capture: true
      });
      Object.assign(me, {
        repaintOnResize: true,
        htmlEncode: false,
        autoSyncHtml: true
      });

      if (!me.grid.resourceImageFolderPath) {
        throw new Error('Must provide a resourceImageFolderPath where resource images are located');
      }

      me.renderer = me.rendererWithAvatars;
    }

    me.grid.on({
      startCellEdit: me.onStartCellEdit,
      finishCellEdit: me.onDoneCellEdit,
      cancelCellEdit: me.onDoneCellEdit,
      thisObj: me
    });
    me.grid.resourceStore.on({
      name: 'resourceStore',
      update: me.onResourceUpdate,
      thisObj: me
    });
  }

  get defaultEditor() {
    return {
      type: AssignmentField.type
    };
  }

  onStartCellEdit({
                    editorContext: {
                      record,
                      column
                    }
                  }) {
    const me = this;

    if (column === me) {
      me.editor.projectEvent = record;
      this.detachListeners('editorStore');
      me.editor.store.on({
        name: 'editorStore',
        changesApplied: me.onEditorChangesApplied,
        thisObj: me
      });
    }
  }

  onDoneCellEdit() {
    this.detachListeners('editorStore');
  }

  onEditorChangesApplied() {
    const me = this,
      cellElement = me.grid.getCell({
        id: me.editor.projectEvent.id,
        columnId: me.id
      });

    if (cellElement) {
      me.renderer({
        value: me.editor.projectEvent.assignments,
        cellElement
      });
    }
  }

  onResourceUpdate() {
    this.grid.refreshColumn(this);
  }

  get chipView() {
    if (!this._chipView) {
      this._chipView = new ChipView({
        cls: 'b-assignment-chipview',
        itemsFocusable: false,
        closable: false,
        itemTpl: this.itemTpl,
        store: {},
        scrollable: {
          overflowX: 'hidden-scroll'
        }
      });


      Object.defineProperty(this.chipView, 'isVisible', {
        get() {
          return true;
        }

      });
    }

    return this._chipView;
  }


  itemTpl(assignment, i) {
    return `${assignment.resourceName} ${assignment.units}%`;
  }

  renderer({
             cellElement,
             value,
             isExport
           }) {
    if (isExport) {
      return value;
    } else {
      const {
        chipView
      } = this;
      chipView.store.storage.replaceValues({
        values: value.filter(a => a.resource).sort((lhs, rhs) => lhs.resourceName.localeCompare(rhs.resourceName)),
        silent: true
      });
      chipView.refresh();
      const chipCloneElement = chipView.element.cloneNode(true);
      chipCloneElement.removeAttribute('id');
      cellElement.innerHTML = '<div class="b-assignment-chipview-wrap"></di>';
      cellElement.firstElementChild.appendChild(chipCloneElement);
    }
  }

  rendererWithAvatars({
                        value,
                        isExport
                      }) {
    if (isExport) {
      return value;
    }

    const me = this,
      nbrVisible = Math.floor((me.width - me.sideMargin) / (me.imageSize + 2)),
      overflowCount = value.length > nbrVisible ? value.length - nbrVisible : 0;
    return '<div class="b-resource-avatar-container">' + Array.from(value).map((assignment, i) => {
      const {
        resource
      } = assignment;

      if (resource && i < nbrVisible) {
        const isLastOverflowing = overflowCount > 0 && i === nbrVisible - 1,
          imgMarkup = me.renderImage({
            resource,
            assignment,
            overflowCount: isLastOverflowing ? overflowCount : 0
          });

        if (isLastOverflowing) {
          return `<div class="b-overflow-img">${imgMarkup}<span class="b-overflow-count">+${overflowCount}</span></div>`;
        }

        return imgMarkup;
      }
    }).join('') + '</div>';
  }

  renderImage({
                resource,
                assignment,
                overflowCount
              }) {
    const tooltip = `${resource.name} ${assignment.units}%${overflowCount ? ` (+${overflowCount} ${this.L('more resources')})` : ''}`;
    return `<img data-btip-scroll-action="realign" data-btip="${tooltip}" class="b-resource-avatar" src="${resource.image ? this.grid.resourceImageFolderPath + resource.image : this.defaultAvatar} ">`;
  }

  onError(event) {
    const img = event.target;

    if (img.classList.contains('b-resource-avatar')) {

      if (img.getAttribute('src').endsWith(this.defaultAvatar)) {
        img.src = defaultUserImage;
      } else {
        img.src = this.defaultAvatar;
      }
    }
  }

  get defaultAvatar() {
    return this.grid.defaultResourceImageName ? this.grid.resourceImageFolderPath + this.grid.defaultResourceImageName : defaultUserImage;
  }

}

ColumnStore.registerColumnType(ResourceAssignmentColumn);
ResourceAssignmentColumn._$name = 'ResourceAssignmentColumn';


class SchedulingModeColumn extends Column {
  static get type() {
    return 'schedulingmodecolumn';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'schedulingMode',
      text: 'Scheduling Mode',
      editor: {
        type: SchedulingModePicker.type,
        allowInvalid: false,
        picker: {
          minWidth: '8.5em'
        }
      }
    };
  }

  afterConstruct() {
    const me = this;
    super.afterConstruct();


    FunctionHelper.createSequence(me.editor.updateLocalization, me.onEditorLocaleChange, me);
  }

  renderer({
             value
           }) {
    const model = this.editor.store.getById(value);
    return model && model.text || '';
  }


  onEditorLocaleChange() {
    this.grid.refreshColumn(this);
  }

}

ColumnStore.registerColumnType(SchedulingModeColumn);
SchedulingModeColumn._$name = 'SchedulingModeColumn';


class SequenceColumn extends Column {
  static get type() {
    return 'sequence';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'sequenceNumber',
      text: 'Sequence',
      sortable: false,
      groupable: false,
      filterable: false,
      width: 70,
      editor: null
    };
  }

}

ColumnStore.registerColumnType(SequenceColumn);
SequenceColumn._$name = 'SequenceColumn';


class StartDateColumn extends GanttDateColumn {
  static get type() {
    return 'startdate';
  }

  static get defaults() {
    return {
      field: 'startDate',
      text: 'Start'
    };
  }

  get defaultEditor() {
    const editorCfg = super.defaultEditor;
    editorCfg.type = 'startdate';
    return editorCfg;
  }

  get editor() {
    let editor = this.data.editor;
    const init = editor && !(editor instanceof Widget);
    editor = super.editor;

    if (editor && init) {
      editor.project = this.gantt.project;
    }

    return editor;
  }

}

ColumnStore.registerColumnType(StartDateColumn);
StartDateColumn._$name = 'StartDateColumn';


class SuccessorColumn extends DependencyColumn {
  static get type() {
    return 'successor';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      text: 'Successors',
      field: 'successors'
    };
  }

}

ColumnStore.registerColumnType(SuccessorColumn);
SuccessorColumn._$name = 'SuccessorColumn';


class TotalSlackColumn extends DurationColumn$1 {
  static get type() {
    return 'totalslack';
  }

  static get isGanttColumn() {
    return true;
  }

  get durationUnitField() {
    return 'slackUnit';
  }

  static get defaults() {
    return {
      field: 'totalSlack',
      text: 'Total Slack'
    };
  }

  canEdit(record) {
    return false;
  }

}

ColumnStore.registerColumnType(TotalSlackColumn);
TotalSlackColumn._$name = 'TotalSlackColumn';


class WBSColumn extends Column {
  static get type() {
    return 'wbs';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'wbsCode',
      text: 'WBS',
      width: 70,
      editor: null
    };
  }

}

ColumnStore.registerColumnType(WBSColumn);
WBSColumn._$name = 'WBSColumn';


var AllColumns = {
  AddNewColumn,
  CalendarColumn,
  ConstraintDateColumn,
  ConstraintTypeColumn,
  DeadlineDateColumn,
  DurationColumn: DurationColumn$1,
  EarlyEndDateColumn,
  EarlyStartDateColumn,
  EffortColumn,
  EndDateColumn,

  LateEndDateColumn,
  LateStartDateColumn,
  ManuallyScheduledColumn,
  MilestoneColumn,
  NameColumn,
  NoteColumn,
  PercentDoneColumn,
  PredecessorColumn,
  ResourceAssignmentColumn,
  RollupColumn,
  SchedulingModeColumn,
  SequenceColumn,
  ShowInTimelineColumn,
  StartDateColumn,
  SuccessorColumn,
  TotalSlackColumn,
  WBSColumn
};


class EventModeColumn extends CheckColumn {
  static get type() {
    return 'eventmode';
  }

  static get isGanttColumn() {
    return true;
  }

  static get defaults() {
    return {
      field: 'manuallyScheduled',
      align: 'left',
      text: 'Event mode'
    };
  }

  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-eventmode-cell';
  }

  renderer({
             value,
             cellElement,
             column,
             isExport
           }) {
    super.renderer(...arguments);

    if (isExport) {
      return this.renderText(value);
    } else {
      if (cellElement.widget) {
        cellElement.widget.text = this.renderText(value);
      }
    }
  }

  onCheckboxChange({
                     source,
                     checked
                   }) {
    super.onCheckboxChange(...arguments);
    source.text = this.renderText(checked);
  }

  renderText(value) {
    return value ? this.L('Manual') : this.L('Auto');
  }

}

ColumnStore.registerColumnType(EventModeColumn);
EventModeColumn._$name = 'EventModeColumn';


class AssignmentModel$2 extends AssignmentModel$1 {
}

AssignmentModel$2._$name = 'AssignmentModel';


class AssignmentStore$2 extends AssignmentStore$1 {
  static get defaultConfig() {
    return {
      modelClass: AssignmentModel$2
    };
  }

}

AssignmentStore$2._$name = 'AssignmentStore';


class DependencyModel$1 extends ProDependencyModel {


}

DependencyModel$1._$name = 'DependencyModel';


class DependencyStore$2 extends DependencyStore$1 {
  static get defaultConfig() {
    return {
      modelClass: DependencyModel$1
    };
  }

}

DependencyStore$2._$name = 'DependencyStore';


class ResourceModel$2 extends ResourceModel$1 {
}

ResourceModel$2._$name = 'ResourceModel';


class ResourceStore$2 extends ResourceStore$1 {
  static get defaultConfig() {
    return {
      modelClass: ResourceModel$2
    };
  }

}

ResourceStore$2._$name = 'ResourceStore';


class Baseline extends TimeSpan {


  static get fields() {
    return [

      {
        name: 'task',
        persist: false
      }


    ];
  }


  get isBaseline() {
    return true;
  }

  get milestone() {


    if (!this.isLeaf) {
      const {
        startDate,
        endDate
      } = this;

      if (startDate && endDate) {
        return endDate.getTime() === startDate.getTime();
      }
    }

    return this.duration === 0;
  }

  set milestone(value) {
    value ? this.convertToMilestone() : this.convertToRegular();
  }

  async setMilestone(value) {
    return value ? this.convertToMilestone() : this.convertToRegular();
  }


  async convertToMilestone() {
    return this.setDuration(0, this.durationUnit, false);
  }


  async convertToRegular() {
    if (this.milestone) {
      return this.setDuration(1, this.durationUnit, false);
    }
  }

}

Baseline._$name = 'Baseline';


const applyBaselineDefaults = (task, baselines) => {
  const {
    startDate,
    durationUnit,
    endDate
  } = task;
  return baselines ? baselines.map(baseline => Object.assign({
    task,
    startDate,
    durationUnit,
    endDate
  }, baseline)) : [];
};


class TaskModel extends PartOfProject(BuildGanttEvent(TimeSpan)) {


  static get fields() {
    return [


      {
        name: 'cls',
        serialize: value => {
          return value.isDomClassList ? value.toString() : value;
        },
        persist: true
      },


      {
        name: 'fullEffort',
        persist: false
      },


      {
        name: 'baselines'
      },

      {
        name: 'note',
        type: 'string'
      },

      {
        name: 'percentDone',
        type: 'number',
        defaultValue: 0
      }, {
        name: 'parentId',
        serialize: (value, record) => {
          const eventStore = record.getEventStore(),
            project = record.getProject();

          if (eventStore && eventStore.getById(value) === project) {
            value = null;
          }

          return value;
        }
      },


      {
        name: 'children',
        persist: false
      },

      {
        name: 'showInTimeline',
        type: 'boolean'
      },

      {
        name: 'rollup',
        type: 'boolean'
      },

      {
        name: 'deadlineDate',
        type: 'date'
      },
      {
        name: 'parentIndex',
        type: 'int',
        persist: true
      },

      'iconCls',

      'taskIconCls',

      {
        name: 'draggable',
        type: 'boolean',
        persist: false,
        defaultValue: true
      },


      {
        name: 'resizable',
        persist: false,
        defaultValue: true
      }
    ];
  }


  static get defaultConfig() {
    return {
      baselineModelClass: Baseline
    };
  }


  get isTask() {
    return true;
  }


  get hasBaselines() {
    return this.baselinesStore && this.baselinesStore.count || Boolean(this.originalData.baselines);
  }


  setBaseline(index) {
    if (index > this.baselines.count + 1) {
      throw new Error(`Attempt to set baseline ${index} when there are only ${this.baselines.count} baselines`);
    }

    if (index === this.baselines.count + 1) {
      return this.baselines.add(applyBaselineDefaults(this, [{}]));
    }

    this.baselines.getAt(index - 1).set(applyBaselineDefaults(this, [{}])[0]);
  }

  get baselines() {
    if (!this.baselinesStore) {
      this.baselinesStore = new Store({
        modelClass: this.constructor.getDefaultConfiguration().baselineModelClass,
        data: applyBaselineDefaults(this, this.originalData.baselines)
      });
    }

    return this.baselinesStore;
  }

  get successors() {
    return Array.from(this.outgoingDeps);
  }

  set successors(successors) {
    this.setOutgoingDeps(successors);
  }

  get predecessors() {
    return Array.from(this.incomingDeps);
  }

  set predecessors(predecessors) {
    this.setIncomingDeps(predecessors);
  }

  get renderedPercentDone() {
    const value = typeof this.percentDone === 'number' && !isNaN(this.percentDone) ? this.percentDone : 0;

    if (value <= 99) {
      return Math.round(value);
    }

    return Math.floor(value);
  }

  set renderedPercentDone(value) {
    this.percentDone = value;
  }

  get isDraggable() {
    return this.draggable;
  }

  get isResizable() {
    return this.resizable && !this.milestone && !this.isParent;
  }


  get isStarted() {
    return this.percentDone > 0;
  }


  get isCompleted() {
    return this.percentDone >= 100;
  }


  get isInProgress() {
    return this.isStarted && !this.isCompleted;
  }


  get milestone() {


    if (!this.isLeaf) {
      const startDate = this.startDate,
        endDate = this.endDate;

      if (startDate && endDate) {
        return endDate.getTime() === startDate.getTime();
      }
    }

    return this.duration === 0;
  }

  get isMilestone() {
    return this.milestone;
  }

  set milestone(value) {
    value ? this.convertToMilestone() : this.convertToRegular();
  }

  async setMilestone(value) {
    return value ? this.convertToMilestone() : this.convertToRegular();
  }


  async convertToMilestone() {
    return this.setDuration(0, this.durationUnit, false);
  }


  async convertToRegular() {
    const me = this;

    if (me.milestone) {
      return me.setDuration(1, me.durationUnit, false);
    }
  }


  get allDependencies() {
    return [...(this.predecessors || []), ...(this.successors || [])];
  }


  get predecessorTasks() {
    return this.predecessors.map(dependency => dependency.fromEvent);
  }


  get successorTasks() {
    return this.successors.map(dependency => dependency.toEvent);
  }


  get previousSiblingsTotalCount() {
    let task = this.previousSibling,
      count = this.parentIndex;

    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }

    return count;
  }


  get sequenceNumber() {
    let code = 0,
      task = this;


    while (task.parent) {
      code += task.previousSiblingsTotalCount + 1;
      task = task.parent;
    }

    return code;
  }


  get isSubProject() {
    return false;
  }


  get subProject() {
    const me = this;
    let project = null;

    if (me.isProject) {

      project = me;
    } else {
      me.bubbleWhile(t => {
        if (t.isProject) {
          project = t;
        }

        return !project;
      });
    }

    return project;
  }


  get fullEffort() {
    return new Duration({
      unit: this.effortUnit,
      magnitude: this.effort
    });
  }

  set fullEffort(effort) {
    this.setEffort(effort.magnitude, effort.unit);
  }


  normalize() {
  }

  inSetNormalize(field) {
  }


  setStartEndDate() {
    throw new Error('Not supported');
  }

  async tryInsertChild() {
    const result = await this.getProject().tryPropagateWithChanges(() => {
      this.insertChild(...arguments);
    });
    return result !== PropagationResult.Canceled;
  }

  copy() {
    const copy = super.copy(...arguments);
    copy.percentDone = 0;
    return copy;
  }

}

TaskModel.convertEmptyParentToLeaf = true;
TaskModel._$name = 'TaskModel';


class CalendarIntervalModel extends ProCalendarIntervalModel {
}

CalendarIntervalModel._$name = 'CalendarIntervalModel';


class CalendarModel extends ProCalendarModel {
  static get defaultConfig() {
    return {
      calendarIntervalModelClass: CalendarIntervalModel
    };
  }

}

CalendarModel._$name = 'CalendarModel';


class CalendarManagerStore$1 extends CalendarManagerStore {
  static get defaultConfig() {
    return {
      modelClass: CalendarModel
    };
  }

}

CalendarManagerStore$1._$name = 'CalendarManagerStore';

var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const CanCriticalPath = base => {
  class CanCriticalPath extends base {
    * calculateCriticalPaths() {
      const paths = [],
        pathsToProcess = [],
        events = yield this.$.childEvents;
      const eventsToProcess = [...events];
      const projectEndDate = yield this.$.endDate;
      let event;

      while (event = eventsToProcess.shift()) {
        const childEvents = yield event.$.childEvents,
          eventIsCritical = yield event.$.critical;

        if (event.endDate - projectEndDate === 0 && eventIsCritical) {
          pathsToProcess.push([{
            event
          }]);
        }

        eventsToProcess.push(...childEvents);
      }

      let path;

      while (path = pathsToProcess.shift()) {
        let taskIndex = path.length - 1,
          node;

        while (node = path[taskIndex]) {
          const criticalPredecessorNodes = [];

          for (const dependency of yield node.event.$.incomingDeps) {
            const event = yield dependency.$.fromEvent,
              eventIsCritical = event && (yield event.$.critical);

            if (eventIsCritical) {
              criticalPredecessorNodes.push({
                event,
                dependency
              });
            }
          }

          if (criticalPredecessorNodes.length) {
            const pathCopy = path.slice();
            path.push(criticalPredecessorNodes[0]);

            for (let i = 1; i < criticalPredecessorNodes.length; i++) {
              pathsToProcess.push(pathCopy.concat(criticalPredecessorNodes[i]));
            }

            taskIndex++;
          } else {
            taskIndex = -1;
          }
        }

        paths.push(path.reverse());
      }

      return paths;
    }

  }

  __decorate$j([field()], CanCriticalPath.prototype, "criticalPaths", void 0);

  __decorate$j([calculate('criticalPaths')], CanCriticalPath.prototype, "calculateCriticalPaths", null);

  return CanCriticalPath;
};

const GanttProjectMixin = base => {
  class GanttProjectMixin extends base {
    getType() {
      return ProjectType.Gantt;
    }

    getDefaultEventModelClass() {
      return GanttEvent;
    }

    * calculateStartDate() {
      const direction = yield this.$.direction;

      if (direction === Direction.Forward) {
        let result = this.$.startDate.proposedValue;
        return result || this.$.startDate.getConsistentValue() || (yield* this.unsafeCalculateInitialMinChildrenStartDateDeep());
      } else if (direction === Direction.Backward) {
        return yield* this.calculateMinChildrenStartDate();
      }
    }

    * calculateEndDate() {
      const direction = yield this.$.direction;

      if (direction === Direction.Forward) {
        return yield* this.calculateMaxChildrenEndDate();
      } else if (direction === Direction.Backward) {
        let result = this.$.endDate.proposedValue;
        return result || this.$.endDate.getConsistentValue() || (yield* this.unsafeCalculateInitialMaxChildrenEndDateDeep());
      }
    }

    * calculateEarlyStartDateConstraintIntervals() {
      const intervals = yield* super.calculateEarlyStartDateConstraintIntervals();
      const direction = yield this.$.direction;

      if (direction === Direction.Forward) {
        const startDate = yield this.$.startDate;
        startDate && intervals.push(DateInterval.new({
          startDate
        }));
      } else if (direction === Direction.Backward) {
        const startDate = yield this.$.lateStartDate;
        startDate && intervals.push(DateInterval.new({
          startDate
        }));
      }

      return intervals;
    }

    * calculateLateEndDateConstraintIntervals() {
      const intervals = yield* super.calculateLateEndDateConstraintIntervals();
      const direction = yield this.$.direction;

      if (direction === Direction.Forward) {
        const endDate = yield this.$.earlyEndDate;
        endDate && intervals.push(DateInterval.new({
          endDate
        }));
      } else if (direction === Direction.Backward) {
        const endDate = yield this.$.endDate;
        endDate && intervals.push(DateInterval.new({
          endDate
        }));
      }

      return intervals;
    }

    * unsafeCalculateInitialMinChildrenStartDateDeep() {
      const childEvents = yield this.$.childEvents;
      if (!childEvents.size) return this.startDate;
      let result = MAX_DATE,
        child;
      const toProcess = [...childEvents];

      while (child = toProcess.shift()) {
        const childDate = child.startDate;
        if (childDate && childDate < result) result = childDate;
        toProcess.push(...(yield child.$.childEvents));
      }

      return result.getTime() !== MIN_DATE.getTime() && result.getTime() !== MAX_DATE.getTime() ? result : null;
    }

    * unsafeCalculateInitialMaxChildrenEndDateDeep() {
      const childEvents = yield this.$.childEvents;
      if (!childEvents.size) return this.endDate;
      let result = MIN_DATE,
        child;
      const toProcess = [...childEvents];

      while (child = toProcess.shift()) {
        const childDate = child.endDate;
        if (childDate && childDate > result) result = childDate;
        toProcess.push(...(yield child.$.childEvents));
      }

      return result.getTime() !== MIN_DATE.getTime() && result.getTime() !== MAX_DATE.getTime() ? result : null;
    }

  }

  return GanttProjectMixin;
};
const BuildMinimalGanttProject = (base = Model) => GanttProjectMixin(CanCriticalPath(ConstrainedLateEvent(BuildMinimalProject(base))));

class MinimalGanttProject extends BuildMinimalGanttProject() {
  static get defaultConfig() {
    return {
      assignmentsData: null,
      calendarsData: null,
      dependenciesData: null,
      eventsData: null,
      resourcesData: null
    };
  }

}

MinimalGanttProject.applyConfigs = true;


class ProjectModel extends CrudManager$1(BuildMinimalGanttProject(Model)) {

  static get defaults() {
    return {


      expanded: true
    };
  }


  static get defaultConfig() {
    return {

      eventModelClass: TaskModel,


      taskModelClass: TaskModel,


      dependencyModelClass: DependencyModel$1,


      resourceModelClass: ResourceModel$2,


      assignmentModelClass: AssignmentModel$2,


      calendarModelClass: CalendarModel,


      eventStoreClass: TaskStore$1,


      taskStoreClass: TaskStore$1,


      dependencyStoreClass: DependencyStore$2,


      resourceStoreClass: ResourceStore$2,


      assignmentStoreClass: AssignmentStore$2,


      calendarManagerStoreClass: CalendarManagerStore$1,


      tasksData: null,

      eventsData: null,


      dependenciesData: null,


      resourcesData: null,


      assignmentsData: null,


      calendarsData: null,


      timeRangeStore: null,
      convertEmptyParentToLeaf: false
    };
  }

  construct(...args) {
    const config = args[0] || {};

    args[0] = config;

    if ('tasksData' in config) {
      config.eventsData = config.tasksData;
      delete config.tasksData;
    }

    if ('taskStore' in config) {
      config.eventStore = config.taskStore;
      delete config.taskStore;
    }


    config.eventModelClass = config.taskModelClass || config.eventModelClass || this.defaultEventModelClass;
    config.eventStoreClass = config.taskStoreClass || config.eventStoreClass || this.defaultEventStoreClass;

    if (!config.timeRangeStore) {
      config.timeRangeStore = {
        modelClass: TimeSpan,
        storeId: 'timeRanges'
      };
    }

    super.construct(...args);
  }

  get defaultEventModelClass() {
    return TaskModel;
  }

  get defaultEventStoreClass() {
    return TaskStore$1;
  }

  get taskStore() {
    return this.getEventStore();
  }

  get timeRangeStore() {
    return this._timeRangeStore;
  }

  set timeRangeStore(store) {
    const me = this;
    me._timeRangeStore = Store.getStore(store, Store);

    if (!me._timeRangeStore.storeId) {
      me._timeRangeStore.storeId = 'timeRanges';
    }
  }

  async tryInsertChild() {
    const result = await this.tryPropagateWithChanges(() => {
      this.insertChild(...arguments);
    });
    return result !== PropagationResult.Canceled;
  }


}

ProjectModel.applyConfigs = true;


ProjectModel._$name = 'ProjectModel';


class TaskStore$1 extends TaskStore {
  static get defaultConfig() {
    return {
      modelClass: TaskModel
    };
  }


  setBaseline(index) {
    const data = this.storage.values;
    this.forEach(task => task.setBaseline(index));
    this.trigger('refresh', {
      action: 'batch',
      records: data,
      data
    });
  }


  async indent(nodes) {
    const me = this,
      {
        taskStore,
        project
      } = me;
    let result = false;
    nodes = Array.isArray(nodes) ? nodes.slice() : [nodes];

    nodes = nodes.filter(task => !(task instanceof ProjectModel) && project.trigger('beforeIndent', {
      task
    }) !== false);


    nodes = nodes.filter(node => {
      let result;
      result = Boolean(node.previousSibling);

      while (result && !node.isRoot) {
        result = !nodes.includes(node.parent);
        node = node.parent;
      }

      return result;
    });

    if (nodes.length) {

      nodes.sort((lhs, rhs) => lhs.wbsCode < rhs.wbsCode ? -1 : lhs.wbsCode > rhs.wbsCode ? 1 : 0);

      taskStore.beginBatch();

      result = await project.tryPropagateWithChanges(() => {
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
      });

      taskStore.endBatch();

      if (result) {

        me.trigger('indent', {
          records: nodes
        });
        me.trigger('change', {
          action: 'indent',
          records: nodes
        });
      }
    }

    return result;
  }


  async outdent(nodes) {
    const me = this,
      {
        taskStore,
        project
      } = me;
    let result = false;
    nodes = Array.isArray(nodes) ? nodes.slice() : [nodes];

    nodes = nodes.filter(task => !(task instanceof ProjectModel) && project.trigger('beforeOutdent', {
      task
    }) !== false);


    nodes = nodes.filter(node => {
      let result;
      result = node.parent && !node.parent.isRoot;

      while (result && !node.isRoot) {
        result = !nodes.includes(node.parent);
        node = node.parent;
      }

      return result;
    });

    if (nodes.length) {

      nodes.sort((lhs, rhs) => lhs.wbsCode < rhs.wbsCode ? 1 : lhs.wbsCode > rhs.wbsCode ? -1 : 0);

      taskStore.beginBatch();
      result = await project.tryPropagateWithChanges(() => {
        for (const node of nodes) {
          const newChildren = node.parent.children.slice(node.parent.children.indexOf(node) + 1);
          node.parent.parent.insertChild(node, node.parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
      });
      taskStore.endBatch();

      if (result) {

        me.trigger('outdent', {
          records: nodes
        });
        me.trigger('change', {
          action: 'outdent',
          records: nodes
        });
      }
    }

    return result;
  }

}

TaskStore$1._$name = 'TaskStore';


const baselineSelector = '.b-task-baseline';


class Baselines extends TooltipBase {

  static get $name() {
    return 'Baselines';
  }

  static get defaultConfig() {
    return {
      cls: 'b-gantt-task-tooltip',
      align: 't-b',
      forSelector: baselineSelector,
      recordType: 'baseline'
    };
  }

  static get pluginConfig() {
    return {
      chain: [
        'onTaskDataGenerated',
        'render']
    };
  }


  construct(gantt, config) {
    const me = this;
    me.tipId = `${gantt.id}-baselines-tip`;
    me.gantt = gantt;
    super.construct(gantt, config);
    me.ganttDetatcher = gantt.on({
      taskDrag: 'onTaskDrag',
      afterTaskDrop: 'onAfterTaskDrop',
      thisObj: me
    });
    me.storeDetacher = gantt.taskStore.on({
      update: {
        fn: 'onStoreUpdateRecord',
        thisObj: me,
        prio: 1000
      }
    });
  }

  doDestroy() {
    this.ganttDetatcher && this.ganttDetatcher();
    this.storeDetacher && this.storeDetacher();
    super.doDestroy();
  }

  doDisable(disable) {
    const me = this,
      {
        dependencies
      } = me.client.features;

    me.client.refresh();


    if (dependencies) {
      me.client.setTimeout(() => dependencies.scheduleDraw(true), 300);
    }

    super.doDisable(disable);
  }


  onAfterTaskDrop({
                    valid
                  }) {
    if (!valid && !this.disabled) {
      this.monitorBaselineSync(300);
    }
  }


  onStoreUpdateRecord({
                        record,
                        changes
                      }) {
    if (!this.disabled && (changes.startDate || changes.endDate) && this.gantt.getElementFromTaskRecord(record)) {
      this.monitorBaselineSync(300);
    }
  }

  onTaskDrag({
               taskRecords,
               dragData
             }) {
    !this.disabled && this.updateTaskBaselines(taskRecords[0], dragData.context.newX);
  }

  updateTaskBaselines(taskRecord, left) {
    const {
      gantt
    } = this;

    if (taskRecord.baselines.count) {
      const taskElement = gantt.getElementFromTaskRecord(taskRecord, false);

      if (taskElement) {

        if (left == null) {

          left = DomHelper.getOffsetX(taskElement, gantt.timeAxisSubGridElement) + gantt.scrollLeft;
        }

        DomSync.sync({
          domConfig: this.getTaskDOMConfig(taskRecord, left),
          targetElement: taskElement.syncIdMap.baselines
        });
      }
    }
  }


  monitorBaselineSync(duration) {
    if (this.baselineMonitor) {
      this.baselineMonitor.cancel();
    }

    this.baselineMonitor = FunctionHelper.animate(duration, this.syncAllBaselines, this);
  }

  syncAllBaselines() {
    !this.isDestroyed && this.gantt.taskStore.forEach(t => this.updateTaskBaselines(t));
  }

  resolveTimeSpanRecord(forElement) {
    const task = this.client.resolveTimeSpanRecord(forElement),
      baselineElement = forElement.closest(baselineSelector);

    if (task && baselineElement) {
      return task.baselines.getAt(parseInt(baselineElement.dataset.index));
    }
  }


  template(data) {
    const me = this,
      {
        baseline
      } = data,
      {
        task
      } = baseline;
    let {
      decimalPrecision
    } = me;

    if (decimalPrecision == null) {
      decimalPrecision = me.client.durationDisplayPrecision;
    }

    const multiplier = Math.pow(10, decimalPrecision),
      displayDuration = Math.round(baseline.duration * multiplier) / multiplier;
    return `
            <div class="b-gantt-task-title">${task.name} (baseline ${baseline.parentIndex + 1})</div>
            <table>
            <tr><td>${me.L('Start')}:</td><td>${data.startClockHtml}</td></tr>
            ${baseline.milestone ? '' : `
                <tr><td>${me.L('End')}:</td><td>${data.endClockHtml}</td></tr>
                <tr><td>${me.L('Duration')}:</td><td class="b-right">${displayDuration + ' ' + DateHelper.getLocalizedNameOfUnit(baseline.durationUnit, baseline.duration !== 1)}</td></tr>
            `}
            </table>
            `;
  }

  getTaskDOMConfig(taskRecord, left) {
    const baselines = taskRecord.baselines.allRecords;
    return {
      className: `b-baseline-wrap`,
      style: {
        flex: baselines.length * 0.5
      },
      dataset: {


        taskFeature: 'baselines'
      },
      children: baselines.map((baseline, i) => {
        const baselineBox = this.gantt.taskRendering.getTaskBox(baseline);
        return baselineBox ? {
          className: baseline.cls + 'b-task-baseline',
          style: {
            width: baselineBox.width,
            left: baselineBox.left - left + 1
          },
          dataset: {
            index: i
          }
        } : null;
      }),
      syncOptions: {
        syncIdField: 'index'
      }
    };
  }

  onTaskDataGenerated({
                        taskRecord,
                        left,
                        wrapperChildren
                      }) {
    if (!this.disabled && taskRecord.hasBaselines) {
      wrapperChildren.push(this.getTaskDOMConfig(taskRecord, left));
    }
  }

}

Baselines._$name = 'Baselines';
GridFeatureManager.registerFeature(Baselines, false, 'Gantt');


class CellEdit$1 extends CellEdit {
  static get $name() {


    return 'CellEdit';
  }

  getAdjacentEditableCell(cellInfo, isForward) {
    let addNewAtEnd = this.addNewAtEnd,
      grid = this.grid,
      store = grid.store,
      rowId = cellInfo.id,
      columnId = cellInfo.columnId,
      columns = grid.columns,
      column = columns.getAdjacentLeaf(columnId, isForward);

    while (rowId) {
      const record = store.getById(rowId);

      if (column) {
        columnId = column.id;

        if (!column.hidden && column.editor && column.canEdit(record)) {
          return {
            id: rowId,
            columnId: column.id
          };
        }

        column = columns.getAdjacentLeaf(columnId, isForward);
      } else {
        let editRec = store.getAdjacent(cellInfo.id, isForward, false, true);


        if (!editRec && isForward && addNewAtEnd) {
          this.doAddNewAtEnd().then(() => {

            const startCell = this.getAdjacentEditableCell(cellInfo, true);

            if (startCell) {
              this.startEditing(startCell);
            }
          });
          this.finishEditing();
          return null;
        }

        rowId = editRec && editRec.id;

        if (editRec) {
          column = isForward ? columns.first : columns.leaves[columns.leaves.length - 1];
        }
      }
    }

    return null;
  }


  async doAddNewAtEnd() {
    const addNewAtEnd = this.addNewAtEnd,
      grid = this.grid,
      store = grid.taskStore,
      rowManager = grid.rowManager;
    const rec = store.rootNode.appendChild(Object.assign({
      name: 'New task',
      startDate: store.getProject().startDate
    }, addNewAtEnd));
    await store.getProject().propagate();


    if (!rowManager.getRowFor(rec)) {
      rowManager.displayRecordAtBottom();
    }

    return rec;
  }

}

CellEdit$1._$name = 'CellEdit';
GridFeatureManager.registerFeature(CellEdit$1, true, 'Gantt');


class CriticalPaths extends Delayable(InstancePlugin) {

  static get $name() {
    return 'CriticalPaths';
  }

  static get defaultConfig() {
    return {
      cls: 'b-gantt-critical-paths',
      criticalDependencyCls: 'b-critical',
      disabled: true
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onPaint']
    };
  }


  doDisable(disable) {
    if (disable) {
      this.unhighlightCriticalPaths();
    } else {
      this.highlightCriticalPaths();
    }

    super.doDisable(disable);
  }


  onPaint() {
    const me = this;
    me.client.project.on({
      commit: me.onProjectCommit,
      thisObj: me
    });
  }

  getDependenciesFeature() {

    return this.client.foregroundCanvas && this.client.features.dependencies;
  }

  highlightCriticalPaths() {
    const me = this,
      client = me.client,
      project = client.project,
      dependencies = me.getDependenciesFeature();

    if (client.element.classList.contains(me.cls)) {
      me.unhighlightCriticalPaths();
    }

    dependencies && project.criticalPaths && project.criticalPaths.forEach(path => {
      path.forEach(node => {
        node.dependency && dependencies.highlight(node.dependency, me.criticalDependencyCls);
      });
    });

    client.element.classList.add(me.cls);


    client.trigger('criticalPathsHighlighted');
  }

  unhighlightCriticalPaths() {
    const me = this,
      client = me.client,
      project = client.project,
      dependencies = me.getDependenciesFeature();

    if (dependencies) {
      project.dependencyStore.forEach(dependency => dependencies.unhighlight(dependency, me.criticalDependencyCls));
    }

    client.element.classList.remove(me.cls);


    client.trigger('criticalPathsUnhighlighted');
  }

  onProjectCommit({
                    records,
                    changedAtoms
                  }) {
    const {
      project
    } = this.client;

    if (!this.disabled && records.has(project) && changedAtoms.includes(project.$.criticalPaths)) {
      this.highlightCriticalPaths();
    }
  }

}

CriticalPaths._$name = 'CriticalPaths';
GridFeatureManager.registerFeature(CriticalPaths, true, 'Gantt');


const fromBoxSide$1 = ['left', 'left', 'right', 'right'],
  toBoxSide$1 = ['left', 'right', 'left', 'right'];


class Dependencies$1 extends Dependencies {

  static get $name() {
    return 'Dependencies';
  }

  static get defaultConfig() {
    return {
      terminalSides: ['left', 'right'],
      storeClass: DependencyStore$2,
      highlightDependenciesOnEventHover: true
    };
  }


  construct(gantt, config = {}) {
    const me = this;

    if (gantt.isGantt) {
      me.gantt = gantt;
    }

    if (Object.prototype.hasOwnProperty.call(config, 'pathFinderConfig')) {
      if (!Object.prototype.hasOwnProperty.call(config.pathFinderConfig, 'otherHorizontalMargin')) {
        config.pathFinderConfig.otherHorizontalMargin = 0;
      }

      if (!Object.prototype.hasOwnProperty.call(config.pathFinderConfig, 'otherVerticalMargin')) {
        config.pathFinderConfig.otherVerticalMargin = 0;
      }
    } else {
      config.pathFinderConfig = {
        otherHorizontalMargin: 0,
        otherVerticalMargin: 0
      };
    }

    super.construct(gantt, config);
  }


  getIteratableDependencyAssignments(dependency) {
    return [null];
  }

  isDependencyVisible(dependency, assignmentData = null) {
    const {
      client
    } = this;
    const from = dependency.sourceTask,
      to = dependency.targetTask;


    if (!from || !to || Object(from) !== from || Object(to) !== to) return;

    if (!(from instanceof TaskModel) || assignmentData) {
      return super.isDependencyVisible(dependency, assignmentData);
    }

    return !from.placeHolder && !from.instanceMeta(client.store).hidden && !to.placeHolder && !to.instanceMeta(client.store).hidden;
  }

  getBox(dependency, source, assignmentData = null) {
    const taskRecord = this.getTimeSpanRecordFromDependency(dependency, source);

    if (!this.gantt) {

      if (taskRecord.isEvent || assignmentData) {
        return super.getBox(dependency, source, assignmentData);
      }

      return taskRecord.assignments.length ? this.client.getResourceEventBox(taskRecord, taskRecord.assignments[0].resource, true) : null;
    }

    return this.gantt.getTaskBox(taskRecord, true, true);
  }

  getRowRecordFromDependency(dependency, source) {
    if (!this.gantt) {

      const taskRecord = this.getTimeSpanRecordFromDependency(dependency, source);

      if (taskRecord.isEvent) {
        return super.getRowRecordFromDependency(dependency, source);
      }

      return taskRecord.assignments.length ? taskRecord.assignments[0].resource : null;
    }

    return this.getTimeSpanRecordFromDependency(dependency, source);
  }


  drawLine(canvas, dependency, points, assignmentData = null, cache = true) {
    const line = super.drawLine(canvas, dependency, points, assignmentData, cache),
      {
        client
      } = this,
      to = dependency.toEvent;

    if (!to.milestone && (to.endDate <= client.startDate || client.endDate <= to.startDate) || to.milestone && (to.endDate < client.startDate || client.endDate < to.startDate)) {
      line.classList.add('b-sch-dependency-ends-outside');
    }
  }

  prepareLineDef(dependency, dependencyDrawData, assignmentData = null) {
    const me = this,
      source = me.getTimeSpanRecordFromDependency(dependency, true),
      target = me.getTimeSpanRecordFromDependency(dependency, false),
      type = dependency.type,
      arrowMargin = this.pathFinder.startArrowMargin;
    let startSide = dependency.fromSide,
      endSide = dependency.toSide;

    if (!startSide) {
      switch (true) {
        case type === DependencyType.StartToEnd:
          startSide = me.getConnectorStartSide(source);
          break;

        case type === DependencyType.StartToStart:
          startSide = me.getConnectorStartSide(source);
          break;

        case type === DependencyType.EndToStart:
          startSide = me.getConnectorEndSide(source);
          break;

        case type === DependencyType.EndToEnd:
          startSide = me.getConnectorEndSide(source);
          break;

        default:
          throw new Error('Invalid dependency type: ' + type);
      }
    }

    if (!endSide) {
      switch (true) {
        case type === DependencyType.StartToEnd:
          endSide = me.getConnectorEndSide(target);
          break;

        case type === DependencyType.StartToStart:
          endSide = me.getConnectorStartSide(target);
          break;

        case type === DependencyType.EndToStart:
          endSide = me.getConnectorStartSide(target);
          break;

        case type === DependencyType.EndToEnd:
          endSide = me.getConnectorEndSide(target);
          break;

        default:
          throw new Error('Invalid dependency type: ' + type);
      }
    }

    const {
      startRectangle,
      endRectangle
    } = dependencyDrawData;

    if (type === DependencyType.EndToStart &&
      startRectangle.bottom < endRectangle.y &&

      Math.round(startRectangle.right) - Math.round(endRectangle.x) <= 0) {

      endSide = 'top';


      if (!dependency.targetTask.milestone) {
        endRectangle.right = endRectangle.x + arrowMargin * 2;
      }
    }


    const sourceRowBox = me.client.getRecordCoords(source, true),
      targetRowBox = me.client.getRecordCoords(target, true),

      otherBoxes = [{
        start: startRectangle.x,
        end: startRectangle.right,
        top: sourceRowBox.y,
        bottom: sourceRowBox.y + sourceRowBox.height
      }, {
        start: endRectangle.x,
        end: endRectangle.right,
        top: targetRowBox.y,
        bottom: targetRowBox.y + targetRowBox.height
      }];

    return {
      endBox: {
        start: startRectangle.x,
        end: startRectangle.right,
        top: startRectangle.y,
        bottom: startRectangle.bottom
      },
      startBox: {
        start: endRectangle.x,
        end: endRectangle.right,
        top: endRectangle.y,
        bottom: endRectangle.bottom
      },
      endSide: startSide,
      startSide: endSide,
      boxesReversed: true,
      otherBoxes
    };
  }


  drawForTask(taskRecord) {
    this.drawForTimeSpan(taskRecord);
  }


  getHoverTipHtml({
                    activeTarget
                  }) {
    const me = this,
      dependencyModel = me.getDependencyForElement(activeTarget);

    if (!dependencyModel) {
      return null;
    }

    const fromTask = dependencyModel.sourceTask,
      toTask = dependencyModel.targetTask;
    return TemplateHelper.tpl`
             <table class="b-sch-dependency-tooltip">
                <tr>
                    <td>${me.L('from')}: </td>
                    <td>${fromTask.name} ${fromTask.id}</td>
                    <td><div class="b-sch-box b-${fromBoxSide$1[dependencyModel.type]}"></div></td>
                </tr>
                <tr>
                    <td>${me.L('to')}: </td>
                    <td>${toTask.name} ${toTask.id}</td>
                    <td><div class="b-sch-box b-${toBoxSide$1[dependencyModel.type]}"></div></td>
                </tr>
            </table>
        `;
  }


  createDependency(data) {
    const me = this,
      source = data.source,
      target = data.target,
      fromSide = data.sourceTerminal.dataset.side,
      toSide = data.targetTerminal.dataset.side,
      type = (fromSide === 'left' ? 0 : 2) + (toSide === 'right' ? 1 : 0);
    me.store.add({
      fromEvent: source,
      toEvent: target,
      type,
      fromSide,
      toSide
    });
    me.store.getProject().propagate();
  }


  createMarkers() {
    super.createMarkers();


    const endMarker = (this.startMarker || this.endMarker).cloneNode(true);
    endMarker.setAttribute('id', 'arrowEndCritical');
    this.client.svgCanvas.appendChild(endMarker);
  }

}

Dependencies$1._$name = 'Dependencies';
GridFeatureManager.registerFeature(Dependencies$1, true, 'Gantt');


class DependencyEditor extends Popup {
  static get $name() {
    return 'DependencyEditor';
  }

  static get defaultConfig() {
    return {
      items: [],
      draggable: {
        handleSelector: ':not(button,.b-field-inner)'

      },
      axisLock: 'flexible'
    };
  }

  processWidgetConfig(widget) {
    const dependencyEditFeature = this.dependencyEditFeature;
    let fieldConfig = {};

    if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {
      return false;
    }

    if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {
      return false;
    }

    Object.assign(widget, fieldConfig);
    return super.processWidgetConfig(widget);
  }

  afterShow(...args) {
    const deleteButton = this.widgetMap.deleteButton;

    if (deleteButton) {
      deleteButton.hidden = !this.record.isPartOfStore();
    }

    super.afterShow(...args);
  }

  onInternalKeyDown(event) {
    this.trigger('keyDown', {
      event
    });
    super.onInternalKeyDown(event);
  }

}

DependencyEditor._$name = 'DependencyEditor';


class DependencyEdit extends InstancePlugin {

  static get $name() {
    return 'DependencyEdit';
  }

  static get defaultConfig() {
    return {

      autoClose: true,


      saveAndCloseOnEnter: true,


      showDeleteButton: true,


      triggerEvent: 'dependencydblclick',


      showLagField: false,
      dependencyRecord: null,


      editorConfig: {
        title: 'L{Edit dependency}',
        localeClass: this,
        closable: true,
        items: [

          {
            type: 'display',
            localeClass: this,
            label: 'L{From}',
            editable: false,
            ref: 'fromNameField'
          },

          {
            type: 'display',
            localeClass: this,
            label: 'L{To}',
            ref: 'toNameField'
          },

          {
            type: 'combo',
            localeClass: this,
            label: 'L{Type}',
            name: 'type',
            ref: 'typeField',
            editable: false,
            valueField: 'id',
            displayField: 'name',
            items: Object.keys(DependencyModel.Type).map(type => {
              return {
                id: DependencyModel.Type[type],
                name: this.L(type)
              };
            })
          },

          {
            type: 'duration',
            localeClass: this,
            label: 'L{Lag}',
            name: 'lag',
            ref: 'lagField',
            allowNegative: true
          }],
        bbar: [{
          type: 'widget',
          cls: 'b-label-filler'
        },

          {
            color: 'b-green',
            localeClass: this,
            text: 'L{Save}',
            ref: 'saveButton'
          },

          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Delete}',
            ref: 'deleteButton'
          },

          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Cancel}',
            ref: 'cancelButton'
          }]
      }
    };
  }


  construct(client, config) {
    const me = this;
    client.dependencyEdit = me;
    me.dependencyStore = client.dependencyStore;
    super.construct(client, config);

    if (!client.features.dependencies) {
      throw new Error('Dependencies feature required when using DependencyEdit');
    }

    me.clientListenersDetacher = client.on({
      [me.triggerEvent]: me.onActivateEditor,
      thisObj: me
    });
  }

  doDestroy() {
    this.clientListenersDetacher();
    this.editor && this.editor.destroy();
    super.doDestroy();
  }


  get editorConfig() {
    return this._editorConfig;
  }

  set editorConfig(editorConfig) {
    const me = this,
      defaultEditorConfig = me.getDefaultConfiguration().editorConfig;

    editorConfig = ObjectHelper.assign({}, defaultEditorConfig, editorConfig);
    editorConfig.items = editorConfig.items || [];
    me._editorConfig = editorConfig;
  }


  get isValid() {
    return Object.values(this.editor.widgetMap).every(field => {
      if (!field.name || field.hidden) {
        return true;
      }

      return field.isValid !== false;
    });
  }

  get values() {
    const values = {};
    this.editor.eachWidget(widget => {
      if (!widget.name || widget.hidden) return;
      values[widget.name] = widget.value;
    }, true);
    return values;
  }


  onBeforeSave(dependencyRecord) {
  }


  onAfterSave(dependencyRecord) {
  }


  updateRecord(dependency) {
    const values = this.values;
    dependency.beginBatch();
    dependency.set(values);

    if (this.lagField) {
      const lag = this.lagField.value;
      dependency.setLag(lag.magnitude, lag.unit);
    }

    if (this.typeField && 'type' in values) {
      dependency.set({
        fromSide: null,
        toSide: null
      });
    }

    dependency.endBatch();
  }


  onPopupKeyDown({
                   event
                 }) {
    if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {

      event.preventDefault();
      this.onSaveClick();
    }
  }

  onSaveClick() {
    if (this.save()) {
      this.editor.hide();
    }
  }

  onDeleteClick() {
    this.deleteDependency();
    this.editor.hide();
  }

  onCancelClick() {
    this.editor.hide();
  }


  internalShowEditor(dependencyRecord) {
    const me = this,
      scheduler = me.client;
    let showPoint = me.lastPointerDownCoordinate;


    if (scheduler.trigger('beforeDependencyEdit', {
      dependencyEdit: me,
      dependencyRecord
    }) === false) {
      return;
    }

    const editor = me.getEditor(dependencyRecord);
    me.loadRecord(dependencyRecord);


    scheduler.trigger('beforeDependencyEditShow', {
      dependencyEdit: me,
      dependencyRecord,
      editor
    });

    if (!showPoint) {
      const center = Rectangle.from(me.client.element).center;
      showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];
    }

    editor.showByPoint(showPoint);
  }


  editDependency(dependencyRecord) {
    if (this.client.readOnly) return;
    this.internalShowEditor(dependencyRecord);
  }


  getEditor() {
    const me = this;
    let {
      editor
    } = me;

    if (editor) {
      return editor;
    }

    editor = me.editor = new DependencyEditor(ObjectHelper.assign({
      dependencyEditFeature: me,
      autoShow: false,
      anchor: true,
      scrollAction: 'realign',
      clippedBy: [me.client.timeAxisSubGridElement, me.client.bodyContainer],
      constrainTo: window,
      autoClose: me.autoClose,
      cls: me.cls,
      listeners: {
        keydown: me.onPopupKeyDown,
        thisObj: me
      }
    }, me.editorConfig));

    if (editor.items.length === 0) {
      console.warn('Editor configured without any `items`');
    }

    editor.eachWidget(widget => {
      const ref = widget.ref || widget.id;

      if (ref && !me[ref]) {
        me[ref] = widget;
      }
    });
    me.saveButton && me.saveButton.on('click', me.onSaveClick, me);
    me.deleteButton && me.deleteButton.on('click', me.onDeleteClick, me);
    me.cancelButton && me.cancelButton.on('click', me.onCancelClick, me);
    return me.editor;
  }


  loadRecord(dependency) {
    const me = this;
    me.fromNameField.value = dependency.sourceEvent.name;
    me.toNameField.value = dependency.targetEvent.name;

    if (me.lagField) {
      me.lagField.unit = dependency.lagUnit;
    }

    me.editor.record = me.dependencyRecord = dependency;
  }


  save() {
    const me = this,
      {
        client,
        dependencyRecord
      } = me;
    if (!dependencyRecord || !me.isValid) return;
    const dependencyStore = me.dependencyStore,
      values = me.values;


    if (client.trigger('beforeDependencySave', {
      dependencyRecord,
      values
    }) !== false) {
      me.onBeforeSave(dependencyRecord);
      me.updateRecord(dependencyRecord);

      if (dependencyStore && !dependencyRecord.stores.length) {

        if (client.trigger('beforeDependencyAdd', {
          dependencyRecord,
          dependencyEdit: me
        }) !== false) {
          dependencyStore.add(dependencyRecord);
        } else {
          return;
        }
      }

      client.project && client.project.propagate();


      client.trigger('afterDependencySave', {
        dependencyRecord
      });
      me.onAfterSave(dependencyRecord);
    }

    return dependencyRecord;
  }


  deleteDependency() {
    const me = this;


    if (me.client.trigger('beforeDependencyDelete', {
      dependencyRecord: me.dependencyRecord
    }) !== false) {
      if (me.editor.containsFocus) {
        me.editor.revertFocus();
      }

      me.client.dependencyStore.remove(me.dependencyRecord);
      me.client.project && me.client.project.propagate();
      return true;
    }

    return false;
  }


  onActivateEditor({
                     dependency,
                     event
                   }) {
    if (!this.disabled) {
      this.lastPointerDownCoordinate = [event.clientX, event.clientY];
      this.editDependency(dependency);
    }
  }

}

DependencyEdit._$name = 'DependencyEdit';
GridFeatureManager.registerFeature(DependencyEdit, false);


class DependencyEdit$1 extends DependencyEdit {

  static get $name() {
    return 'DependencyEdit';
  }

  static get defaultConfig() {
    return {

      showLagField: true
    };
  }

}

DependencyEdit$1._$name = 'DependencyEdit';
GridFeatureManager.registerFeature(DependencyEdit$1, false);


const sides = ['top', 'left', 'right', 'bottom'],
  editorAlign = {
    top: 'b-b',
    right: 'l-l',
    bottom: 't-t',
    left: 'r-r'
  },
  topBottom = {
    top: 1,
    bottom: 1
  };


class Labels extends InstancePlugin {

  static get $name() {
    return 'Labels';
  }

  static get defaultConfig() {
    return {

      labelCls: 'b-sch-label',


      top: null,


      right: null,


      bottom: null,


      left: null,
      thisObj: null,


      blurAction: 'cancel'
    };
  }

  static get pluginConfig() {
    return {};
  }


  construct(scheduler, config) {
    const me = this;

    if (scheduler.isVertical) {
      throw new Error('Labels feature is not supported in vertical mode');
    }

    me.scheduler = scheduler;
    me.labelElements = {};
    super.construct(scheduler, config);
    const {
      top,
      bottom,
      left,
      right
    } = me;

    if (top || bottom || left || right) {
      me.schedulerDetatcher = scheduler.on({
        eventpaint: 'onEventPaint',
        eventrepaint: 'onEventPaint',
        thisObj: me
      });
      me.updateHostClasslist();


    }
  }

  updateHostClasslist() {
    const {
        top,
        bottom
      } = this,
      {
        classList
      } = this.scheduler.element;
    classList.remove('b-labels-topbottom');
    classList.remove('b-labels-top');
    classList.remove('b-labels-bottom');

    if (top || bottom) {
      classList.add('b-labels-topbottom');

      if (top) {
        classList.add('b-labels-top');
      }

      if (bottom) {
        classList.add('b-labels-bottom');
      }
    }
  }

  onLabelDblClick(event) {
    const me = this,
      target = event.target;

    if (target && !me.scheduler.readOnly) {
      const {
          side
        } = target.dataset,
        labelConfig = me[side],
        {
          editor,
          field,
          recordType
        } = labelConfig;

      if (editor) {
        const eventRecord = this.scheduler.resolveEventRecord(event.target);

        if (!(editor instanceof Editor)) {
          labelConfig.editor = new Editor({
            appendTo: me.scheduler.element,
            blurAction: me.blurAction,
            inputField: editor,
            scrollAction: 'realign'
          });
        }

        labelConfig.editor.startEdit({
          target,
          align: editorAlign[side],
          matchSize: false,
          record: eventRecord,
          field
        });
        event.stopImmediatePropagation();
        return false;
      }
    }
  }

  set top(top) {
    this._top = this.processLabelSpec(top, 'top');
    this.updateHostClasslist();
  }

  get top() {
    return this._top;
  }

  set right(right) {
    this._right = this.processLabelSpec(right, 'right');
    this.updateHostClasslist();
  }

  get right() {
    return this._right;
  }

  set bottom(bottom) {
    this._bottom = this.processLabelSpec(bottom, 'bottom');
    this.updateHostClasslist();
  }

  get bottom() {
    return this._bottom;
  }

  set left(left) {
    this._left = this.processLabelSpec(left, 'left');
    this.updateHostClasslist();
  }

  get left() {
    return this._left;
  }

  processLabelSpec(labelSpec, side) {
    if (typeof labelSpec === 'function') {
      labelSpec = {
        renderer: labelSpec
      };
    } else if (typeof labelSpec === 'string') {
      labelSpec = {
        field: labelSpec
      };
    } else if (labelSpec) {
      labelSpec = Object.setPrototypeOf({}, labelSpec);
    } else {
      return;
    }

    const {
        scheduler
      } = this,
      {
        eventStore,
        resourceStore,
        taskStore,
        id
      } = scheduler,
      {
        field,
        editor
      } = labelSpec;


    if (topBottom[side]) {
      scheduler.milestoneWidth = null;
    }

    if (field) {
      let fieldDef;

      if (eventStore && !taskStore) {
        fieldDef = eventStore.modelClass.fieldMap[field];

        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = 'event';
        } else if (Reflect.has(eventStore.modelClass.prototype, field)) {
          labelSpec.recordType = 'event';
        }
      }

      if (!fieldDef && taskStore) {
        fieldDef = taskStore.modelClass.fieldMap[field];

        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = 'task';
        } else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
          labelSpec.recordType = 'task';
        }
      }

      if (!fieldDef && resourceStore) {
        fieldDef = resourceStore.modelClass.fieldMap[field];

        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = 'resource';
        } else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
          labelSpec.recordType = 'resource';
        }
      }

      if (editor) {
        if (typeof editor === 'boolean') {
          scheduler.editor = {
            type: 'textfield'
          };
        } else if (typeof editor === 'string') {
          scheduler.editor = {
            type: editor
          };
        }

        EventHelper.on({
          element: scheduler.timeAxisSubGrid.element,
          delegate: '.b-sch-label',
          dblclick: 'onLabelDblClick',
          thisObj: this
        });
      }
    }

    return labelSpec;
  }

  doDestroy() {
    this.schedulerDetatcher && this.schedulerDetatcher();
    super.doDestroy();
  }

  doDisable(disable) {
    super.doDisable(disable);

    if (this.client.isPainted) {
      this.client.refresh();
    }
  }


  onEventPaint(paintEvent) {

    DomHelper.removeEachSelector(paintEvent.element, '.b-sch-label');

    if (!this.disabled) {

      for (const side of sides) {
        if (this[side]) {
          this.appendLabel(side, paintEvent.element, paintEvent);
        }
      }
    }
  }


  appendLabel(side, appendTo, paintEvent) {
    this.labelElements[side] = DomHelper.createElement({
      tag: 'label',
      dataset: {
        side
      },
      parent: appendTo
    });
    this.updateLabel(side, paintEvent);
  }


  updateLabel(side, paintEvent) {
    const me = this,
      {
        field,
        fieldDef,
        recordType,
        renderer,
        thisObj
      } = me[side],
      labelElement = me.labelElements[side];
    let value;

    labelElement.className = `${me.labelCls} ${me.labelCls}-${side}`;

    if (renderer) {
      value = renderer.call(thisObj || me.thisObj || me, Object.assign({
        labelElement
      }, paintEvent));
    } else {
      value = paintEvent[`${recordType}Record`][field];

      if (fieldDef && fieldDef.type === 'date' && !renderer) {
        value = DateHelper.format(value, me.scheduler.displayDateFormat);
      }
    }

    labelElement.innerHTML = value || '\xa0';
  }

}

Labels.featureClass = 'b-sch-labels';
Labels._$name = 'Labels';
GridFeatureManager.registerFeature(Labels, false, 'Scheduler');

const sides$1 = ['top', 'left', 'right', 'bottom'];


class Labels$1 extends Labels {
  static get $name() {
    return 'Labels';
  }

  construct(gantt, config) {
    super.construct(gantt, config);
  }

  static get pluginConfig() {
    return {
      chain: ['onTaskDataGenerated']
    };
  }

  onTaskDataGenerated(data) {
    const me = this;

    if (!me.disabled) {

      for (const side of sides$1) {
        if (me[side]) {
          const {
            field,
            fieldDef,
            recordType,
            renderer,
            thisObj
          } = me[side];
          let value;

          if (renderer) {
            value = renderer.call(thisObj || me.thisObj || me, data);
          } else {
            value = data[`${recordType}Record`][field];

            if (fieldDef && fieldDef.type === 'date' && !renderer) {
              value = DateHelper.format(value, me.client.displayDateFormat);
            }
          }

          data.wrapperChildren.push({
            tag: 'label',
            className: `${me.labelCls} ${me.labelCls}-${side}`,
            dataset: {
              side,
              taskFeature: `label-${side}`
            },
            html: value || '\xa0'
          });
        }
      }
    }
  }

}

Labels$1._$name = 'Labels';
GridFeatureManager.registerFeature(Labels$1, false, 'Gantt');


class Indicators extends TooltipBase {

  static get $name() {
    return 'Indicators';
  }

  static get defaultConfig() {
    return {
      cls: 'b-gantt-task-tooltip',

      forSelector: '.b-indicator',
      recordType: 'indicator',
      hoverDelay: 500,
      defaultIndicators: {
        earlyDates: taskRecord => taskRecord.earlyStartDate && !taskRecord.isMilestone ? {
          startDate: taskRecord.earlyStartDate,
          endDate: taskRecord.earlyEndDate,
          cls: 'b-bottom b-early-dates',
          name: this.L('earlyDates')
        } : null,
        lateDates: taskRecord => taskRecord.lateStartDate && !taskRecord.isMilestone ? {
          startDate: taskRecord.lateStartDate,
          endDate: taskRecord.lateEndDate,
          cls: 'b-bottom b-late-dates',
          name: this.L('lateDates')
        } : null,
        constraintDate: taskRecord => taskRecord.constraintDate ? {
          startDate: taskRecord.constraintDate,
          cls: `b-bottom b-constraint-date b-constraint-type-${taskRecord.constraintType}`,
          name: this.L(taskRecord.constraintType, undefined, 'ConstraintTypePicker')
        } : null,
        deadlineDate: taskRecord => taskRecord.deadlineDate ? {
          startDate: taskRecord.deadlineDate,
          cls: `b-bottom b-deadline-date`,
          name: this.L('deadlineDate')
        } : null
      },


      items: {}
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onTaskDataGenerated', 'render']
    };
  }

  construct(gantt, config = {}) {
    this.tipId = `${gantt.id}-indicators-tip`;
    this.gantt = gantt;


    const {
      items
    } = config;
    delete config.items;
    super.construct(gantt, config);
    this.items = items;
  }

  set items(indicators) {
    const me = this;

    me._indicators = ObjectHelper.assign({}, me.defaultIndicators, indicators);

    me._indicatorAccessors = {};

    me._indicatorStatus = {};

    for (const name in me._indicators) {

      me._indicatorStatus[name] = Boolean(me._indicators[name]);

      if (typeof me._indicators[name] !== 'function') {
        me._indicators[name] = me.defaultIndicators[name];
      }


      Object.defineProperty(me._indicatorAccessors, name, {
        enumerable: true,

        get() {
          return me._indicatorStatus[name] ? me._indicators[name] : false;
        },

        set(value) {
          me._indicatorStatus[name] = value;
          me.gantt.refresh();
        }

      });
    }
  }


  get items() {

    return this._indicatorAccessors;
  }


  createIndicatorDOMConfig(indicator, index) {
    const {
        gantt,
        renderData
      } = this,
      {
        cls,
        iconCls
      } = indicator,
      x = gantt.getCoordinateFromDate(indicator.startDate),
      width = indicator.endDate ? gantt.getCoordinateFromDate(indicator.endDate) - x : null,
      classList = cls && cls.isDomClassList ? cls : new DomClassList(cls);
    return {
      className: Object.assign(classList, {
        'b-indicator': 1,
        'b-has-icon': indicator.iconCls
      }),
      style: {
        transform: `translate(${x}px, ${renderData.top}px)`,
        height: renderData.height,
        width,
        style: indicator.style
      },
      dataset: {

        taskId: `${renderData.taskId}-indicator-${index}`,
        title: indicator.name
      },
      children: [iconCls ? {
        tag: 'i',
        className: iconCls
      } : null],
      elementData: indicator
    };
  }

  onTaskDataGenerated(renderData) {
    const {
        items
      } = this,
      usedIndicators = [];

    for (const name in items) {
      const indicatorFn = items[name];

      if (this._indicatorStatus[name] && typeof indicatorFn === 'function') {
        const timeSpan = indicatorFn(renderData.taskRecord);
        timeSpan && this.gantt.timeAxis.timeSpanInAxis(timeSpan.startDate, timeSpan.endDate) && usedIndicators.push(timeSpan);
      }
    }

    renderData.extraConfigs.push(...usedIndicators.map(this.createIndicatorDOMConfig, {
      gantt: this.gantt,
      renderData
    }));
  }


  resolveTimeSpanRecord(forElement) {
    return forElement.lastDomConfig.elementData;
  }

  template(data) {
    const {
      indicator
    } = data;

    if (data.endDate) {
      return `
                ${indicator.name ? `<div class="b-gantt-task-title">${indicator.name}</div>` : ''}
                <table border="0" cellspacing="0" cellpadding="0">
                    <tr><td>${this.L('Start')}:</td><td>${data.startClockHtml}</td></tr>
                    <tr><td>${this.L('End')}:</td><td>${data.endClockHtml}</td></tr>
                </table>
            `;
    }

    return `
            ${indicator.name ? `<div class="b-gantt-task-title">${indicator.name}</div>` : ''}
            ${data.startText}
        `;
  }

}

Indicators._$name = 'Indicators';
GridFeatureManager.registerFeature(Indicators, false);


class PercentBar extends InstancePlugin {

  static get $name() {
    return 'PercentBar';
  }

  static get defaultConfig() {
    return {

      allowResize: true
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onPaint', 'onTaskDataGenerated']
    };
  }


  onPaint() {
    const me = this,
      gantt = me.client;

    if (me.resize) {
      me.resize.destroy();
    }

    me.resize = new ResizeHelper({
      name: 'percentBarResize',
      outerElement: gantt.timeAxisSubGridElement,
      targetSelector: '.b-gantt-task-percent',
      handleSelector: '.b-gantt-task-percent-handle',
      allowResize: me.isResizable.bind(me),
      dragThreshold: 0,
      listeners: {
        resizeStart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onFinishResize,
        cancel: me.onCancelResize,
        thisObj: me
      }
    });
  }

  get allowResize() {
    return this._allowResize;
  }

  set allowResize(value) {
    this._allowResize = value;
    this.client.element.classList[value ? 'remove' : 'add']('b-percentbar-drag-disabled');
  }

  doDestroy() {
    this.resize && this.resize.destroy();
    super.doDestroy();
  }

  doDisable(disable) {

    if (this.client.isPainted) {
      this.client.refresh();
    }

    super.doDisable(disable);
  }


  isResizable(el) {

    return this.allowResize && !el.closest('.b-gantt-task-parent');
  }


  cleanup(context) {
    const gantt = this.client,
      taskEl = context.element.closest(gantt.eventSelector);
    taskEl.classList.remove('b-gantt-task-percent-resizing');
    gantt.element.classList.remove('b-gantt-resizing-task-percent');
  }

  onTaskDataGenerated(taskData) {
    const {
      task,
      children
    } = taskData;

    if (!task.milestone && !this.disabled) {
      children.unshift({
        className: 'b-gantt-task-percent',
        dataset: {
          percent: Math.round(task.percentDone),
          taskBarFeature: 'percentBar'
        },
        style: {
          width: task.percentDone + '%'
        },
        children: [{
          className: 'b-gantt-task-percent-handle'
        }]
      });
    }
  }


  onResizeStart({
                  context
                }) {
    const taskEl = context.element.closest(this.client.eventSelector);
    taskEl.classList.add('b-gantt-task-percent-resizing');
    this.client.element.classList.add('b-gantt-resizing-task-percent');
  }

  onResizing({
               context
             }) {
    const el = context.element,
      taskEl = el.closest(this.client.eventSelector),
      width = el.offsetWidth === 1 ? 0 : el.offsetWidth;
    el.dataset.percent = Math.min(100, Math.round(100 * width / taskEl.offsetWidth));
  }

  onFinishResize({
                   context
                 }) {
    const me = this,
      gantt = me.client,
      el = context.element,
      taskRecord = gantt.resolveTaskRecord(el);
    me.cleanup(context);
    taskRecord.setPercentDone(parseInt(el.dataset.percent));
  }

  onCancelResize({
                   context
                 }) {
    this.cleanup(context);
  }

}

PercentBar._$name = 'PercentBar';
GridFeatureManager.registerFeature(PercentBar, true, 'Gantt');


class ProgressLine extends Delayable(InstancePlugin) {


  static get $name() {
    return 'ProgressLine';
  }

  static get defaultConfig() {
    return {

      statusDate: new Date(),


      drawLineOnlyWhenStatusDateVisible: false,
      lineCls: 'b-gantt-progress-line',
      containerCls: 'b-progress-line-canvas'
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onPaint']
    };
  }


  construct(client, config = {}) {
    const me = this;


    me.scheduleDraw = me.createOnFrame('draw', [], me, true);
    super.construct(client, config);
    this.lineSegments = [];
    client.store.on({
      refresh: me.onRowStoreRefresh,
      thisObj: me
    });
    client.rowManager.on({
      translaterow: me.onTranslateRow,
      refresh: me.scheduleDraw,
      rerender: me.scheduleDraw,
      changetotalheight: me.scheduleDraw,
      thisObj: me
    });

    client.on({
      horizontalscroll: me.scheduleDraw,
      togglenode: me.scheduleDraw,
      taskdrag: me.onTaskDrag,
      taskdragabort: me.scheduleDraw,
      aftertaskdrop: me.scheduleDraw,
      timelineviewportresize: me.scheduleDraw,
      thisObj: me
    });
  }

  doDisable(disable) {
    if (this.client.rendered) {
      this.draw();
    }

    super.doDisable(disable);
  }

  get statusDate() {
    return this._statusDate;
  }


  set statusDate(date) {
    if (date instanceof Date) {
      this._statusDate = date;
      this.scheduleDraw();
    }
  }

  getSVGCanvas() {
    const me = this,
      {
        client
      } = me;

    if (!me._svgCanvas) {
      const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

      svg.retainElement = true;
      svg.classList.add(me.containerCls);
      client.foregroundCanvas.appendChild(svg);
    }

    return me._svgCanvas;
  }

  onPaint() {
    this.client.taskStore.on({
      change: this.scheduleDraw,
      thisObj: this
    });
  }


  onRowStoreRefresh({
                      action
                    }) {
    switch (action) {
      case 'sort':
      case 'filter':
        this.scheduleDraw();
    }
  }

  onTranslateRow({
                   row
                 }) {


    if (row.lastTop >= 0 && row.top !== row.lastTop) {
      this.scheduleDraw();
    }
  }

  onTaskDrag({
               taskRecords,
               dragData
             }) {
    taskRecords.forEach(record => {
      this.updateLineForTask(record, {
        [record.id]: DateHelper.add(record.startDate, dragData.timeDiff)
      });
    });
  }


  shouldDrawProgressLine() {
    return !this.client.timeAxisSubGrid.collapsed && !this.disabled && (!this.drawLineOnlyWhenStatusDateVisible || this.client.timeAxis.dateInAxis(this.statusDate));
  }


  getStatusDateX() {
    let {
        client
      } = this,
      statusDate = this.statusDate,
      isStatusDateInAxis = client.timeAxis.dateInAxis(statusDate);

    if (!isStatusDateInAxis) {
      statusDate = statusDate < client.timeAxis.startDate ? client.timeAxis.startDate : client.timeAxis.endDate;
    }

    return client.getCoordinateFromDate(statusDate);
  }


  getRenderData() {
    const statusDateX = this.getStatusDateX(),


      viewBox = this.client.timeAxisSubGridElement.getBoundingClientRect(),
      viewXY = [this.client.scrollLeft - viewBox.left, -viewBox.top];
    return {
      statusDateX,
      viewXY
    };
  }


  draw() {
    const me = this,
      {
        client
      } = me;
    me.lineSegments.forEach(el => el.remove());
    me.lineSegments = [];

    if (!me.shouldDrawProgressLine()) {
      return;
    }

    if (client.isAnimating) {
      client.on({
        transitionend() {
          me.scheduleDraw();
        },

        once: true
      });
      return;
    }

    const data = me.getRenderData(),
      lines = [];
    client.rowManager.forEach(row => {
      lines.push(...me.getLineSegmentRenderData(row, data));
    });


    lines.forEach(line => me.drawLineSegment(line));
    client.trigger('progressLineDrawn');
  }


  updateLineForTask(taskRecord, renderData) {
    const me = this;

    if (me.disabled) {
      return;
    }

    const row = me.client.getRowFor(taskRecord);

    if (row) {
      const toRemove = [];
      me.lineSegments.forEach(el => {
        if (el.dataset.taskId == taskRecord.id) {
          toRemove.push(el);
          el.remove();
        }
      });
      ArrayHelper.remove(me.lineSegments, ...toRemove);
      me.getLineSegmentRenderData(row, me.getRenderData(), renderData).forEach(line => me.drawLineSegment(line));
    }
  }


  getLineSegmentRenderData(row, data, renderData = {}) {
    const me = this,
      {
        statusDateX,
        viewXY
      } = data,
      taskRecord = me.client.getRecordFromElement(row.elements.normal),
      taskId = taskRecord.id;
    let lineDefinitions = [],
      point;

    if (me.isStatusLineTask(taskRecord, renderData[taskRecord.id])) {
      point = me.calculateCoordinateForTask(taskRecord, viewXY);


      point && lineDefinitions.push({
        dataset: {
          taskId
        },
        x1: statusDateX,
        y1: row.top,
        x2: point.x,
        y2: point.y
      }, {
        dataset: {
          taskId
        },
        x1: point.x,
        y1: point.y,
        x2: statusDateX,
        y2: row.bottom
      });
    }

    if (!point) {
      lineDefinitions.push({
        dataset: {
          taskId
        },
        x1: statusDateX,
        y1: row.top,
        x2: statusDateX,
        y2: row.bottom
      });
    }

    return lineDefinitions;
  }


  drawLineSegment(data) {
    const me = this;
    me.lineSegments.push(DomHelper.createElement(Object.assign({
      tag: 'line',
      ns: 'http://www.w3.org/2000/svg',
      class: me.lineCls,
      parent: me.getSVGCanvas()
    }, data)));
  }


  isStatusLineTask(taskRecord, startDate) {
    const statusDate = this.statusDate;
    startDate = startDate || taskRecord.startDate;
    return taskRecord && this.client.timeAxis.isTimeSpanInAxis(taskRecord) && !taskRecord.milestone && (
      taskRecord.isInProgress ||
      !taskRecord.isStarted && startDate < statusDate ||
      taskRecord.isCompleted && startDate > statusDate);
  }


  calculateCoordinateForTask(record, translateBy) {
    const {
        client
      } = this,
      node = client.getElementFromTaskRecord(record),
      progressBarEl = node === null || node === void 0 ? void 0 : node.querySelector('.b-gantt-task-percent');

    if (progressBarEl) {
      const box = progressBarEl.getBoundingClientRect(),
        totalSize = client.timeAxisViewModel.totalSize;
      return {
        x: Math.min(box.right + translateBy[0], totalSize),
        y: box.top + box.height / 2 + translateBy[1]
      };
    }
  }

}

ProgressLine._$name = 'ProgressLine';
GridFeatureManager.registerFeature(ProgressLine);


class ProjectLines extends AbstractTimeRanges {

  static get $name() {
    return 'ProjectLines';
  }

  static get defaultConfig() {
    return {
      showHeaderElements: true,
      cls: 'b-gantt-project-line'
    };
  }


  startConfigure() {
  }


  onPaint() {
    const me = this;
    [me.startDateLine, me.endDateLine] = me.store.add([{
      name: me.L('Project Start')
    }, {
      name: me.L('Project End')
    }]);
    me.updateDateFromProject();


    me.client.project.taskStore.on({
      update: me.onProjectTaskStoreRecordUpdate,
      refresh: me.onProjectTaskStoreRefresh,
      thisObj: me
    });
    super.onPaint();
  }

  updateLocalization() {
    const me = this;

    if (me.client.rendered) {

      me.startDateLine.name = me.L('Project Start');
      me.endDateLine.name = me.L('Project End');
    }
  }

  updateDateFromProject() {
    const project = this.client.project;
    this.startDateLine.startDate = project.startDate;
    this.endDateLine.startDate = project.endDate;
  }

  onProjectTaskStoreRecordUpdate({
                                   record
                                 }) {
    if (record === this.client.project) {
      this.updateDateFromProject();
    }
  }

  onProjectTaskStoreRefresh(data) {
    this.updateDateFromProject();
  }

}

ProjectLines._$name = 'ProjectLines';
GridFeatureManager.registerFeature(ProjectLines, true, 'Gantt');


const rollupCls = 'b-task-rollup',
  rollupSelector = `.${rollupCls}`;


class Rollups extends TooltipBase {

  static get $name() {
    return 'Rollups';
  }

  static get defaultConfig() {
    return {
      cls: 'b-gantt-task-tooltip',
      align: 't-b',
      forSelector: rollupSelector
    };
  }

  static get pluginConfig() {
    return {
      chain: [
        'onTaskDataGenerated',
        'render']
    };
  }


  construct(gantt, config) {
    const me = this;
    me.tipId = `${gantt.id}-rollups-tip`;
    super.construct(gantt, config);
    me.storeDetacher = gantt.taskStore.on({
      update: 'onStoreUpdateRecord',
      thisObj: me
    });
  }

  doDestroy() {
    this.storeDetacher && this.storeDetacher();
    super.doDestroy();
  }

  doDisable(disable) {
    const me = this,
      {
        dependencies
      } = me.client.features;

    if (me.tooltip) {
      me.tooltip.disabled = disable;
    }

    me.client.refresh();


    if (dependencies) {
      me.client.setTimeout(() => dependencies.scheduleDraw(true), 300);
    }

    super.doDisable(disable);
  }

  getTipHtml({
               activeTarget,
               event
             }) {
    const {
        client
      } = this,
      task = client.resolveTaskRecord(activeTarget),
      isMs = BrowserHelper.isEdge || BrowserHelper.isIE11,
      elementsFromPointMethod = isMs ? 'msElementsFromPoint' : 'elementsFromPoint',
      rawElements = document[elementsFromPointMethod](event.pageX + window.pageXOffset, event.pageY + window.pageYOffset),

      rollupElements = Array.from(rawElements).filter(e => e.classList.contains(rollupCls)).sort((lhs, rhs) => parseInt(lhs.dataset.index, 10) - parseInt(rhs.dataset.index, 10)),
      children = [];

    for (const rollupElement of rollupElements) {
      children.push(task.children[parseInt(rollupElement.dataset.index, 10)]);
    }

    return this.template({
      task,
      children
    });
  }


  template({
             children
           }) {
    const me = this,
      {
        client
      } = me,
      pieces = [];
    children.map((child, index) => {
      const {
          startDate,
          endDate
        } = child,
        startText = client.getFormattedDate(startDate),
        endDateValue = client.getDisplayEndDate(endDate, startDate),
        endText = client.getFormattedDate(endDateValue);
      pieces.push(`<div class="b-gantt-task-title ${index ? 'b-follow-on' : ''}">${child.name}</div><table>`, `<tr><td>${me.L('Start')}:</td><td>${me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      })}</td></tr>`, `<tr><td>${me.L('End')}:</td><td>${child.isMilestone ? '' : me.clockTemplate.template({
        date: endDateValue,
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })}</td></tr></table>`);
    });
    return pieces.join('');
  }

  onStoreUpdateRecord({
                        record,
                        changes
                      }) {

    if (record.parent && (changes.rollup || changes.startDate || changes.endDate)) {
      this.client.taskRendering.redraw(record.parent);
    }
  }

  onTaskDataGenerated({
                        taskRecord,
                        left,
                        wrapperChildren
                      }) {
    if (!this.disabled && taskRecord.isParent) {
      const


        children = taskRecord.children.slice().sort((lhs, rhs) => rhs.durationMS - lhs.durationMS);
      wrapperChildren.push({
        className: `${rollupCls}-wrap`,
        dataset: {
          taskFeature: 'rollups'
        },
        children: children.map(child => {
          if (child.rollup) {
            const positionData = this.client.getSizeAndPosition(child);

            if (!positionData) {
              return null;
            }

            const {
              position,
              width
            } = positionData;
            return {
              dataset: {
                index: child.parentIndex,
                rollupTaskId: child.id
              },
              className: `${rollupCls} ${child.isMilestone ? 'b-milestone' : ''}`,
              style: {
                width: child.isMilestone ? null : width,
                left: position - left
              }
            };
          }

          return null;
        }),
        syncOptions: {
          syncIdField: 'rollupTaskId'
        }
      });
    }
  }

}

Rollups._$name = 'Rollups';
GridFeatureManager.registerFeature(Rollups, false, 'Gantt');


class TaskContextMenu extends TimeSpanRecordContextMenuBase {

  static get $name() {
    return 'TaskContextMenu';
  }

  static get defaultConfig() {
    return {

      defaultItems: {
        add: true,
        indent: true,
        outdent: true,
        deleteTask: true
      }
    };
  }

  construct(client, config) {

    client.showRemoveRowInContextMenu = false;

    if (client.features.contextMenu) {
      client.features.contextMenu.disableCellContextMenu = true;
    }

    super.construct(client, config);
  }


  resolveRecord(element) {


    return this.client.resolveTaskRecord(element) || this.client.getRecordFromElement(element);
  }


  showContextMenuFor(taskRecord, {
    targetElement,
    event
  } = {}) {
    const me = this;

    if (!taskRecord) {
      return;
    }

    if (!targetElement) {
      targetElement = me.client.getElementFromTaskRecord(taskRecord);

      if (!targetElement) {
        return;
      }
    }

    me.showContextMenu({
      menuType: 'task',
      taskElement: targetElement,
      targetElement,
      taskRecord,
      event
    });
  }

  beforeContextMenuShow(eventParams) {
    const {
        taskRecord,
        items,
        namedItems,
        selection
      } = eventParams,


      multiSelected = (eventParams.selectionIncludesContextTask = selection.includes(taskRecord)) && selection.length > 1;

    if (items.editTask) {
      items.editTask.hidden = multiSelected;
    }

    namedItems.add.hidden = multiSelected;
    namedItems.addTaskAbove.hidden = multiSelected;
    namedItems.addTaskBelow.hidden = multiSelected;
    namedItems.milestone.hidden = multiSelected;
    namedItems.subtask.hidden = multiSelected;
    namedItems.successor.hidden = multiSelected;
    namedItems.predecessor.hidden = multiSelected;
    namedItems.convertToMilestone.hidden = multiSelected;
    namedItems.predecessor.disabled = !taskRecord.previousSibling;
    namedItems.outdent.disabled = taskRecord.parent === this.client.taskStore.rootNode;
  }

  get namedItems() {
    const me = this,
      {
        client
      } = me;

    if (!me._namedItems) {
      const namedItems = me._namedItems = {
        addTaskAbove: {
          text: client.L('Task above'),
          icon: 'b-icon-up',
          onItem: ({
                     taskRecord
                   }) => {
            client.addTaskAbove(taskRecord);
          }
        },
        addTaskBelow: {
          text: client.L('Task below'),
          icon: 'b-icon-down',
          onItem: ({
                     taskRecord
                   }) => {
            client.addTaskBelow(taskRecord);
          }
        },
        milestone: {
          text: client.L('Milestone'),
          icon: 'b-fa-flag',
          name: 'milestone',
          onItem: ({
                     taskRecord
                   }) => {
            client.addMilestonBelow(taskRecord);
          }
        },
        subtask: {
          text: client.L('Sub-task'),
          name: 'subtask',
          onItem: ({
                     taskRecord
                   }) => {
            client.addSubtask(taskRecord);
          }
        },
        successor: {
          text: client.L('Successor'),
          onItem: ({
                     taskRecord
                   }) => {
            client.addSuccessor(taskRecord);
          }
        },
        predecessor: {
          text: client.L('Predecessor'),
          name: 'predecessor',
          onItem: ({
                     taskRecord
                   }) => {
            client.addPredecessor(taskRecord);
          }
        },
        deleteTask: {
          text: client.L('Delete task'),
          icon: 'b-icon-trash',
          name: 'deleteTask',
          onItem: ({
                     selectionIncludesContextTask,
                     selection,
                     taskRecord
                   }) => {


            client.taskStore.remove(selectionIncludesContextTask ? selection : taskRecord);
          }
        },
        convertToMilestone: {
          text: client.L('Convert to milestone'),
          onItem: ({
                     taskRecord
                   }) => {
            taskRecord.convertToMilestone();
          }
        },
        indent: {
          text: client.L('Indent'),
          icon: 'b-fa-indent',
          onItem: ({
                     selectionIncludesContextTask,
                     selection,
                     taskRecord
                   }) => {


            client.indent(selectionIncludesContextTask ? selection : taskRecord);
          }
        },
        outdent: {
          text: client.L('Outdent'),
          icon: 'b-fa-outdent',
          onItem: ({
                     selectionIncludesContextTask,
                     selection,
                     taskRecord
                   }) => {

            client.outdent(selectionIncludesContextTask ? selection : taskRecord);
          }
        }
      };
      namedItems.add = {
        text: client.L('Add'),
        icon: 'b-icon-add',
        menu: {
          items: {
            addTaskAbove: true,
            addTaskBelow: true,
            milestone: true,
            subtask: true,
            successor: true,
            predecessor: true
          }
        }
      };
    }

    return me._namedItems;
  }

}

TaskContextMenu.featureClass = '';
TaskContextMenu._$name = 'TaskContextMenu';
GridFeatureManager.registerFeature(TaskContextMenu, true, 'Gantt');


class TaskEditor extends GanttTaskEditor {
  static get $name() {
    return 'TaskEditor';
  }

  static get defaultConfig() {
    return {
      cls: 'b-gantt-taskeditor b-schedulerpro-taskeditor'
    };
  }

}

TaskEditor._$name = 'TaskEditor';


class TaskEdit extends ProTaskEdit {
  static get $name() {
    return 'TaskEdit';
  }

  static get defaultConfig() {
    return {

      triggerEvent: 'taskdblclick',
      saveAndCloseOnEnter: true,


      tabsConfig: null,
      editorClass: TaskEditor
    };
  }

  static get pluginConfig() {
    return {
      chain: ['getTaskMenuItems', 'onTaskEnterKey'],
      assign: ['editTask']
    };
  }


  editTask(taskRecord, element) {
    return this.editEvent(taskRecord, null, element);
  }

  onActivateEditor({
                     taskRecord,
                     taskElement
                   }) {
    this.editTask(taskRecord, taskElement);
  }

  getElementFromTaskRecord(taskRecord) {
    return this.client.getElementFromTaskRecord(taskRecord);
  }

  onTaskEnterKey({
                   taskRecord
                 }) {
    this.editTask(taskRecord);
  }

  getTaskMenuItems({
                     taskRecord,
                     items
                   }) {
    if (!this.client.readOnly) {
      items.editTask = {
        text: this.client.L('Edit'),
        icon: 'b-icon b-icon-edit',
        weight: -200,
        disabled: this.disabled,
        onItem: () => this.editTask(taskRecord)
      };
    }
  }

  onEventEnterKey({
                    taskRecord,
                    target
                  }) {
    this.editTask(taskRecord);
  }

  scrollTaskIntoView(taskRecord) {
    this.scrollEventIntoView(taskRecord);
  }

  scrollEventIntoView(eventRecord) {
    this.client.scrollTaskIntoView(eventRecord);
  }

}

TaskEdit._$name = 'TaskEdit';
GridFeatureManager.registerFeature(TaskEdit, true, 'Gantt');


class TaskTooltip extends TooltipBase {
  static get $name() {
    return 'TaskTooltip';
  }

  static get defaultConfig() {
    return {

      template(data) {
        const me = this,
          {
            taskRecord
          } = data;
        let {
          decimalPrecision
        } = me;

        if (decimalPrecision == null) {
          decimalPrecision = me.client.durationDisplayPrecision;
        }

        const multiplier = Math.pow(10, decimalPrecision),
          displayDuration = Math.round(taskRecord.duration * multiplier) / multiplier;
        return `
                    ${taskRecord.name ? `<div class="b-gantt-task-title">${taskRecord.name}</div>` : ''}
                    <table border="0" cellspacing="0" cellpadding="0">
                    <tr><td>${me.L('Start')}:</td><td>${data.startClockHtml}</td></tr>
                    ${taskRecord.milestone ? '' : `
                        <tr><td>${me.L('End')}:</td><td>${data.endClockHtml}</td></tr>
                        <tr><td>${me.L('Duration')}:</td><td class="b-right">${displayDuration + ' ' + DateHelper.getLocalizedNameOfUnit(taskRecord.durationUnit, taskRecord.duration !== 1)}</td></tr>
                        <tr><td>${me.L('Complete')}:</td><td class="b-right">${taskRecord.renderedPercentDone}%</td></tr>
                    `}
                    </table>
                `;
      },


      decimalPrecision: null,
      cls: 'b-gantt-task-tooltip'
    };
  }

}

TaskTooltip._$name = 'TaskTooltip';
GridFeatureManager.registerFeature(TaskTooltip, true, 'Gantt');


var GanttExporterMixin = (base => class GanttExporterMixin extends base {
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this,

      fgCanvasEl = me.element.querySelector('.b-sch-foreground-canvas');
    DomHelper.removeEachSelector(fgCanvasEl, '.b-gantt-task-wrap');
  }

  collectEvents(rows, config) {
    const me = this,
      addedRows = rows.length,
      {
        client
      } = config,
      normalRows = me.exportMeta.subGrids.normal.rows;
    rows.forEach((row, index) => {
      const rowConfig = normalRows[normalRows.length - addedRows + index],
        event = client.store.getAt(row.dataIndex),
        eventsMap = rowConfig[3];

      if (event.isScheduled) {
        const el = client.getElementFromTaskRecord(event, false);

        if (el && !eventsMap.has(event.id)) {
          eventsMap.set(event.id, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);
        }
      }
    });
  }

});

class MultiPageExporter$2 extends GanttExporterMixin(MultiPageExporter$1) {
}

MultiPageExporter$2._$name = 'MultiPageExporter';

class SinglePageExporter$2 extends GanttExporterMixin(SinglePageExporter$1) {
}

SinglePageExporter$2._$name = 'SinglePageExporter';


class PdfExport$2 extends PdfExport$1 {
  static get $name() {
    return 'PdfExport';
  }

  static get defaultConfig() {
    return {
      exporters: [SinglePageExporter$2, MultiPageExporter$2]
    };
  }

}

PdfExport$2._$name = 'PdfExport';
GridFeatureManager.registerFeature(PdfExport$2, false, 'Gantt');


class SubProjectModel extends ProSubProjectModel {
}

SubProjectModel._$name = 'SubProjectModel';


class TaskSegmentModel extends ProTaskSegmentModel {
}

TaskSegmentModel._$name = 'TaskSegmentModel';


const today = new Date(),
  firstDateOfThisYear = new Date(today.getFullYear(), 0, 1),
  rnd = new RandomGenerator();

function getNum(id, token) {
  return parseInt('' + id + token);
}


class ProjectGenerator {
  static generateAsync(requestedTaskCount, maxProjectSize, progressCallback = null, startDate = firstDateOfThisYear) {
    const config = {
      startDate,
      tasksData: [],
      dependenciesData: []
    };
    const blockCount = Math.ceil(requestedTaskCount / 10),
      projectSize = Math.ceil(maxProjectSize / 10),
      generator = this.generateBlocks(blockCount, projectSize, config.startDate);
    let duration = 0,
      taskCount = 0,
      dependencyCount = 0;
    return new Promise(resolve => {
      function generate() {

        for (let i = 0; i < 100; i++) {
          const res = generator.next();

          if (!res.done) {
            const block = res.value;
            config.tasksData.push(...block.tasksData);
            config.dependenciesData.push(...block.dependenciesData);

            if (block.projectDuration) {
              duration = Math.max(block.projectDuration, duration);
            }

            taskCount += block.taskCount;
            dependencyCount += block.dependencyCount;
          } else {
            progressCallback && progressCallback(taskCount, dependencyCount, true);
            config.endDate = DateHelper.add(config.startDate, Math.max(duration, 30), 'days');
            return resolve(config);
          }
        }

        progressCallback && progressCallback(taskCount, dependencyCount, false);
        setTimeout(generate, 0);
      }

      generate();
    });
  }

  static* generateBlocks(count, projectSize, startDate) {
    let currentId = 1,
      dependencyId = 1,
      projectDuration = 0,
      blockDuration = 0;

    function rndDuration(addToTotal = true) {
      const value = rnd.nextRandom(5) + 2;

      if (addToTotal) {
        blockDuration += value;
      }

      return value;
    }

    for (let i = 0; i < count; i++) {
      const blockStartId = currentId,
        block = {
          tasksData: [{
            id: currentId++,
            name: 'Parent ' + blockStartId,
            startDate,
            expanded: true,
            children: [{
              id: currentId++,
              name: 'Sub-parent ' + getNum(blockStartId, 1),
              startDate,
              expanded: true,
              children: [{
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 11),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }, {
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 12),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }, {
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 13),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }, {
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 14),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }]
            }, {
              id: currentId++,
              name: 'Sub-parent ' + getNum(blockStartId, 2),
              startDate,


              expanded: true,
              children: [{
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 21),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }, {
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 22),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }, {
                id: currentId++,
                name: 'Task ' + getNum(blockStartId, 23),
                startDate,
                duration: rndDuration(),
                percentDone: rnd.nextRandom(100)
              }]
            }]
          }],
          dependenciesData: [{
            id: dependencyId++,
            fromEvent: blockStartId + 2,
            toEvent: blockStartId + 3
          }, {
            id: dependencyId++,
            fromEvent: blockStartId + 3,
            toEvent: blockStartId + 4
          }, {
            id: dependencyId++,
            fromEvent: blockStartId + 4,
            toEvent: blockStartId + 5
          }, {
            id: dependencyId++,
            fromEvent: blockStartId + 5,
            toEvent: blockStartId + 7
          }, {
            id: dependencyId++,
            fromEvent: blockStartId + 7,
            toEvent: blockStartId + 8
          }, {
            id: dependencyId++,
            fromEvent: blockStartId + 8,
            toEvent: blockStartId + 9
          }],
          taskCount: 10,
          dependencyCount: 5
        };
      projectDuration += blockDuration;
      blockDuration = 0;
      block.projectDuration = projectDuration;

      if (i % projectSize !== 0) {
        block.dependenciesData.push({
          id: dependencyId++,
          fromEvent: blockStartId - 2,
          toEvent: blockStartId + 2
        });
        block.dependencyCount++;
      } else {
        projectDuration = 0;
      }

      currentId++;
      yield block;
    }
  }

}

ProjectGenerator._$name = 'ProjectGenerator';

const releaseEventActions$1 = {
    releaseElement: 1,

    reuseElement: 1

  },
  renderEventActions$1 = {
    newElement: 1,
    reuseOwnElement: 1,
    reuseElement: 1
  },

  horizontalTickBuffer = 100;


class NewTaskRendering extends Base {

  static get properties() {
    return {
      rowMap: new Map()
    };
  }

  construct(gantt) {
    this.gantt = gantt;
    gantt.rowManager.on({
      renderDone: 'onRenderDone',
      removeRows: 'onRemoveRows',
      beforeRowHeight: 'onBeforeRowHeightChange',
      thisObj: this
    });
    super.construct({});
  }

  init() {
  }


  bindTaskStore() {
  }

  refreshRows() {
  }

  onTimeAxisViewModelUpdate() {

    this.updateFromHorizontalScroll(this.gantt.timeAxisSubGrid.scrollable.x);
  }

  onViewportResize() {
  }

  onDragAbort() {
  }

  onBeforeRowHeightChange(event) {
    const {
      gantt
    } = this;

    if (gantt.foregroundCanvas) {

      gantt.foregroundCanvas.style.fontSize = `${(event && event.height || gantt.rowHeight) - gantt.resourceMargin * 2}px`;
    }
  }


  get visibleDateRange() {
    return this._visibleDateRange;
  }

  getVisibleDateRange() {
    return this.visibleDateRange;
  }

  getTaskBox(taskRecord, includeOutside = false, inner = false) {
    const {
      gantt
    } = this;

    if (inner) {
      const innerElement = this.getElementFromTaskRecord(taskRecord);

      if (innerElement) {
        return Rectangle.from(innerElement, gantt.timeAxisSubGridElement);
      }
    }


    if (!taskRecord.startDate || taskRecord.isTask && !gantt.taskStore.isAvailable(taskRecord)) {
      return null;
    }

    const positionData = this.getSizeAndPosition(taskRecord, includeOutside);

    if (!positionData) {
      return null;
    }

    const {
        position,
        width
      } = positionData,
      top = gantt.taskStore.indexOf(taskRecord) * gantt.rowManager.rowOffsetHeight + gantt.resourceMargin,
      height = gantt.rowHeight - gantt.resourceMargin * 2;
    return new Rectangle(position, top, width, height);
  }

  getSizeAndPosition(taskRecord, includeOutside) {
    const me = this,
      {
        gantt
      } = me,
      {
        timeAxis
      } = gantt,
      viewStart = timeAxis.startDate,
      viewEnd = timeAxis.endDate,
      taskStart = taskRecord.startDate,

      taskEnd = taskRecord.endDate || (taskRecord.duration != null ? DateHelper.add(taskStart, taskRecord.duration, taskRecord.durationUnit) : null),
      isMilestone = taskRecord.milestone,
      horizontalAdjustment = isMilestone ? gantt.features.dependencies.pathFinder.startArrowMargin : 0;
    let startCoordinate, endCoordinate;

    if (!includeOutside && (taskEnd < viewStart || taskStart > viewEnd)) {
      return null;
    }


    if (includeOutside && taskStart < viewStart) {
      startCoordinate = gantt.getCoordinateFromDate(viewStart) - horizontalAdjustment;
    } else if (includeOutside && taskStart > viewEnd) {
      startCoordinate = gantt.getCoordinateFromDate(viewEnd) + horizontalAdjustment;
    } else if (taskStart < viewStart) {
      const
        pxPerSecond = gantt.timeAxisViewModel.getSingleUnitInPixels('second'),
        secondsOutOfView = (timeAxis.startMS - taskRecord.startDateMS) / 1000,

        pxOutOfView = secondsOutOfView * pxPerSecond;
      startCoordinate = gantt.getCoordinateFromDate(viewStart) - pxOutOfView;
    } else {
      startCoordinate = gantt.getCoordinateFromDate(taskStart);
    }

    if (!isMilestone) {

      if (includeOutside && taskEnd < viewStart) {
        endCoordinate = gantt.getCoordinateFromDate(viewStart) - horizontalAdjustment;
      } else if (includeOutside && taskEnd > viewEnd) {
        endCoordinate = gantt.getCoordinateFromDate(viewEnd) + horizontalAdjustment;
      } else if (taskEnd > viewEnd) {
        const pxPerSecond = gantt.timeAxisViewModel.getSingleUnitInPixels('second'),
          secondsOutOfView = (taskRecord.endDateMS - timeAxis.endMS) / 1000,

          pxOutOfView = secondsOutOfView * pxPerSecond;
        endCoordinate = gantt.getCoordinateFromDate(viewEnd) + pxOutOfView;
      } else {
        endCoordinate = gantt.getCoordinateFromDate(taskEnd);
      }
    }

    const width = isMilestone ? 0 : endCoordinate - startCoordinate;

    if (!includeOutside && startCoordinate + width < 0) {
      return null;
    }

    return {
      position: startCoordinate,
      width
    };
  }

  getRowRegion(taskRecord, startDate, endDate) {
    const {
        gantt
      } = this,
      row = gantt.getRowFor(taskRecord);

    if (!row) {
      return null;
    }

    const rowElement = row.getElement(gantt.timeAxisSubGrid.region),
      taStart = gantt.timeAxis.startDate,
      taEnd = gantt.timeAxis.endDate,
      start = startDate ? DateHelper.max(taStart, startDate) : taStart,
      end = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
      startX = gantt.getCoordinateFromDate(start),
      endX = gantt.getCoordinateFromDate(end, true, true),
      y = row.top + gantt.scrollTop,
      x = Math.min(startX, endX),
      bottom = y + rowElement.offsetHeight;
    return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);
  }

  getDateFromXY(xy, roundingMethod, local) {
    let coord = xy[0];

    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }

    return this.gantt.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
  }

  translateToScheduleCoordinate(x) {
    const pos = x - this.gantt.timeAxisSubGridElement.getBoundingClientRect().left;
    return pos + this.gantt.scrollLeft;
  }

  translateToPageCoordinate(x) {
    const element = this.gantt.timeAxisSubGridElement;
    return x + element.getBoundingClientRect().left - element.scrollLeft;
  }


  getElementFromTaskRecord(taskRecord, inner = true) {
    const row = this.gantt.rowManager.getRowFor(taskRecord);

    if (row && this.rowMap.has(row)) {
      const wrapper = this.rowMap.get(row)[0]._element;

      if (wrapper) {
        return inner ? wrapper.syncIdMap.task : wrapper;
      }
    }

    return null;
  }


  getConnectorStartSide(taskRecord) {
    return 'left';
  }


  getConnectorEndSide(taskRecord) {
    return 'right';
  }


  onRemoveRows({
                 rows
               }) {
    rows.forEach(row => this.rowMap.delete(row));
    this.onRenderDone();
  }

  updateFromHorizontalScroll(scrollLeft) {
    const me = this,
      {
        gantt
      } = me,
      width = gantt.timeAxisSubGrid.width,
      startDate = gantt.getDateFromX(Math.max(0, scrollLeft - horizontalTickBuffer)),
      endDate = gantt.getDateFromX(scrollLeft + width + horizontalTickBuffer) || gantt.endDate,
      visibleStartDate = gantt.getDateFromX(scrollLeft),
      visibleEndDate = gantt.getDateFromX(scrollLeft + width) || gantt.endDate;


    this._visibleDateRange = {
      startDate: visibleStartDate,
      endDate: visibleEndDate
    };

    this.gantt.timeView.range = {
      startDate,
      endDate
    };
  }

  populateTaskRenderData(renderData, taskRecord) {
    const me = this,
      {
        gantt
      } = me,
      baselinesDisabled = !!(gantt.features.baselines && gantt.features.baselines.disabled);
    const taskContent = {
      className: 'b-gantt-task-content',
      dataset: {
        taskBarFeature: 'content'
      },
      children: []
    };

    if (renderData) {
      let resizable = taskRecord.isResizable === undefined ? true : taskRecord.isResizable;

      if (renderData.startsOutsideView) {
        if (resizable === true) {
          resizable = 'end';
        } else if (resizable === 'start') {
          resizable = false;
        }
      }

      if (renderData.endsOutsideView) {
        if (resizable === true) {
          resizable = 'start';
        } else if (resizable === 'end') {
          resizable = false;
        }
      }

      Object.assign(renderData, {
        iconCls: new DomClassList(taskRecord.taskIconCls),
        id: gantt.getEventRenderId(taskRecord),
        style: taskRecord.style || '',
        taskId: taskRecord.id,

        wrapperCls: new DomClassList({
          [gantt.eventCls + '-wrap']: 1,
          [`${gantt.eventCls}-parent`]: taskRecord.isParent,
          'b-milestone-wrap': taskRecord.milestone,
          'b-has-baselines': taskRecord.hasBaselines && !baselinesDisabled
        }),


        cls: taskRecord.isResourceTimeRange ? new DomClassList() : taskRecord.cls.clone(),

        extraConfigs: []
      });


      Object.assign(renderData.cls, {
        [gantt.eventCls]: 1,
        [gantt.generatedIdCls]: taskRecord.hasGeneratedId,
        [gantt.dirtyCls]: taskRecord.modifications,
        [gantt.committingCls]: taskRecord.isCommitting,
        [gantt.endsOutsideViewCls]: renderData.endsOutsideView,
        [gantt.startsOutsideViewCls]: renderData.startsOutsideView,
        [gantt.fixedEventCls]: taskRecord.isDraggable === false,
        [`b-sch-event-resizable-${resizable}`]: 1,
        'b-milestone': taskRecord.milestone,
        'b-critical': taskRecord.critical,
        'b-task-started': taskRecord.percentDone > 0,
        'b-task-finished': taskRecord.isCompleted,
        'b-task-selected': gantt.selectedRecords.includes(taskRecord)
      });
      const eventStyle = taskRecord.eventStyle || gantt.eventStyle,
        eventColor = taskRecord.eventColor || gantt.eventColor;
      renderData.eventColor = eventColor;
      renderData.eventStyle = eventStyle;

      if (gantt.taskRenderer) {

        const value = gantt.taskRenderer.call(gantt.taskRendererThisObj || gantt, {
          taskRecord,
          tplData: renderData,
          renderData
        });

        if (typeof renderData.cls === 'string') {
          renderData.cls = new DomClassList(renderData.cls);
        }

        if (typeof renderData.iconCls === 'string') {
          renderData.iconCls = new DomClassList(renderData.iconCls);
        }

        let childContent = null;

        if (typeof value === 'string' && value.includes('<')) {
          childContent = {
            html: value
          };
        } else if (typeof value === 'string' || typeof value === 'object') {
          childContent = value;
        } else if (value != null) {
          childContent = String(value);
        }

        if (childContent) {
          taskContent.children.push(childContent);
          renderData.cls.add('b-has-content');
        }
      }

      renderData.cls['b-sch-event-withicon'] = renderData.iconCls.length;

      renderData.wrapperCls[`b-sch-style-${renderData.eventStyle}`] = renderData.eventStyle;

      if (renderData.eventColor && renderData.eventColor.startsWith('#')) {
        renderData.style = `background-color:${renderData.eventColor};` + renderData.style;
      } else {
        renderData.wrapperCls[`b-sch-color-${renderData.eventColor}`] = renderData.eventColor;
      }

      if (renderData.iconCls && renderData.iconCls.length) {
        taskContent.children.unshift({
          tag: 'i',
          className: renderData.iconCls
        });
      }

      if (taskContent.children.length) {
        renderData.children.push(taskContent);
      }
    }

    renderData.taskContent = taskContent;
    renderData.wrapperChildren = [];

    gantt.onTaskDataGenerated(renderData);
  }

  renderer({
             row,
             record: taskRecord
           }) {
    const me = this,
      box = me.getTaskBox(taskRecord);


    if (!box) {
      me.rowMap.delete(row);
      return;
    }

    const data = {
      top: box.top,
      left: box.left,
      width: box.width,
      height: box.height,
      taskRecord,
      task: taskRecord,

      row,
      children: []
    };
    me.populateTaskRenderData(data, taskRecord);
    const config = {
      className: data.wrapperCls,
      tabIndex: '0',
      children: [{
        className: data.cls,
        style: (data.internalStyle || '') + (data.style || ''),
        children: data.children,
        dataset: {


          taskFeature: 'task'
        },
        syncOptions: {
          syncIdField: 'taskBarFeature'
        }
      }, ...data.wrapperChildren],
      style: {
        transform: `translate(${data.left}px, ${data.top}px)`,

        height: data.height,
        width: data.width,
        zIndex: data.zIndex
      },
      dataset: {
        taskId: data.taskId
      },

      elementData: data,

      syncOptions: {
        syncIdField: 'taskFeature',

        releaseThreshold: 0
      }
    };
    me.gantt.trigger('beforeRenderTask', {
      renderData: data,
      domConfig: config
    });

    me.rowMap.set(row, [config, ...data.extraConfigs]);
  }

  onRenderDone() {
    const {
        gantt
      } = this,
      configs = Array.from(this.rowMap.values()).flat();

    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: configs
      },
      targetElement: gantt.foregroundCanvas,
      syncIdField: 'taskId',


      callback({
                 action,
                 domConfig,
                 lastDomConfig,
                 element
               }) {

        if (action !== 'none' && domConfig && domConfig.className && domConfig.className[gantt.eventCls + '-wrap']) {
          const

            isRelease = releaseEventActions$1[action],
            isRender = renderEventActions$1[action];

          if (isRelease && lastDomConfig) {
            const event = {
              renderData: lastDomConfig.elementData,
              taskRecord: lastDomConfig.elementData.taskRecord,
              element
            };

            gantt.trigger('releaseTask', event);
          }

          if (isRender) {
            const event = {
              renderData: domConfig.elementData,
              taskRecord: domConfig.elementData.taskRecord,
              element
            };
            event.reusingElement = action === 'reuseElement';

            gantt.trigger('renderTask', event);
          }
        }
      }

    });
  }

  redraw(taskRecord) {
    const row = this.gantt.rowManager.getRowFor(taskRecord);

    if (row) {
      const cell = row.getCell(this.gantt.timeAxisColumn.id);

      if (cell) {

        row.renderCell(cell);

        this.onRenderDone();
      }
    }
  }

}

NewTaskRendering._$name = 'NewTaskRendering';


const hyphenRe$1 = /-/g;


var GanttDom = (Target => class GanttDom extends (Target || Base) {

  resolveEventRecord(element) {
    return this.resolveTaskRecord(element);
  }


  resolveTaskRecord(element) {
    element = DomHelper.up(element, this.eventSelector);

    if (!element) {
      return null;
    }

    return this.taskStore.getById(element.dataset.taskId);
  }


  getElementFromTaskRecord(taskRecord, inner = true) {
    return this.taskRendering.getElementFromTaskRecord(taskRecord, inner);
  }


  getElementFromEventRecord(eventRecord) {
    return this.getElementFromTaskRecord(eventRecord);
  }


  getEventRenderId(taskRecord) {

    return `${this.id.toString().replace(hyphenRe$1, '_')}-${taskRecord.id}`;
  }


  getEventData(event) {
    const me = this,
      record = me.resolveTimeSpanRecord(event.target);

    if (record) {
      const cellElement = me.getCell({
          record,
          column: me.timeAxisColumn
        }),
        cellData = DomDataStore.get(cellElement),
        id = cellData.id,
        columnId = cellData.columnId;
      return {
        cellElement,
        cellData,
        columnId,
        id,
        record,
        cellSelector: {
          id,
          columnId
        }
      };
    } else {
      return super.getEventData(event);
    }
  }


  get widgetClass() {
  }

});


var GanttRegions = (Target => class GanttRegions extends (Target || Base) {

  getScheduleRegion(taskRecord, local) {
    const me = this,
      element = me.timeAxisSubGridElement;
    let region;

    if (taskRecord) {
      const taskElement = me.getElementFromTaskRecord(taskRecord);
      region = Rectangle.from(me.getRowById(taskRecord.id).getElement('locked'));

      if (taskElement) {
        const taskRegion = Rectangle.from(taskElement, element);
        region.y = taskRegion.y;
        region.bottom = taskRegion.bottom;
      } else {
        region.y = region.y + me.barMargin;
        region.bottom = region.bottom - me.barMargin;
      }
    } else {


      region = Rectangle.from(element).moveTo(null, 0);
      region.width = element.scrollWidth;
      region.y = region.y + me.barMargin;
      region.bottom = region.bottom - me.barMargin;
    }

    const taStart = me.timeAxis.startDate,
      taEnd = me.timeAxis.endDate,
      dateConstraints = me.getDateConstraints(taskRecord) || {
        start: taStart,
        end: taEnd
      },
      top = region.y,
      bottom = region.bottom;
    let startX = me.getCoordinateFromDate(DateHelper.max(taStart, dateConstraints.start)),
      endX = me.getCoordinateFromDate(DateHelper.min(taEnd, dateConstraints.end));

    if (!local) {
      startX = me.translateToPageCoordinate(startX);
      endX = me.translateToPageCoordinate(endX);
    }

    return {
      top,
      right: Math.max(startX, endX),
      bottom,
      left: Math.min(startX, endX)
    };
  }

  translateToPageCoordinate(x) {
    const element = this.timeAxisSubGridElement;
    return x + element.getBoundingClientRect().left - element.scrollLeft;
  }

  isRowVisible(taskRecord) {

    return this.store.indexOf(taskRecord) >= 0;
  }


  getTaskBox(taskRecord, includeOutside = false, inner = false) {
    return this.taskRendering.getTaskBox(...arguments);
  }

  getSizeAndPosition() {
    return this.taskRendering.getSizeAndPosition(...arguments);
  }


  get widgetClass() {
  }

});


const defaultScrollOptions$4 = {
  block: 'nearest',
  edgeOffset: 20
};


var GanttScroll = (Target => class GanttScroll extends (Target || Base) {

  scrollTaskIntoView(taskRecord, options = defaultScrollOptions$4) {
    let el,
      taskStart = taskRecord.startDate,
      taskEnd = taskRecord.endDate;
    const me = this;

    if (options.edgeOffset == null) {
      options.edgeOffset = 20;
    }

    if (!taskRecord.isScheduled) {
      return this.scrollRowIntoView(taskRecord, options);
    }

    taskStart = taskStart || taskEnd;
    taskEnd = taskEnd || taskStart;
    const taskIsOutside = taskStart < me.timeAxis.startDate | (taskEnd > me.timeAxis.endDate) << 1;


    if (taskIsOutside && options.extendTimeAxis !== false) {
      const currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate;
      let startAnchorPoint, endAnchorPoint;

      if (taskIsOutside === 3) {
        me.timeAxis.setTimeSpan(new Date(taskStart.valueOf() - currentTimeSpanRange / 2), new Date(taskEnd.getTime() + currentTimeSpanRange / 2));
      } else {
        startAnchorPoint = me.getCoordinateFromDate(taskIsOutside & 1 ? taskEnd : taskStart);

        if (taskIsOutside & 1) {
          me.timeAxis.setTimeSpan(new Date(taskStart), new Date(taskStart.valueOf() + currentTimeSpanRange));
        } else {
          me.timeAxis.setTimeSpan(new Date(taskEnd.valueOf() - currentTimeSpanRange), new Date(taskEnd));
        }

        endAnchorPoint = taskIsOutside & 1 ? me.getCoordinateFromDate(taskEnd) : me.getCoordinateFromDate(taskStart);
        me.timeAxisSubGrid.scrollable.scrollBy(endAnchorPoint - startAnchorPoint);
      }
    }

    el = me.getElementFromTaskRecord(taskRecord);

    if (el) {
      const scroller = me.timeAxisSubGrid.scrollable;


      return scroller.scrollIntoView(el, ObjectHelper.assign({
        silent: true
      }, options));
    } else {

      return me.scrollUnrenderedTaskIntoView(taskRecord, options);
    }
  }


  scrollUnrenderedTaskIntoView(taskRec, options = defaultScrollOptions$4) {
    if (options.edgeOffset == null) {
      options.edgeOffset = 20;
    }

    const me = this,
      scroller = me.timeAxisSubGrid.scrollable,
      box = me.getTaskBox(taskRec),
      scrollerViewport = scroller.viewport,
      targetRect = box.translate(scrollerViewport.x - scroller.x, scrollerViewport.y - scroller.y);
    let result = scroller.scrollIntoView(targetRect, Object.assign({}, options, {
      highlight: false
    }));

    if (options.highlight || options.focus) {
      const detacher = me.on({
        renderTask({
                     taskRecord,
                     element
                   }) {
          if (taskRecord === taskRec) {
            detacher();
            result = result.then(() => {
              options.highlight && DomHelper.highlight(element);
              options.focus && element.focus();
            });
          }
        }

      });
    } else {

      result = Promise.all([result, new Promise(resolve => {
        const detacher = me.on({
          renderTask({
                       taskRecord
                     }) {
            if (taskRecord === taskRec) {
              detacher();
              resolve();
            }
          }

        });
      })]);
    }

    return result;
  }


  get widgetClass() {
  }

});


const copyProperties$1 = ['barMargin', 'tickSize', 'zoomLevel', 'startDate', 'endDate'];


var GanttState = (Target => class GanttState extends (Target || Base) {

  getState() {
    return ObjectHelper.copyProperties(super.getState(), this, copyProperties$1);
  }


  applyState(state) {
    ObjectHelper.copyProperties(this, state, copyProperties$1);
    super.applyState(state);
  }


  get widgetClass() {
  }

});


var GanttStores = (Target => class GanttStores extends (Target || Base) {

  get project() {
    return this._project;
  }

  set project(project) {
    this._project = project;
    this.onTaskStoreChange(project.eventStore);
  }


  set tasks(tasks) {
    this.taskStore.data = tasks;
  }


  get eventStore() {
    return this.project.eventStore;
  }


  get taskStore() {
    return this.eventStore;
  }

  onTaskStoreChange(taskStore) {
    const me = this;

    taskStore.metaMapId = me.id;

    me.store = me.timeAxisViewModel.store = taskStore;
    me.dependencyStore = this.project.dependencyStore;


    if (me.features.dependencies) me.features.dependencies.store = me.dependencyStore;
    me.currentOrientation.bindTaskStore(taskStore);

  }


  get assignmentStore() {
    return this.project.assignmentStore;
  }

  bindAssignmentStore(assignmentStore, initial) {
  }


  get resourceStore() {
    return this.project.resourceStore;
  }

  bindResourceStore(resourceStore, initial) {
  }


  get widgetClass() {
  }

});


var GanttTimelineDateMapper = (Target => class GanttTimelineDateMapper extends (Target || Base) {

  getDisplayEndDate(endDate, startDate) {
    return endDate;
  }


  get widgetClass() {
  }

});


var TaskNavigation = (Target => class TaskNavigation extends (Target || Base) {
  static get defaultConfig() {
    return {
      navigator: {
        inlineFlow: false,
        prevKey: 'ArrowUp',
        nextKey: 'ArrowDown',
        keys: {
          ArrowLeft: () => {
          },
          ArrowRight: () => {
          },
          Enter: 'onTaskEnterKey'
        }
      }
    };
  }

  processEvent(event) {
    const me = this,
      eventElement = DomHelper.up(event.target, me.eventSelector);

    if (!me.navigator.disabled && eventElement) {
      event.taskRecord = event.eventRecord = me.resolveTaskRecord(eventElement);

      if (event.type === 'click') {
        me.selectEvent(event.taskRecord, event.ctrlKey || event.metaKey);
      }
    }

    return event;
  }

  selectEvent(record, preserveSelection = false) {

    this.selectRow({
      record: record.id,
      column: false,
      addToSelection: preserveSelection
    });
  }

  deselectEvent(record) {
    this.deselectRow(record.id);
  }

  getNext(taskRecord) {
    const me = this,
      {
        taskStore
      } = me;

    for (let rowIdx = taskStore.indexOf(taskRecord) + 1; rowIdx < taskStore.count; rowIdx++) {
      const nextTask = taskStore.getAt(rowIdx);

      if (me.isInTimeAxis(nextTask)) {
        return nextTask;
      }
    }
  }

  getPrevious(taskRecord) {
    const me = this,
      {
        taskStore
      } = me;

    for (let rowIdx = taskStore.indexOf(taskRecord) - 1; rowIdx >= 0; rowIdx--) {
      const prevTask = taskStore.getAt(rowIdx);

      if (me.isInTimeAxis(prevTask)) {
        return prevTask;
      }
    }
  }

  navigateTo(targetEvent, uiEvent = {}) {
    const me = this;

    if (targetEvent) {

      me.navigator.disabled = true;
      me.scrollTaskIntoView(targetEvent, {
        animate: 100
      }).then(() => {
        me.navigator.disabled = false;
        me.activeEvent = targetEvent;
        me.navigator.trigger('navigate', {
          event: uiEvent,
          item: me.getElementFromTaskRecord(targetEvent).parentNode
        });
      });
    }
  }

  clearEventSelection() {
    this.deselectAll();
  }

  onTaskEnterKey() {
  }


  get widgetClass() {
  }

});

const locale$5 =  locale_zh.locale$5

for (const i in locale$4) {
  locale$5[i] = locale$4[i];
}
LocaleManagerSingelton.registerLocale('En', {
  desc: 'English',
  locale: locale$5
});


const emptyObject$4 = Object.freeze({});
let newTaskCount = 0;


class GanttBase extends base(TimelineBase).mixes(CrudManagerView, GanttDom, GanttRegions, GanttScroll, GanttState, GanttStores, GanttTimelineDateMapper, EventNavigation, TaskNavigation) {


  static get $name() {
    return 'GanttBase';
  }

  static get defaultConfig() {
    return {
      project: null,
      resourceImageFolderPath: null,
      defaultResourceImageName: null,
      calendars: null,
      resources: null,
      tasks: null,
      dependencies: null,
      assignments: null,
      eventCls: 'b-gantt-task',
      eventBarTextField: null,
      eventLayout: 'none',
      eventSelectionDisable: true,
      eventColor: null,
      eventStyle: null,
      rowHeight: 45,
      scheduledEventName: 'task',
      eventScrollMode: 'move',
      overScheduledEventClass: 'b-gantt-task-hover',
      mode: 'horizontal',
      timeCellCls: 'b-sch-timeaxis-cell',
      timeCellSelector: '.b-sch-timeaxis-cell',
      focusCls: 'b-active',
      durationDisplayPrecision: 1,
      taskRenderer: null,
      localeClass: 'Gantt'
    };
  }
  get isGantt() {
    return true;
  }
  construct(config) {
    const me = this,
      hasInlineStores = Boolean(config.calendars || config.taskStore || config.dependencyStore || config.resourceStore || config.assignmentStore),
      hasInlineData = Boolean(config.calendars || config.tasks || config.dependencies || config.resources || config.assignments);

    if (!config.features) {
      config.features = {};
    }
    if (!('tree' in config.features)) {
      config.features.tree = true;
    }
    let project = config.project;
    if (project && (hasInlineStores || hasInlineData)) {
      throw new Error('Providing both project and inline data is not supported');
    }
    if (!(project instanceof ProjectModel)) {
      project = config.project = new ProjectModel(ObjectHelper.assign({
        calendarsData: config.calendars,
        eventsData: config.tasks,
        dependenciesData: config.dependencies,
        resourcesData: config.resources,
        assignmentsData: config.assignments,
        resourceStore: config.resourceStore,
        eventStore: config.taskStore,
        assignmentStore: config.assignmentStore,
        dependencyStore: config.dependencyStore,
        timeRangeStore: config.timeRangeStore
      }, project));
      delete config.resourceStore;
      delete config.taskStore;
      delete config.assignmentStore;
      delete config.dependencyStore;
      delete config.timeRangeStore;
      delete config.calendars;
      delete config.resources;
      delete config.tasks;
      delete config.assignments;
      delete config.dependencies;
    }
    project.getEventStore().on({
      add: me.onTaskStoreAddOrRemove,
      remove: me.onTaskStoreAddOrRemove,
      prio: -1,
      thisObj: me
    });
    project.on({
      eventstorechanged: me.onTaskStoreChange,
      refresh: me.onProjectRefresh,
      load: me.onProjectLoad,
      commit: me.onProjectCommit,
      prio: 1000,
      thisObj: me
    });
    config.crudManager = project;
    super.construct(config);
    if (me.features.cellEdit) {
      me.features.cellEdit.addNewAtEnd = {
        name: me.L('New Task'),
        startDate: project.startDate,
        duration: 1,
        durationUnit: me.timeAxis.unit
      };
    }
    me.on('taskclick', me.onTaskBarClick, me);
  }

  get columns() {
    return super.columns;
  }

  set columns(columns) {
    if (columns) {
      let cols = columns;

      if (!Array.isArray(columns)) {
        cols = columns.data;

        this._thisIsAUsedExpression(this.taskStore);
      }

      if (!cols.some(column => {
        const constructor = column instanceof Column ? column.constructor : ColumnStore.getColumnClass(column.type) || Column;
        return constructor === NameColumn || constructor.prototype instanceof NameColumn;
      })) {
        cols.unshift({
          type: 'name'
        });
      }
    }

    super.columns = columns;
  }

  set timeAxisViewModel(timeAxisViewModel) {
    super.timeAxisViewModel = timeAxisViewModel;

    if (this.taskStore) {
      this.timeAxisViewModel.store = this.taskStore;
    }
  }

  get timeAxisViewModel() {
    return super.timeAxisViewModel;
  }


  onStoreUpdateRecord(params) {
    if (!this.project.isPropagating()) {
      let result;
      this.runWithTransition(() => {
        result = super.onStoreUpdateRecord(params);
      });
      return result;
    }
  }

  onProjectCommit({
                    records
                  }) {
    if (this.isPainted) {
      const {
          rowManager
        } = this,
        rows = [];

      for (const record of records) {
        if (record.isTask && this.taskStore.isAvailable(record)) {
          const row = rowManager.getRowFor(record);

          if (row) {
            rows.push(row);
          }
        }
      }

      rows.sort((a, b) => a.index - b.index);
      this.runWithTransition(() => {
        rowManager.renderRows(rows);
      });
    }
  }

  onTaskStoreAddOrRemove({
                           isExpand,
                           isCollapse
                         }) {


    if (!isExpand && !isCollapse && !this.project.stm.isRestoring) {


      if (!this.project.isPropagating()) {
        this.project.propagate();
      }
    }
  }

  onProjectRefresh() {
    this.refreshRows();

    const dependencyFeature = this.features.dependencies;


    this.dependencies.forEach(dep => dependencyFeature.addToGridCache(dep));
  }

  onProjectLoad() {
    const me = this;

    if (!('startDate' in me.initialConfig) && me.project.startDate) {
      me.startDate = me.project.startDate;
    }
  }

  onTaskDataGenerated() {
  }

  onTaskBarClick({
                   taskRecord
                 }) {
    if (!taskRecord.isLeaf) {
      this.toggleCollapse(taskRecord);
    }
  }


  triggerChangeEvent(selectionChangeEvent, silent) {
    super.triggerChangeEvent(selectionChangeEvent, silent);
    const me = this;

    function setTaskSelection(record, selected) {
      const taskElement = me.getElementFromTaskRecord(record);

      if (taskElement) {
        taskElement.classList[selected ? 'add' : 'remove']('b-task-selected');
      }
    }

    if (selectionChangeEvent.mode === 'row') {
      selectionChangeEvent.selected.map(record => setTaskSelection(record, true));
      selectionChangeEvent.deselected.map(record => setTaskSelection(record, false));
    }
  }


  toggleEmptyText() {
    if (this.bodyContainer) {
      DomHelper.toggleClasses(this.bodyContainer, 'b-grid-empty', !(this.rowManager.rowCount || this.project.isLoadingOrSyncing));
    }
  }

  get currentOrientation() {
    const me = this;

    if (!me._currentOrientation) {

      me.taskRendering = me._currentOrientation = new NewTaskRendering(me);
    }

    return me._currentOrientation;
  }

  getTimeSpanMouseEventParams(taskElement, event) {
    const taskRecord = this.resolveTaskRecord(taskElement);
    return !taskRecord ? null : {
      taskRecord,
      taskElement,
      event
    };
  }

  getScheduleMouseEventParams(cellData) {
    return {
      taskRecord: this.store.getById(cellData.id)
    };
  }

  resolveTimeSpanRecord(element) {
    return this.resolveTaskRecord(element);
  }

  repaintEventsForResource(taskRecord) {
    this.taskRendering.redraw(taskRecord);
  }


  async addTask(referenceTask, options = emptyObject$4) {
    const me = this,
      {
        milestone,
        above,
        asChild,
        asPredecessor,
        asSuccessor
      } = options,
      project = me.store.getProject(),
      parent = referenceTask.parent,
      newRecord = referenceTask.copy();

    if (milestone) {
      newRecord.name = `${me.L('New milestone')} ${++newTaskCount}`;
    } else {
      newRecord.name = `${me.L('New task')} ${++newTaskCount}`;
    }

    if (asChild) {
      referenceTask.insertChild(newRecord, referenceTask.firstChild);
    } else if (above) {
      referenceTask.parent.insertChild(newRecord, referenceTask);
    } else {
      parent.insertChild(newRecord, referenceTask.nextSibling);
    }

    if (milestone) {
      await project.waitForPropagateCompleted();
      await newRecord.convertToMilestone();
    } else {

      if (!project.isPropagating()) {
        await project.propagate();
      }
    }


    if (asSuccessor) {
      me.dependencyStore.add({
        fromEvent: referenceTask,
        toEvent: newRecord,
        type: DependencyType.EndToStart,
        fromSide: 'right',
        toSide: 'left'
      });
    } else if (asPredecessor) {
      me.dependencyStore.add({
        fromEvent: newRecord,
        toEvent: referenceTask,
        type: DependencyType.EndToStart,
        fromSide: 'right',
        toSide: 'left'
      });
    }

    if (asSuccessor || asPredecessor) {

      await project.propagate();
    }

    return newRecord;
  }

  addTaskAbove(taskRecord) {
    return this.addTask(taskRecord, {
      above: true
    });
  }

  addTaskBelow(taskRecord) {
    return this.addTask(taskRecord);
  }

  addMilestonBelow(taskRecord) {
    return this.addTask(taskRecord, {
      milestone: true
    });
  }

  addSubtask(taskRecord) {
    const result = this.addTask(taskRecord, {
      asChild: true
    });
    this.toggleCollapse(taskRecord, false);
    return result;
  }

  addSuccessor(taskRecord) {
    return this.addTask(taskRecord, {
      asSuccessor: true
    });
  }

  addPredecessor(taskRecord) {
    return this.addTask(taskRecord, {
      above: true,
      asPredecessor: true
    });
  }


  async indent(nodes) {
    const me = this,
      result = await me.taskStore.indent(nodes);

    if (result === PropagationResult.Canceled) {
      Toast.show(me.L('changeRejected'));
    }

    return result;
  }


  async outdent(nodes) {
    const me = this,
      result = await me.taskStore.outdent(nodes);

    if (result === PropagationResult.Canceled) {
      Toast.show(me.L('changeRejected'));
    }

    return result;
  }

}

GanttBase.localeClass = 'Gantt';
GanttBase._$name = 'GanttBase';
BryntumWidgetAdapterRegister.register('ganttbase', GanttBase);
VersionHelper.setVersion('gantt', '2.1.4');


class TaskDrag extends DragBase {

  static get $name() {
    return 'TaskDrag';
  }

  static get defaultConfig() {
    return {

      validatorFn: (taskRecords, date, duration, e) => true,


      validatorFnThisObj: null,
      tooltipCls: 'b-gantt-taskdrag-tooltip'
    };
  }


  construct(gantt, config) {
    this.gantt = gantt;
    this.store = gantt.taskStore;
    super.construct(gantt, config);
  }


  isElementDraggable(el, event) {
    const {
        gantt
      } = this,
      taskElement = DomHelper.up(el, gantt.eventSelector),
      {
        taskResize
      } = gantt.features;

    if (!taskElement) {
      return false;
    }


    if (el.matches('[class$="-handle"]')) {
      return false;
    }

    const taskRecord = gantt.resolveTaskRecord(taskElement);

    if (!taskRecord || !taskRecord.isDraggable) {
      return false;
    }


    if (taskResize && !taskRecord.isMilestone && taskResize.resize.overAnyHandle(event, taskElement)) {
      return false;
    }

    return gantt.trigger('beforeTaskDrag', {
      taskRecord
    }) !== false;
  }

  triggerEventDrag(dd, start) {


    this.gantt.trigger('taskDrag', {
      taskRecords: dd.draggedRecords,
      startDate: dd.startDate,
      endDate: dd.endDate,
      dragData: dd,
      changed: dd.startDate - start !== 0
    });
  }


  getProductDragContext(dd) {
    return {
      valid: true
    };
  }

  setupProductDragData(info) {
    const me = this,
      gantt = me.gantt,
      element = info.element,
      taskRecord = gantt.resolveTaskRecord(element),
      taskRegion = Rectangle.from(element),
      relatedRecords = me.getRelatedRecords(taskRecord) || [],
      dateConstraints = gantt.getDateConstraints(taskRecord);
    let eventBarEls = [element];
    me.setupConstraints(gantt.getScheduleRegion(taskRecord), taskRegion, gantt.timeAxisViewModel.snapPixelAmount, Boolean(dateConstraints));

    relatedRecords.forEach(r => {
      ArrayHelper.include(eventBarEls, gantt.getElementFromTaskRecord(r, false));
    });
    const draggedRecords = [taskRecord, ...relatedRecords];
    return {
      record: taskRecord,
      dateConstraints,
      eventBarEls,
      draggedRecords
    };
  }


  getCoordinate(taskRecord, element, coord) {
    return coord[0];
  }


  checkDragValidity(dragData, event) {
    return this.validatorFn.call(this.validatorFnThisObj || this, dragData.draggedRecords, dragData.startDate, dragData.duration, event);
  }


  isValidDrop(dragData) {
    return true;
  }


  async updateRecords(context) {
    const taskRecord = context.draggedRecords[0],
      oldStartDate = taskRecord.startDate,
      startDate = context.startDate,
      propagatePromise = taskRecord.setStartDate(startDate, true);

    await propagatePromise;

    if (taskRecord.startDate - oldStartDate) {
      this.gantt.trigger('taskDrop', {
        taskRecords: context.draggedRecords
      });
    } else {
      this.dragData.valid = false;
    }

    return propagatePromise;
  }

}

TaskDrag._$name = 'TaskDrag';
GridFeatureManager.registerFeature(TaskDrag, true, 'Gantt');


class TaskDragCreate extends DragCreateBase {

  static get $name() {
    return 'TaskDragCreate';
  }

  static get defaultConfig() {
    return {

      preventMultiple: true,


      validatorFn: () => {
      }
    };
  }


  construct(gantt, config) {
    const me = this;
    me.gantt = gantt;
    me.store = gantt.taskStore;
    super.construct(gantt, config);
  }


  async finalizeDragCreate(context) {
    const {
      taskRecord
    } = context;
    taskRecord.beginBatch();
    taskRecord.setStartDate(context.startDate);
    taskRecord.setEndDate(context.endDate);
    taskRecord.endBatch();
    await this.gantt.project.propagate();
    this.gantt.trigger('dragCreateEnd', {
      taskRecord,
      event: context.event,
      proxyElement: this.proxy
    });
  }

  handleBeforeDragCreate(dateTime, event) {
    const me = this,
      result = me.gantt.trigger('beforeDragCreate', {
        taskRecord: me.createContext.taskRecord,
        date: dateTime,
        event
      });

    if (result) {


      const tipFeature = me.gantt.features.scheduleTooltip;

      if (tipFeature) {
        tipFeature.hoverTip && tipFeature.hoverTip.hide();
      }
    }

    me.dateConstraints = me.gantt.getDateConstraints(me.createContext.rowRecord, dateTime);
    return result;
  }

  checkValidity(context, event) {
    const me = this;
    context.taskRecord = context.rowRecord;
    return me.validatorFn.call(me.validatorFnThisObj || me, context, event);
  }

  isRowEmpty(taskRecord) {
    return !taskRecord.startDate || !taskRecord.endDate;
  }

}

TaskDragCreate._$name = 'TaskDragCreate';
GridFeatureManager.registerFeature(TaskDragCreate, true, 'Gantt');


class TaskResize extends ResizeBase {
  static get $name() {
    return 'TaskResize';
  }


  getTimespanRecord(context) {
    return context.taskRecord;
  }

  getRowRecord(context) {
    return context.taskRecord;
  }

  setupProductResizeContext(context, event) {
    const gantt = this.client,
      taskRecord = gantt.resolveTaskRecord(context.element);
    Object.assign(context, {
      taskRecord,
      dateConstraints: gantt.getDateConstraints(taskRecord)
    });
  }

  get store() {
    return this.client.taskStore;
  }

  internalUpdateRecord(context, timespanRecord) {
    const newDuration = timespanRecord.run('calculateProjectedDuration', context.startDate, context.endDate);

    if (newDuration === timespanRecord.duration) {

      context.element.lastDomConfig.style.width = null;
      return false;
    } else {
      timespanRecord.setDuration(newDuration);
      return true;
    }
  }

  createResizeHelper() {
    const me = this,
      client = me.client;
    return new ResizeHelper({
      name: me.constructor.name,

      isElementResizable: (el, event) => me.isElementResizable(el, event),
      targetSelector: client.eventSelector,
      resizingCls: 'b-sch-event-resizing',
      allowResize: me.isElementResizable.bind(me),
      outerElement: client.timeAxisSubGridElement,

      scrollManager: client.scrollManager,

      leftHandle: false,
      dragThreshold: 0,
      dynamicHandleSize: true,
      reservedSpace: 5,
      listeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onFinishResize,
        cancel: me.onCancelResize,
        thisObj: me
      },

      highlightHandle() {
        const target = DomHelper.up(this.currentElement, this.targetSelector),
          taskEl = DomHelper.up(this.currentElement, client.eventInnerSelector);

        if (taskEl) {
          taskEl.classList.add('b-resize-handle');
          target.classList.add('b-over-resize-handle');
        }
      },

      unHighlightHandle() {
        const target = DomHelper.up(this.currentElement, this.targetSelector);
        target && target.classList.remove('b-over-resize-handle');
        const currentTarget = DomHelper.up(this.currentElement, client.eventInnerSelector);
        currentTarget && currentTarget.classList.remove('b-resize-handle');
        this.currentElement = null;
      }

    });
  }

}

TaskResize._$name = 'TaskResize';
GridFeatureManager.registerFeature(TaskResize, true, 'Gantt');


class Gantt extends GanttBase {


  static get $name() {
    return 'Gantt';
  }

}

Gantt._$name = 'Gantt';
BryntumWidgetAdapterRegister.register('gantt', Gantt);

class AssignmentEditGrid extends Container {

  static get $name() {
    return 'AssignmentEditGrid';
  }

  static get defaultConfig() {
    return {
      id: 'assignmenteditgrid',
      cls: 'b-assignmenteditgrid',
      items: [{
        type: 'button',
        cls: 'b-add-button green',
        icon: 'plus',
        id: 'assignmenteditgrid-add'
      }, {
        type: 'button',
        cls: 'b-remove-button red',
        icon: 'trash',
        disabled: true,
        id: 'assignmenteditgrid-remove'
      }, {
        type: 'grid',
        id: 'assignmenteditgrid-grid',
        storeConfig: {
          modelClass: ResourceModel$2
        },
        columns: [{
          field: 'name',
          text: 'L{Name}',
          flex: 1,
          editor: {
            type: 'combo',
            textField: 'name',
            valueField: 'id'
          }
        }, {
          field: 'units',
          text: 'L{Units}',
          width: 80
        }]
      }]
    };
  }


  afterConfigure() {
    super.afterConfigure();
    const me = this,
      addButton = me.addButton = WidgetHelper.getById('assignmenteditgrid-add'),
      removeButton = me.removeButton = WidgetHelper.getById('assignmenteditgrid-remove'),
      grid = me.grid = WidgetHelper.getById('assignmenteditgrid-grid').grid;
    addButton && addButton.on('click', me.onAddClick, me);
    removeButton && removeButton.on('click', me.onRemoveClick, me);
    grid.on({
      rowselect: () => removeButton.enable()
    });
  }

}

AssignmentEditGrid._$name = 'AssignmentEditGrid';


class Timeline extends Scheduler {
  static get $name() {
    return 'Timeline';
  }

  static get type() {
    return 'timeline';
  }

  construct(config) {
    const me = this;
    me.startDateLabel = document.createElement('label');
    me.startDateLabel.className = 'b-timeline-startdate';
    me.endDateLabel = document.createElement('label');
    me.endDateLabel.className = 'b-timeline-enddate';
    super.construct(config);

    if (!me.project) {
      throw new Error('You need to configure the Timeline with a Project');
    }

    if (!(me.project instanceof ProjectModel)) {
      me.project = new ProjectModel(me.project);
    }

    me.taskStore = me.project.taskStore;

    me.features.timeRanges.store = new Store();
    me.fillFromTaskStore();
    me.fillFromTaskStore = me.buffer(me.fillFromTaskStore, 100);
    me.taskStore.on({
      refresh: me.fillFromTaskStore,
      change: me.onTaskStoreChange,
      thisObj: me
    });
    me.on({
      resize: me.onSizeChanged,
      thisObj: me
    });
    me.bodyContainer.appendChild(me.startDateLabel);
    me.bodyContainer.appendChild(me.endDateLabel);
    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      thisObj: me
    });
  }

  static get defaultConfig() {
    return {

      height: '13em',
      eventLayout: 'pack',
      barMargin: 1,
      readOnly: true,
      forceFit: true,
      zoomOnMouseWheel: false,
      zoomOnTimeAxisDoubleClick: false,
      eventColor: null,
      eventStyle: null,
      rowHeight: 48,
      displayDateFormat: 'L',
      features: {
        columnLines: false,
        eventContextMenu: false,
        contextMenu: false,
        scheduleContextMenu: false,
        timeRanges: {
          showCurrentTimeLine: true
        }
      },

      resources: [{
        id: 1
      }],
      columns: []
    };
  }

  onSizeChanged({
                  width,
                  oldWidth
                }) {
    this.suspendRefresh();
    this.updateRowHeight();
    this.resumeRefresh();

    if (width !== oldWidth) {
      this.fitTimeline();
    }
  }

  updateRowHeight() {
    this.rowHeight = this.bodyContainer.offsetHeight;
  }

  fitTimeline() {
    if (this.eventStore.count > 0) {
      this.zoomToFit({
        leftMargin: 50,
        rightMargin: 50
      });
    }

    this.updateStartEndLabels();
  }

  updateStartEndLabels() {
    const me = this;
    me.startDateLabel.innerHTML = me.getFormattedDate(me.startDate);
    me.endDateLabel.innerHTML = me.getFormattedDate(me.endDate);
  }

  async onTaskStoreChange(event) {
    const me = this,
      eventStore = me.eventStore;
    let needsFit;

    switch (event.action) {
      case 'add':
        event.records.forEach(task => {
          if (task.showInTimeline) {
            eventStore.add(me.cloneTask(task));
            needsFit = true;
          }
        });
        break;

      case 'remove':
        if (!event.isCollapse) {
          event.records.forEach(task => {
            if (task.showInTimeline) {
              eventStore.remove(task.id);
              needsFit = true;
            }
          });
        }

        break;

      case 'removeall':
        me.fillFromTaskStore();
        break;

      case 'update':
        const task = event.record;

        if (event.changes.showInTimeline) {

          if (task.showInTimeline) {
            eventStore.add(me.cloneTask(task));
          } else {
            eventStore.remove(eventStore.getById(task.id));
          }

          needsFit = true;
        } else if (task.showInTimeline) {

          const clone = eventStore.getById(task.id);

          if (clone) {
            const filteredData = Object.assign({}, task.data);

            delete filteredData.expanded;
            clone.set(filteredData);
            needsFit = true;
          }
        }

        break;
    }

    if (needsFit) {
      me.fitTimeline();
    }
  }

  cloneTask(task) {
    return {
      id: task.id,
      resourceId: 1,
      startDate: task.startDate,
      endDate: task.endDate,
      duration: task.duration,
      durationUnit: task.durationUnit,
      name: task.name
    };
  }

  render() {
    super.render();
    this.updateRowHeight();
  }

  fillFromTaskStore() {
    const me = this,
      timelineTasks = [];
    me.taskStore.traverse(task => {
      if (task.showInTimeline && task.isScheduled) {
        timelineTasks.push(me.cloneTask(task));
      }
    });
    me.suspendRefresh();
    me.events = timelineTasks;
    me.resumeRefresh();
    me.fitTimeline();
  }

  onLocaleChange() {
    this.updateStartEndLabels();
  }

}

Timeline._$name = 'Timeline';
BryntumWidgetAdapterRegister.register(Timeline.type, Timeline);


class GanttTag extends (window.customElements ? HTMLElement : Object) {
  constructor() {
    super();
    const me = this,
      columns = [],
      features = {};
    let project;

    for (let tag of me.children) {
      if (tag.tagName === 'COLUMN') {
        const width = parseInt(tag.dataset.width),
          flex = parseInt(tag.dataset.flex),
          column = {
            field: tag.dataset.field,
            text: tag.innerHTML,
            type: tag.dataset.type
          };
        if (width) column.width = width; else if (flex) column.flex = flex; else column.flex = 1;
        columns.push(column);
      } else if (tag.tagName === 'PROJECT') {
        project = new ProjectModel({
          transport: {
            load: {
              url: tag.dataset.loadUrl
            }
          }
        });
      } else if (tag.tagName === 'FEATURE') {
        const name = tag.dataset.name,
          config = Object.assign({}, tag.dataset);
        delete config.name;

        if (Object.keys(config).length) {
          features[name] = config;
        } else {
          features[name] = tag.textContent !== 'false';
        }
      }
    }

    const config = Object.assign({}, me.dataset),
      theme = config.theme || 'stockholm',

      shadowRoot = this.attachShadow({
        mode: 'open'
      }),

      link = document.createElement('link');
    delete config.theme;
    link.rel = 'stylesheet';
    link.href = `../../build/gantt.${theme}.css`;

    link.onload = () => {
      const div = document.createElement('div');
      div.id = 'container';
      div.style.width = '100%';
      div.style.height = '100%';
      shadowRoot.appendChild(div);

      setupFocusListeners(shadowRoot);
      Object.assign(config, {
        appendTo: div,
        columns: columns,
        features,
        project
      });

      const gantt = new Gantt(config);

      if (project instanceof ProjectModel) {
        project.load();
      }

      if (!window.gantt) window.gantt = gantt;
    };

    shadowRoot.appendChild(link);
  }

}

try {
  window.customElements && window.customElements.define('bryntum-gantt', GanttTag);
} catch (error) {
}

GanttTag._$name = 'GanttTag';


if (!window.bryntum) window.bryntum = {};

export {
  AbstractCrudManager,
  ActionColumn,
  AddNewColumn,
  AdvancedTab,
  AggregateColumn,
  AjaxHelper,
  AjaxStore,
  AjaxTransport,
  AllColumns,
  ArrayHelper,
  AssignmentEditGrid,
  AssignmentField,
  AssignmentGrid,
  AssignmentModel$2 as AssignmentModel,
  AssignmentPicker,
  AssignmentStore$2 as AssignmentStore,
  AssignmentsManipulationModel,
  AssignmentsManipulationStore,
  Badge,
  Bag,
  Bar,
  Base,
  Baseline,
  Baselines,
  BooleanCombo,
  BrowserHelper,
  BryntumWidgetAdapter,
  BryntumWidgetAdapterRegister,
  Button,
  ButtonGroup,
  CSSHelper,
  CalendarColumn,
  CalendarIntervalModel,
  CalendarModel,
  CalendarPanel,
  CellEdit$1 as CellEdit,
  CellTooltip,
  CheckColumn,
  Checkbox,
  ChipView,
  ClickRepeater,
  Collection,
  CollectionFilter,
  CollectionSorter,
  Column,
  ColumnDragToolbar,
  ColumnLines,
  ColumnPicker,
  ColumnReorder,
  ColumnResize,
  ColumnStore,
  Combo,
  ConstraintDateColumn,
  ConstraintType,
  ConstraintTypeColumn,
  ConstraintTypePicker,
  Container,
  ContextMenu,
  CriticalPaths,
  CrudManager$1 as CrudManager,
  CrudManagerView,
  DataGenerator,
  DateColumn,
  DateField,
  DateHelper,
  DatePicker,
  DeadlineDateColumn,
  Delayable,
  DemoBot,
  Dependencies$1 as Dependencies,
  DependencyBaseModel,
  DependencyColumn,
  DependencyEdit$1 as DependencyEdit,
  DependencyField,
  DependencyModel$1 as DependencyModel,
  DependencyStore$2 as DependencyStore,
  DependencyTab,
  DependencyTypePicker,
  DisplayField,
  DomClassList,
  DomDataStore,
  DomHelper,
  DomSync,
  DragHelper,
  Duration,
  DurationColumn$1 as DurationColumn,
  DurationField,
  EarlyEndDateColumn,
  EarlyStartDateColumn,
  Editor,
  EffectResolutionResult,
  EffortColumn,
  EffortField,
  EndDateColumn,
  EndDateField,
  EventChangePropagator,
  EventContextMenu,
  EventDrag,
  EventDragCreate,
  EventEdit,
  EventFilter,
  EventHelper,
  EventLoader,
  EventModeColumn,
  EventModel,
  EventResize,
  EventStore,
  EventTooltip,
  Events,
  ExcelExporter$1 as ExcelExporter,
  Field,
  FileField,
  FileFormat,
  FilePicker,
  Filter,
  FilterBar,
  FlagField,
  FormTab,
  Fullscreen,
  FunctionHelper,
  Gantt,
  GanttBase,
  GanttDateColumn,
  GanttTag,
  GanttTaskEditor,
  GeneralTab,
  GlobalEvents,
  Grid,
  ExcelExporter as GridExcelExporter,
  ExportDialog as GridExportDialog,
  GridFeatureManager,
  MultiPageExporter as GridMultiPageExporter,
  PdfExport as GridPdfExport,
  GridRowModel,
  SinglePageExporter as GridSinglePageExporter,
  Group,
  GroupSummary,
  Header,
  HeaderContextMenu,
  HeaderZoom,
  HorizontalTimeAxis,
  IdHelper,
  Indicators,
  InstancePlugin,
  Labels$1 as Labels,
  LateEndDateColumn,
  LateStartDateColumn,
  List,
  LocaleManagerSingelton as LocaleManager,
  Localizable,
  ManuallyScheduledColumn,
  Mask,
  Menu,
  MenuItem,
  md as MessageDialog,
  MilestoneColumn,
  MinimalGanttProject,
  Model,
  Month,
  MultiPageExporter$2 as MultiPageExporter,
  NameColumn,
  NonWorkingTime,
  NoteColumn,
  NotesTab,
  NumberField,
  ObjectHelper,
  Orientation,
  Override,
  PagingToolbar,
  Pan,
  Panel,
  PaperFormat,
  Parser,
  PdfExport$2 as PdfExport,
  PercentBar,
  PercentColumn,
  PercentDoneColumn,
  Pluggable,
  Point,
  Popup,
  PredecessorColumn,
  PredecessorsTab,
  pm as PresetManager,
  PresetStore,
  ProAssignmentAPI,
  AssignmentModel$1 as ProAssignmentModel,
  AssignmentStore$1 as ProAssignmentStore,
  ProCalendarIntervalModel,
  CalendarManagerStore as ProCalendarManagerStore,
  ProCalendarModel,
  CrudManager$1 as ProCrudManager,
  ProDataAPI,
  ProDependencies,
  ProDependencyAPI,
  ProDependencyModel,
  DependencyStore$1 as ProDependencyStore,
  ProEventAPI,
  ProEventDrag,
  ProEventDragCreate,
  ProNonWorkingTime,
  ProProjectAPI,
  ProProjectModel,
  ProResourceAPI,
  ResourceModel$1 as ProResourceModel,
  ResourceStore$1 as ProResourceStore,
  ProScheduler,
  ProSchedulerStores,
  ProSubProjectModel,
  ProTaskEdit,
  ProTaskEditStm,
  ProTaskModel,
  ProTaskSegmentModel,
  TaskStore as ProTaskStore,
  ProgressLine,
  ProjectGenerator,
  ProjectLines,
  ProjectModel,
  ProjectType,
  QuickFind,
  RandomGenerator,
  RatingColumn,
  Rectangle,
  RectangularPathFinder,
  RegionResize,
  ResizeHelper,
  ResizeMonitor,
  ResourceAssignmentColumn,
  Parser$1 as ResourceAssignmentParser,
  ResourceInfoColumn,
  ResourceModel$2 as ResourceModel,
  ResourceStore$2 as ResourceStore,
  ResourceTimeRanges,
  ResourcesTab,
  Ripple,
  RollupColumn,
  Rollups,
  RowManager,
  RowNumberColumn,
  RowReorder,
  RowsRange,
  ScheduleRange,
  Scheduler,
  AssignmentModel as SchedulerAssignmentModel,
  AssignmentStore as SchedulerAssignmentStore,
  Calendar as SchedulerCalendar,
  CalendarDayModel as SchedulerCalendarDayModel,
  CrudManager as SchedulerCrudManager,
  Dependencies as SchedulerDependencies,
  DependencyModel as SchedulerDependencyModel,
  DependencyStore as SchedulerDependencyStore,
  SchedulerExportDialog,
  SchedulerGeneralTab,
  MultiPageExporter$1 as SchedulerMultiPageExporter,
  PdfExport$1 as SchedulerPdfExport,
  AdvancedTab as SchedulerProAdvancedTab,
  CalendarField as SchedulerProCalendarField,
  SchedulerProCommon,
  ConstraintTypePicker as SchedulerProConstraintTypePicker,
  DependencyTab as SchedulerProDependencyTab,
  DependencyTypePicker as SchedulerProDependencyTypePicker,
  DurationColumn as SchedulerProDurationColumn,
  EffortField as SchedulerProEffortField,
  EventChangePropagator as SchedulerProEventChangePropagator,
  EventLoader as SchedulerProEventLoader,
  FormTab as SchedulerProFormTab,
  GeneralTab as SchedulerProGeneralTab,
  ModelCombo as SchedulerProModelCombo,
  NotesTab as SchedulerProNotesTab,
  PartOfProject as SchedulerProPartOfProject,
  PredecessorsTab as SchedulerProPredecessorsTab,
  ReadyStatePropagator as SchedulerProReadyStatePropagator,
  ResourcesTab as SchedulerProResourcesTab,
  SchedulingModePicker as SchedulerProSchedulingModePicker,
  SuccessorsTab as SchedulerProSuccessorsTab,
  TaskEditorBase as SchedulerProTaskEditorBase,
  TaskEditorTab as SchedulerProTaskEditorTab,
  ResourceModel as SchedulerResourceModel,
  ResourceStore as SchedulerResourceStore,
  SinglePageExporter$1 as SchedulerSinglePageExporter,
  SchedulerTaskEditor,
  SchedulingMode,
  SchedulingModeColumn,
  SchedulingModePicker,
  ScrollManager,
  Scroller,
  Search,
  SequenceColumn,
  ShowInTimelineColumn,
  SimpleEventEdit,
  SinglePageExporter$2 as SinglePageExporter,
  Slider,
  Sort,
  Splitter,
  StartDateColumn,
  StartDateField,
  State,
  StateTrackingManager,
  Store,
  StringHelper,
  Stripe,
  SubGrid,
  SubProjectModel,
  SuccessorColumn,
  SuccessorsTab,
  Summary,
  TabPanel,
  ScheduleTableExporter as TableExporter,
  TaskContextMenu,
  TaskEdit,
  ProTaskEditStm as TaskEditStm,
  TaskEditor,
  TaskModel,
  TaskSegmentModel,
  TaskStore$1 as TaskStore,
  TaskTooltip,
  TemplateColumn,
  TemplateHelper,
  TextAreaField,
  TextField,
  TimeAxis,
  TimeAxisColumn,
  TimeAxisViewModel,
  TimeColumn,
  TimeField,
  TimePicker,
  TimeRanges,
  TimeSpan,
  TimeUnit,
  Timeline,
  Toast,
  Tool,
  Toolbar,
  Tooltip,
  TotalSlackColumn,
  Transaction,
  Tree,
  TreeColumn,
  TreeGrid,
  VersionHelper,
  ViewPreset,
  WBSColumn,
  Widget,
  WidgetColumn,
  WidgetHelper
};

